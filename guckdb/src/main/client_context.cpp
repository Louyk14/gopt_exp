#include "duckdb/main/client_context.hpp"

#include "duckdb/catalog/catalog_entry/scalar_function_catalog_entry.hpp"
#include "duckdb/catalog/catalog_entry/table_catalog_entry.hpp"
#include "duckdb/catalog/catalog_search_path.hpp"
#include "duckdb/common/file_system.hpp"
#include "duckdb/common/http_state.hpp"
#include "duckdb/common/preserved_error.hpp"
#include "duckdb/common/progress_bar/progress_bar.hpp"
#include "duckdb/common/serializer/buffered_file_writer.hpp"
#include "duckdb/common/types/column/column_data_collection.hpp"
#include "duckdb/execution/column_binding_resolver.hpp"
#include "duckdb/execution/operator/helper/physical_result_collector.hpp"
#include "duckdb/execution/physical_plan_generator.hpp"
#include "duckdb/main/appender.hpp"
#include "duckdb/main/attached_database.hpp"
#include "duckdb/main/client_context_file_opener.hpp"
#include "duckdb/main/client_data.hpp"
#include "duckdb/main/database.hpp"
#include "duckdb/main/database_manager.hpp"
#include "duckdb/main/error_manager.hpp"
#include "duckdb/main/materialized_query_result.hpp"
#include "duckdb/main/query_profiler.hpp"
#include "duckdb/main/query_result.hpp"
#include "duckdb/main/relation.hpp"
#include "duckdb/main/stream_query_result.hpp"
#include "duckdb/optimizer/optimizer.hpp"
#include "duckdb/parser/expression/constant_expression.hpp"
#include "duckdb/parser/expression/parameter_expression.hpp"
#include "duckdb/parser/parsed_data/create_function_info.hpp"
#include "duckdb/parser/parser.hpp"
#include "duckdb/parser/query_node/select_node.hpp"
#include "duckdb/parser/statement/drop_statement.hpp"
#include "duckdb/parser/statement/execute_statement.hpp"
#include "duckdb/parser/statement/explain_statement.hpp"
#include "duckdb/parser/statement/prepare_statement.hpp"
#include "duckdb/parser/statement/relation_statement.hpp"
#include "duckdb/parser/statement/select_statement.hpp"
#include "duckdb/planner/operator/logical_execute.hpp"
#include "duckdb/planner/planner.hpp"
#include "duckdb/planner/pragma_handler.hpp"
#include "duckdb/transaction/meta_transaction.hpp"
#include "duckdb/transaction/transaction_manager.hpp"

#include "duckdb/execution/operator/projection/physical_projection.hpp"
#include "duckdb/execution/operator/scan/physical_table_scan.hpp"
#include "duckdb/execution/operator/join/physical_sip_join.hpp"
#include "duckdb/execution/operator/join/physical_merge_sip_join.hpp"
#include "duckdb/execution/operator/order/physical_top_n.hpp"
#include "duckdb/catalog/catalog_entry/table_function_catalog_entry.hpp"
#include "duckdb/planner/operator/logical_get.hpp"
#include "duckdb/catalog/catalog_entry/aggregate_function_catalog_entry.hpp"
#include "duckdb/function/function_binder.hpp"
#include "duckdb/execution/operator/aggregate/physical_ungrouped_aggregate.hpp"
#include "duckdb/execution/operator/filter/physical_filter.hpp"
#include "duckdb/execution/operator/join/physical_hash_join.hpp"
#include "duckdb/function/scalar/string_functions.hpp"
#include "duckdb/execution/operator/join/physical_extend_intersect.hpp"
#include "duckdb/execution/operator/join/physical_cross_product.hpp"
#include "duckdb/execution/operator/scan/physical_column_data_scan.hpp"

namespace duckdb {

struct ActiveQueryContext {
	//! The query that is currently being executed
	string query;
	//! The currently open result
	BaseQueryResult *open_result = nullptr;
	//! Prepared statement data
	shared_ptr<PreparedStatementData> prepared;
	//! The query executor
	unique_ptr<Executor> executor;
	//! The progress bar
	unique_ptr<ProgressBar> progress_bar;
};

ClientContext::ClientContext(shared_ptr<DatabaseInstance> database, int sql_mode_input, string pb_file_input)
    : db(std::move(database)), interrupted(false), client_data(make_uniq<ClientData>(*this)), transaction(*this),
    sql_mode(sql_mode_input), pb_file(pb_file_input){
}

ClientContext::~ClientContext() {
	if (Exception::UncaughtException()) {
		return;
	}
	// destroy the client context and rollback if there is an active transaction
	// but only if we are not destroying this client context as part of an exception stack unwind
	Destroy();
}

unique_ptr<ClientContextLock> ClientContext::LockContext() {
	return make_uniq<ClientContextLock>(context_lock);
}

void ClientContext::Destroy() {
	auto lock = LockContext();
	if (transaction.HasActiveTransaction()) {
		transaction.ResetActiveQuery();
		if (!transaction.IsAutoCommit()) {
			transaction.Rollback();
		}
	}
	CleanupInternal(*lock);
}

unique_ptr<DataChunk> ClientContext::Fetch(ClientContextLock &lock, StreamQueryResult &result) {
	D_ASSERT(IsActiveResult(lock, &result));
	D_ASSERT(active_query->executor);
	return FetchInternal(lock, *active_query->executor, result);
}

unique_ptr<DataChunk> ClientContext::FetchInternal(ClientContextLock &lock, Executor &executor,
                                                   BaseQueryResult &result) {
	bool invalidate_query = true;
	try {
		// fetch the chunk and return it
		auto chunk = executor.FetchChunk();
		if (!chunk || chunk->size() == 0) {
			CleanupInternal(lock, &result);
		}
		return chunk;
	} catch (StandardException &ex) {
		// standard exceptions do not invalidate the current transaction
		result.SetError(PreservedError(ex));
		invalidate_query = false;
	} catch (FatalException &ex) {
		// fatal exceptions invalidate the entire database
		result.SetError(PreservedError(ex));
		auto &db = DatabaseInstance::GetDatabase(*this);
		ValidChecker::Invalidate(db, ex.what());
	} catch (const Exception &ex) {
		result.SetError(PreservedError(ex));
	} catch (std::exception &ex) {
		result.SetError(PreservedError(ex));
	} catch (...) { // LCOV_EXCL_START
		result.SetError(PreservedError("Unhandled exception in FetchInternal"));
	} // LCOV_EXCL_STOP
	CleanupInternal(lock, &result, invalidate_query);
	return nullptr;
}

void ClientContext::BeginTransactionInternal(ClientContextLock &lock, bool requires_valid_transaction) {
	// check if we are on AutoCommit. In this case we should start a transaction
	D_ASSERT(!active_query);
	auto &db = DatabaseInstance::GetDatabase(*this);
	if (ValidChecker::IsInvalidated(db)) {
		throw FatalException(ErrorManager::FormatException(*this, ErrorType::INVALIDATED_DATABASE,
		                                                   ValidChecker::InvalidatedMessage(db)));
	}
	if (requires_valid_transaction && transaction.HasActiveTransaction() &&
	    ValidChecker::IsInvalidated(transaction.ActiveTransaction())) {
		throw Exception(ErrorManager::FormatException(*this, ErrorType::INVALIDATED_TRANSACTION));
	}
	active_query = make_uniq<ActiveQueryContext>();
	if (transaction.IsAutoCommit()) {
		transaction.BeginTransaction();
	}
}

void ClientContext::BeginQueryInternal(ClientContextLock &lock, const string &query) {
	BeginTransactionInternal(lock, false);
	LogQueryInternal(lock, query);
	active_query->query = query;
	query_progress = -1;
	transaction.SetActiveQuery(db->GetDatabaseManager().GetNewQueryNumber());
}

PreservedError ClientContext::EndQueryInternal(ClientContextLock &lock, bool success, bool invalidate_transaction) {
	client_data->profiler->EndQuery();

	if (client_data->http_state) {
		client_data->http_state->Reset();
	}

	// Notify any registered state of query end
	for (auto const &s : registered_state) {
		s.second->QueryEnd();
	}

	D_ASSERT(active_query.get());
	active_query.reset();
	query_progress = -1;
	PreservedError error;
	try {
		if (transaction.HasActiveTransaction()) {
			// Move the query profiler into the history
			auto &prev_profilers = client_data->query_profiler_history->GetPrevProfilers();
			prev_profilers.emplace_back(transaction.GetActiveQuery(), std::move(client_data->profiler));
			// Reinitialize the query profiler
			client_data->profiler = make_shared<QueryProfiler>(*this);
			// Propagate settings of the saved query into the new profiler.
			client_data->profiler->Propagate(*prev_profilers.back().second);
			if (prev_profilers.size() >= client_data->query_profiler_history->GetPrevProfilersSize()) {
				prev_profilers.pop_front();
			}

			transaction.ResetActiveQuery();
			if (transaction.IsAutoCommit()) {
				if (success) {
					transaction.Commit();
				} else {
					transaction.Rollback();
				}
			} else if (invalidate_transaction) {
				D_ASSERT(!success);
				ValidChecker::Invalidate(ActiveTransaction(), "Failed to commit");
			}
		}
	} catch (FatalException &ex) {
		auto &db = DatabaseInstance::GetDatabase(*this);
		ValidChecker::Invalidate(db, ex.what());
		error = PreservedError(ex);
	} catch (const Exception &ex) {
		error = PreservedError(ex);
	} catch (std::exception &ex) {
		error = PreservedError(ex);
	} catch (...) { // LCOV_EXCL_START
		error = PreservedError("Unhandled exception!");
	} // LCOV_EXCL_STOP
	return error;
}

void ClientContext::CleanupInternal(ClientContextLock &lock, BaseQueryResult *result, bool invalidate_transaction) {
	client_data->http_state = make_shared<HTTPState>();
	if (!active_query) {
		// no query currently active
		return;
	}
	if (active_query->executor) {
		active_query->executor->CancelTasks();
	}
	active_query->progress_bar.reset();

	auto error = EndQueryInternal(lock, result ? !result->HasError() : false, invalidate_transaction);
	if (result && !result->HasError()) {
		// if an error occurred while committing report it in the result
		result->SetError(error);
	}
	D_ASSERT(!active_query);
}

Executor &ClientContext::GetExecutor() {
	D_ASSERT(active_query);
	D_ASSERT(active_query->executor);
	return *active_query->executor;
}

const string &ClientContext::GetCurrentQuery() {
	D_ASSERT(active_query);
	return active_query->query;
}

unique_ptr<QueryResult> ClientContext::FetchResultInternal(ClientContextLock &lock, PendingQueryResult &pending) {
	D_ASSERT(active_query);
	D_ASSERT(active_query->open_result == &pending);
	D_ASSERT(active_query->prepared);
	auto &executor = GetExecutor();
	auto &prepared = *active_query->prepared;
	bool create_stream_result = prepared.properties.allow_stream_result && pending.allow_stream_result;
	if (create_stream_result) {
		D_ASSERT(!executor.HasResultCollector());
		active_query->progress_bar.reset();
		query_progress = -1;

		// successfully compiled SELECT clause, and it is the last statement
		// return a StreamQueryResult so the client can call Fetch() on it and stream the result
		auto stream_result = make_uniq<StreamQueryResult>(pending.statement_type, pending.properties,
		                                                  shared_from_this(), pending.types, pending.names);
		active_query->open_result = stream_result.get();
		return std::move(stream_result);
	}
	unique_ptr<QueryResult> result;
	if (executor.HasResultCollector()) {
		// we have a result collector - fetch the result directly from the result collector
		result = executor.GetResult();
		CleanupInternal(lock, result.get(), false);
	} else {
		// no result collector - create a materialized result by continuously fetching
		auto result_collection = make_uniq<ColumnDataCollection>(Allocator::DefaultAllocator(), pending.types);
		D_ASSERT(!result_collection->Types().empty());
		auto materialized_result =
		    make_uniq<MaterializedQueryResult>(pending.statement_type, pending.properties, pending.names,
		                                       std::move(result_collection), GetClientProperties());

		auto &collection = materialized_result->Collection();
		D_ASSERT(!collection.Types().empty());
		ColumnDataAppendState append_state;
		collection.InitializeAppend(append_state);
		while (true) {
			auto chunk = FetchInternal(lock, GetExecutor(), *materialized_result);
			if (!chunk || chunk->size() == 0) {
				break;
			}
#ifdef DEBUG
			for (idx_t i = 0; i < chunk->ColumnCount(); i++) {
				if (pending.types[i].id() == LogicalTypeId::VARCHAR) {
					chunk->data[i].UTFVerify(chunk->size());
				}
			}
#endif
			collection.Append(append_state, *chunk);
		}
		result = std::move(materialized_result);
	}
	return result;
}

static bool IsExplainAnalyze(SQLStatement *statement) {
	if (!statement) {
		return false;
	}
	if (statement->type != StatementType::EXPLAIN_STATEMENT) {
		return false;
	}
	auto &explain = statement->Cast<ExplainStatement>();
	return explain.explain_type == ExplainType::EXPLAIN_ANALYZE;
}

shared_ptr<PreparedStatementData>
ClientContext::CreatePreparedStatement(ClientContextLock &lock, const string &query, unique_ptr<SQLStatement> statement,
                                       optional_ptr<case_insensitive_map_t<Value>> values) {
	StatementType statement_type = statement->type;
	auto result = make_shared<PreparedStatementData>(statement_type);

	auto &profiler = QueryProfiler::Get(*this);
	profiler.StartQuery(query, IsExplainAnalyze(statement.get()), true);
	profiler.StartPhase("planner");
	Planner planner(*this);
	if (values) {
		auto &parameter_values = *values;
		for (auto &value : parameter_values) {
			planner.parameter_data.emplace(value.first, BoundParameterData(value.second));
		}
	}

	client_data->http_state = make_shared<HTTPState>();
    if ((query[0] == 's' || query[0] == 'S')) {
        int k = 0;
    }
    planner.CreatePlan(std::move(statement));
	D_ASSERT(planner.plan || !planner.properties.bound_all_parameters);
	profiler.EndPhase();

	auto plan = std::move(planner.plan);
	// extract the result column names from the plan
	result->properties = planner.properties;
	result->names = planner.names;
	result->types = planner.types;
	result->value_map = std::move(planner.value_map);
	result->catalog_version = MetaTransaction::Get(*this).catalog_version;

	if (!planner.properties.bound_all_parameters) {
		return result;
	}
#ifdef DEBUG
	plan->Verify(*this);
#endif
	if (config.enable_optimizer && plan->RequireOptimizer()) {
		profiler.StartPhase("optimizer");
		Optimizer optimizer(*planner.binder, *this);
		plan = optimizer.Optimize(std::move(plan));
		D_ASSERT(plan);
		profiler.EndPhase();

#ifdef DEBUG
		plan->Verify(*this);
#endif
	}

	profiler.StartPhase("physical_planner");
	// now convert logical query plan into a physical query plan
	PhysicalPlanGenerator physical_planner(*this);
	auto physical_plan = physical_planner.CreatePlan(std::move(plan));
    // std::cout << physical_plan->ToString() << std::endl;
	profiler.EndPhase();

    if (sql_mode == 2 && (query[0] == 's' || query[0] == 'S')) {
        if (pb_file == "1-1") {
            auto physical_plan_by_hand = GenerateIC11PlanGLogue();
            physical_plan = move(physical_plan_by_hand);
        }
        else if (pb_file == "1-2") {
            auto physical_plan_by_hand = GenerateIC12PlanGLogue();
            physical_plan = move(physical_plan_by_hand);
        }
        else if (pb_file == "1-3") {
            auto physical_plan_by_hand = GenerateIC13PlanGLogue();
            physical_plan = move(physical_plan_by_hand);
        }
        else if (pb_file == "2-1") {
            auto physical_plan_by_hand = GenerateIC21PlanGLogue();
            physical_plan = move(physical_plan_by_hand);
        }
        else if (pb_file == "3-1") {
            auto physical_plan_by_hand = GenerateIC31PlanGLogue();
            physical_plan = move(physical_plan_by_hand);
        }
        else if (pb_file == "3-2") {
            auto physical_plan_by_hand = GenerateIC32PlanGLogue();
            physical_plan = move(physical_plan_by_hand);
        }
        else if (pb_file == "4-1") {
            auto physical_plan_by_hand = GenerateIC41PlanGLogue();
            physical_plan = move(physical_plan_by_hand);
        }
        else if (pb_file == "5-1") {
            auto physical_plan_by_hand = GenerateIC51PlanGLogueEI();
            physical_plan = move(physical_plan_by_hand);
        }
        else if (pb_file == "5-2") {
            auto physical_plan_by_hand = GenerateIC52PlanByPassFromPerson();
            physical_plan = move(physical_plan_by_hand);
        }
        else if (pb_file == "6-1") {
            auto physical_plan_by_hand = GenerateIC61PlanGLogue();
            physical_plan = move(physical_plan_by_hand);
        }
        else if (pb_file == "6-2") {
            auto physical_plan_by_hand = GenerateIC62PlanGLogue();
            physical_plan = move(physical_plan_by_hand);
        }
        else if (pb_file == "7-1") {
            auto physical_plan_by_hand = GenerateIC71PlanGLogue();
            physical_plan = move(physical_plan_by_hand);
        }
        else if (pb_file == "8-1") {
            auto physical_plan_by_hand = GenerateIC81PlanGLogue();
            physical_plan = move(physical_plan_by_hand);
        }
        else if (pb_file == "9-1") {
            auto physical_plan_by_hand = GenerateIC91PlanGLogue();
            physical_plan = move(physical_plan_by_hand);
        }
        else if (pb_file == "9-2") {
            auto physical_plan_by_hand = GenerateIC92PlanGLogue();
            physical_plan = move(physical_plan_by_hand);
        }
        else if (pb_file == "11-1") {
            auto physical_plan_by_hand = GenerateIC111PlanGLogue();
            physical_plan = move(physical_plan_by_hand);
        }
        else if (pb_file == "11-2") {
            auto physical_plan_by_hand = GenerateIC112PlanGLogue();
            physical_plan = move(physical_plan_by_hand);
        }
        else if (pb_file == "12-1") {
            auto physical_plan_by_hand = GenerateIC121PlanGLogue();
            physical_plan = move(physical_plan_by_hand);
        }
        else if (pb_file == "job1a") {
            auto physical_plan_by_hand = GenerateJOB1aPlanMerge(*this);
            physical_plan = move(physical_plan_by_hand);
        }
        else if (pb_file == "job2a") {
            auto physical_plan_by_hand = GenerateJOB2aPlanNewDirect(*this);
            physical_plan = move(physical_plan_by_hand);
        }
        else if (pb_file == "job3a") {
            auto physical_plan_by_hand = GenerateJOB3aPlanMerge(*this);
            physical_plan = move(physical_plan_by_hand);
        }
        else if (pb_file == "job4a") {
            auto physical_plan_by_hand = GenerateJOB4aPlan(*this);
            physical_plan = move(physical_plan_by_hand);
        }
        else if (pb_file == "job5a") {
            auto physical_plan_by_hand = GenerateJOB5aPlan(*this);
            physical_plan = move(physical_plan_by_hand);
        }
        else if (pb_file == "job6a") {
            auto physical_plan_by_hand = GenerateJOB6aPlan(*this);
            physical_plan = move(physical_plan_by_hand);
        }
        else if (pb_file == "job7a") {
            auto physical_plan_by_hand = GenerateJOB7aPlan(*this);
            physical_plan = move(physical_plan_by_hand);
        }
        else if (pb_file == "job8a") {
            auto physical_plan_by_hand = GenerateJOB8aPlan(*this);
            physical_plan = move(physical_plan_by_hand);
        }
        else if (pb_file == "job9a") {
            auto physical_plan_by_hand = GenerateJOB9aPlan(*this);
            physical_plan = move(physical_plan_by_hand);
        }
        else if (pb_file == "job10a") {
            auto physical_plan_by_hand = GenerateJOB10aPlan(*this);
            physical_plan = move(physical_plan_by_hand);
        }
        else if (pb_file == "job11a") {
            auto physical_plan_by_hand = GenerateJOB11aPlan(*this);
            physical_plan = move(physical_plan_by_hand);
        }
        else if (pb_file == "job12a") {
            auto physical_plan_by_hand = GenerateJOB12aPlan(*this);
            physical_plan = move(physical_plan_by_hand);
        }
        else if (pb_file == "job13a") {
            auto physical_plan_by_hand = GenerateJOB13aPlan(*this);
            physical_plan = move(physical_plan_by_hand);
        }
        else if (pb_file == "job14a") {
            auto physical_plan_by_hand = GenerateJOB14aPlan(*this);
            physical_plan = move(physical_plan_by_hand);
        }
        else if (pb_file == "job15a") {
            auto physical_plan_by_hand = GenerateJOB15aPlan(*this);
            physical_plan = move(physical_plan_by_hand);
        }
        else if (pb_file == "job16a") {
            auto physical_plan_by_hand = GenerateJOB16aPlan(*this);
            physical_plan = move(physical_plan_by_hand);
        }
        else if (pb_file == "job17a") {
            auto physical_plan_by_hand = GenerateJOB17aPlan(*this);
            physical_plan = move(physical_plan_by_hand);
        }
        else if (pb_file == "job18a") {
            auto physical_plan_by_hand = GenerateJOB18aPlan(*this);
            physical_plan = move(physical_plan_by_hand);
        }
        else if (pb_file == "job19a") {
            auto physical_plan_by_hand = GenerateJOB19aPlan(*this);
            physical_plan = move(physical_plan_by_hand);
        }
        else if (pb_file == "job20a") {
            auto physical_plan_by_hand = GenerateJOB20aPlan(*this);
            physical_plan = move(physical_plan_by_hand);
        }
        else if (pb_file == "job21a") {
            auto physical_plan_by_hand = GenerateJOB21aPlan(*this);
            physical_plan = move(physical_plan_by_hand);
        }
        else if (pb_file == "job22a") {
            auto physical_plan_by_hand = GenerateJOB22aPlan(*this);
            physical_plan = move(physical_plan_by_hand);
        }
        else if (pb_file == "job23a") {
            auto physical_plan_by_hand = GenerateJOB23aPlan(*this);
            physical_plan = move(physical_plan_by_hand);
        }
        else if (pb_file == "job24a") {
            auto physical_plan_by_hand = GenerateJOB24aPlan(*this);
            physical_plan = move(physical_plan_by_hand);
        }
        else if (pb_file == "job25a") {
            auto physical_plan_by_hand = GenerateJOB25aPlan(*this);
            physical_plan = move(physical_plan_by_hand);
        }
        else if (pb_file == "job26a") {
            auto physical_plan_by_hand = GenerateJOB26aPlan(*this);
            physical_plan = move(physical_plan_by_hand);
        }
        else if (pb_file == "job27a") {
            auto physical_plan_by_hand = GenerateJOB27aPlan(*this);
            physical_plan = move(physical_plan_by_hand);
        }
        else if (pb_file == "job28a") {
            auto physical_plan_by_hand = GenerateJOB28aPlan(*this);
            physical_plan = move(physical_plan_by_hand);
        }
        else if (pb_file == "job29a") {
            auto physical_plan_by_hand = GenerateJOB29aPlan(*this);
            physical_plan = move(physical_plan_by_hand);
        }
        else if (pb_file == "job30a") {
            auto physical_plan_by_hand = GenerateJOB30aPlan(*this);
            physical_plan = move(physical_plan_by_hand);
        }
        else if (pb_file == "job31a") {
            auto physical_plan_by_hand = GenerateJOB31aPlan(*this);
            physical_plan = move(physical_plan_by_hand);
        }
        else if (pb_file == "job32a") {
            auto physical_plan_by_hand = GenerateJOB32aPlan(*this);
            physical_plan = move(physical_plan_by_hand);
        }
        else if (pb_file == "job33a") {
            auto physical_plan_by_hand = GenerateJOB33aPlan(*this);
            physical_plan = move(physical_plan_by_hand);
        }
        else if (pb_file == "triangle") {
            auto physical_plan_by_hand = GenerateTriangle(*this);
            physical_plan = move(physical_plan_by_hand);
        }
        else if (pb_file == "path") {
            auto physical_plan_by_hand = GeneratePath(*this);
            physical_plan = move(physical_plan_by_hand);
        }
    }

    if (sql_mode == 1 && (query[0] == 's' || query[0] == 'S')) {
		// std::cout << physical_plan->ToString() << std::endl;
        unordered_map<int, string> tableid2name;
        // planner.binder->bind_context.GetBindingsMap(tableid2name);
        // string pb_file = "output.log";
        pb_serializer.SerializeToFile(pb_file, physical_plan.get(), tableid2name);
	}
#ifdef DEBUG
	D_ASSERT(!physical_plan->ToString().empty());
#endif
	result->plan = std::move(physical_plan);
	return result;
}

double ClientContext::GetProgress() {
	return query_progress.load();
}

unique_ptr<PendingQueryResult> ClientContext::PendingPreparedStatement(ClientContextLock &lock,
                                                                       shared_ptr<PreparedStatementData> statement_p,
                                                                       const PendingQueryParameters &parameters) {
	D_ASSERT(active_query);
	auto &statement = *statement_p;
	if (ValidChecker::IsInvalidated(ActiveTransaction()) && statement.properties.requires_valid_transaction) {
		throw Exception(ErrorManager::FormatException(*this, ErrorType::INVALIDATED_TRANSACTION));
	}
	auto &transaction = MetaTransaction::Get(*this);
	auto &manager = DatabaseManager::Get(*this);
	for (auto &modified_database : statement.properties.modified_databases) {
		auto entry = manager.GetDatabase(*this, modified_database);
		if (!entry) {
			throw InternalException("Database \"%s\" not found", modified_database);
		}
		if (entry->IsReadOnly()) {
			throw Exception(StringUtil::Format(
			    "Cannot execute statement of type \"%s\" on database \"%s\" which is attached in read-only mode!",
			    StatementTypeToString(statement.statement_type), modified_database));
		}
		transaction.ModifyDatabase(*entry);
	}

	// bind the bound values before execution
	case_insensitive_map_t<Value> owned_values;
	if (parameters.parameters) {
		auto &params = *parameters.parameters;
		for (auto &val : params) {
			owned_values.emplace(val);
		}
	}
	statement.Bind(std::move(owned_values));

	active_query->executor = make_uniq<Executor>(*this);
	auto &executor = *active_query->executor;
	if (config.enable_progress_bar) {
		progress_bar_display_create_func_t display_create_func = nullptr;
		if (config.print_progress_bar) {
			// If a custom display is set, use that, otherwise just use the default
			display_create_func =
			    config.display_create_func ? config.display_create_func : ProgressBar::DefaultProgressBarDisplay;
		}
		active_query->progress_bar = make_uniq<ProgressBar>(executor, config.wait_time, display_create_func);
		active_query->progress_bar->Start();
		query_progress = 0;
	}
	auto stream_result = parameters.allow_stream_result && statement.properties.allow_stream_result;
	if (!stream_result && statement.properties.return_type == StatementReturnType::QUERY_RESULT) {
		unique_ptr<PhysicalResultCollector> collector;
		auto &config = ClientConfig::GetConfig(*this);
		auto get_method =
		    config.result_collector ? config.result_collector : PhysicalResultCollector::GetResultCollector;
		collector = get_method(*this, statement);
		D_ASSERT(collector->type == PhysicalOperatorType::RESULT_COLLECTOR);
		executor.Initialize(std::move(collector));
	} else {
		executor.Initialize(*statement.plan);
	}
	auto types = executor.GetTypes();
	D_ASSERT(types == statement.types);
	D_ASSERT(!active_query->open_result);

	auto pending_result =
	    make_uniq<PendingQueryResult>(shared_from_this(), *statement_p, std::move(types), stream_result);
	active_query->prepared = std::move(statement_p);
	active_query->open_result = pending_result.get();
	return pending_result;
}

PendingExecutionResult ClientContext::ExecuteTaskInternal(ClientContextLock &lock, PendingQueryResult &result) {
	D_ASSERT(active_query);
	D_ASSERT(active_query->open_result == &result);
	try {
		auto result = active_query->executor->ExecuteTask();
		if (active_query->progress_bar) {
			active_query->progress_bar->Update(result == PendingExecutionResult::RESULT_READY);
			query_progress = active_query->progress_bar->GetCurrentPercentage();
		}
		return result;
	} catch (FatalException &ex) {
		// fatal exceptions invalidate the entire database
		result.SetError(PreservedError(ex));
		auto &db = DatabaseInstance::GetDatabase(*this);
		ValidChecker::Invalidate(db, ex.what());
	} catch (const Exception &ex) {
		result.SetError(PreservedError(ex));
	} catch (std::exception &ex) {
		result.SetError(PreservedError(ex));
	} catch (...) { // LCOV_EXCL_START
		result.SetError(PreservedError("Unhandled exception in ExecuteTaskInternal"));
	} // LCOV_EXCL_STOP
	EndQueryInternal(lock, false, true);
	return PendingExecutionResult::EXECUTION_ERROR;
}

void ClientContext::InitialCleanup(ClientContextLock &lock) {
	//! Cleanup any open results and reset the interrupted flag
	CleanupInternal(lock);
	interrupted = false;
}

vector<unique_ptr<SQLStatement>> ClientContext::ParseStatements(const string &query) {
	auto lock = LockContext();
	return ParseStatementsInternal(*lock, query);
}

vector<unique_ptr<SQLStatement>> ClientContext::ParseStatementsInternal(ClientContextLock &lock, const string &query) {
	Parser parser(GetParserOptions());
	parser.ParseQuery(query);

	PragmaHandler handler(*this);
	handler.HandlePragmaStatements(lock, parser.statements);

	return std::move(parser.statements);
}

void ClientContext::HandlePragmaStatements(vector<unique_ptr<SQLStatement>> &statements) {
	auto lock = LockContext();

	PragmaHandler handler(*this);
	handler.HandlePragmaStatements(*lock, statements);
}

unique_ptr<LogicalOperator> ClientContext::ExtractPlan(const string &query) {
	auto lock = LockContext();

	auto statements = ParseStatementsInternal(*lock, query);
	if (statements.size() != 1) {
		throw Exception("ExtractPlan can only prepare a single statement");
	}

	unique_ptr<LogicalOperator> plan;
	client_data->http_state = make_shared<HTTPState>();
	RunFunctionInTransactionInternal(*lock, [&]() {
		Planner planner(*this);
		planner.CreatePlan(std::move(statements[0]));
		D_ASSERT(planner.plan);

		plan = std::move(planner.plan);

		if (config.enable_optimizer) {
			Optimizer optimizer(*planner.binder, *this);
			plan = optimizer.Optimize(std::move(plan));
		}

		ColumnBindingResolver resolver;
		resolver.Verify(*plan);
		resolver.VisitOperator(*plan);

		plan->ResolveOperatorTypes();
	});
	return plan;
}

unique_ptr<PreparedStatement> ClientContext::PrepareInternal(ClientContextLock &lock,
                                                             unique_ptr<SQLStatement> statement) {
	auto n_param = statement->n_param;
	auto named_param_map = std::move(statement->named_param_map);
	auto statement_query = statement->query;
	shared_ptr<PreparedStatementData> prepared_data;
	auto unbound_statement = statement->Copy();
	RunFunctionInTransactionInternal(
	    lock, [&]() { prepared_data = CreatePreparedStatement(lock, statement_query, std::move(statement)); }, false);
	prepared_data->unbound_statement = std::move(unbound_statement);
	return make_uniq<PreparedStatement>(shared_from_this(), std::move(prepared_data), std::move(statement_query),
	                                    n_param, std::move(named_param_map));
}

unique_ptr<PreparedStatement> ClientContext::Prepare(unique_ptr<SQLStatement> statement) {
	auto lock = LockContext();
	// prepare the query
	try {
		InitialCleanup(*lock);
		return PrepareInternal(*lock, std::move(statement));
	} catch (const Exception &ex) {
		return make_uniq<PreparedStatement>(PreservedError(ex));
	} catch (std::exception &ex) {
		return make_uniq<PreparedStatement>(PreservedError(ex));
	}
}

unique_ptr<PreparedStatement> ClientContext::Prepare(const string &query) {
	auto lock = LockContext();
	// prepare the query
	try {
		InitialCleanup(*lock);

		// first parse the query
		auto statements = ParseStatementsInternal(*lock, query);
		if (statements.empty()) {
			throw Exception("No statement to prepare!");
		}
		if (statements.size() > 1) {
			throw Exception("Cannot prepare multiple statements at once!");
		}
		return PrepareInternal(*lock, std::move(statements[0]));
	} catch (const Exception &ex) {
		return make_uniq<PreparedStatement>(PreservedError(ex));
	} catch (std::exception &ex) {
		return make_uniq<PreparedStatement>(PreservedError(ex));
	}
}

unique_ptr<PendingQueryResult> ClientContext::PendingQueryPreparedInternal(ClientContextLock &lock, const string &query,
                                                                           shared_ptr<PreparedStatementData> &prepared,
                                                                           const PendingQueryParameters &parameters) {
	try {
		InitialCleanup(lock);
	} catch (const Exception &ex) {
		return make_uniq<PendingQueryResult>(PreservedError(ex));
	} catch (std::exception &ex) {
		return make_uniq<PendingQueryResult>(PreservedError(ex));
	}
	return PendingStatementOrPreparedStatementInternal(lock, query, nullptr, prepared, parameters);
}

unique_ptr<PendingQueryResult> ClientContext::PendingQuery(const string &query,
                                                           shared_ptr<PreparedStatementData> &prepared,
                                                           const PendingQueryParameters &parameters) {
	auto lock = LockContext();
	return PendingQueryPreparedInternal(*lock, query, prepared, parameters);
}

unique_ptr<QueryResult> ClientContext::Execute(const string &query, shared_ptr<PreparedStatementData> &prepared,
                                               const PendingQueryParameters &parameters) {
	auto lock = LockContext();
	auto pending = PendingQueryPreparedInternal(*lock, query, prepared, parameters);
	if (pending->HasError()) {
		return make_uniq<MaterializedQueryResult>(pending->GetErrorObject());
	}
	return pending->ExecuteInternal(*lock);
}

unique_ptr<QueryResult> ClientContext::Execute(const string &query, shared_ptr<PreparedStatementData> &prepared,
                                               case_insensitive_map_t<Value> &values, bool allow_stream_result) {
	PendingQueryParameters parameters;
	parameters.parameters = &values;
	parameters.allow_stream_result = allow_stream_result;
	return Execute(query, prepared, parameters);
}

unique_ptr<PendingQueryResult> ClientContext::PendingStatementInternal(ClientContextLock &lock, const string &query,
                                                                       unique_ptr<SQLStatement> statement,
                                                                       const PendingQueryParameters &parameters) {
	// prepare the query for execution
	auto prepared = CreatePreparedStatement(lock, query, std::move(statement), parameters.parameters);
	idx_t parameter_count = !parameters.parameters ? 0 : parameters.parameters->size();
	if (prepared->properties.parameter_count > 0 && parameter_count == 0) {
		string error_message = StringUtil::Format("Expected %lld parameters, but none were supplied",
		                                          prepared->properties.parameter_count);
		return make_uniq<PendingQueryResult>(PreservedError(error_message));
	}
	if (!prepared->properties.bound_all_parameters) {
		return make_uniq<PendingQueryResult>(PreservedError("Not all parameters were bound"));
	}
	// execute the prepared statement
	return PendingPreparedStatement(lock, std::move(prepared), parameters);
}

unique_ptr<QueryResult> ClientContext::RunStatementInternal(ClientContextLock &lock, const string &query,
                                                            unique_ptr<SQLStatement> statement,
                                                            bool allow_stream_result, bool verify) {
	PendingQueryParameters parameters;
	parameters.allow_stream_result = allow_stream_result;
	auto pending = PendingQueryInternal(lock, std::move(statement), parameters, verify);
	if (pending->HasError()) {
		return make_uniq<MaterializedQueryResult>(pending->GetErrorObject());
	}
	return ExecutePendingQueryInternal(lock, *pending);
}

bool ClientContext::IsActiveResult(ClientContextLock &lock, BaseQueryResult *result) {
	if (!active_query) {
		return false;
	}
	return active_query->open_result == result;
}

unique_ptr<PendingQueryResult> ClientContext::PendingStatementOrPreparedStatementInternal(
    ClientContextLock &lock, const string &query, unique_ptr<SQLStatement> statement,
    shared_ptr<PreparedStatementData> &prepared, const PendingQueryParameters &parameters) {
	// check if we are on AutoCommit. In this case we should start a transaction.
	if (statement && config.AnyVerification()) {
		// query verification is enabled
		// create a copy of the statement, and use the copy
		// this way we verify that the copy correctly copies all properties
		auto copied_statement = statement->Copy();
		switch (statement->type) {
		case StatementType::SELECT_STATEMENT: {
			// in case this is a select query, we verify the original statement
			PreservedError error;
			try {
				error = VerifyQuery(lock, query, std::move(statement));
			} catch (const Exception &ex) {
				error = PreservedError(ex);
			} catch (std::exception &ex) {
				error = PreservedError(ex);
			}
			if (error) {
				// error in verifying query
				return make_uniq<PendingQueryResult>(error);
			}
			statement = std::move(copied_statement);
			break;
		}
#ifndef DUCKDB_ALTERNATIVE_VERIFY
		case StatementType::COPY_STATEMENT:
		case StatementType::INSERT_STATEMENT:
		case StatementType::DELETE_STATEMENT:
		case StatementType::UPDATE_STATEMENT: {
			Parser parser;
			PreservedError error;
			try {
				parser.ParseQuery(statement->ToString());
			} catch (const Exception &ex) {
				error = PreservedError(ex);
			} catch (std::exception &ex) {
				error = PreservedError(ex);
			}
			if (error) {
				// error in verifying query
				return make_uniq<PendingQueryResult>(error);
			}
			statement = std::move(parser.statements[0]);
			break;
		}
#endif
		default:
			statement = std::move(copied_statement);
			break;
		}
	}
	return PendingStatementOrPreparedStatement(lock, query, std::move(statement), prepared, parameters);
}

unique_ptr<PendingQueryResult> ClientContext::PendingStatementOrPreparedStatement(
    ClientContextLock &lock, const string &query, unique_ptr<SQLStatement> statement,
    shared_ptr<PreparedStatementData> &prepared, const PendingQueryParameters &parameters) {
	unique_ptr<PendingQueryResult> result;

	try {
		BeginQueryInternal(lock, query);
	} catch (FatalException &ex) {
		// fatal exceptions invalidate the entire database
		auto &db = DatabaseInstance::GetDatabase(*this);
		ValidChecker::Invalidate(db, ex.what());
		result = make_uniq<PendingQueryResult>(PreservedError(ex));
		return result;
	} catch (const Exception &ex) {
		return make_uniq<PendingQueryResult>(PreservedError(ex));
	} catch (std::exception &ex) {
		return make_uniq<PendingQueryResult>(PreservedError(ex));
	}
	// start the profiler
	auto &profiler = QueryProfiler::Get(*this);
	profiler.StartQuery(query, IsExplainAnalyze(statement ? statement.get() : prepared->unbound_statement.get()));

	bool invalidate_query = true;
	try {
		if (statement) {
			result = PendingStatementInternal(lock, query, std::move(statement), parameters);
		} else {
			if (prepared->RequireRebind(*this, parameters.parameters)) {
				// catalog was modified: rebind the statement before execution
				auto new_prepared =
				    CreatePreparedStatement(lock, query, prepared->unbound_statement->Copy(), parameters.parameters);
				D_ASSERT(new_prepared->properties.bound_all_parameters);
				new_prepared->unbound_statement = std::move(prepared->unbound_statement);
				prepared = std::move(new_prepared);
				prepared->properties.bound_all_parameters = false;
			}
			result = PendingPreparedStatement(lock, prepared, parameters);
		}
	} catch (StandardException &ex) {
		// standard exceptions do not invalidate the current transaction
		result = make_uniq<PendingQueryResult>(PreservedError(ex));
		invalidate_query = false;
	} catch (FatalException &ex) {
		// fatal exceptions invalidate the entire database
		if (!config.query_verification_enabled) {
			auto &db = DatabaseInstance::GetDatabase(*this);
			ValidChecker::Invalidate(db, ex.what());
		}
		result = make_uniq<PendingQueryResult>(PreservedError(ex));
	} catch (const Exception &ex) {
		// other types of exceptions do invalidate the current transaction
		result = make_uniq<PendingQueryResult>(PreservedError(ex));
	} catch (std::exception &ex) {
		// other types of exceptions do invalidate the current transaction
		result = make_uniq<PendingQueryResult>(PreservedError(ex));
	}
	if (result->HasError()) {
		// query failed: abort now
		EndQueryInternal(lock, false, invalidate_query);
		return result;
	}
	D_ASSERT(active_query->open_result == result.get());
	return result;
}

void ClientContext::LogQueryInternal(ClientContextLock &, const string &query) {
	if (!client_data->log_query_writer) {
#ifdef DUCKDB_FORCE_QUERY_LOG
		try {
			string log_path(DUCKDB_FORCE_QUERY_LOG);
			client_data->log_query_writer =
			    make_uniq<BufferedFileWriter>(FileSystem::GetFileSystem(*this), log_path,
			                                  BufferedFileWriter::DEFAULT_OPEN_FLAGS, client_data->file_opener.get());
		} catch (...) {
			return;
		}
#else
		return;
#endif
	}
	// log query path is set: log the query
	client_data->log_query_writer->WriteData(const_data_ptr_cast(query.c_str()), query.size());
	client_data->log_query_writer->WriteData(const_data_ptr_cast("\n"), 1);
	client_data->log_query_writer->Flush();
	client_data->log_query_writer->Sync();
}

unique_ptr<QueryResult> ClientContext::Query(unique_ptr<SQLStatement> statement, bool allow_stream_result) {
	auto pending_query = PendingQuery(std::move(statement), allow_stream_result);
	if (pending_query->HasError()) {
		return make_uniq<MaterializedQueryResult>(pending_query->GetErrorObject());
	}
	return pending_query->Execute();
}

unique_ptr<QueryResult> ClientContext::Query(const string &query, bool allow_stream_result) {
	auto lock = LockContext();

	PreservedError error;
	vector<unique_ptr<SQLStatement>> statements;
	if (!ParseStatements(*lock, query, statements, error)) {
		return make_uniq<MaterializedQueryResult>(std::move(error));
	}
	if (statements.empty()) {
		// no statements, return empty successful result
		StatementProperties properties;
		vector<string> names;
		auto collection = make_uniq<ColumnDataCollection>(Allocator::DefaultAllocator());
		return make_uniq<MaterializedQueryResult>(StatementType::INVALID_STATEMENT, properties, std::move(names),
		                                          std::move(collection), GetClientProperties());
	}

	unique_ptr<QueryResult> result;
	QueryResult *last_result = nullptr;
	bool last_had_result = false;
	for (idx_t i = 0; i < statements.size(); i++) {
		auto &statement = statements[i];
		bool is_last_statement = i + 1 == statements.size();
		PendingQueryParameters parameters;
		parameters.allow_stream_result = allow_stream_result && is_last_statement;
		auto pending_query = PendingQueryInternal(*lock, std::move(statement), parameters);
		auto has_result = pending_query->properties.return_type == StatementReturnType::QUERY_RESULT;

        // std::cout << "come here" << std::endl;
	if (sql_mode == 1) {
            return result;
        }

		unique_ptr<QueryResult> current_result;
		if (pending_query->HasError()) {
			current_result = make_uniq<MaterializedQueryResult>(pending_query->GetErrorObject());
		} else {
			current_result = ExecutePendingQueryInternal(*lock, *pending_query);
		}
		// now append the result to the list of results
		if (!last_result || !last_had_result) {
			// first result of the query
			result = std::move(current_result);
			last_result = result.get();
			last_had_result = has_result;
		} else {
			// later results; attach to the result chain
			// but only if there is a result
			if (!has_result) {
				continue;
			}
			last_result->next = std::move(current_result);
			last_result = last_result->next.get();
		}
	}
	return result;
}

bool ClientContext::ParseStatements(ClientContextLock &lock, const string &query,
                                    vector<unique_ptr<SQLStatement>> &result, PreservedError &error) {
	try {
		InitialCleanup(lock);
		// parse the query and transform it into a set of statements
		result = ParseStatementsInternal(lock, query);
		return true;
	} catch (const Exception &ex) {
		error = PreservedError(ex);
		return false;
	} catch (std::exception &ex) {
		error = PreservedError(ex);
		return false;
	}
}

unique_ptr<PendingQueryResult> ClientContext::PendingQuery(const string &query, bool allow_stream_result) {
	auto lock = LockContext();

	PreservedError error;
	vector<unique_ptr<SQLStatement>> statements;
	if (!ParseStatements(*lock, query, statements, error)) {
		return make_uniq<PendingQueryResult>(std::move(error));
	}
	if (statements.size() != 1) {
		return make_uniq<PendingQueryResult>(PreservedError("PendingQuery can only take a single statement"));
	}
	PendingQueryParameters parameters;
	parameters.allow_stream_result = allow_stream_result;
	return PendingQueryInternal(*lock, std::move(statements[0]), parameters);
}

unique_ptr<PendingQueryResult> ClientContext::PendingQuery(unique_ptr<SQLStatement> statement,
                                                           bool allow_stream_result) {
	auto lock = LockContext();
	PendingQueryParameters parameters;
	parameters.allow_stream_result = allow_stream_result;
	return PendingQueryInternal(*lock, std::move(statement), parameters);
}

unique_ptr<PendingQueryResult> ClientContext::PendingQueryInternal(ClientContextLock &lock,
                                                                   unique_ptr<SQLStatement> statement,
                                                                   const PendingQueryParameters &parameters,
                                                                   bool verify) {
	auto query = statement->query;
	shared_ptr<PreparedStatementData> prepared;
	if (verify) {
		return PendingStatementOrPreparedStatementInternal(lock, query, std::move(statement), prepared, parameters);
	} else {
		return PendingStatementOrPreparedStatement(lock, query, std::move(statement), prepared, parameters);
	}
}

unique_ptr<QueryResult> ClientContext::ExecutePendingQueryInternal(ClientContextLock &lock, PendingQueryResult &query) {
	return query.ExecuteInternal(lock);
}

void ClientContext::Interrupt() {
	interrupted = true;
}

void ClientContext::EnableProfiling() {
	auto lock = LockContext();
	auto &config = ClientConfig::GetConfig(*this);
	config.enable_profiler = true;
	config.emit_profiler_output = true;
}

void ClientContext::DisableProfiling() {
	auto lock = LockContext();
	auto &config = ClientConfig::GetConfig(*this);
	config.enable_profiler = false;
}

void ClientContext::RegisterFunction(CreateFunctionInfo &info) {
	RunFunctionInTransaction([&]() {
		auto existing_function = Catalog::GetEntry<ScalarFunctionCatalogEntry>(*this, INVALID_CATALOG, info.schema,
		                                                                       info.name, OnEntryNotFound::RETURN_NULL);
		if (existing_function) {
			auto &new_info = info.Cast<CreateScalarFunctionInfo>();
			if (new_info.functions.MergeFunctionSet(existing_function->functions)) {
				// function info was updated from catalog entry, rewrite is needed
				info.on_conflict = OnCreateConflict::REPLACE_ON_CONFLICT;
			}
		}
		// create function
		auto &catalog = Catalog::GetSystemCatalog(*this);
		catalog.CreateFunction(*this, info);
	});
}

void ClientContext::RunFunctionInTransactionInternal(ClientContextLock &lock, const std::function<void(void)> &fun,
                                                     bool requires_valid_transaction) {
	if (requires_valid_transaction && transaction.HasActiveTransaction() &&
	    ValidChecker::IsInvalidated(ActiveTransaction())) {
		throw TransactionException(ErrorManager::FormatException(*this, ErrorType::INVALIDATED_TRANSACTION));
	}
	// check if we are on AutoCommit. In this case we should start a transaction
	bool require_new_transaction = transaction.IsAutoCommit() && !transaction.HasActiveTransaction();
	if (require_new_transaction) {
		D_ASSERT(!active_query);
		transaction.BeginTransaction();
	}
	try {
		fun();
	} catch (StandardException &ex) {
		if (require_new_transaction) {
			transaction.Rollback();
		}
		throw;
	} catch (FatalException &ex) {
		auto &db = DatabaseInstance::GetDatabase(*this);
		ValidChecker::Invalidate(db, ex.what());
		throw;
	} catch (std::exception &ex) {
		if (require_new_transaction) {
			transaction.Rollback();
		} else {
			ValidChecker::Invalidate(ActiveTransaction(), ex.what());
		}
		throw;
	}
	if (require_new_transaction) {
		transaction.Commit();
	}
}

void ClientContext::RunFunctionInTransaction(const std::function<void(void)> &fun, bool requires_valid_transaction) {
	auto lock = LockContext();
	RunFunctionInTransactionInternal(*lock, fun, requires_valid_transaction);
}

unique_ptr<TableDescription> ClientContext::TableInfo(const string &schema_name, const string &table_name) {
	unique_ptr<TableDescription> result;
	RunFunctionInTransaction([&]() {
		// obtain the table info
		auto table = Catalog::GetEntry<TableCatalogEntry>(*this, INVALID_CATALOG, schema_name, table_name,
		                                                  OnEntryNotFound::RETURN_NULL);
		if (!table) {
			return;
		}
		// write the table info to the result
		result = make_uniq<TableDescription>();
		result->schema = schema_name;
		result->table = table_name;
		for (auto &column : table->GetColumns().Logical()) {
			result->columns.emplace_back(column.Name(), column.Type());
		}
	});
	return result;
}

void ClientContext::Append(TableDescription &description, ColumnDataCollection &collection) {
	RunFunctionInTransaction([&]() {
		auto &table_entry =
		    Catalog::GetEntry<TableCatalogEntry>(*this, INVALID_CATALOG, description.schema, description.table);
		// verify that the table columns and types match up
		if (description.columns.size() != table_entry.GetColumns().PhysicalColumnCount()) {
			throw Exception("Failed to append: table entry has different number of columns!");
		}
		for (idx_t i = 0; i < description.columns.size(); i++) {
			if (description.columns[i].Type() != table_entry.GetColumns().GetColumn(PhysicalIndex(i)).Type()) {
				throw Exception("Failed to append: table entry has different number of columns!");
			}
		}
		table_entry.GetStorage().LocalAppend(table_entry, *this, collection);
	});
}

void ClientContext::TryBindRelation(Relation &relation, vector<ColumnDefinition> &result_columns) {
#ifdef DEBUG
	D_ASSERT(!relation.GetAlias().empty());
	D_ASSERT(!relation.ToString().empty());
#endif
	client_data->http_state = make_shared<HTTPState>();
	RunFunctionInTransaction([&]() {
		// bind the expressions
		auto binder = Binder::CreateBinder(*this);
		auto result = relation.Bind(*binder);
		D_ASSERT(result.names.size() == result.types.size());

		result_columns.reserve(result_columns.size() + result.names.size());
		for (idx_t i = 0; i < result.names.size(); i++) {
			result_columns.emplace_back(result.names[i], result.types[i]);
		}
	});
}

unordered_set<string> ClientContext::GetTableNames(const string &query) {
	auto lock = LockContext();

	auto statements = ParseStatementsInternal(*lock, query);
	if (statements.size() != 1) {
		throw InvalidInputException("Expected a single statement");
	}

	unordered_set<string> result;
	RunFunctionInTransactionInternal(*lock, [&]() {
		// bind the expressions
		auto binder = Binder::CreateBinder(*this);
		binder->SetBindingMode(BindingMode::EXTRACT_NAMES);
		binder->Bind(*statements[0]);
		result = binder->GetTableNames();
	});
	return result;
}

unique_ptr<PendingQueryResult> ClientContext::PendingQueryInternal(ClientContextLock &lock,
                                                                   const shared_ptr<Relation> &relation,
                                                                   bool allow_stream_result) {
	InitialCleanup(lock);

	string query;
	if (config.query_verification_enabled) {
		// run the ToString method of any relation we run, mostly to ensure it doesn't crash
		relation->ToString();
		relation->GetAlias();
		if (relation->IsReadOnly()) {
			// verify read only statements by running a select statement
			auto select = make_uniq<SelectStatement>();
			select->node = relation->GetQueryNode();
			RunStatementInternal(lock, query, std::move(select), false);
		}
	}

	auto relation_stmt = make_uniq<RelationStatement>(relation);
	PendingQueryParameters parameters;
	parameters.allow_stream_result = allow_stream_result;
	return PendingQueryInternal(lock, std::move(relation_stmt), parameters);
}

unique_ptr<PendingQueryResult> ClientContext::PendingQuery(const shared_ptr<Relation> &relation,
                                                           bool allow_stream_result) {
	auto lock = LockContext();
	return PendingQueryInternal(*lock, relation, allow_stream_result);
}

unique_ptr<QueryResult> ClientContext::Execute(const shared_ptr<Relation> &relation) {
	auto lock = LockContext();
	auto &expected_columns = relation->Columns();
	auto pending = PendingQueryInternal(*lock, relation, false);
	if (!pending->success) {
		return make_uniq<MaterializedQueryResult>(pending->GetErrorObject());
	}

	unique_ptr<QueryResult> result;
	result = ExecutePendingQueryInternal(*lock, *pending);
	if (result->HasError()) {
		return result;
	}
	// verify that the result types and result names of the query match the expected result types/names
	if (result->types.size() == expected_columns.size()) {
		bool mismatch = false;
		for (idx_t i = 0; i < result->types.size(); i++) {
			if (result->types[i] != expected_columns[i].Type() || result->names[i] != expected_columns[i].Name()) {
				mismatch = true;
				break;
			}
		}
		if (!mismatch) {
			// all is as expected: return the result
			return result;
		}
	}
	// result mismatch
	string err_str = "Result mismatch in query!\nExpected the following columns: [";
	for (idx_t i = 0; i < expected_columns.size(); i++) {
		if (i > 0) {
			err_str += ", ";
		}
		err_str += expected_columns[i].Name() + " " + expected_columns[i].Type().ToString();
	}
	err_str += "]\nBut result contained the following: ";
	for (idx_t i = 0; i < result->types.size(); i++) {
		err_str += i == 0 ? "[" : ", ";
		err_str += result->names[i] + " " + result->types[i].ToString();
	}
	err_str += "]";
	return make_uniq<MaterializedQueryResult>(PreservedError(err_str));
}

bool ClientContext::TryGetCurrentSetting(const std::string &key, Value &result) {
	// first check the built-in settings
	auto &db_config = DBConfig::GetConfig(*this);
	auto option = db_config.GetOptionByName(key);
	if (option) {
		result = option->get_setting(*this);
		return true;
	}

	// check the client session values
	const auto &session_config_map = config.set_variables;

	auto session_value = session_config_map.find(key);
	bool found_session_value = session_value != session_config_map.end();
	if (found_session_value) {
		result = session_value->second;
		return true;
	}
	// finally check the global session values
	return db->TryGetCurrentSetting(key, result);
}

ParserOptions ClientContext::GetParserOptions() const {
	auto &client_config = ClientConfig::GetConfig(*this);
	ParserOptions options;
	options.preserve_identifier_case = client_config.preserve_identifier_case;
	options.integer_division = client_config.integer_division;
	options.max_expression_depth = client_config.max_expression_depth;
	options.extensions = &DBConfig::GetConfig(*this).parser_extensions;
	return options;
}

ClientProperties ClientContext::GetClientProperties() const {
	string timezone = "UTC";
	Value result;
	// 1) Check Set Variable
	auto &client_config = ClientConfig::GetConfig(*this);
	auto tz_config = client_config.set_variables.find("timezone");
	if (tz_config == client_config.set_variables.end()) {
		// 2) Check for Default Value
		auto default_value = db->config.extension_parameters.find("timezone");
		if (default_value != db->config.extension_parameters.end()) {
			timezone = default_value->second.default_value.GetValue<string>();
		}
	} else {
		timezone = tz_config->second.GetValue<string>();
	}
	return {timezone, db->config.options.arrow_offset_size};
}

bool ClientContext::ExecutionIsFinished() {
	if (!active_query || !active_query->executor) {
		return false;
	}
	return active_query->executor->ExecutionIsFinished();
}

void ClientContext::SetPbParameters(int sql_mode_input, std::string pb_file_input, unique_ptr<std::vector<string>> parameters) {
    sql_mode = sql_mode_input;
    pb_file = pb_file_input;
    paras = move(parameters);
}

unique_ptr<LogicalGet> getLogicalGet(ClientContext& context, TableCatalogEntry& table, string& alias, idx_t table_index, vector<LogicalType>& table_types) {
    auto &catalog = Catalog::GetSystemCatalog(context);
    unique_ptr<FunctionData> bind_data;
    auto scan_function = table.GetScanFunction(context, bind_data);
    vector<string> table_names;
    vector<TableColumnType> table_categories;
    vector<string> column_name_alias;

    vector<LogicalType> return_types;
    vector<string> return_names;
    for (auto &col : table.GetColumns().Logical()) {
        table_types.push_back(col.Type());
        table_names.push_back(col.Name());
        return_types.push_back(col.Type());
        return_names.push_back(col.Name());
    }
    table_names = BindContext::AliasColumnNames(alias, table_names, column_name_alias);

    auto logical_get = make_uniq<LogicalGet>(table_index, scan_function, std::move(bind_data),
                                             std::move(return_types), std::move(return_names));


   // context.AddBaseTable(table_index, alias, table_names, table_types, logical_get->column_ids,
    //                          logical_get->GetTable().get());

    return logical_get;
}

unique_ptr<PhysicalOperator> ClientContext::GenerateIC11Plan() {
    vector<idx_t> left_projection_map, right_projection_map;

    string table_vertex_person = "person";
    string table_edge_knows = "knows";
    string table_vertex_place = "place";
    idx_t table_index_person1 = 6;
    idx_t table_index_person2 = 8;
    idx_t table_index_knows = 7;
    idx_t table_index_place = 11;


    auto table_or_view_person = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                  table_vertex_person, OnEntryNotFound::RETURN_NULL);
    auto &table_person = table_or_view_person->Cast<TableCatalogEntry>();


    auto table_or_view_knows = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                 table_edge_knows, OnEntryNotFound::RETURN_NULL);
    auto &table_knows = table_or_view_knows->Cast<TableCatalogEntry>();

    auto table_or_view_place = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                        table_vertex_place, OnEntryNotFound::RETURN_NULL);
    auto &table_place = table_or_view_place->Cast<TableCatalogEntry>();

    string p_person_first_name = paras->data()[1];
    Value p_first_name(p_person_first_name);
    vector<idx_t> person2_ids{1, COLUMN_IDENTIFIER_ROW_ID, 9, 0, 2, 4, 5, 3, 7, 6};
    vector<LogicalType> get_person2_types{LogicalType::VARCHAR, LogicalType::BIGINT, LogicalType::BIGINT,
                                          LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::DATE, LogicalType::BIGINT,
                                          LogicalType::VARCHAR, LogicalType::VARCHAR, LogicalType::VARCHAR};
    string alias_person2 = "p2";
    vector<LogicalType> table_types_person2;
    vector<unique_ptr<Expression>> filter_person2;
    unique_ptr<LogicalGet> get_op_person2 = move(
            getLogicalGet(*this, table_person, alias_person2, table_index_person2, table_types_person2));
    unique_ptr<TableFilterSet> table_filters_person2 = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_person2 = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL,
                                                                                           p_first_name);
    table_filters_person2->filters[0] = move(constant_filter_person2);
    unique_ptr<PhysicalTableScan> scan_person2 = make_uniq<PhysicalTableScan>(get_person2_types,
                                                                              get_op_person2->function,
                                                                              get_op_person2->table_index,
                                                                              move(get_op_person2->bind_data),
                                                                              table_types_person2, person2_ids,
                                                                              move(filter_person2), vector<column_t>(),
                                                                              get_op_person2->names,
                                                                              std::move(table_filters_person2),
                                                                              get_op_person2->estimated_cardinality,
                                                                              get_op_person2->extra_info);

    idx_t p_person_id = atoll(paras->data()[0].c_str()); // 933;
    Value p_person = Value::BIGINT(p_person_id);
    vector<idx_t> person1_ids{0, COLUMN_IDENTIFIER_ROW_ID};
    vector<LogicalType> get_person1_types{LogicalType::BIGINT, LogicalType::BIGINT};
    string alias_person1 = "p1";
    vector<LogicalType> table_types_person1;
    unique_ptr<LogicalGet> get_op_person1 = move(
            getLogicalGet(*this, table_person, alias_person1, table_index_person1, table_types_person1));
    vector<unique_ptr<Expression>> filter_person1;
    unique_ptr<TableFilterSet> table_filters_person1 = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL,
                                                                                   p_person);
    table_filters_person1->filters[0] = move(constant_filter);
    unique_ptr<PhysicalTableScan> scan_person1 = make_uniq<PhysicalTableScan>(get_person1_types,
                                                                              get_op_person1->function,
                                                                              get_op_person1->table_index,
                                                                              move(get_op_person1->bind_data),
                                                                              table_types_person1, person1_ids,
                                                                              move(filter_person1), vector<column_t>(),
                                                                              get_op_person1->names,
                                                                              std::move(table_filters_person1),
                                                                              get_op_person1->estimated_cardinality,
                                                                              get_op_person1->extra_info);

    vector<JoinCondition> cond_knows;
    JoinCondition join_condition_knows;
    join_condition_knows.left = make_uniq<BoundReferenceExpression>("person_rowid", LogicalType::BIGINT, 1);
    join_condition_knows.right = make_uniq<BoundReferenceExpression>("person_rowid", LogicalType::BIGINT, 1);
    join_condition_knows.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_knows = make_uniq<RAIInfo>();
    rai_info_knows->rai = table_knows.GetStorage().info->rais[0].get();
    rai_info_knows->rai_type = RAIType::TARGET_EDGE;
    rai_info_knows->forward = true;
    rai_info_knows->vertex = &table_person;
    rai_info_knows->vertex_id = table_index_person2;
    rai_info_knows->passing_tables[0] = table_index_person2;
    rai_info_knows->left_cardinalities[0] = table_person.GetStorage().info->cardinality;
    // rai_info_knows->compact_list = &rai_info_knows->rai->alist->compact_backward_list;

    join_condition_knows.rais.push_back(move(rai_info_knows));
    cond_knows.push_back(move(join_condition_knows));

    LogicalComparisonJoin join_knows_op(JoinType::INNER);
    vector<LogicalType> output_knows_types{LogicalType::VARCHAR, LogicalType::BIGINT, LogicalType::BIGINT,
                                           LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::DATE,
                                           LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::VARCHAR,
                                           LogicalType::VARCHAR, LogicalType::BIGINT};
    join_knows_op.types = output_knows_types;
    vector<idx_t> right_projection_map_knows{1};
    vector<idx_t> merge_project_map;
    vector<LogicalType> delim_types;
    auto join_knows = make_uniq<PhysicalMergeSIPJoin>(join_knows_op, move(scan_person2), move(scan_person1),
                                                      move(cond_knows),
                                                      JoinType::INNER, left_projection_map, right_projection_map_knows,
                                                      merge_project_map, delim_types, 0);

    // join place with person-person
    vector<idx_t> place_ids{COLUMN_IDENTIFIER_ROW_ID, 1};
    vector<LogicalType> get_place_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_place = "pl";
    vector<LogicalType> table_types_place;
    vector<unique_ptr<Expression>> filter_place;
    unique_ptr<LogicalGet> get_op_place = move(
            getLogicalGet(*this, table_place, alias_place, table_index_place, table_types_place));
    unique_ptr<TableFilterSet> table_filters_place = NULL;
    unique_ptr<PhysicalTableScan> scan_place = make_uniq<PhysicalTableScan>(get_place_types, get_op_place->function,
                                                                           get_op_place->table_index,
                                                                           move(get_op_place->bind_data),
                                                                           table_types_place, place_ids,
                                                                           move(filter_place), vector<column_t>(),
                                                                           get_op_place->names,
                                                                           std::move(table_filters_place),
                                                                           get_op_place->estimated_cardinality,
                                                                           get_op_place->extra_info);

    vector<JoinCondition> cond_place;
    JoinCondition join_condition_place;
    join_condition_place.left = make_uniq<BoundReferenceExpression>("place_rowid", LogicalType::BIGINT, 0);
    join_condition_place.right = make_uniq<BoundReferenceExpression>("p_placeid_rowid", LogicalType::BIGINT, 2);
    join_condition_place.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_place = make_uniq<RAIInfo>();
    rai_info_place->rai = table_person.GetStorage().info->rais[0].get();
    rai_info_place->rai_type = RAIType::TARGET_EDGE;
    rai_info_place->forward = true;
    rai_info_place->vertex = &table_place;
    rai_info_place->vertex_id = table_index_place;
    rai_info_place->passing_tables[0] = table_index_place;
    rai_info_place->left_cardinalities[0] = table_place.GetStorage().info->cardinality;
    // rai_info_place->compact_list = &rai_info_place->rai->alist->compact_forward_list;

    join_condition_place.rais.push_back(move(rai_info_place));
    cond_place.push_back(move(join_condition_place));

    LogicalComparisonJoin join_place_op(JoinType::INNER);
    vector<LogicalType> output_place_types{LogicalType::BIGINT, LogicalType::VARCHAR,
                                           LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::DATE,
                                           LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::VARCHAR,
                                           LogicalType::VARCHAR};
    join_place_op.types = output_place_types;
    vector<idx_t> right_projection_map_place{3, 4, 5, 6, 7, 8, 9};
    vector<idx_t> merge_project_map_place;
    vector<LogicalType> delim_types_place;
    auto join_place = make_uniq<PhysicalSIPJoin>(join_place_op, move(scan_place), move(join_knows), move(cond_place),
                                                JoinType::INNER, left_projection_map, right_projection_map_place,
                                                delim_types_place, 0);


    // project
    vector<LogicalType> result_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::DATE,
                                     LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::VARCHAR,
                                     LogicalType::VARCHAR, LogicalType::VARCHAR};
    vector<unique_ptr<Expression>> select_list;
    auto result_col0 = make_uniq<BoundReferenceExpression>("p_personid", LogicalType::BIGINT, 2);
    auto result_col1 = make_uniq<BoundReferenceExpression>("p_lastname", LogicalType::VARCHAR, 3);
    auto result_col2 = make_uniq<BoundReferenceExpression>("p_birthday", LogicalType::DATE, 4);
    auto result_col3 = make_uniq<BoundReferenceExpression>("p_creationdate", LogicalType::BIGINT, 5);
    auto result_col4 = make_uniq<BoundReferenceExpression>("p_gender", LogicalType::VARCHAR, 6);
    auto result_col5 = make_uniq<BoundReferenceExpression>("p_browserused", LogicalType::VARCHAR, 7);
    auto result_col6 = make_uniq<BoundReferenceExpression>("p_locationip", LogicalType::VARCHAR, 8);
    auto result_col7 = make_uniq<BoundReferenceExpression>("pl_name", LogicalType::VARCHAR, 1);

    select_list.push_back(move(result_col0));
    select_list.push_back(move(result_col1));
    select_list.push_back(move(result_col2));
    select_list.push_back(move(result_col3));
    select_list.push_back(move(result_col4));
    select_list.push_back(move(result_col5));
    select_list.push_back(move(result_col6));
    select_list.push_back(move(result_col7));

    auto projection = make_uniq<PhysicalProjection>(result_types, move(select_list), 0);
    projection->children.push_back(move(join_place));

    return projection;
}

unique_ptr<PhysicalOperator> ClientContext::GenerateIC11PlanGLogue() {
    vector<idx_t> left_projection_map, right_projection_map;

    string table_vertex_PERSON_p1 = "PERSON";
    string table_vertex_PERSON_p2 = "PERSON";
    string table_vertex_PLACE_pl = "PLACE";
    string table_vertex_KNOWS_ = "KNOWS";
    string table_vertex_ISLOCATEDIN_ = "ISLOCATEDIN";

    idx_t table_index_PERSON_p1 = 1;
    idx_t table_index_PERSON_p2 = 2;
    idx_t table_index_PLACE_pl = 3;
    idx_t table_index_KNOWS_ = 4;
    idx_t table_index_ISLOCATEDIN_ = 5;
    auto table_or_view_PERSON = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_PERSON_p1,
                                                  OnEntryNotFound::RETURN_NULL);
    auto &table_PERSON = table_or_view_PERSON->Cast<TableCatalogEntry>();
    auto table_or_view_PLACE = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_PLACE_pl,
                                                 OnEntryNotFound::RETURN_NULL);
    auto &table_PLACE = table_or_view_PLACE->Cast<TableCatalogEntry>();
    auto table_or_view_KNOWS = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_KNOWS_,
                                                 OnEntryNotFound::RETURN_NULL);
    auto &table_KNOWS = table_or_view_KNOWS->Cast<TableCatalogEntry>();

    idx_t p_person_id = atoll(paras->data()[0].c_str()); // 933;
    Value p_person = Value::BIGINT(p_person_id);
    vector<idx_t> PERSON_p1_ids{0, COLUMN_IDENTIFIER_ROW_ID};
    vector<LogicalType> get_PERSON_p1_types{LogicalType::BIGINT, LogicalType::BIGINT};
    string alias_PERSON_p1 = "p1";
    vector<LogicalType> table_types_PERSON_p1;
    vector<unique_ptr<Expression>> filter_PERSON_p1;
    unique_ptr<LogicalGet> get_op_PERSON_p1 = move(
            getLogicalGet(*this, table_PERSON, alias_PERSON_p1, table_index_PERSON_p1, table_types_PERSON_p1));
    unique_ptr<TableFilterSet> table_filters_PERSON_p1 = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL,
                                                                                   p_person);
    table_filters_PERSON_p1->filters[0] = move(constant_filter);
    unique_ptr<PhysicalTableScan> scan_PERSON_p1 = make_uniq<PhysicalTableScan>(get_PERSON_p1_types,
                                                                                get_op_PERSON_p1->function,
                                                                                get_op_PERSON_p1->table_index,
                                                                                move(get_op_PERSON_p1->bind_data),
                                                                                table_types_PERSON_p1, PERSON_p1_ids,
                                                                                move(filter_PERSON_p1),
                                                                                vector<column_t>(),
                                                                                get_op_PERSON_p1->names,
                                                                                std::move(table_filters_PERSON_p1),
                                                                                get_op_PERSON_p1->estimated_cardinality,
                                                                                get_op_PERSON_p1->extra_info);

    string p_person_first_name = paras->data()[1];
    Value p_first_name(p_person_first_name);
    vector<idx_t> PERSON_p2_ids{1, 0, 2, 4, 5, 3, 7, 6, COLUMN_IDENTIFIER_ROW_ID, 9};
    vector<LogicalType> get_PERSON_p2_types{LogicalType::VARCHAR, LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::DATE,
                                            LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::VARCHAR,
                                            LogicalType::VARCHAR, LogicalType::BIGINT, LogicalType::BIGINT};
    string alias_PERSON_p2 = "p2";
    vector<LogicalType> table_types_PERSON_p2;
    vector<unique_ptr<Expression>> filter_PERSON_p2;
    unique_ptr<LogicalGet> get_op_PERSON_p2 = move(
            getLogicalGet(*this, table_PERSON, alias_PERSON_p2, table_index_PERSON_p2, table_types_PERSON_p2));
    unique_ptr<TableFilterSet> table_filters_PERSON_p2 = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_person2 = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL,
                                                                                           p_first_name);
    table_filters_PERSON_p2->filters[0] = move(constant_filter_person2);
    unique_ptr<PhysicalTableScan> scan_PERSON_p2 = make_uniq<PhysicalTableScan>(get_PERSON_p2_types,
                                                                                get_op_PERSON_p2->function,
                                                                                get_op_PERSON_p2->table_index,
                                                                                move(get_op_PERSON_p2->bind_data),
                                                                                table_types_PERSON_p2, PERSON_p2_ids,
                                                                                move(filter_PERSON_p2),
                                                                                vector<column_t>(),
                                                                                get_op_PERSON_p2->names,
                                                                                std::move(table_filters_PERSON_p2),
                                                                                get_op_PERSON_p2->estimated_cardinality,
                                                                                get_op_PERSON_p2->extra_info);


    vector<JoinCondition> cond_KNOWS_;
    JoinCondition join_condition_KNOWS_;
    join_condition_KNOWS_.left = make_uniq<BoundReferenceExpression>("person_rowid", LogicalType::BIGINT, 8);
    join_condition_KNOWS_.right = make_uniq<BoundReferenceExpression>("person_rowid", LogicalType::BIGINT, 1);
    join_condition_KNOWS_.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_KNOWS_ = make_uniq<RAIInfo>();
    rai_info_KNOWS_->rai = table_KNOWS.GetStorage().info->rais[0].get();
    rai_info_KNOWS_->rai_type = RAIType::TARGET_EDGE;
    rai_info_KNOWS_->forward = true;
    rai_info_KNOWS_->vertex = &table_PERSON;
    rai_info_KNOWS_->vertex_id = table_index_PERSON_p2;
    rai_info_KNOWS_->passing_tables[0] = table_index_PERSON_p2;
    rai_info_KNOWS_->left_cardinalities[0] = table_PERSON.GetStorage().info->cardinality;
    // rai_info_KNOWS_->compact_list = &rai_info_KNOWS_->rai->alist->compact__list;

    join_condition_KNOWS_.rais.push_back(move(rai_info_KNOWS_));
    cond_KNOWS_.push_back(move(join_condition_KNOWS_));

    LogicalComparisonJoin join_KNOWS__op(JoinType::INNER);
    vector<LogicalType> output_KNOWS__types{LogicalType::VARCHAR, LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::DATE,
                                            LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::VARCHAR,
                                            LogicalType::VARCHAR, LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::BIGINT};
    join_KNOWS__op.types = output_KNOWS__types;
    vector<idx_t> right_projection_map_KNOWS_{1};
    vector<idx_t> merge_project_map_KNOWS_;
    vector<LogicalType> delim_types_KNOWS_;
    auto join_KNOWS_ = make_uniq<PhysicalMergeSIPJoin>(join_KNOWS__op, move(scan_PERSON_p2), move(scan_PERSON_p1), move(cond_KNOWS_),
                                                       JoinType::INNER, left_projection_map,
                                                       right_projection_map_KNOWS_, merge_project_map_KNOWS_,
                                                       delim_types_KNOWS_, 0);


    vector<idx_t> PLACE_pl_ids{1, COLUMN_IDENTIFIER_ROW_ID};
    vector<LogicalType> get_PLACE_pl_types{LogicalType::VARCHAR, LogicalType::BIGINT};
    string alias_PLACE_pl = "pl";
    vector<LogicalType> table_types_PLACE_pl;
    vector<unique_ptr<Expression>> filter_PLACE_pl;
    unique_ptr<LogicalGet> get_op_PLACE_pl = move(
            getLogicalGet(*this, table_PLACE, alias_PLACE_pl, table_index_PLACE_pl, table_types_PLACE_pl));
    unique_ptr<TableFilterSet> table_filters_PLACE_pl = NULL;
    unique_ptr<PhysicalTableScan> scan_PLACE_pl = make_uniq<PhysicalTableScan>(get_PLACE_pl_types,
                                                                               get_op_PLACE_pl->function,
                                                                               get_op_PLACE_pl->table_index,
                                                                               move(get_op_PLACE_pl->bind_data),
                                                                               table_types_PLACE_pl, PLACE_pl_ids,
                                                                               move(filter_PLACE_pl),
                                                                               vector<column_t>(),
                                                                               get_op_PLACE_pl->names,
                                                                               std::move(table_filters_PLACE_pl),
                                                                               get_op_PLACE_pl->estimated_cardinality,
                                                                               get_op_PLACE_pl->extra_info);


    vector<JoinCondition> cond_ISLOCATEDIN_;
    JoinCondition join_condition_ISLOCATEDIN_;
    join_condition_ISLOCATEDIN_.left = make_uniq<BoundReferenceExpression>("place_rowid", LogicalType::BIGINT, 1);
    join_condition_ISLOCATEDIN_.right = make_uniq<BoundReferenceExpression>("placeid_rowid", LogicalType::BIGINT, 9);
    join_condition_ISLOCATEDIN_.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_ISLOCATEDIN_ = make_uniq<RAIInfo>();
    rai_info_ISLOCATEDIN_->rai = table_PERSON.GetStorage().info->rais[0].get();
    rai_info_ISLOCATEDIN_->rai_type = RAIType::TARGET_EDGE;
    rai_info_ISLOCATEDIN_->forward = true;
    rai_info_ISLOCATEDIN_->vertex = &table_PLACE;
    rai_info_ISLOCATEDIN_->vertex_id = table_index_PLACE_pl;
    rai_info_ISLOCATEDIN_->passing_tables[0] = table_index_PLACE_pl;
    rai_info_ISLOCATEDIN_->left_cardinalities[0] = table_PLACE.GetStorage().info->cardinality;
    // rai_info_ISLOCATEDIN_->compact_list = &rai_info_ISLOCATEDIN_->rai->alist->compact__list;

    join_condition_ISLOCATEDIN_.rais.push_back(move(rai_info_ISLOCATEDIN_));
    cond_ISLOCATEDIN_.push_back(move(join_condition_ISLOCATEDIN_));

    LogicalComparisonJoin join_ISLOCATEDIN__op(JoinType::INNER);
    vector<LogicalType> output_ISLOCATEDIN__types{LogicalType::VARCHAR, LogicalType::BIGINT,
                                                  LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::DATE,
                                                  LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::VARCHAR,
                                                  LogicalType::VARCHAR};
    join_ISLOCATEDIN__op.types = output_ISLOCATEDIN__types;
    vector<idx_t> right_projection_map_ISLOCATEDIN_{1, 2, 3, 4, 5, 6, 7};
    vector<idx_t> merge_project_map_ISLOCATEDIN_;
    vector<LogicalType> delim_types_ISLOCATEDIN_;
    auto join_ISLOCATEDIN_ = make_uniq<PhysicalSIPJoin>(join_ISLOCATEDIN__op, move(scan_PLACE_pl), move(join_KNOWS_),
                                                             move(cond_ISLOCATEDIN_), JoinType::INNER,
                                                             left_projection_map, right_projection_map_ISLOCATEDIN_,
                                                             delim_types_ISLOCATEDIN_,
                                                             0);


    vector<LogicalType> result_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::DATE,
                                     LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::VARCHAR,
                                     LogicalType::VARCHAR, LogicalType::VARCHAR};
    vector<unique_ptr<Expression>> select_list;
    auto result_col0 = make_uniq<BoundReferenceExpression>("p_personid", LogicalType::BIGINT, 2);
    auto result_col1 = make_uniq<BoundReferenceExpression>("p_lastname", LogicalType::VARCHAR, 3);
    auto result_col2 = make_uniq<BoundReferenceExpression>("p_birthday", LogicalType::DATE, 4);
    auto result_col3 = make_uniq<BoundReferenceExpression>("p_creationdate", LogicalType::BIGINT, 5);
    auto result_col4 = make_uniq<BoundReferenceExpression>("p_gender", LogicalType::VARCHAR, 6);
    auto result_col5 = make_uniq<BoundReferenceExpression>("p_browserused", LogicalType::VARCHAR, 7);
    auto result_col6 = make_uniq<BoundReferenceExpression>("p_locationip", LogicalType::VARCHAR, 8);
    auto result_col7 = make_uniq<BoundReferenceExpression>("pl_name", LogicalType::VARCHAR, 0);
    select_list.push_back(move(result_col0));
    select_list.push_back(move(result_col1));
    select_list.push_back(move(result_col2));
    select_list.push_back(move(result_col3));
    select_list.push_back(move(result_col4));
    select_list.push_back(move(result_col5));
    select_list.push_back(move(result_col6));
    select_list.push_back(move(result_col7));
    auto projection = make_uniq<PhysicalProjection>(result_types, move(select_list), 0);
    projection->children.push_back(move(join_ISLOCATEDIN_));

    return projection;
}

unique_ptr<PhysicalOperator> ClientContext::GenerateIC12Plan() {
    vector<idx_t> left_projection_map, right_projection_map;

    string table_vertex_person = "person";
    string table_edge_knows = "knows";
    string table_vertex_place = "place";
    idx_t table_index_person1 = 6;
    idx_t table_index_person2 = 8;
    idx_t table_index_person_tmp = 10;
    idx_t table_index_knows = 7;
    idx_t table_index_knows2 = 9;
    idx_t table_index_place = 11;


    auto table_or_view_person = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                  table_vertex_person, OnEntryNotFound::RETURN_NULL);
    auto &table_person = table_or_view_person->Cast<TableCatalogEntry>();

    auto table_or_view_knows = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                 table_edge_knows, OnEntryNotFound::RETURN_NULL);
    auto &table_knows = table_or_view_knows->Cast<TableCatalogEntry>();

    auto table_or_view_place = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                 table_vertex_place, OnEntryNotFound::RETURN_NULL);
    auto &table_place = table_or_view_place->Cast<TableCatalogEntry>();


    idx_t p_person_id = atoll(paras->data()[0].c_str()); // 933;
    Value p_person = Value::BIGINT(p_person_id);
    vector<idx_t> person1_ids{0, COLUMN_IDENTIFIER_ROW_ID};
    vector<LogicalType> get_person1_types{LogicalType::BIGINT, LogicalType::BIGINT};
    string alias_person1 = "p1";
    vector<LogicalType> table_types_person1;
    unique_ptr<LogicalGet> get_op_person1 = move(
            getLogicalGet(*this, table_person, alias_person1, table_index_person1, table_types_person1));
    vector<unique_ptr<Expression>> filter_person1;
    unique_ptr<TableFilterSet> table_filters_person1 = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL,
                                                                                   p_person);
    table_filters_person1->filters[0] = move(constant_filter);
    unique_ptr<PhysicalTableScan> scan_person1 = make_uniq<PhysicalTableScan>(get_person1_types,
                                                                              get_op_person1->function,
                                                                              get_op_person1->table_index,
                                                                              move(get_op_person1->bind_data),
                                                                              table_types_person1, person1_ids,
                                                                              move(filter_person1), vector<column_t>(),
                                                                              get_op_person1->names,
                                                                              std::move(table_filters_person1),
                                                                              get_op_person1->estimated_cardinality,
                                                                              get_op_person1->extra_info);

    vector<idx_t> person_tmp_ids{COLUMN_IDENTIFIER_ROW_ID};
    vector<LogicalType> get_person_tmp_types{LogicalType::BIGINT};
    string alias_person_tmp = "ptmp";
    vector<LogicalType> table_types_person_tmp;
    unique_ptr<LogicalGet> get_op_person_tmp = move(
            getLogicalGet(*this, table_person, alias_person_tmp, table_index_person_tmp, table_types_person_tmp));
    vector<unique_ptr<Expression>> filter_person_tmp;
    unique_ptr<TableFilterSet> table_filters_person_tmp = NULL;
    unique_ptr<PhysicalTableScan> scan_person_tmp = make_uniq<PhysicalTableScan>(get_person_tmp_types,
                                                                              get_op_person_tmp->function,
                                                                              get_op_person_tmp->table_index,
                                                                              move(get_op_person_tmp->bind_data),
                                                                              table_types_person_tmp, person_tmp_ids,
                                                                              move(filter_person_tmp), vector<column_t>(),
                                                                              get_op_person_tmp->names,
                                                                              std::move(table_filters_person_tmp),
                                                                              get_op_person_tmp->estimated_cardinality,
                                                                              get_op_person_tmp->extra_info);

    vector<JoinCondition> cond_knows;
    JoinCondition join_condition_knows;
    join_condition_knows.left = make_uniq<BoundReferenceExpression>("person_rowid", LogicalType::BIGINT, 0);
    join_condition_knows.right = make_uniq<BoundReferenceExpression>("person_rowid", LogicalType::BIGINT, 1);
    join_condition_knows.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_knows = make_uniq<RAIInfo>();
    rai_info_knows->rai = table_knows.GetStorage().info->rais[0].get();
    rai_info_knows->rai_type = RAIType::TARGET_EDGE;
    rai_info_knows->forward = true;
    rai_info_knows->vertex = &table_person;
    rai_info_knows->vertex_id = table_index_person_tmp;
    rai_info_knows->passing_tables[0] = table_index_person_tmp;
    rai_info_knows->left_cardinalities[0] = table_person.GetStorage().info->cardinality;
    // rai_info_knows->compact_list = &rai_info_knows->rai->alist->compact_backward_list;

    join_condition_knows.rais.push_back(move(rai_info_knows));
    cond_knows.push_back(move(join_condition_knows));

    LogicalComparisonJoin join_knows_op(JoinType::INNER);
    vector<LogicalType> output_knows_types{LogicalType::BIGINT, LogicalType::BIGINT};
    join_knows_op.types = output_knows_types;
    vector<idx_t> right_projection_map_knows{1};
    vector<idx_t> merge_project_map;
    vector<LogicalType> delim_types;
    auto join_knows = make_uniq<PhysicalMergeSIPJoin>(join_knows_op, move(scan_person_tmp), move(scan_person1),
                                                      move(cond_knows),
                                                      JoinType::INNER, left_projection_map, right_projection_map_knows,
                                                      merge_project_map, delim_types, 0);


    // join person2 with person-person_tmp

    string p_person_first_name = paras->data()[1];
    Value p_first_name(p_person_first_name);
    vector<idx_t> person2_ids{1, COLUMN_IDENTIFIER_ROW_ID, 9, 0, 2, 4, 5, 3, 7, 6};
    vector<LogicalType> get_person2_types{LogicalType::VARCHAR, LogicalType::BIGINT, LogicalType::BIGINT,
                                          LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::DATE,
                                          LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::VARCHAR,
                                          LogicalType::VARCHAR};
    string alias_person2 = "p2";
    vector<LogicalType> table_types_person2;
    vector<unique_ptr<Expression>> filter_person2;
    unique_ptr<LogicalGet> get_op_person2 = move(
            getLogicalGet(*this, table_person, alias_person2, table_index_person2, table_types_person2));
    unique_ptr<TableFilterSet> table_filters_person2 = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_person2 = duckdb::make_uniq<ConstantFilter>(
            ExpressionType::COMPARE_EQUAL,
            p_first_name);
    table_filters_person2->filters[0] = move(constant_filter_person2);
    unique_ptr<PhysicalTableScan> scan_person2 = make_uniq<PhysicalTableScan>(get_person2_types,
                                                                              get_op_person2->function,
                                                                              get_op_person2->table_index,
                                                                              move(get_op_person2->bind_data),
                                                                              table_types_person2, person2_ids,
                                                                              move(filter_person2), vector<column_t>(),
                                                                              get_op_person2->names,
                                                                              std::move(table_filters_person2),
                                                                              get_op_person2->estimated_cardinality,
                                                                              get_op_person2->extra_info);

    vector<JoinCondition> cond_knows_2;
    JoinCondition join_condition_knows_2;
    join_condition_knows_2.left = make_uniq<BoundReferenceExpression>("person_rowid", LogicalType::BIGINT, 1);
    join_condition_knows_2.right = make_uniq<BoundReferenceExpression>("person_rowid", LogicalType::BIGINT, 0);
    join_condition_knows_2.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_knows_2 = make_uniq<RAIInfo>();
    rai_info_knows_2->rai = table_knows.GetStorage().info->rais[0].get();
    rai_info_knows_2->rai_type = RAIType::TARGET_EDGE;
    rai_info_knows_2->forward = true;
    rai_info_knows_2->vertex = &table_person;
    rai_info_knows_2->vertex_id = table_index_person2;
    rai_info_knows_2->passing_tables[0] = table_index_person2;
    rai_info_knows_2->left_cardinalities[0] = table_person.GetStorage().info->cardinality;
    // rai_info_knows->compact_list = &rai_info_knows->rai->alist->compact_backward_list;

    join_condition_knows_2.rais.push_back(move(rai_info_knows_2));
    cond_knows_2.push_back(move(join_condition_knows_2));

    LogicalComparisonJoin join_knows_2_op(JoinType::INNER);
    vector<LogicalType> output_knows_2_types{LogicalType::VARCHAR, LogicalType::BIGINT, LogicalType::BIGINT,
                                             LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::DATE,
                                             LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::VARCHAR,
                                             LogicalType::VARCHAR, LogicalType::BIGINT};
    join_knows_2_op.types = output_knows_2_types;
    vector<idx_t> right_projection_map_knows_2{0};
    vector<idx_t> merge_project_map_2;
    vector<LogicalType> delim_types_2;
    auto join_knows_2 = make_uniq<PhysicalMergeSIPJoin>(join_knows_2_op, move(scan_person2), move(join_knows),
                                                      move(cond_knows_2),
                                                      JoinType::INNER, left_projection_map, right_projection_map_knows_2,
                                                      merge_project_map_2, delim_types_2, 0);


    // join place with person-person
    vector<idx_t> place_ids{COLUMN_IDENTIFIER_ROW_ID, 1};
    vector<LogicalType> get_place_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_place = "pl";
    vector<LogicalType> table_types_place;
    vector<unique_ptr<Expression>> filter_place;
    unique_ptr<LogicalGet> get_op_place = move(
            getLogicalGet(*this, table_place, alias_place, table_index_place, table_types_place));
    unique_ptr<TableFilterSet> table_filters_place = NULL;
    unique_ptr<PhysicalTableScan> scan_place = make_uniq<PhysicalTableScan>(get_place_types, get_op_place->function,
                                                                            get_op_place->table_index,
                                                                            move(get_op_place->bind_data),
                                                                            table_types_place, place_ids,
                                                                            move(filter_place), vector<column_t>(),
                                                                            get_op_place->names,
                                                                            std::move(table_filters_place),
                                                                            get_op_place->estimated_cardinality,
                                                                            get_op_place->extra_info);

    vector<JoinCondition> cond_place;
    JoinCondition join_condition_place;
    join_condition_place.left = make_uniq<BoundReferenceExpression>("place_rowid", LogicalType::BIGINT, 0);
    join_condition_place.right = make_uniq<BoundReferenceExpression>("p_placeid_rowid", LogicalType::BIGINT, 2);
    join_condition_place.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_place = make_uniq<RAIInfo>();
    rai_info_place->rai = table_person.GetStorage().info->rais[0].get();
    rai_info_place->rai_type = RAIType::TARGET_EDGE;
    rai_info_place->forward = true;
    rai_info_place->vertex = &table_place;
    rai_info_place->vertex_id = table_index_place;
    rai_info_place->passing_tables[0] = table_index_place;
    rai_info_place->left_cardinalities[0] = table_place.GetStorage().info->cardinality;
    // rai_info_place->compact_list = &rai_info_place->rai->alist->compact_forward_list;

    join_condition_place.rais.push_back(move(rai_info_place));
    cond_place.push_back(move(join_condition_place));

    LogicalComparisonJoin join_place_op(JoinType::INNER);
    vector<LogicalType> output_place_types{LogicalType::BIGINT, LogicalType::VARCHAR,
                                           LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::DATE,
                                           LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::VARCHAR,
                                           LogicalType::VARCHAR};
    join_place_op.types = output_place_types;
    vector<idx_t> right_projection_map_place{3, 4, 5, 6, 7, 8, 9};
    vector<idx_t> merge_project_map_place;
    vector<LogicalType> delim_types_place;
    auto join_place = make_uniq<PhysicalSIPJoin>(join_place_op, move(scan_place), move(join_knows_2), move(cond_place),
                                                 JoinType::INNER, left_projection_map, right_projection_map_place,
                                                 delim_types_place, 0);


    // project
    vector<LogicalType> result_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::DATE,
                                     LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::VARCHAR,
                                     LogicalType::VARCHAR, LogicalType::VARCHAR};
    vector<unique_ptr<Expression>> select_list;
    auto result_col0 = make_uniq<BoundReferenceExpression>("p_personid", LogicalType::BIGINT, 2);
    auto result_col1 = make_uniq<BoundReferenceExpression>("p_lastname", LogicalType::VARCHAR, 3);
    auto result_col2 = make_uniq<BoundReferenceExpression>("p_birthday", LogicalType::DATE, 4);
    auto result_col3 = make_uniq<BoundReferenceExpression>("p_creationdate", LogicalType::BIGINT, 5);
    auto result_col4 = make_uniq<BoundReferenceExpression>("p_gender", LogicalType::VARCHAR, 6);
    auto result_col5 = make_uniq<BoundReferenceExpression>("p_browserused", LogicalType::VARCHAR, 7);
    auto result_col6 = make_uniq<BoundReferenceExpression>("p_locationip", LogicalType::VARCHAR, 8);
    auto result_col7 = make_uniq<BoundReferenceExpression>("pl_name", LogicalType::VARCHAR, 1);

    select_list.push_back(move(result_col0));
    select_list.push_back(move(result_col1));
    select_list.push_back(move(result_col2));
    select_list.push_back(move(result_col3));
    select_list.push_back(move(result_col4));
    select_list.push_back(move(result_col5));
    select_list.push_back(move(result_col6));
    select_list.push_back(move(result_col7));

    auto projection = make_uniq<PhysicalProjection>(result_types, move(select_list), 0);
    projection->children.push_back(move(join_place));

    return projection;
}

unique_ptr<PhysicalOperator> ClientContext::GenerateIC12PlanGLogue() {
    vector<idx_t> left_projection_map, right_projection_map;

    string table_vertex_person = "person";
    string table_edge_knows = "knows";
    string table_vertex_place = "place";
    idx_t table_index_person1 = 6;
    idx_t table_index_person2 = 8;
    idx_t table_index_person_tmp = 10;
    idx_t table_index_knows = 7;
    idx_t table_index_knows2 = 9;
    idx_t table_index_place = 11;


    auto table_or_view_person = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                  table_vertex_person, OnEntryNotFound::RETURN_NULL);
    auto &table_person = table_or_view_person->Cast<TableCatalogEntry>();

    auto table_or_view_knows = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                 table_edge_knows, OnEntryNotFound::RETURN_NULL);
    auto &table_knows = table_or_view_knows->Cast<TableCatalogEntry>();

    auto table_or_view_place = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                 table_vertex_place, OnEntryNotFound::RETURN_NULL);
    auto &table_place = table_or_view_place->Cast<TableCatalogEntry>();


    vector<idx_t> knows_ids{3, 4};
    vector<LogicalType> get_knows_types{LogicalType::BIGINT, LogicalType::BIGINT};
    string alias_knows = "k1";
    vector<LogicalType> table_types_knows;
    vector<unique_ptr<Expression>> filter_knows;
    unique_ptr<LogicalGet> get_op_knows = move(
            getLogicalGet(*this, table_knows, alias_knows, table_index_knows, table_types_knows));
    unique_ptr<TableFilterSet> table_filters_knows = NULL;
    unique_ptr<PhysicalTableScan> scan_knows = make_uniq<PhysicalTableScan>(get_knows_types,
                                                                            get_op_knows->function,
                                                                            get_op_knows->table_index,
                                                                            move(get_op_knows->bind_data),
                                                                            table_types_knows, knows_ids,
                                                                            move(filter_knows), vector<column_t>(),
                                                                            get_op_knows->names,
                                                                            std::move(table_filters_knows),
                                                                            get_op_knows->estimated_cardinality,
                                                                            get_op_knows->extra_info);


    idx_t p_person_id = atoll(paras->data()[0].c_str()); // 933;
    Value p_person = Value::BIGINT(p_person_id);
    vector<idx_t> person1_ids{0, COLUMN_IDENTIFIER_ROW_ID};
    vector<LogicalType> get_person1_types{LogicalType::BIGINT, LogicalType::BIGINT};
    string alias_person1 = "p1";
    vector<LogicalType> table_types_person1;
    unique_ptr<LogicalGet> get_op_person1 = move(
            getLogicalGet(*this, table_person, alias_person1, table_index_person1, table_types_person1));
    vector<unique_ptr<Expression>> filter_person1;
    unique_ptr<TableFilterSet> table_filters_person1 = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL,
                                                                                   p_person);
    table_filters_person1->filters[0] = move(constant_filter);
    unique_ptr<PhysicalTableScan> scan_person1 = make_uniq<PhysicalTableScan>(get_person1_types,
                                                                              get_op_person1->function,
                                                                              get_op_person1->table_index,
                                                                              move(get_op_person1->bind_data),
                                                                              table_types_person1, person1_ids,
                                                                              move(filter_person1), vector<column_t>(),
                                                                              get_op_person1->names,
                                                                              std::move(table_filters_person1),
                                                                              get_op_person1->estimated_cardinality,
                                                                              get_op_person1->extra_info);

    vector<JoinCondition> cond_knows;
    JoinCondition join_condition_knows;
    join_condition_knows.left = make_uniq<BoundReferenceExpression>("k_person1id_rowid", LogicalType::BIGINT, 0);
    join_condition_knows.right = make_uniq<BoundReferenceExpression>("person_rowid", LogicalType::BIGINT, 1);
    join_condition_knows.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_knows = make_uniq<RAIInfo>();
    rai_info_knows->rai = table_knows.GetStorage().info->rais[0].get();
    rai_info_knows->rai_type = RAIType::EDGE_SOURCE;
    rai_info_knows->forward = true;
    rai_info_knows->vertex = &table_person;
    rai_info_knows->vertex_id = table_index_person1;
    rai_info_knows->passing_tables[0] = table_index_knows;
    rai_info_knows->left_cardinalities[0] = table_knows.GetStorage().info->cardinality;
    rai_info_knows->compact_list = &rai_info_knows->rai->alist->compact_forward_list;

    join_condition_knows.rais.push_back(move(rai_info_knows));
    cond_knows.push_back(move(join_condition_knows));

    LogicalComparisonJoin join_knows_op(JoinType::INNER);
    vector<LogicalType> output_knows_types{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::BIGINT};
    join_knows_op.types = output_knows_types;
    vector<idx_t> right_projection_map_knows{1};
    vector<idx_t> merge_project_map;
    vector<LogicalType> delim_types;
    auto join_knows = make_uniq<PhysicalSIPJoin>(join_knows_op, move(scan_knows), move(scan_person1),
                                                 move(cond_knows),
                                                 JoinType::INNER, left_projection_map, right_projection_map_knows,
                                                 delim_types, 0);

    // join the two knows
    vector<idx_t> knows2_ids{3, 4};
    vector<LogicalType> get_knows2_types{LogicalType::BIGINT, LogicalType::BIGINT};
    string alias_knows2 = "k2";
    vector<LogicalType> table_types_knows2;
    vector<unique_ptr<Expression>> filter_knows2;
    unique_ptr<LogicalGet> get_op_knows2 = move(
            getLogicalGet(*this, table_knows, alias_knows2, table_index_knows2, table_types_knows2));
    unique_ptr<TableFilterSet> table_filters_knows2 = NULL;
    unique_ptr<PhysicalTableScan> scan_knows2 = make_uniq<PhysicalTableScan>(get_knows2_types,
                                                                             get_op_knows2->function,
                                                                             get_op_knows2->table_index,
                                                                             move(get_op_knows2->bind_data),
                                                                             table_types_knows2, knows2_ids,
                                                                             move(filter_knows2), vector<column_t>(),
                                                                             get_op_knows2->names,
                                                                             std::move(table_filters_knows2),
                                                                             get_op_knows2->estimated_cardinality,
                                                                             get_op_knows2->extra_info);

    vector<JoinCondition> cond_knows_2;
    JoinCondition join_condition_knows_2;
    join_condition_knows_2.left = make_uniq<BoundReferenceExpression>("k_person1id_rowid", LogicalType::BIGINT, 0);
    join_condition_knows_2.right = make_uniq<BoundReferenceExpression>("k_person2id_rowid", LogicalType::BIGINT, 1);
    join_condition_knows_2.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_knows_2 = make_uniq<RAIInfo>();
    rai_info_knows_2->rai = table_knows.GetStorage().info->rais[0].get();
    rai_info_knows_2->rai_type = RAIType::SELF;
    rai_info_knows_2->forward = true;
    rai_info_knows_2->vertex = &table_knows;
    rai_info_knows_2->vertex_id = table_index_knows2;
    rai_info_knows_2->passing_tables[0] = table_index_knows2;
    rai_info_knows_2->left_cardinalities[0] = table_knows.GetStorage().info->cardinality;
    rai_info_knows_2->compact_list = &rai_info_knows_2->rai->alist->compact_forward_list;

    join_condition_knows_2.rais.push_back(move(rai_info_knows_2));
    cond_knows_2.push_back(move(join_condition_knows_2));

    LogicalComparisonJoin join_knows_op_2(JoinType::INNER);
    vector<LogicalType> output_knows_types_2{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::BIGINT};
    join_knows_op_2.types = output_knows_types_2;
    vector<idx_t> right_projection_map_knows_2{0};
    vector<idx_t> merge_project_map_2;
    vector<LogicalType> delim_types_2;
    auto join_knows_2 = make_uniq<PhysicalSIPJoin>(join_knows_op_2, move(scan_knows2), move(join_knows),
                                                   move(cond_knows_2),
                                                   JoinType::INNER, left_projection_map,
                                                   right_projection_map_knows_2,
                                                   delim_types_2, 0);


    // join person2 with person-person_tmp

    string p_person_first_name = paras->data()[1];
    Value p_first_name(p_person_first_name);
    vector<idx_t> person2_ids{1, COLUMN_IDENTIFIER_ROW_ID, 9, 0, 2, 4, 5, 3, 7, 6};
    vector<LogicalType> get_person2_types{LogicalType::VARCHAR, LogicalType::BIGINT, LogicalType::BIGINT,
                                          LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::DATE,
                                          LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::VARCHAR,
                                          LogicalType::VARCHAR};
    string alias_person2 = "p2";
    vector<LogicalType> table_types_person2;
    vector<unique_ptr<Expression>> filter_person2;
    unique_ptr<LogicalGet> get_op_person2 = move(
            getLogicalGet(*this, table_person, alias_person2, table_index_person2, table_types_person2));
    unique_ptr<TableFilterSet> table_filters_person2 = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_person2 = duckdb::make_uniq<ConstantFilter>(
            ExpressionType::COMPARE_EQUAL,
            p_first_name);
    table_filters_person2->filters[0] = move(constant_filter_person2);
    unique_ptr<PhysicalTableScan> scan_person2 = make_uniq<PhysicalTableScan>(get_person2_types,
                                                                              get_op_person2->function,
                                                                              get_op_person2->table_index,
                                                                              move(get_op_person2->bind_data),
                                                                              table_types_person2, person2_ids,
                                                                              move(filter_person2), vector<column_t>(),
                                                                              get_op_person2->names,
                                                                              std::move(table_filters_person2),
                                                                              get_op_person2->estimated_cardinality,
                                                                              get_op_person2->extra_info);

    vector<JoinCondition> cond_knows_3;
    JoinCondition join_condition_knows_3;
    join_condition_knows_3.left = make_uniq<BoundReferenceExpression>("person_rowid", LogicalType::BIGINT, 1);
    join_condition_knows_3.right = make_uniq<BoundReferenceExpression>("k_person2id_rowid", LogicalType::BIGINT, 1);
    join_condition_knows_3.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_knows_3 = make_uniq<RAIInfo>();
    rai_info_knows_3->rai = table_knows.GetStorage().info->rais[0].get();
    rai_info_knows_3->rai_type = RAIType::TARGET_EDGE;
    rai_info_knows_3->forward = true;
    rai_info_knows_3->vertex = &table_person;
    rai_info_knows_3->vertex_id = table_index_person2;
    rai_info_knows_3->passing_tables[0] = table_index_person2;
    rai_info_knows_3->left_cardinalities[0] = table_person.GetStorage().info->cardinality;
    // rai_info_knows->compact_list = &rai_info_knows->rai->alist->compact_backward_list;

    join_condition_knows_3.rais.push_back(move(rai_info_knows_3));
    cond_knows_3.push_back(move(join_condition_knows_3));

    LogicalComparisonJoin join_knows_3_op(JoinType::INNER);
    vector<LogicalType> output_knows_3_types{LogicalType::VARCHAR, LogicalType::BIGINT, LogicalType::BIGINT,
                                             LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::DATE,
                                             LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::VARCHAR,
                                             LogicalType::VARCHAR, LogicalType::BIGINT};
    join_knows_3_op.types = output_knows_3_types;
    vector<idx_t> right_projection_map_knows_3{0};
    vector<idx_t> merge_project_map_3;
    vector<LogicalType> delim_types_3;
    auto join_knows_3 = make_uniq<PhysicalSIPJoin>(join_knows_3_op, move(scan_person2), move(join_knows_2),
                                                        move(cond_knows_3),
                                                        JoinType::INNER, left_projection_map,
                                                        right_projection_map_knows_3,
                                                        delim_types_3, 0);


    // join place with person-person
    vector<idx_t> place_ids{COLUMN_IDENTIFIER_ROW_ID, 1};
    vector<LogicalType> get_place_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_place = "pl";
    vector<LogicalType> table_types_place;
    vector<unique_ptr<Expression>> filter_place;
    unique_ptr<LogicalGet> get_op_place = move(
            getLogicalGet(*this, table_place, alias_place, table_index_place, table_types_place));
    unique_ptr<TableFilterSet> table_filters_place = NULL;
    unique_ptr<PhysicalTableScan> scan_place = make_uniq<PhysicalTableScan>(get_place_types, get_op_place->function,
                                                                            get_op_place->table_index,
                                                                            move(get_op_place->bind_data),
                                                                            table_types_place, place_ids,
                                                                            move(filter_place), vector<column_t>(),
                                                                            get_op_place->names,
                                                                            std::move(table_filters_place),
                                                                            get_op_place->estimated_cardinality,
                                                                            get_op_place->extra_info);

    vector<JoinCondition> cond_place;
    JoinCondition join_condition_place;
    join_condition_place.left = make_uniq<BoundReferenceExpression>("place_rowid", LogicalType::BIGINT, 0);
    join_condition_place.right = make_uniq<BoundReferenceExpression>("p_placeid_rowid", LogicalType::BIGINT, 2);
    join_condition_place.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_place = make_uniq<RAIInfo>();
    rai_info_place->rai = table_person.GetStorage().info->rais[0].get();
    rai_info_place->rai_type = RAIType::TARGET_EDGE;
    rai_info_place->forward = true;
    rai_info_place->vertex = &table_place;
    rai_info_place->vertex_id = table_index_place;
    rai_info_place->passing_tables[0] = table_index_place;
    rai_info_place->left_cardinalities[0] = table_place.GetStorage().info->cardinality;
    // rai_info_place->compact_list = &rai_info_place->rai->alist->compact_forward_list;

    join_condition_place.rais.push_back(move(rai_info_place));
    cond_place.push_back(move(join_condition_place));

    LogicalComparisonJoin join_place_op(JoinType::INNER);
    vector<LogicalType> output_place_types{LogicalType::BIGINT, LogicalType::VARCHAR,
                                           LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::DATE,
                                           LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::VARCHAR,
                                           LogicalType::VARCHAR};
    join_place_op.types = output_place_types;
    vector<idx_t> right_projection_map_place{3, 4, 5, 6, 7, 8, 9};
    vector<idx_t> merge_project_map_place;
    vector<LogicalType> delim_types_place;
    auto join_place = make_uniq<PhysicalSIPJoin>(join_place_op, move(scan_place), move(join_knows_3), move(cond_place),
                                                 JoinType::INNER, left_projection_map, right_projection_map_place,
                                                 delim_types_place, 0);


    // project
    vector<LogicalType> result_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::DATE,
                                     LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::VARCHAR,
                                     LogicalType::VARCHAR, LogicalType::VARCHAR};
    vector<unique_ptr<Expression>> select_list;
    auto result_col0 = make_uniq<BoundReferenceExpression>("p_personid", LogicalType::BIGINT, 2);
    auto result_col1 = make_uniq<BoundReferenceExpression>("p_lastname", LogicalType::VARCHAR, 3);
    auto result_col2 = make_uniq<BoundReferenceExpression>("p_birthday", LogicalType::DATE, 4);
    auto result_col3 = make_uniq<BoundReferenceExpression>("p_creationdate", LogicalType::BIGINT, 5);
    auto result_col4 = make_uniq<BoundReferenceExpression>("p_gender", LogicalType::VARCHAR, 6);
    auto result_col5 = make_uniq<BoundReferenceExpression>("p_browserused", LogicalType::VARCHAR, 7);
    auto result_col6 = make_uniq<BoundReferenceExpression>("p_locationip", LogicalType::VARCHAR, 8);
    auto result_col7 = make_uniq<BoundReferenceExpression>("pl_name", LogicalType::VARCHAR, 1);

    select_list.push_back(move(result_col0));
    select_list.push_back(move(result_col1));
    select_list.push_back(move(result_col2));
    select_list.push_back(move(result_col3));
    select_list.push_back(move(result_col4));
    select_list.push_back(move(result_col5));
    select_list.push_back(move(result_col6));
    select_list.push_back(move(result_col7));

    auto projection = make_uniq<PhysicalProjection>(result_types, move(select_list), 0);
    projection->children.push_back(move(join_place));

    return projection;
}

unique_ptr<PhysicalOperator> ClientContext::GenerateIC13PlanGLogue() {
    vector<idx_t> left_projection_map, right_projection_map;

    string table_vertex_person = "person";
    string table_edge_knows = "knows";
    string table_vertex_place = "place";
    idx_t table_index_person1 = 6;
    idx_t table_index_person2 = 8;
    idx_t table_index_person_tmp = 10;
    idx_t table_index_person_tmp2 = 12;
    idx_t table_index_knows = 7;
    idx_t table_index_knows2 = 9;
    idx_t table_index_knows3 = 11;
    idx_t table_index_place = 13;


    auto table_or_view_person = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                  table_vertex_person, OnEntryNotFound::RETURN_NULL);
    auto &table_person = table_or_view_person->Cast<TableCatalogEntry>();

    auto table_or_view_knows = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                 table_edge_knows, OnEntryNotFound::RETURN_NULL);
    auto &table_knows = table_or_view_knows->Cast<TableCatalogEntry>();

    auto table_or_view_place = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                 table_vertex_place, OnEntryNotFound::RETURN_NULL);
    auto &table_place = table_or_view_place->Cast<TableCatalogEntry>();


    idx_t p_person_id = atoll(paras->data()[0].c_str()); // 933;
    Value p_person = Value::BIGINT(p_person_id);
    vector<idx_t> person1_ids{0, COLUMN_IDENTIFIER_ROW_ID};
    vector<LogicalType> get_person1_types{LogicalType::BIGINT, LogicalType::BIGINT};
    string alias_person1 = "p1";
    vector<LogicalType> table_types_person1;
    unique_ptr<LogicalGet> get_op_person1 = move(
            getLogicalGet(*this, table_person, alias_person1, table_index_person1, table_types_person1));
    vector<unique_ptr<Expression>> filter_person1;
    unique_ptr<TableFilterSet> table_filters_person1 = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL,
                                                                                   p_person);
    table_filters_person1->filters[0] = move(constant_filter);
    unique_ptr<PhysicalTableScan> scan_person1 = make_uniq<PhysicalTableScan>(get_person1_types,
                                                                              get_op_person1->function,
                                                                              get_op_person1->table_index,
                                                                              move(get_op_person1->bind_data),
                                                                              table_types_person1, person1_ids,
                                                                              move(filter_person1), vector<column_t>(),
                                                                              get_op_person1->names,
                                                                              std::move(table_filters_person1),
                                                                              get_op_person1->estimated_cardinality,
                                                                              get_op_person1->extra_info);

    vector<idx_t> person_tmp_ids{COLUMN_IDENTIFIER_ROW_ID};
    vector<LogicalType> get_person_tmp_types{LogicalType::BIGINT};
    string alias_person_tmp = "ptmp";
    vector<LogicalType> table_types_person_tmp;
    unique_ptr<LogicalGet> get_op_person_tmp = move(
            getLogicalGet(*this, table_person, alias_person_tmp, table_index_person_tmp, table_types_person_tmp));
    vector<unique_ptr<Expression>> filter_person_tmp;
    unique_ptr<TableFilterSet> table_filters_person_tmp = NULL;
    unique_ptr<PhysicalTableScan> scan_person_tmp = make_uniq<PhysicalTableScan>(get_person_tmp_types,
                                                                                 get_op_person_tmp->function,
                                                                                 get_op_person_tmp->table_index,
                                                                                 move(get_op_person_tmp->bind_data),
                                                                                 table_types_person_tmp, person_tmp_ids,
                                                                                 move(filter_person_tmp),
                                                                                 vector<column_t>(),
                                                                                 get_op_person_tmp->names,
                                                                                 std::move(table_filters_person_tmp),
                                                                                 get_op_person_tmp->estimated_cardinality,
                                                                                 get_op_person_tmp->extra_info);

    vector<JoinCondition> cond_knows;
    JoinCondition join_condition_knows;
    join_condition_knows.left = make_uniq<BoundReferenceExpression>("person_rowid", LogicalType::BIGINT, 0);
    join_condition_knows.right = make_uniq<BoundReferenceExpression>("person_rowid", LogicalType::BIGINT, 1);
    join_condition_knows.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_knows = make_uniq<RAIInfo>();
    rai_info_knows->rai = table_knows.GetStorage().info->rais[0].get();
    rai_info_knows->rai_type = RAIType::TARGET_EDGE;
    rai_info_knows->forward = true;
    rai_info_knows->vertex = &table_person;
    rai_info_knows->vertex_id = table_index_person_tmp;
    rai_info_knows->passing_tables[0] = table_index_person_tmp;
    rai_info_knows->left_cardinalities[0] = table_person.GetStorage().info->cardinality;
    // rai_info_knows->compact_list = &rai_info_knows->rai->alist->compact_backward_list;

    join_condition_knows.rais.push_back(move(rai_info_knows));
    cond_knows.push_back(move(join_condition_knows));

    LogicalComparisonJoin join_knows_op(JoinType::INNER);
    vector<LogicalType> output_knows_types{LogicalType::BIGINT, LogicalType::BIGINT};
    join_knows_op.types = output_knows_types;
    vector<idx_t> right_projection_map_knows{1};
    vector<idx_t> merge_project_map;
    vector<LogicalType> delim_types;
    auto join_knows = make_uniq<PhysicalMergeSIPJoin>(join_knows_op, move(scan_person_tmp), move(scan_person1),
                                                      move(cond_knows),
                                                      JoinType::INNER, left_projection_map, right_projection_map_knows,
                                                      merge_project_map, delim_types, 0);

    // join person_tmp2 with person-person_tmp
    vector<idx_t> person_tmp2_ids{COLUMN_IDENTIFIER_ROW_ID};
    vector<LogicalType> get_person_tmp2_types{LogicalType::BIGINT};
    string alias_person_tmp2 = "ptmp2";
    vector<LogicalType> table_types_person_tmp2;
    unique_ptr<LogicalGet> get_op_person_tmp2 = move(
            getLogicalGet(*this, table_person, alias_person_tmp2, table_index_person_tmp2, table_types_person_tmp2));
    vector<unique_ptr<Expression>> filter_person_tmp2;
    unique_ptr<TableFilterSet> table_filters_person_tmp2 = NULL;
    unique_ptr<PhysicalTableScan> scan_person_tmp2 = make_uniq<PhysicalTableScan>(get_person_tmp2_types,
                                                                                 get_op_person_tmp2->function,
                                                                                 get_op_person_tmp2->table_index,
                                                                                 move(get_op_person_tmp2->bind_data),
                                                                                 table_types_person_tmp2, person_tmp2_ids,
                                                                                 move(filter_person_tmp2),
                                                                                 vector<column_t>(),
                                                                                 get_op_person_tmp2->names,
                                                                                 std::move(table_filters_person_tmp2),
                                                                                 get_op_person_tmp2->estimated_cardinality,
                                                                                 get_op_person_tmp2->extra_info);

    vector<JoinCondition> cond_knows_2;
    JoinCondition join_condition_knows_2;
    join_condition_knows_2.left = make_uniq<BoundReferenceExpression>("person_rowid", LogicalType::BIGINT, 0);
    join_condition_knows_2.right = make_uniq<BoundReferenceExpression>("person_rowid", LogicalType::BIGINT, 0);
    join_condition_knows_2.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_knows_2 = make_uniq<RAIInfo>();
    rai_info_knows_2->rai = table_knows.GetStorage().info->rais[0].get();
    rai_info_knows_2->rai_type = RAIType::TARGET_EDGE;
    rai_info_knows_2->forward = true;
    rai_info_knows_2->vertex = &table_person;
    rai_info_knows_2->vertex_id = table_index_person_tmp2;
    rai_info_knows_2->passing_tables[0] = table_index_person_tmp2;
    rai_info_knows_2->left_cardinalities[0] = table_person.GetStorage().info->cardinality;
    // rai_info_knows->compact_list = &rai_info_knows->rai->alist->compact_backward_list;

    join_condition_knows_2.rais.push_back(move(rai_info_knows_2));
    cond_knows_2.push_back(move(join_condition_knows_2));

    LogicalComparisonJoin join_knows_2_op(JoinType::INNER);
    vector<LogicalType> output_knows_2_types{LogicalType::BIGINT, LogicalType::BIGINT};
    join_knows_2_op.types = output_knows_2_types;
    vector<idx_t> right_projection_map_knows_2{0};
    vector<idx_t> merge_project_map_2;
    vector<LogicalType> delim_types_2;
    auto join_knows_2 = make_uniq<PhysicalMergeSIPJoin>(join_knows_2_op, move(scan_person_tmp2), move(join_knows),
                                                      move(cond_knows_2),
                                                      JoinType::INNER, left_projection_map, right_projection_map_knows_2,
                                                      merge_project_map_2, delim_types_2, 0);

    // join person2 with person-person_tmp-person_tmp2
    string p_person_first_name = paras->data()[1];
    Value p_first_name(p_person_first_name);
    vector<idx_t> person2_ids{1, COLUMN_IDENTIFIER_ROW_ID, 9, 0, 2, 4, 5, 3, 7, 6};
    vector<LogicalType> get_person2_types{LogicalType::VARCHAR, LogicalType::BIGINT, LogicalType::BIGINT,
                                          LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::DATE,
                                          LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::VARCHAR,
                                          LogicalType::VARCHAR};
    string alias_person2 = "p2";
    vector<LogicalType> table_types_person2;
    vector<unique_ptr<Expression>> filter_person2;
    unique_ptr<LogicalGet> get_op_person2 = move(
            getLogicalGet(*this, table_person, alias_person2, table_index_person2, table_types_person2));
    unique_ptr<TableFilterSet> table_filters_person2 = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_person2 = duckdb::make_uniq<ConstantFilter>(
            ExpressionType::COMPARE_EQUAL,
            p_first_name);
    table_filters_person2->filters[0] = move(constant_filter_person2);
    unique_ptr<PhysicalTableScan> scan_person2 = make_uniq<PhysicalTableScan>(get_person2_types,
                                                                              get_op_person2->function,
                                                                              get_op_person2->table_index,
                                                                              move(get_op_person2->bind_data),
                                                                              table_types_person2, person2_ids,
                                                                              move(filter_person2), vector<column_t>(),
                                                                              get_op_person2->names,
                                                                              std::move(table_filters_person2),
                                                                              get_op_person2->estimated_cardinality,
                                                                              get_op_person2->extra_info);

    vector<JoinCondition> cond_knows_3;
    JoinCondition join_condition_knows_3;
    join_condition_knows_3.left = make_uniq<BoundReferenceExpression>("person_rowid", LogicalType::BIGINT, 1);
    join_condition_knows_3.right = make_uniq<BoundReferenceExpression>("person_rowid", LogicalType::BIGINT, 0);
    join_condition_knows_3.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_knows_3 = make_uniq<RAIInfo>();
    rai_info_knows_3->rai = table_knows.GetStorage().info->rais[0].get();
    rai_info_knows_3->rai_type = RAIType::TARGET_EDGE;
    rai_info_knows_3->forward = true;
    rai_info_knows_3->vertex = &table_person;
    rai_info_knows_3->vertex_id = table_index_person2;
    rai_info_knows_3->passing_tables[0] = table_index_person2;
    rai_info_knows_3->left_cardinalities[0] = table_person.GetStorage().info->cardinality;
    // rai_info_knows->compact_list = &rai_info_knows->rai->alist->compact_backward_list;

    join_condition_knows_3.rais.push_back(move(rai_info_knows_3));
    cond_knows_3.push_back(move(join_condition_knows_3));

    LogicalComparisonJoin join_knows_3_op(JoinType::INNER);
    vector<LogicalType> output_knows_3_types{LogicalType::VARCHAR, LogicalType::BIGINT, LogicalType::BIGINT,
                                             LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::DATE,
                                             LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::VARCHAR,
                                             LogicalType::VARCHAR, LogicalType::BIGINT};
    join_knows_3_op.types = output_knows_3_types;
    vector<idx_t> right_projection_map_knows_3{0};
    vector<idx_t> merge_project_map_3;
    vector<LogicalType> delim_types_3;
    auto join_knows_3 = make_uniq<PhysicalMergeSIPJoin>(join_knows_3_op, move(scan_person2), move(join_knows_2),
                                                        move(cond_knows_3),
                                                        JoinType::INNER, left_projection_map,
                                                        right_projection_map_knows_3,
                                                        merge_project_map_3, delim_types_3, 0);


    // join place with person-person
    vector<idx_t> place_ids{COLUMN_IDENTIFIER_ROW_ID, 1};
    vector<LogicalType> get_place_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_place = "pl";
    vector<LogicalType> table_types_place;
    vector<unique_ptr<Expression>> filter_place;
    unique_ptr<LogicalGet> get_op_place = move(
            getLogicalGet(*this, table_place, alias_place, table_index_place, table_types_place));
    unique_ptr<TableFilterSet> table_filters_place = NULL;
    unique_ptr<PhysicalTableScan> scan_place = make_uniq<PhysicalTableScan>(get_place_types, get_op_place->function,
                                                                            get_op_place->table_index,
                                                                            move(get_op_place->bind_data),
                                                                            table_types_place, place_ids,
                                                                            move(filter_place), vector<column_t>(),
                                                                            get_op_place->names,
                                                                            std::move(table_filters_place),
                                                                            get_op_place->estimated_cardinality,
                                                                            get_op_place->extra_info);

    vector<JoinCondition> cond_place;
    JoinCondition join_condition_place;
    join_condition_place.left = make_uniq<BoundReferenceExpression>("place_rowid", LogicalType::BIGINT, 0);
    join_condition_place.right = make_uniq<BoundReferenceExpression>("p_placeid_rowid", LogicalType::BIGINT, 2);
    join_condition_place.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_place = make_uniq<RAIInfo>();
    rai_info_place->rai = table_person.GetStorage().info->rais[0].get();
    rai_info_place->rai_type = RAIType::TARGET_EDGE;
    rai_info_place->forward = true;
    rai_info_place->vertex = &table_place;
    rai_info_place->vertex_id = table_index_place;
    rai_info_place->passing_tables[0] = table_index_place;
    rai_info_place->left_cardinalities[0] = table_place.GetStorage().info->cardinality;
    // rai_info_place->compact_list = &rai_info_place->rai->alist->compact_forward_list;

    join_condition_place.rais.push_back(move(rai_info_place));
    cond_place.push_back(move(join_condition_place));

    LogicalComparisonJoin join_place_op(JoinType::INNER);
    vector<LogicalType> output_place_types{LogicalType::BIGINT, LogicalType::VARCHAR,
                                           LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::DATE,
                                           LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::VARCHAR,
                                           LogicalType::VARCHAR};
    join_place_op.types = output_place_types;
    vector<idx_t> right_projection_map_place{3, 4, 5, 6, 7, 8, 9};
    vector<idx_t> merge_project_map_place;
    vector<LogicalType> delim_types_place;
    auto join_place = make_uniq<PhysicalSIPJoin>(join_place_op, move(scan_place), move(join_knows_3), move(cond_place),
                                                 JoinType::INNER, left_projection_map, right_projection_map_place,
                                                 delim_types_place, 0);


    // project
    vector<LogicalType> result_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::DATE,
                                     LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::VARCHAR,
                                     LogicalType::VARCHAR, LogicalType::VARCHAR};
    vector<unique_ptr<Expression>> select_list;
    auto result_col0 = make_uniq<BoundReferenceExpression>("p_personid", LogicalType::BIGINT, 2);
    auto result_col1 = make_uniq<BoundReferenceExpression>("p_lastname", LogicalType::VARCHAR, 3);
    auto result_col2 = make_uniq<BoundReferenceExpression>("p_birthday", LogicalType::DATE, 4);
    auto result_col3 = make_uniq<BoundReferenceExpression>("p_creationdate", LogicalType::BIGINT, 5);
    auto result_col4 = make_uniq<BoundReferenceExpression>("p_gender", LogicalType::VARCHAR, 6);
    auto result_col5 = make_uniq<BoundReferenceExpression>("p_browserused", LogicalType::VARCHAR, 7);
    auto result_col6 = make_uniq<BoundReferenceExpression>("p_locationip", LogicalType::VARCHAR, 8);
    auto result_col7 = make_uniq<BoundReferenceExpression>("pl_name", LogicalType::VARCHAR, 1);

    select_list.push_back(move(result_col0));
    select_list.push_back(move(result_col1));
    select_list.push_back(move(result_col2));
    select_list.push_back(move(result_col3));
    select_list.push_back(move(result_col4));
    select_list.push_back(move(result_col5));
    select_list.push_back(move(result_col6));
    select_list.push_back(move(result_col7));

    auto projection = make_uniq<PhysicalProjection>(result_types, move(select_list), 0);
    projection->children.push_back(move(join_place));

    return projection;
}

unique_ptr<PhysicalOperator> ClientContext::GenerateIC21PlanGLogue() {
    vector<idx_t> left_projection_map, right_projection_map;

    string table_vertex_person = "person";
    string table_edge_knows = "knows";
    string table_vertex_comment = "comment";
    idx_t table_index_person1 = 6;
    idx_t table_index_person2 = 8;
    idx_t table_index_knows = 7;
    idx_t table_index_comment = 11;


    auto table_or_view_person = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                  table_vertex_person, OnEntryNotFound::RETURN_NULL);
    auto &table_person = table_or_view_person->Cast<TableCatalogEntry>();


    auto table_or_view_knows = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                 table_edge_knows, OnEntryNotFound::RETURN_NULL);
    auto &table_knows = table_or_view_knows->Cast<TableCatalogEntry>();

    auto table_or_view_comment = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                 table_vertex_comment, OnEntryNotFound::RETURN_NULL);
    auto &table_comment = table_or_view_comment->Cast<TableCatalogEntry>();


    vector<idx_t> person2_ids{COLUMN_IDENTIFIER_ROW_ID, 0, 1, 2};
    vector<LogicalType> get_person2_types{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::VARCHAR,
                                          LogicalType::VARCHAR};
    string alias_person2 = "p2";
    vector<LogicalType> table_types_person2;
    vector<unique_ptr<Expression>> filter_person2;
    unique_ptr<LogicalGet> get_op_person2 = move(
            getLogicalGet(*this, table_person, alias_person2, table_index_person2, table_types_person2));
    unique_ptr<TableFilterSet> table_filters_person2 = NULL;
    unique_ptr<PhysicalTableScan> scan_person2 = make_uniq<PhysicalTableScan>(get_person2_types,
                                                                              get_op_person2->function,
                                                                              get_op_person2->table_index,
                                                                              move(get_op_person2->bind_data),
                                                                              table_types_person2, person2_ids,
                                                                              move(filter_person2), vector<column_t>(),
                                                                              get_op_person2->names,
                                                                              std::move(table_filters_person2),
                                                                              get_op_person2->estimated_cardinality,
                                                                              get_op_person2->extra_info);

    idx_t p_person_id = atoll(paras->data()[0].c_str()); // 933;
    Value p_person = Value::BIGINT(p_person_id);
    vector<idx_t> person1_ids{0, COLUMN_IDENTIFIER_ROW_ID};
    vector<LogicalType> get_person1_types{LogicalType::BIGINT, LogicalType::BIGINT};
    string alias_person1 = "p1";
    vector<LogicalType> table_types_person1;
    unique_ptr<LogicalGet> get_op_person1 = move(
            getLogicalGet(*this, table_person, alias_person1, table_index_person1, table_types_person1));
    vector<unique_ptr<Expression>> filter_person1;
    unique_ptr<TableFilterSet> table_filters_person1 = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL,
                                                                                   p_person);
    table_filters_person1->filters[0] = move(constant_filter);
    unique_ptr<PhysicalTableScan> scan_person1 = make_uniq<PhysicalTableScan>(get_person1_types,
                                                                              get_op_person1->function,
                                                                              get_op_person1->table_index,
                                                                              move(get_op_person1->bind_data),
                                                                              table_types_person1, person1_ids,
                                                                              move(filter_person1), vector<column_t>(),
                                                                              get_op_person1->names,
                                                                              std::move(table_filters_person1),
                                                                              get_op_person1->estimated_cardinality,
                                                                              get_op_person1->extra_info);

    vector<JoinCondition> cond_knows;
    JoinCondition join_condition_knows;
    join_condition_knows.left = make_uniq<BoundReferenceExpression>("person_rowid", LogicalType::BIGINT, 0);
    join_condition_knows.right = make_uniq<BoundReferenceExpression>("person_rowid", LogicalType::BIGINT, 1);
    join_condition_knows.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_knows = make_uniq<RAIInfo>();
    rai_info_knows->rai = table_knows.GetStorage().info->rais[0].get();
    rai_info_knows->rai_type = RAIType::TARGET_EDGE;
    rai_info_knows->forward = true;
    rai_info_knows->vertex = &table_person;
    rai_info_knows->vertex_id = table_index_person2;
    rai_info_knows->passing_tables[0] = table_index_person2;
    rai_info_knows->left_cardinalities[0] = table_person.GetStorage().info->cardinality;
    // rai_info_knows->compact_list = &rai_info_knows->rai->alist->compact_backward_list;

    join_condition_knows.rais.push_back(move(rai_info_knows));
    cond_knows.push_back(move(join_condition_knows));

    LogicalComparisonJoin join_knows_op(JoinType::INNER);
    vector<LogicalType> output_knows_types{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::VARCHAR,
                                           LogicalType::VARCHAR, LogicalType::BIGINT};
    join_knows_op.types = output_knows_types;
    vector<idx_t> right_projection_map_knows{1};
    vector<idx_t> merge_project_map;
    vector<LogicalType> delim_types;
    auto join_knows = make_uniq<PhysicalMergeSIPJoin>(join_knows_op, move(scan_person2), move(scan_person1),
                                                      move(cond_knows),
                                                      JoinType::INNER, left_projection_map, right_projection_map_knows,
                                                      merge_project_map, delim_types, 0);

    // join comment with person-person
    idx_t p_comment_date = atoll(paras->data()[1].c_str());
    Value p_comment = Value::BIGINT(p_comment_date);
    vector<idx_t> comment_ids{10, 1, 0, 4};
    vector<LogicalType> get_comment_types{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::BIGINT,
                                          LogicalType::VARCHAR};
    string alias_comment = "c";
    vector<LogicalType> table_types_comment;
    vector<unique_ptr<Expression>> filter_comment;
    unique_ptr<LogicalGet> get_op_comment = move(
            getLogicalGet(*this, table_comment, alias_comment, table_index_comment, table_types_comment));
    unique_ptr<TableFilterSet> table_filters_comment = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_comment = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_LESSTHAN,
                                                                                   p_comment);
    table_filters_comment->filters[1] = move(constant_filter_comment);
    unique_ptr<PhysicalTableScan> scan_comment = make_uniq<PhysicalTableScan>(get_comment_types, get_op_comment->function,
                                                                            get_op_comment->table_index,
                                                                            move(get_op_comment->bind_data),
                                                                            table_types_comment, comment_ids,
                                                                            move(filter_comment), vector<column_t>(),
                                                                            get_op_comment->names,
                                                                            std::move(table_filters_comment),
                                                                            get_op_comment->estimated_cardinality,
                                                                            get_op_comment->extra_info);

    vector<JoinCondition> cond_comment;
    JoinCondition join_condition_comment;
    join_condition_comment.left = make_uniq<BoundReferenceExpression>("m_creatorid_rowid", LogicalType::BIGINT, 0);
    join_condition_comment.right = make_uniq<BoundReferenceExpression>("person_rowid", LogicalType::BIGINT, 0);
    join_condition_comment.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_comment = make_uniq<RAIInfo>();
    rai_info_comment->rai = table_comment.GetStorage().info->rais[0].get();
    rai_info_comment->rai_type = RAIType::EDGE_SOURCE;
    rai_info_comment->forward = true;
    rai_info_comment->vertex = &table_person;
    rai_info_comment->vertex_id = table_index_person2;
    rai_info_comment->passing_tables[0] = table_index_comment;
    rai_info_comment->left_cardinalities[0] = table_comment.GetStorage().info->cardinality;
    rai_info_comment->compact_list = &rai_info_comment->rai->alist->compact_forward_list;

    join_condition_comment.rais.push_back(move(rai_info_comment));
    cond_comment.push_back(move(join_condition_comment));

    LogicalComparisonJoin join_comment_op(JoinType::INNER);
    vector<LogicalType> output_comment_types{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::BIGINT,
                                             LogicalType::VARCHAR, LogicalType::BIGINT, LogicalType::VARCHAR,
                                             LogicalType::VARCHAR};
    join_comment_op.types = output_comment_types;
    vector<idx_t> right_projection_map_comment{1, 2, 3};
    vector<idx_t> merge_project_map_comment;
    vector<LogicalType> delim_types_comment;
    auto join_place = make_uniq<PhysicalSIPJoin>(join_comment_op, move(scan_comment), move(join_knows), move(cond_comment),
                                                 JoinType::INNER, left_projection_map, right_projection_map_comment,
                                                 delim_types_comment, 0);


    // project
    vector<LogicalType> result_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::VARCHAR,
                                     LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::BIGINT};
    vector<unique_ptr<Expression>> select_list;
    auto result_col0 = make_uniq<BoundReferenceExpression>("p_personid", LogicalType::BIGINT, 4);
    auto result_col1 = make_uniq<BoundReferenceExpression>("p_firstname", LogicalType::VARCHAR, 5);
    auto result_col2 = make_uniq<BoundReferenceExpression>("p_lastname", LogicalType::VARCHAR, 6);
    auto result_col3 = make_uniq<BoundReferenceExpression>("m_messageid", LogicalType::BIGINT, 2);
    auto result_col4 = make_uniq<BoundReferenceExpression>("m_content", LogicalType::VARCHAR, 3);
    auto result_col5 = make_uniq<BoundReferenceExpression>("m_creationdate", LogicalType::BIGINT, 1);

    select_list.push_back(move(result_col0));
    select_list.push_back(move(result_col1));
    select_list.push_back(move(result_col2));
    select_list.push_back(move(result_col3));
    select_list.push_back(move(result_col4));
    select_list.push_back(move(result_col5));

    auto projection = make_uniq<PhysicalProjection>(result_types, move(select_list), 0);
    projection->children.push_back(move(join_place));

    return projection;
}

unique_ptr<PhysicalOperator> ClientContext::GenerateIC31PlanGLogue() {
    vector<idx_t> left_projection_map, right_projection_map;

    string table_vertex_person = "person";
    string table_edge_knows = "knows";
    string table_vertex_comment = "comment";
    string table_vertex_place = "place";
    idx_t table_index_person1 = 6;
    idx_t table_index_person2 = 8;
    idx_t table_index_knows = 7;
    idx_t table_index_comment1 = 11;
    idx_t table_index_comment2 = 12;
    idx_t table_index_place1 = 13;
    idx_t table_index_place2 = 14;


    auto table_or_view_person = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                  table_vertex_person, OnEntryNotFound::RETURN_NULL);
    auto &table_person = table_or_view_person->Cast<TableCatalogEntry>();


    auto table_or_view_knows = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                 table_edge_knows, OnEntryNotFound::RETURN_NULL);
    auto &table_knows = table_or_view_knows->Cast<TableCatalogEntry>();

    auto table_or_view_comment = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                   table_vertex_comment, OnEntryNotFound::RETURN_NULL);
    auto &table_comment = table_or_view_comment->Cast<TableCatalogEntry>();

    auto table_or_view_place = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                   table_vertex_place, OnEntryNotFound::RETURN_NULL);
    auto &table_place = table_or_view_place->Cast<TableCatalogEntry>();


    vector<idx_t> person2_ids{COLUMN_IDENTIFIER_ROW_ID, 0, 1, 2};
    vector<LogicalType> get_person2_types{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::VARCHAR,
                                          LogicalType::VARCHAR};
    string alias_person2 = "p2";
    vector<LogicalType> table_types_person2;
    vector<unique_ptr<Expression>> filter_person2;
    unique_ptr<LogicalGet> get_op_person2 = move(
            getLogicalGet(*this, table_person, alias_person2, table_index_person2, table_types_person2));
    unique_ptr<TableFilterSet> table_filters_person2 = NULL;
    unique_ptr<PhysicalTableScan> scan_person2 = make_uniq<PhysicalTableScan>(get_person2_types,
                                                                              get_op_person2->function,
                                                                              get_op_person2->table_index,
                                                                              move(get_op_person2->bind_data),
                                                                              table_types_person2, person2_ids,
                                                                              move(filter_person2), vector<column_t>(),
                                                                              get_op_person2->names,
                                                                              std::move(table_filters_person2),
                                                                              get_op_person2->estimated_cardinality,
                                                                              get_op_person2->extra_info);

    idx_t p_person_id = atoll(paras->data()[0].c_str()); // 933;
    Value p_person = Value::BIGINT(p_person_id);
    vector<idx_t> person1_ids{0, COLUMN_IDENTIFIER_ROW_ID};
    vector<LogicalType> get_person1_types{LogicalType::BIGINT, LogicalType::BIGINT};
    string alias_person1 = "p1";
    vector<LogicalType> table_types_person1;
    unique_ptr<LogicalGet> get_op_person1 = move(
            getLogicalGet(*this, table_person, alias_person1, table_index_person1, table_types_person1));
    vector<unique_ptr<Expression>> filter_person1;
    unique_ptr<TableFilterSet> table_filters_person1 = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL,
                                                                                   p_person);
    table_filters_person1->filters[0] = move(constant_filter);
    unique_ptr<PhysicalTableScan> scan_person1 = make_uniq<PhysicalTableScan>(get_person1_types,
                                                                              get_op_person1->function,
                                                                              get_op_person1->table_index,
                                                                              move(get_op_person1->bind_data),
                                                                              table_types_person1, person1_ids,
                                                                              move(filter_person1), vector<column_t>(),
                                                                              get_op_person1->names,
                                                                              std::move(table_filters_person1),
                                                                              get_op_person1->estimated_cardinality,
                                                                              get_op_person1->extra_info);

    vector<JoinCondition> cond_knows;
    JoinCondition join_condition_knows;
    join_condition_knows.left = make_uniq<BoundReferenceExpression>("person_rowid", LogicalType::BIGINT, 0);
    join_condition_knows.right = make_uniq<BoundReferenceExpression>("person_rowid", LogicalType::BIGINT, 1);
    join_condition_knows.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_knows = make_uniq<RAIInfo>();
    rai_info_knows->rai = table_knows.GetStorage().info->rais[0].get();
    rai_info_knows->rai_type = RAIType::TARGET_EDGE;
    rai_info_knows->forward = true;
    rai_info_knows->vertex = &table_person;
    rai_info_knows->vertex_id = table_index_person2;
    rai_info_knows->passing_tables[0] = table_index_person2;
    rai_info_knows->left_cardinalities[0] = table_person.GetStorage().info->cardinality;
    // rai_info_knows->compact_list = &rai_info_knows->rai->alist->compact_backward_list;

    join_condition_knows.rais.push_back(move(rai_info_knows));
    cond_knows.push_back(move(join_condition_knows));

    LogicalComparisonJoin join_knows_op(JoinType::INNER);
    vector<LogicalType> output_knows_types{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::VARCHAR,
                                           LogicalType::VARCHAR, LogicalType::BIGINT};
    join_knows_op.types = output_knows_types;
    vector<idx_t> right_projection_map_knows{1};
    vector<idx_t> merge_project_map;
    vector<LogicalType> delim_types;
    auto join_knows = make_uniq<PhysicalMergeSIPJoin>(join_knows_op, move(scan_person2), move(scan_person1),
                                                      move(cond_knows),
                                                      JoinType::INNER, left_projection_map, right_projection_map_knows,
                                                      merge_project_map, delim_types, 0);

    // join comment with person-person
    idx_t p_comment1_start = atoll(paras->data()[1].c_str());
    idx_t p_comment1_end = atoll(paras->data()[2].c_str());
    Value p_comment1_start_time = Value::BIGINT(p_comment1_start);
    Value p_comment1_end_time = Value::BIGINT(p_comment1_end);
    vector<idx_t> comment1_ids{10, 1, 11};
    vector<LogicalType> get_comment1_types{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::BIGINT};
    string alias_comment1 = "c1";
    vector<LogicalType> table_types_comment1;
    vector<unique_ptr<Expression>> filter_comment1;
    unique_ptr<LogicalGet> get_op_comment1 = move(
            getLogicalGet(*this, table_comment, alias_comment1, table_index_comment1, table_types_comment1));
    unique_ptr<TableFilterSet> table_filters_comment1 = make_uniq<TableFilterSet>();
    unique_ptr<ConjunctionAndFilter> and_filter_comment1 = duckdb::make_uniq<ConjunctionAndFilter>();
    unique_ptr<ConstantFilter> constant_filter_comment1_start = duckdb::make_uniq<ConstantFilter>(
            ExpressionType::COMPARE_GREATERTHANOREQUALTO, p_comment1_start_time);
    unique_ptr<ConstantFilter> constant_filter_comment1_end = duckdb::make_uniq<ConstantFilter>(
            ExpressionType::COMPARE_LESSTHAN, p_comment1_end_time);
    and_filter_comment1->child_filters.push_back(move(constant_filter_comment1_start));
    and_filter_comment1->child_filters.push_back(move(constant_filter_comment1_end));
    table_filters_comment1->filters[1] = move(and_filter_comment1);
    unique_ptr<PhysicalTableScan> scan_comment1 = make_uniq<PhysicalTableScan>(get_comment1_types,
                                                                              get_op_comment1->function,
                                                                              get_op_comment1->table_index,
                                                                              move(get_op_comment1->bind_data),
                                                                              table_types_comment1, comment1_ids,
                                                                              move(filter_comment1), vector<column_t>(),
                                                                              get_op_comment1->names,
                                                                              std::move(table_filters_comment1),
                                                                              get_op_comment1->estimated_cardinality,
                                                                              get_op_comment1->extra_info);

    vector<JoinCondition> cond_comment1;
    JoinCondition join_condition_comment1;
    join_condition_comment1.left = make_uniq<BoundReferenceExpression>("m_creatorid_rowid", LogicalType::BIGINT, 0);
    join_condition_comment1.right = make_uniq<BoundReferenceExpression>("person_rowid", LogicalType::BIGINT, 0);
    join_condition_comment1.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_comment = make_uniq<RAIInfo>();
    rai_info_comment->rai = table_comment.GetStorage().info->rais[0].get();
    rai_info_comment->rai_type = RAIType::EDGE_SOURCE;
    rai_info_comment->forward = true;
    rai_info_comment->vertex = &table_person;
    rai_info_comment->vertex_id = table_index_person2;
    rai_info_comment->passing_tables[0] = table_index_comment1;
    rai_info_comment->left_cardinalities[0] = table_comment.GetStorage().info->cardinality;
    rai_info_comment->compact_list = &rai_info_comment->rai->alist->compact_forward_list;

    join_condition_comment1.rais.push_back(move(rai_info_comment));
    cond_comment1.push_back(move(join_condition_comment1));

    LogicalComparisonJoin join_comment1_op(JoinType::INNER);
    vector<LogicalType> output_comment1_types{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::BIGINT,
                                             LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::VARCHAR,
                                             LogicalType::VARCHAR};
    join_comment1_op.types = output_comment1_types;
    vector<idx_t> right_projection_map_comment1{0, 1, 2, 3};
    vector<idx_t> merge_project_map_comment1;
    vector<LogicalType> delim_types_comment1;
    auto join_comment1 = make_uniq<PhysicalSIPJoin>(join_comment1_op, move(scan_comment1), move(join_knows),
                                                 move(cond_comment1),
                                                 JoinType::INNER, left_projection_map, right_projection_map_comment1,
                                                 delim_types_comment1, 0);

    // join place1 with person-person-comment
    string p_place1 = paras->data()[3];
    Value p_place1_name = Value(p_place1);
    vector<idx_t> place1_ids{COLUMN_IDENTIFIER_ROW_ID, 1};
    vector<LogicalType> get_place1_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_place1 = "pl1";
    vector<LogicalType> table_types_place1;
    vector<unique_ptr<Expression>> filter_place1;
    unique_ptr<LogicalGet> get_op_place1 = move(
            getLogicalGet(*this, table_place, alias_place1, table_index_place1, table_types_place1));
    unique_ptr<TableFilterSet> table_filters_place1 = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_place1_name = duckdb::make_uniq<ConstantFilter>(
            ExpressionType::COMPARE_EQUAL, p_place1_name);
    table_filters_place1->filters[1] = move(constant_filter_place1_name);
    unique_ptr<PhysicalTableScan> scan_place1 = make_uniq<PhysicalTableScan>(get_place1_types, get_op_place1->function,
                                                                            get_op_place1->table_index,
                                                                            move(get_op_place1->bind_data),
                                                                            table_types_place1, place1_ids,
                                                                            move(filter_place1), vector<column_t>(),
                                                                            get_op_place1->names,
                                                                            std::move(table_filters_place1),
                                                                            get_op_place1->estimated_cardinality,
                                                                            get_op_place1->extra_info);

    vector<JoinCondition> cond_place1;
    JoinCondition join_condition_place1;
    join_condition_place1.left = make_uniq<BoundReferenceExpression>("place_rowid", LogicalType::BIGINT, 0);
    join_condition_place1.right = make_uniq<BoundReferenceExpression>("m_locationid_rowid", LogicalType::BIGINT, 2);
    join_condition_place1.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_place1 = make_uniq<RAIInfo>();
    rai_info_place1->rai = table_comment.GetStorage().info->rais[1].get();
    rai_info_place1->rai_type = RAIType::TARGET_EDGE;
    rai_info_place1->forward = true;
    rai_info_place1->vertex = &table_place;
    rai_info_place1->vertex_id = table_index_place1;
    rai_info_place1->passing_tables[0] = table_index_place1;
    rai_info_place1->left_cardinalities[0] = table_place.GetStorage().info->cardinality;
    // rai_info_place->compact_list = &rai_info_place->rai->alist->compact_forward_list;

    join_condition_place1.rais.push_back(move(rai_info_place1));
    cond_place1.push_back(move(join_condition_place1));

    LogicalComparisonJoin join_place1_op(JoinType::INNER);
    vector<LogicalType> output_place1_types{LogicalType::BIGINT, LogicalType::VARCHAR,
                                           LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::VARCHAR,
                                           LogicalType::VARCHAR};
    join_place1_op.types = output_place1_types;
    vector<idx_t> right_projection_map_place1{3, 4, 5, 6};
    vector<idx_t> merge_project_map_place1;
    vector<LogicalType> delim_types_place1;
    auto join_place1 = make_uniq<PhysicalSIPJoin>(join_place1_op, move(scan_place1), move(join_comment1), move(cond_place1),
                                                 JoinType::INNER, left_projection_map, right_projection_map_place1,
                                                 delim_types_place1, 0);

    // comment2 and place2
    idx_t p_comment2_start = atoll(paras->data()[1].c_str());
    idx_t p_comment2_end = atoll(paras->data()[2].c_str());
    Value p_comment2_start_time = Value::BIGINT(p_comment2_start);
    Value p_comment2_end_time = Value::BIGINT(p_comment2_end);
    vector<idx_t> comment2_ids{10, 1, 11};
    vector<LogicalType> get_comment2_types{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::BIGINT};
    string alias_comment2 = "c1";
    vector<LogicalType> table_types_comment2;
    vector<unique_ptr<Expression>> filter_comment2;
    unique_ptr<LogicalGet> get_op_comment2 = move(
            getLogicalGet(*this, table_comment, alias_comment2, table_index_comment2, table_types_comment2));
    unique_ptr<TableFilterSet> table_filters_comment2 = make_uniq<TableFilterSet>();
    unique_ptr<ConjunctionAndFilter> and_filter_comment2 = duckdb::make_uniq<ConjunctionAndFilter>();
    unique_ptr<ConstantFilter> constant_filter_comment2_start = duckdb::make_uniq<ConstantFilter>(
            ExpressionType::COMPARE_GREATERTHANOREQUALTO, p_comment2_start_time);
    unique_ptr<ConstantFilter> constant_filter_comment2_end = duckdb::make_uniq<ConstantFilter>(
            ExpressionType::COMPARE_LESSTHAN, p_comment2_end_time);
    and_filter_comment2->child_filters.push_back(move(constant_filter_comment2_start));
    and_filter_comment2->child_filters.push_back(move(constant_filter_comment2_end));
    table_filters_comment2->filters[1] = move(and_filter_comment2);
    unique_ptr<PhysicalTableScan> scan_comment2 = make_uniq<PhysicalTableScan>(get_comment2_types,
                                                                               get_op_comment2->function,
                                                                               get_op_comment2->table_index,
                                                                               move(get_op_comment2->bind_data),
                                                                               table_types_comment2, comment2_ids,
                                                                               move(filter_comment2), vector<column_t>(),
                                                                               get_op_comment2->names,
                                                                               std::move(table_filters_comment2),
                                                                               get_op_comment2->estimated_cardinality,
                                                                               get_op_comment2->extra_info);

    vector<JoinCondition> cond_comment2;
    JoinCondition join_condition_comment2;
    join_condition_comment2.left = make_uniq<BoundReferenceExpression>("m_creatorid_rowid", LogicalType::BIGINT, 0);
    join_condition_comment2.right = make_uniq<BoundReferenceExpression>("person_rowid", LogicalType::BIGINT, 2);
    join_condition_comment2.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_comment2 = make_uniq<RAIInfo>();
    rai_info_comment2->rai = table_comment.GetStorage().info->rais[0].get();
    rai_info_comment2->rai_type = RAIType::EDGE_SOURCE;
    rai_info_comment2->forward = true;
    rai_info_comment2->vertex = &table_person;
    rai_info_comment2->vertex_id = table_index_person2;
    rai_info_comment2->passing_tables[0] = table_index_comment2;
    rai_info_comment2->left_cardinalities[0] = table_comment.GetStorage().info->cardinality;
    rai_info_comment2->compact_list = &rai_info_comment2->rai->alist->compact_forward_list;

    join_condition_comment2.rais.push_back(move(rai_info_comment2));
    cond_comment2.push_back(move(join_condition_comment2));

    LogicalComparisonJoin join_comment2_op(JoinType::INNER);
    vector<LogicalType> output_comment2_types{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::BIGINT,
                                              LogicalType::BIGINT, LogicalType::VARCHAR,
                                              LogicalType::VARCHAR};
    join_comment2_op.types = output_comment2_types;
    vector<idx_t> right_projection_map_comment2{3, 4, 5};
    vector<idx_t> merge_project_map_comment2;
    vector<LogicalType> delim_types_comment2;
    auto join_comment2 = make_uniq<PhysicalSIPJoin>(join_comment2_op, move(scan_comment2), move(join_place1),
                                                    move(cond_comment2),
                                                    JoinType::INNER, left_projection_map, right_projection_map_comment2,
                                                    delim_types_comment2, 0);

    // join place2 with person-person-comment
    string p_place2 = paras->data()[4];
    Value p_place2_name = Value(p_place2);
    vector<idx_t> place2_ids{COLUMN_IDENTIFIER_ROW_ID, 1};
    vector<LogicalType> get_place2_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_place2 = "pl2";
    vector<LogicalType> table_types_place2;
    vector<unique_ptr<Expression>> filter_place2;
    unique_ptr<LogicalGet> get_op_place2 = move(
            getLogicalGet(*this, table_place, alias_place2, table_index_place2, table_types_place2));
    unique_ptr<TableFilterSet> table_filters_place2 = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_place2_name = duckdb::make_uniq<ConstantFilter>(
            ExpressionType::COMPARE_EQUAL, p_place2_name);
    table_filters_place2->filters[1] = move(constant_filter_place2_name);
    unique_ptr<PhysicalTableScan> scan_place2 = make_uniq<PhysicalTableScan>(get_place2_types, get_op_place2->function,
                                                                             get_op_place2->table_index,
                                                                             move(get_op_place2->bind_data),
                                                                             table_types_place2, place2_ids,
                                                                             move(filter_place2), vector<column_t>(),
                                                                             get_op_place2->names,
                                                                             std::move(table_filters_place2),
                                                                             get_op_place2->estimated_cardinality,
                                                                             get_op_place2->extra_info);

    vector<JoinCondition> cond_place2;
    JoinCondition join_condition_place2;
    join_condition_place2.left = make_uniq<BoundReferenceExpression>("place_rowid", LogicalType::BIGINT, 0);
    join_condition_place2.right = make_uniq<BoundReferenceExpression>("m_locationid_rowid", LogicalType::BIGINT, 2);
    join_condition_place2.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_place2 = make_uniq<RAIInfo>();
    rai_info_place2->rai = table_comment.GetStorage().info->rais[1].get();
    rai_info_place2->rai_type = RAIType::TARGET_EDGE;
    rai_info_place2->forward = true;
    rai_info_place2->vertex = &table_place;
    rai_info_place2->vertex_id = table_index_place2;
    rai_info_place2->passing_tables[0] = table_index_place2;
    rai_info_place2->left_cardinalities[0] = table_place.GetStorage().info->cardinality;
    // rai_info_place->compact_list = &rai_info_place->rai->alist->compact_forward_list;

    join_condition_place2.rais.push_back(move(rai_info_place2));
    cond_place2.push_back(move(join_condition_place2));

    LogicalComparisonJoin join_place2_op(JoinType::INNER);
    vector<LogicalType> output_place2_types{LogicalType::BIGINT, LogicalType::VARCHAR,
                                            LogicalType::BIGINT, LogicalType::VARCHAR,
                                            LogicalType::VARCHAR};
    join_place2_op.types = output_place2_types;
    vector<idx_t> right_projection_map_place2{3, 4, 5};
    vector<idx_t> merge_project_map_place2;
    vector<LogicalType> delim_types_place2;
    auto join_place2 = make_uniq<PhysicalSIPJoin>(join_place2_op, move(scan_place2), move(join_comment2), move(cond_place2),
                                                  JoinType::INNER, left_projection_map, right_projection_map_place2,
                                                  delim_types_place2, 0);

    // project
    vector<LogicalType> result_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::VARCHAR};
    vector<unique_ptr<Expression>> select_list;
    auto result_col0 = make_uniq<BoundReferenceExpression>("p_personid", LogicalType::BIGINT, 2);
    auto result_col1 = make_uniq<BoundReferenceExpression>("p_firstname", LogicalType::VARCHAR, 3);
    auto result_col2 = make_uniq<BoundReferenceExpression>("p_lastname", LogicalType::VARCHAR, 4);

    select_list.push_back(move(result_col0));
    select_list.push_back(move(result_col1));
    select_list.push_back(move(result_col2));

    auto projection = make_uniq<PhysicalProjection>(result_types, move(select_list), 0);
    projection->children.push_back(move(join_place2));

    return projection;
}

unique_ptr<PhysicalOperator> ClientContext::GenerateIC32PlanGLogue() {
    vector<idx_t> left_projection_map, right_projection_map;

    string table_vertex_person = "person";
    string table_edge_knows = "knows";
    string table_vertex_comment = "comment";
    string table_vertex_place = "place";
    idx_t table_index_person1 = 6;
    idx_t table_index_person2 = 8;
    idx_t table_index_person3 = 9;
    idx_t table_index_knows = 7;
    idx_t table_index_comment1 = 11;
    idx_t table_index_comment2 = 12;
    idx_t table_index_place1 = 13;
    idx_t table_index_place2 = 14;


    auto table_or_view_person = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                  table_vertex_person, OnEntryNotFound::RETURN_NULL);
    auto &table_person = table_or_view_person->Cast<TableCatalogEntry>();


    auto table_or_view_knows = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                 table_edge_knows, OnEntryNotFound::RETURN_NULL);
    auto &table_knows = table_or_view_knows->Cast<TableCatalogEntry>();

    auto table_or_view_comment = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                   table_vertex_comment, OnEntryNotFound::RETURN_NULL);
    auto &table_comment = table_or_view_comment->Cast<TableCatalogEntry>();

    auto table_or_view_place = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                 table_vertex_place, OnEntryNotFound::RETURN_NULL);
    auto &table_place = table_or_view_place->Cast<TableCatalogEntry>();


    vector<idx_t> person2_ids{COLUMN_IDENTIFIER_ROW_ID, 0, 1, 2};
    vector<LogicalType> get_person2_types{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::VARCHAR,
                                          LogicalType::VARCHAR};
    string alias_person2 = "p2";
    vector<LogicalType> table_types_person2;
    vector<unique_ptr<Expression>> filter_person2;
    unique_ptr<LogicalGet> get_op_person2 = move(
            getLogicalGet(*this, table_person, alias_person2, table_index_person2, table_types_person2));
    unique_ptr<TableFilterSet> table_filters_person2 = NULL;
    unique_ptr<PhysicalTableScan> scan_person2 = make_uniq<PhysicalTableScan>(get_person2_types,
                                                                              get_op_person2->function,
                                                                              get_op_person2->table_index,
                                                                              move(get_op_person2->bind_data),
                                                                              table_types_person2, person2_ids,
                                                                              move(filter_person2), vector<column_t>(),
                                                                              get_op_person2->names,
                                                                              std::move(table_filters_person2),
                                                                              get_op_person2->estimated_cardinality,
                                                                              get_op_person2->extra_info);


    vector<idx_t> person3_ids{COLUMN_IDENTIFIER_ROW_ID};
    vector<LogicalType> get_person3_types{LogicalType::BIGINT};
    string alias_person3 = "tmp";
    vector<LogicalType> table_types_person3;
    vector<unique_ptr<Expression>> filter_person3;
    unique_ptr<LogicalGet> get_op_person3 = move(
            getLogicalGet(*this, table_person, alias_person3, table_index_person3, table_types_person3));
    unique_ptr<TableFilterSet> table_filters_person3 = NULL;
    unique_ptr<PhysicalTableScan> scan_person3 = make_uniq<PhysicalTableScan>(get_person3_types,
                                                                              get_op_person3->function,
                                                                              get_op_person3->table_index,
                                                                              move(get_op_person3->bind_data),
                                                                              table_types_person3, person3_ids,
                                                                              move(filter_person3), vector<column_t>(),
                                                                              get_op_person3->names,
                                                                              std::move(table_filters_person3),
                                                                              get_op_person3->estimated_cardinality,
                                                                              get_op_person3->extra_info);


    idx_t p_person_id = atoll(paras->data()[0].c_str()); // 933;
    Value p_person = Value::BIGINT(p_person_id);
    vector<idx_t> person1_ids{0, COLUMN_IDENTIFIER_ROW_ID};
    vector<LogicalType> get_person1_types{LogicalType::BIGINT, LogicalType::BIGINT};
    string alias_person1 = "p1";
    vector<LogicalType> table_types_person1;
    unique_ptr<LogicalGet> get_op_person1 = move(
            getLogicalGet(*this, table_person, alias_person1, table_index_person1, table_types_person1));
    vector<unique_ptr<Expression>> filter_person1;
    unique_ptr<TableFilterSet> table_filters_person1 = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL,
                                                                                   p_person);
    table_filters_person1->filters[0] = move(constant_filter);
    unique_ptr<PhysicalTableScan> scan_person1 = make_uniq<PhysicalTableScan>(get_person1_types,
                                                                              get_op_person1->function,
                                                                              get_op_person1->table_index,
                                                                              move(get_op_person1->bind_data),
                                                                              table_types_person1, person1_ids,
                                                                              move(filter_person1), vector<column_t>(),
                                                                              get_op_person1->names,
                                                                              std::move(table_filters_person1),
                                                                              get_op_person1->estimated_cardinality,
                                                                              get_op_person1->extra_info);

    vector<JoinCondition> cond_knows_inter;
    JoinCondition join_condition_knows_inter;
    join_condition_knows_inter.left = make_uniq<BoundReferenceExpression>("person_rowid", LogicalType::BIGINT, 0);
    join_condition_knows_inter.right = make_uniq<BoundReferenceExpression>("person_rowid", LogicalType::BIGINT, 1);
    join_condition_knows_inter.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_knows_inter = make_uniq<RAIInfo>();
    rai_info_knows_inter->rai = table_knows.GetStorage().info->rais[0].get();
    rai_info_knows_inter->rai_type = RAIType::TARGET_EDGE;
    rai_info_knows_inter->forward = true;
    rai_info_knows_inter->vertex = &table_person;
    rai_info_knows_inter->vertex_id = table_index_person3;
    rai_info_knows_inter->passing_tables[0] = table_index_person3;
    rai_info_knows_inter->left_cardinalities[0] = table_person.GetStorage().info->cardinality;
    // rai_info_knows->compact_list = &rai_info_knows->rai->alist->compact_backward_list;

    join_condition_knows_inter.rais.push_back(move(rai_info_knows_inter));
    cond_knows_inter.push_back(move(join_condition_knows_inter));

    LogicalComparisonJoin join_knows_inter_op(JoinType::INNER);
    vector<LogicalType> output_knows_inter_types{LogicalType::BIGINT, LogicalType::BIGINT};
    join_knows_inter_op.types = output_knows_inter_types;
    vector<idx_t> right_projection_map_knows_inter{1};
    vector<idx_t> merge_project_map_inter;
    vector<LogicalType> delim_types_inter;
    auto join_knows_inter = make_uniq<PhysicalMergeSIPJoin>(join_knows_inter_op, move(scan_person3), move(scan_person1),
                                                      move(cond_knows_inter),
                                                      JoinType::INNER, left_projection_map, right_projection_map_knows_inter,
                                                      merge_project_map_inter, delim_types_inter, 0);


    vector<JoinCondition> cond_knows;
    JoinCondition join_condition_knows;
    join_condition_knows.left = make_uniq<BoundReferenceExpression>("person_rowid", LogicalType::BIGINT, 0);
    join_condition_knows.right = make_uniq<BoundReferenceExpression>("person_rowid", LogicalType::BIGINT, 0);
    join_condition_knows.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_knows = make_uniq<RAIInfo>();
    rai_info_knows->rai = table_knows.GetStorage().info->rais[0].get();
    rai_info_knows->rai_type = RAIType::TARGET_EDGE;
    rai_info_knows->forward = true;
    rai_info_knows->vertex = &table_person;
    rai_info_knows->vertex_id = table_index_person2;
    rai_info_knows->passing_tables[0] = table_index_person2;
    rai_info_knows->left_cardinalities[0] = table_person.GetStorage().info->cardinality;
    // rai_info_knows->compact_list = &rai_info_knows->rai->alist->compact_backward_list;

    join_condition_knows.rais.push_back(move(rai_info_knows));
    cond_knows.push_back(move(join_condition_knows));

    LogicalComparisonJoin join_knows_op(JoinType::INNER);
    vector<LogicalType> output_knows_types{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::VARCHAR,
                                           LogicalType::VARCHAR, LogicalType::BIGINT};
    join_knows_op.types = output_knows_types;
    vector<idx_t> right_projection_map_knows{1};
    vector<idx_t> merge_project_map;
    vector<LogicalType> delim_types;
    auto join_knows = make_uniq<PhysicalMergeSIPJoin>(join_knows_op, move(scan_person2), move(join_knows_inter),
                                                      move(cond_knows),
                                                      JoinType::INNER, left_projection_map, right_projection_map_knows,
                                                      merge_project_map, delim_types, 0);

    // join comment with person-person
    idx_t p_comment1_start = atoll(paras->data()[1].c_str());
    idx_t p_comment1_end = atoll(paras->data()[2].c_str());
    Value p_comment1_start_time = Value::BIGINT(p_comment1_start);
    Value p_comment1_end_time = Value::BIGINT(p_comment1_end);
    vector<idx_t> comment1_ids{10, 1, 11};
    vector<LogicalType> get_comment1_types{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::BIGINT};
    string alias_comment1 = "c1";
    vector<LogicalType> table_types_comment1;
    vector<unique_ptr<Expression>> filter_comment1;
    unique_ptr<LogicalGet> get_op_comment1 = move(
            getLogicalGet(*this, table_comment, alias_comment1, table_index_comment1, table_types_comment1));
    unique_ptr<TableFilterSet> table_filters_comment1 = make_uniq<TableFilterSet>();
    unique_ptr<ConjunctionAndFilter> and_filter_comment1 = duckdb::make_uniq<ConjunctionAndFilter>();
    unique_ptr<ConstantFilter> constant_filter_comment1_start = duckdb::make_uniq<ConstantFilter>(
            ExpressionType::COMPARE_GREATERTHANOREQUALTO, p_comment1_start_time);
    unique_ptr<ConstantFilter> constant_filter_comment1_end = duckdb::make_uniq<ConstantFilter>(
            ExpressionType::COMPARE_LESSTHAN, p_comment1_end_time);
    and_filter_comment1->child_filters.push_back(move(constant_filter_comment1_start));
    and_filter_comment1->child_filters.push_back(move(constant_filter_comment1_end));
    table_filters_comment1->filters[1] = move(and_filter_comment1);
    unique_ptr<PhysicalTableScan> scan_comment1 = make_uniq<PhysicalTableScan>(get_comment1_types,
                                                                               get_op_comment1->function,
                                                                               get_op_comment1->table_index,
                                                                               move(get_op_comment1->bind_data),
                                                                               table_types_comment1, comment1_ids,
                                                                               move(filter_comment1),
                                                                               vector<column_t>(),
                                                                               get_op_comment1->names,
                                                                               std::move(table_filters_comment1),
                                                                               get_op_comment1->estimated_cardinality,
                                                                               get_op_comment1->extra_info);

    vector<JoinCondition> cond_comment1;
    JoinCondition join_condition_comment1;
    join_condition_comment1.left = make_uniq<BoundReferenceExpression>("m_creatorid_rowid", LogicalType::BIGINT, 0);
    join_condition_comment1.right = make_uniq<BoundReferenceExpression>("person_rowid", LogicalType::BIGINT, 0);
    join_condition_comment1.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_comment = make_uniq<RAIInfo>();
    rai_info_comment->rai = table_comment.GetStorage().info->rais[0].get();
    rai_info_comment->rai_type = RAIType::EDGE_SOURCE;
    rai_info_comment->forward = true;
    rai_info_comment->vertex = &table_person;
    rai_info_comment->vertex_id = table_index_person2;
    rai_info_comment->passing_tables[0] = table_index_comment1;
    rai_info_comment->left_cardinalities[0] = table_comment.GetStorage().info->cardinality;
    rai_info_comment->compact_list = &rai_info_comment->rai->alist->compact_forward_list;

    join_condition_comment1.rais.push_back(move(rai_info_comment));
    cond_comment1.push_back(move(join_condition_comment1));

    LogicalComparisonJoin join_comment1_op(JoinType::INNER);
    vector<LogicalType> output_comment1_types{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::BIGINT,
                                              LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::VARCHAR,
                                              LogicalType::VARCHAR};
    join_comment1_op.types = output_comment1_types;
    vector<idx_t> right_projection_map_comment1{0, 1, 2, 3};
    vector<idx_t> merge_project_map_comment1;
    vector<LogicalType> delim_types_comment1;
    auto join_comment1 = make_uniq<PhysicalSIPJoin>(join_comment1_op, move(scan_comment1), move(join_knows),
                                                    move(cond_comment1),
                                                    JoinType::INNER, left_projection_map, right_projection_map_comment1,
                                                    delim_types_comment1, 0);

    // join place1 with person-person-comment
    string p_place1 = paras->data()[3];
    Value p_place1_name = Value(p_place1);
    vector<idx_t> place1_ids{COLUMN_IDENTIFIER_ROW_ID, 1};
    vector<LogicalType> get_place1_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_place1 = "pl1";
    vector<LogicalType> table_types_place1;
    vector<unique_ptr<Expression>> filter_place1;
    unique_ptr<LogicalGet> get_op_place1 = move(
            getLogicalGet(*this, table_place, alias_place1, table_index_place1, table_types_place1));
    unique_ptr<TableFilterSet> table_filters_place1 = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_place1_name = duckdb::make_uniq<ConstantFilter>(
            ExpressionType::COMPARE_EQUAL, p_place1_name);
    table_filters_place1->filters[1] = move(constant_filter_place1_name);
    unique_ptr<PhysicalTableScan> scan_place1 = make_uniq<PhysicalTableScan>(get_place1_types, get_op_place1->function,
                                                                             get_op_place1->table_index,
                                                                             move(get_op_place1->bind_data),
                                                                             table_types_place1, place1_ids,
                                                                             move(filter_place1), vector<column_t>(),
                                                                             get_op_place1->names,
                                                                             std::move(table_filters_place1),
                                                                             get_op_place1->estimated_cardinality,
                                                                             get_op_place1->extra_info);

    vector<JoinCondition> cond_place1;
    JoinCondition join_condition_place1;
    join_condition_place1.left = make_uniq<BoundReferenceExpression>("place_rowid", LogicalType::BIGINT, 0);
    join_condition_place1.right = make_uniq<BoundReferenceExpression>("m_locationid_rowid", LogicalType::BIGINT, 2);
    join_condition_place1.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_place1 = make_uniq<RAIInfo>();
    rai_info_place1->rai = table_comment.GetStorage().info->rais[1].get();
    rai_info_place1->rai_type = RAIType::TARGET_EDGE;
    rai_info_place1->forward = true;
    rai_info_place1->vertex = &table_place;
    rai_info_place1->vertex_id = table_index_place1;
    rai_info_place1->passing_tables[0] = table_index_place1;
    rai_info_place1->left_cardinalities[0] = table_place.GetStorage().info->cardinality;
    // rai_info_place->compact_list = &rai_info_place->rai->alist->compact_forward_list;

    join_condition_place1.rais.push_back(move(rai_info_place1));
    cond_place1.push_back(move(join_condition_place1));

    LogicalComparisonJoin join_place1_op(JoinType::INNER);
    vector<LogicalType> output_place1_types{LogicalType::BIGINT, LogicalType::VARCHAR,
                                            LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::VARCHAR,
                                            LogicalType::VARCHAR};
    join_place1_op.types = output_place1_types;
    vector<idx_t> right_projection_map_place1{3, 4, 5, 6};
    vector<idx_t> merge_project_map_place1;
    vector<LogicalType> delim_types_place1;
    auto join_place1 = make_uniq<PhysicalSIPJoin>(join_place1_op, move(scan_place1), move(join_comment1),
                                                  move(cond_place1),
                                                  JoinType::INNER, left_projection_map, right_projection_map_place1,
                                                  delim_types_place1, 0);

    // comment2 and place2
    idx_t p_comment2_start = atoll(paras->data()[1].c_str());
    idx_t p_comment2_end = atoll(paras->data()[2].c_str());
    Value p_comment2_start_time = Value::BIGINT(p_comment2_start);
    Value p_comment2_end_time = Value::BIGINT(p_comment2_end);
    vector<idx_t> comment2_ids{10, 1, 11};
    vector<LogicalType> get_comment2_types{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::BIGINT};
    string alias_comment2 = "c1";
    vector<LogicalType> table_types_comment2;
    vector<unique_ptr<Expression>> filter_comment2;
    unique_ptr<LogicalGet> get_op_comment2 = move(
            getLogicalGet(*this, table_comment, alias_comment2, table_index_comment2, table_types_comment2));
    unique_ptr<TableFilterSet> table_filters_comment2 = make_uniq<TableFilterSet>();
    unique_ptr<ConjunctionAndFilter> and_filter_comment2 = duckdb::make_uniq<ConjunctionAndFilter>();
    unique_ptr<ConstantFilter> constant_filter_comment2_start = duckdb::make_uniq<ConstantFilter>(
            ExpressionType::COMPARE_GREATERTHANOREQUALTO, p_comment2_start_time);
    unique_ptr<ConstantFilter> constant_filter_comment2_end = duckdb::make_uniq<ConstantFilter>(
            ExpressionType::COMPARE_LESSTHAN, p_comment2_end_time);
    and_filter_comment2->child_filters.push_back(move(constant_filter_comment2_start));
    and_filter_comment2->child_filters.push_back(move(constant_filter_comment2_end));
    table_filters_comment2->filters[1] = move(and_filter_comment2);
    unique_ptr<PhysicalTableScan> scan_comment2 = make_uniq<PhysicalTableScan>(get_comment2_types,
                                                                               get_op_comment2->function,
                                                                               get_op_comment2->table_index,
                                                                               move(get_op_comment2->bind_data),
                                                                               table_types_comment2, comment2_ids,
                                                                               move(filter_comment2),
                                                                               vector<column_t>(),
                                                                               get_op_comment2->names,
                                                                               std::move(table_filters_comment2),
                                                                               get_op_comment2->estimated_cardinality,
                                                                               get_op_comment2->extra_info);

    vector<JoinCondition> cond_comment2;
    JoinCondition join_condition_comment2;
    join_condition_comment2.left = make_uniq<BoundReferenceExpression>("m_creatorid_rowid", LogicalType::BIGINT, 0);
    join_condition_comment2.right = make_uniq<BoundReferenceExpression>("person_rowid", LogicalType::BIGINT, 2);
    join_condition_comment2.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_comment2 = make_uniq<RAIInfo>();
    rai_info_comment2->rai = table_comment.GetStorage().info->rais[0].get();
    rai_info_comment2->rai_type = RAIType::EDGE_SOURCE;
    rai_info_comment2->forward = true;
    rai_info_comment2->vertex = &table_person;
    rai_info_comment2->vertex_id = table_index_person2;
    rai_info_comment2->passing_tables[0] = table_index_comment2;
    rai_info_comment2->left_cardinalities[0] = table_comment.GetStorage().info->cardinality;
    rai_info_comment2->compact_list = &rai_info_comment2->rai->alist->compact_forward_list;

    join_condition_comment2.rais.push_back(move(rai_info_comment2));
    cond_comment2.push_back(move(join_condition_comment2));

    LogicalComparisonJoin join_comment2_op(JoinType::INNER);
    vector<LogicalType> output_comment2_types{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::BIGINT,
                                              LogicalType::BIGINT, LogicalType::VARCHAR,
                                              LogicalType::VARCHAR};
    join_comment2_op.types = output_comment2_types;
    vector<idx_t> right_projection_map_comment2{3, 4, 5};
    vector<idx_t> merge_project_map_comment2;
    vector<LogicalType> delim_types_comment2;
    auto join_comment2 = make_uniq<PhysicalSIPJoin>(join_comment2_op, move(scan_comment2), move(join_place1),
                                                    move(cond_comment2),
                                                    JoinType::INNER, left_projection_map, right_projection_map_comment2,
                                                    delim_types_comment2, 0);

    // join place2 with person-person-comment
    string p_place2 = paras->data()[4];
    Value p_place2_name = Value(p_place2);
    vector<idx_t> place2_ids{COLUMN_IDENTIFIER_ROW_ID, 1};
    vector<LogicalType> get_place2_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_place2 = "pl2";
    vector<LogicalType> table_types_place2;
    vector<unique_ptr<Expression>> filter_place2;
    unique_ptr<LogicalGet> get_op_place2 = move(
            getLogicalGet(*this, table_place, alias_place2, table_index_place2, table_types_place2));
    unique_ptr<TableFilterSet> table_filters_place2 = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_place2_name = duckdb::make_uniq<ConstantFilter>(
            ExpressionType::COMPARE_EQUAL, p_place2_name);
    table_filters_place2->filters[1] = move(constant_filter_place2_name);
    unique_ptr<PhysicalTableScan> scan_place2 = make_uniq<PhysicalTableScan>(get_place2_types, get_op_place2->function,
                                                                             get_op_place2->table_index,
                                                                             move(get_op_place2->bind_data),
                                                                             table_types_place2, place2_ids,
                                                                             move(filter_place2), vector<column_t>(),
                                                                             get_op_place2->names,
                                                                             std::move(table_filters_place2),
                                                                             get_op_place2->estimated_cardinality,
                                                                             get_op_place2->extra_info);

    vector<JoinCondition> cond_place2;
    JoinCondition join_condition_place2;
    join_condition_place2.left = make_uniq<BoundReferenceExpression>("place_rowid", LogicalType::BIGINT, 0);
    join_condition_place2.right = make_uniq<BoundReferenceExpression>("m_locationid_rowid", LogicalType::BIGINT, 2);
    join_condition_place2.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_place2 = make_uniq<RAIInfo>();
    rai_info_place2->rai = table_comment.GetStorage().info->rais[1].get();
    rai_info_place2->rai_type = RAIType::TARGET_EDGE;
    rai_info_place2->forward = true;
    rai_info_place2->vertex = &table_place;
    rai_info_place2->vertex_id = table_index_place2;
    rai_info_place2->passing_tables[0] = table_index_place2;
    rai_info_place2->left_cardinalities[0] = table_place.GetStorage().info->cardinality;
    // rai_info_place->compact_list = &rai_info_place->rai->alist->compact_forward_list;

    join_condition_place2.rais.push_back(move(rai_info_place2));
    cond_place2.push_back(move(join_condition_place2));

    LogicalComparisonJoin join_place2_op(JoinType::INNER);
    vector<LogicalType> output_place2_types{LogicalType::BIGINT, LogicalType::VARCHAR,
                                            LogicalType::BIGINT, LogicalType::VARCHAR,
                                            LogicalType::VARCHAR};
    join_place2_op.types = output_place2_types;
    vector<idx_t> right_projection_map_place2{3, 4, 5};
    vector<idx_t> merge_project_map_place2;
    vector<LogicalType> delim_types_place2;
    auto join_place2 = make_uniq<PhysicalSIPJoin>(join_place2_op, move(scan_place2), move(join_comment2),
                                                  move(cond_place2),
                                                  JoinType::INNER, left_projection_map, right_projection_map_place2,
                                                  delim_types_place2, 0);

    // project
    vector<LogicalType> result_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::VARCHAR};
    vector<unique_ptr<Expression>> select_list;
    auto result_col0 = make_uniq<BoundReferenceExpression>("p_personid", LogicalType::BIGINT, 2);
    auto result_col1 = make_uniq<BoundReferenceExpression>("p_firstname", LogicalType::VARCHAR, 3);
    auto result_col2 = make_uniq<BoundReferenceExpression>("p_lastname", LogicalType::VARCHAR, 4);

    select_list.push_back(move(result_col0));
    select_list.push_back(move(result_col1));
    select_list.push_back(move(result_col2));

    auto projection = make_uniq<PhysicalProjection>(result_types, move(select_list), 0);
    projection->children.push_back(move(join_place2));

    return projection;
}

unique_ptr<PhysicalOperator> ClientContext::GenerateIC41PlanGLogue() {
    vector<idx_t> left_projection_map, right_projection_map;

    string table_vertex_PERSON_p3 = "PERSON";
    string table_vertex_PERSON_p1 = "PERSON";
    string table_vertex_PERSON_p2 = "PERSON";
    string table_vertex_POST_ps = "POST";
    string table_vertex_TAG_t = "TAG";
    string table_vertex_KNOWS_ = "KNOWS";
    string table_vertex_HASTAG_ = "POST_TAG";

    idx_t table_index_PERSON_p3 = 1;
    idx_t table_index_PERSON_p1 = 2;
    idx_t table_index_PERSON_p2 = 3;
    idx_t table_index_POST_ps = 4;
    idx_t table_index_TAG_t = 5;
    idx_t table_index_KNOWS_ = 7;
    idx_t table_index_KNOWS_k2 = 6;
    idx_t table_index_HASCREATOR_ = 8;
    idx_t table_index_HASTAG_ = 9;
    auto table_or_view_PERSON = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_PERSON_p3,
                                                  OnEntryNotFound::RETURN_NULL);
    auto &table_PERSON = table_or_view_PERSON->Cast<TableCatalogEntry>();
    auto table_or_view_POST = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_POST_ps,
                                                OnEntryNotFound::RETURN_NULL);
    auto &table_POST = table_or_view_POST->Cast<TableCatalogEntry>();
    auto table_or_view_TAG = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_TAG_t,
                                               OnEntryNotFound::RETURN_NULL);
    auto &table_TAG = table_or_view_TAG->Cast<TableCatalogEntry>();
    auto table_or_view_KNOWS = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_KNOWS_,
                                                 OnEntryNotFound::RETURN_NULL);
    auto &table_KNOWS = table_or_view_KNOWS->Cast<TableCatalogEntry>();
    auto table_or_view_HASTAG = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_HASTAG_,
                                                  OnEntryNotFound::RETURN_NULL);
    auto &table_HASTAG = table_or_view_HASTAG->Cast<TableCatalogEntry>();

    idx_t p_person_id = atoll(paras->data()[0].c_str()); // 933;
    Value p_person = Value::BIGINT(p_person_id);
    vector<idx_t> PERSON_p1_ids{COLUMN_IDENTIFIER_ROW_ID, 0};
    vector<LogicalType> get_PERSON_p1_types{LogicalType::BIGINT, LogicalType::BIGINT};
    string alias_PERSON_p1 = "p1";
    vector<LogicalType> table_types_PERSON_p1;
    vector<unique_ptr<Expression>> filter_PERSON_p1;
    unique_ptr<LogicalGet> get_op_PERSON_p1 = move(
            getLogicalGet(*this, table_PERSON, alias_PERSON_p1, table_index_PERSON_p1, table_types_PERSON_p1));
    unique_ptr<TableFilterSet> table_filters_PERSON_p1 = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL,
                                                                                   p_person);
    table_filters_PERSON_p1->filters[1] = move(constant_filter);
    unique_ptr<PhysicalTableScan> scan_PERSON_p1 = make_uniq<PhysicalTableScan>(get_PERSON_p1_types,
                                                                                get_op_PERSON_p1->function,
                                                                                get_op_PERSON_p1->table_index,
                                                                                move(get_op_PERSON_p1->bind_data),
                                                                                table_types_PERSON_p1, PERSON_p1_ids,
                                                                                move(filter_PERSON_p1),
                                                                                vector<column_t>(),
                                                                                get_op_PERSON_p1->names,
                                                                                std::move(table_filters_PERSON_p1),
                                                                                get_op_PERSON_p1->estimated_cardinality,
                                                                                get_op_PERSON_p1->extra_info);


    vector<idx_t> PERSON_p2_ids{COLUMN_IDENTIFIER_ROW_ID};
    vector<LogicalType> get_PERSON_p2_types{LogicalType::BIGINT};
    string alias_PERSON_p2 = "p2";
    vector<LogicalType> table_types_PERSON_p2;
    vector<unique_ptr<Expression>> filter_PERSON_p2;
    unique_ptr<LogicalGet> get_op_PERSON_p2 = move(
            getLogicalGet(*this, table_PERSON, alias_PERSON_p2, table_index_PERSON_p2, table_types_PERSON_p2));
    unique_ptr<TableFilterSet> table_filters_PERSON_p2 = NULL;
    unique_ptr<PhysicalTableScan> scan_PERSON_p2 = make_uniq<PhysicalTableScan>(get_PERSON_p2_types,
                                                                                get_op_PERSON_p2->function,
                                                                                get_op_PERSON_p2->table_index,
                                                                                move(get_op_PERSON_p2->bind_data),
                                                                                table_types_PERSON_p2, PERSON_p2_ids,
                                                                                move(filter_PERSON_p2),
                                                                                vector<column_t>(),
                                                                                get_op_PERSON_p2->names,
                                                                                std::move(table_filters_PERSON_p2),
                                                                                get_op_PERSON_p2->estimated_cardinality,
                                                                                get_op_PERSON_p2->extra_info);


    vector<JoinCondition> cond_KNOWS_;
    JoinCondition join_condition_KNOWS_;
    join_condition_KNOWS_.left = make_uniq<BoundReferenceExpression>("person_rowid", LogicalType::BIGINT, 0);
    join_condition_KNOWS_.right = make_uniq<BoundReferenceExpression>("person_rowid", LogicalType::BIGINT, 0);
    join_condition_KNOWS_.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_KNOWS_ = make_uniq<RAIInfo>();
    rai_info_KNOWS_->rai = table_KNOWS.GetStorage().info->rais[0].get();
    rai_info_KNOWS_->rai_type = RAIType::TARGET_EDGE;
    rai_info_KNOWS_->forward = true;
    rai_info_KNOWS_->vertex = &table_PERSON;
    rai_info_KNOWS_->vertex_id = table_index_PERSON_p2;
    rai_info_KNOWS_->passing_tables[0] = table_index_PERSON_p2;
    rai_info_KNOWS_->left_cardinalities[0] = table_PERSON.GetStorage().info->cardinality;
    // rai_info_KNOWS_->compact_list = &rai_info_KNOWS_->rai->alist->compact__list;

    join_condition_KNOWS_.rais.push_back(move(rai_info_KNOWS_));
    cond_KNOWS_.push_back(move(join_condition_KNOWS_));

    LogicalComparisonJoin join_KNOWS__op(JoinType::INNER);
    vector<LogicalType> output_KNOWS__types{LogicalType::BIGINT, LogicalType::BIGINT};
    join_KNOWS__op.types = output_KNOWS__types;
    vector<idx_t> right_projection_map_KNOWS_{0};
    vector<idx_t> merge_project_map_KNOWS_;
    vector<LogicalType> delim_types_KNOWS_;
    auto join_KNOWS_ = make_uniq<PhysicalMergeSIPJoin>(join_KNOWS__op, move(scan_PERSON_p2), move(scan_PERSON_p1), move(cond_KNOWS_),
                                                       JoinType::INNER, left_projection_map,
                                                       right_projection_map_KNOWS_, merge_project_map_KNOWS_,
                                                       delim_types_KNOWS_, 0);


    idx_t p_post_start = atoll(paras->data()[1].c_str());
    idx_t p_post_end = atoll(paras->data()[2].c_str());
    Value p_post_start_time = Value::BIGINT(p_post_start);
    Value p_post_end_time = Value::BIGINT(p_post_end);
    vector<idx_t> POST_ps_ids{11, COLUMN_IDENTIFIER_ROW_ID, 2};
    vector<LogicalType> get_POST_ps_types{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::BIGINT};
    string alias_POST_ps = "ps";
    vector<LogicalType> table_types_POST_ps;
    vector<unique_ptr<Expression>> filter_POST_ps;
    unique_ptr<LogicalGet> get_op_POST_ps = move(
            getLogicalGet(*this, table_POST, alias_POST_ps, table_index_POST_ps, table_types_POST_ps));
    unique_ptr<TableFilterSet> table_filters_POST_ps = make_uniq<TableFilterSet>();
    unique_ptr<ConjunctionAndFilter> and_filter_post = duckdb::make_uniq<ConjunctionAndFilter>();
    unique_ptr<ConstantFilter> constant_filter_post_start = duckdb::make_uniq<ConstantFilter>(
            ExpressionType::COMPARE_GREATERTHANOREQUALTO, p_post_start_time);
    unique_ptr<ConstantFilter> constant_filter_post_end = duckdb::make_uniq<ConstantFilter>(
            ExpressionType::COMPARE_LESSTHAN, p_post_end_time);
    and_filter_post->child_filters.push_back(move(constant_filter_post_start));
    and_filter_post->child_filters.push_back(move(constant_filter_post_end));
    table_filters_POST_ps->filters[2] = move(and_filter_post);
    unique_ptr<PhysicalTableScan> scan_POST_ps = make_uniq<PhysicalTableScan>(get_POST_ps_types,
                                                                              get_op_POST_ps->function,
                                                                              get_op_POST_ps->table_index,
                                                                              move(get_op_POST_ps->bind_data),
                                                                              table_types_POST_ps, POST_ps_ids,
                                                                              move(filter_POST_ps), vector<column_t>(),
                                                                              get_op_POST_ps->names,
                                                                              std::move(table_filters_POST_ps),
                                                                              get_op_POST_ps->estimated_cardinality,
                                                                              get_op_POST_ps->extra_info);



    vector<JoinCondition> cond_HASCREATOR_;
    JoinCondition join_condition_HASCREATOR_;
    join_condition_HASCREATOR_.left = make_uniq<BoundReferenceExpression>("m_creatorid_rowid", LogicalType::BIGINT, 0);
    join_condition_HASCREATOR_.right = make_uniq<BoundReferenceExpression>("person_rowid", LogicalType::BIGINT, 0);
    join_condition_HASCREATOR_.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_HASCREATOR_ = make_uniq<RAIInfo>();
    rai_info_HASCREATOR_->rai = table_POST.GetStorage().info->rais[0].get();
    rai_info_HASCREATOR_->rai_type = RAIType::EDGE_SOURCE;
    rai_info_HASCREATOR_->forward = true;
    rai_info_HASCREATOR_->vertex = &table_PERSON;
    rai_info_HASCREATOR_->vertex_id = table_index_PERSON_p2;
    rai_info_HASCREATOR_->passing_tables[0] = table_index_POST_ps;
    rai_info_HASCREATOR_->left_cardinalities[0] = table_POST.GetStorage().info->cardinality;
    rai_info_HASCREATOR_->compact_list = &rai_info_HASCREATOR_->rai->alist->compact_forward_list;

    join_condition_HASCREATOR_.rais.push_back(move(rai_info_HASCREATOR_));
    cond_HASCREATOR_.push_back(move(join_condition_HASCREATOR_));

    LogicalComparisonJoin join_HASCREATOR__op(JoinType::INNER);
    vector<LogicalType> output_HASCREATOR__types{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::BIGINT};
    join_HASCREATOR__op.types = output_HASCREATOR__types;
    vector<idx_t> right_projection_map_HASCREATOR_{1};
    vector<idx_t> merge_project_map_HASCREATOR_;
    vector<LogicalType> delim_types_HASCREATOR_;
    auto join_HASCREATOR_ = make_uniq<PhysicalSIPJoin>(join_HASCREATOR__op, move(scan_POST_ps), move(join_KNOWS_), move(cond_HASCREATOR_),
                                                            JoinType::INNER, left_projection_map,
                                                            right_projection_map_HASCREATOR_,
                                                            delim_types_HASCREATOR_, 0);




    vector<idx_t> TAG_t_ids{COLUMN_IDENTIFIER_ROW_ID, 1};
    vector<LogicalType> get_TAG_t_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_TAG_t = "t";
    vector<LogicalType> table_types_TAG_t;
    vector<unique_ptr<Expression>> filter_TAG_t;
    unique_ptr<LogicalGet> get_op_TAG_t = move(
            getLogicalGet(*this, table_TAG, alias_TAG_t, table_index_TAG_t, table_types_TAG_t));
    unique_ptr<TableFilterSet> table_filters_TAG_t = NULL;
    unique_ptr<PhysicalTableScan> scan_TAG_t = make_uniq<PhysicalTableScan>(get_TAG_t_types, get_op_TAG_t->function,
                                                                            get_op_TAG_t->table_index,
                                                                            move(get_op_TAG_t->bind_data),
                                                                            table_types_TAG_t, TAG_t_ids,
                                                                            move(filter_TAG_t), vector<column_t>(),
                                                                            get_op_TAG_t->names,
                                                                            std::move(table_filters_TAG_t),
                                                                            get_op_TAG_t->estimated_cardinality,
                                                                            get_op_TAG_t->extra_info);


    vector<JoinCondition> cond_HASTAG_;
    JoinCondition join_condition_HASTAG_;
    join_condition_HASTAG_.left = make_uniq<BoundReferenceExpression>("tag_rowid", LogicalType::BIGINT, 0);
    join_condition_HASTAG_.right = make_uniq<BoundReferenceExpression>("post_rowid", LogicalType::BIGINT, 1);
    join_condition_HASTAG_.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_HASTAG_ = make_uniq<RAIInfo>();
    rai_info_HASTAG_->rai = table_HASTAG.GetStorage().info->rais[0].get();
    rai_info_HASTAG_->rai_type = RAIType::TARGET_EDGE;
    rai_info_HASTAG_->forward = true;
    rai_info_HASTAG_->vertex = &table_TAG;
    rai_info_HASTAG_->vertex_id = table_index_TAG_t;
    rai_info_HASTAG_->passing_tables[0] = table_index_TAG_t;
    rai_info_HASTAG_->left_cardinalities[0] = table_TAG.GetStorage().info->cardinality;
    // rai_info_HASTAG_->compact_list = &rai_info_HASTAG_->rai->alist->compact__list;

    join_condition_HASTAG_.rais.push_back(move(rai_info_HASTAG_));
    cond_HASTAG_.push_back(move(join_condition_HASTAG_));

    LogicalComparisonJoin join_HASTAG__op(JoinType::INNER);
    vector<LogicalType> output_HASTAG__types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::BIGINT};
    join_HASTAG__op.types = output_HASTAG__types;
    vector<idx_t> right_projection_map_HASTAG_{3};
    vector<idx_t> merge_project_map_HASTAG_;
    vector<LogicalType> delim_types_HASTAG_;
    auto join_HASTAG_ = make_uniq<PhysicalMergeSIPJoin>(join_HASTAG__op, move(scan_TAG_t), move(join_HASCREATOR_), move(cond_HASTAG_),
                                                        JoinType::INNER, left_projection_map,
                                                        right_projection_map_HASTAG_, merge_project_map_HASTAG_,
                                                        delim_types_HASTAG_, 0);


    vector<idx_t> KNOWS_k2_ids{3};
    vector<LogicalType> get_KNOWS_k2_types{LogicalType::BIGINT};
    string alias_KNOWS_k2 = "k2";
    vector<LogicalType> table_types_KNOWS_k2;
    vector<unique_ptr<Expression>> filter_KNOWS_k2;
    unique_ptr<LogicalGet> get_op_KNOWS_k2 = move(
            getLogicalGet(*this, table_KNOWS, alias_KNOWS_k2, table_index_KNOWS_k2, table_types_KNOWS_k2));
    unique_ptr<TableFilterSet> table_filters_KNOWS_k2 = NULL;
    unique_ptr<PhysicalTableScan> scan_KNOWS_k2 = make_uniq<PhysicalTableScan>(get_KNOWS_k2_types,
                                                                                get_op_KNOWS_k2->function,
                                                                                get_op_KNOWS_k2->table_index,
                                                                                move(get_op_KNOWS_k2->bind_data),
                                                                                table_types_KNOWS_k2, KNOWS_k2_ids,
                                                                                move(filter_KNOWS_k2),
                                                                                vector<column_t>(),
                                                                                get_op_KNOWS_k2->names,
                                                                                std::move(table_filters_KNOWS_k2),
                                                                                get_op_KNOWS_k2->estimated_cardinality,
                                                                                get_op_KNOWS_k2->extra_info);


    vector<JoinCondition> cond_KNOWS_k2;
    JoinCondition join_condition_KNOWS_k2;
    join_condition_KNOWS_k2.left = make_uniq<BoundReferenceExpression>("k_person1id_rowid", LogicalType::BIGINT, 0);
    join_condition_KNOWS_k2.right = make_uniq<BoundReferenceExpression>("person_rowid", LogicalType::BIGINT, 2);
    join_condition_KNOWS_k2.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_KNOWS_k2 = make_uniq<RAIInfo>();
    rai_info_KNOWS_k2->rai = table_KNOWS.GetStorage().info->rais[0].get();
    rai_info_KNOWS_k2->rai_type = RAIType::EDGE_SOURCE;
    rai_info_KNOWS_k2->forward = true;
    rai_info_KNOWS_k2->vertex = &table_PERSON;
    rai_info_KNOWS_k2->vertex_id = table_index_PERSON_p1;
    rai_info_KNOWS_k2->passing_tables[0] = table_index_KNOWS_k2;
    rai_info_KNOWS_k2->left_cardinalities[0] = table_KNOWS.GetStorage().info->cardinality;
    rai_info_KNOWS_k2->compact_list = &rai_info_KNOWS_k2->rai->alist->compact_forward_list;

    join_condition_KNOWS_k2.rais.push_back(move(rai_info_KNOWS_k2));
    cond_KNOWS_k2.push_back(move(join_condition_KNOWS_k2));

    LogicalComparisonJoin join_KNOWS_k2_op(JoinType::INNER);
    vector<LogicalType> output_KNOWS_k2_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    join_KNOWS_k2_op.types = output_KNOWS_k2_types;
    vector<idx_t> right_projection_map_KNOWS_k2{1};
    vector<idx_t> merge_project_map_KNOWS_k2;
    vector<LogicalType> delim_types_KNOWS_k2;
    auto join_KNOWS_k2 = make_uniq<PhysicalSIPJoin>(join_KNOWS_k2_op, move(scan_KNOWS_k2), move(join_HASTAG_), move(cond_KNOWS_k2),
                                                       JoinType::INNER, left_projection_map,
                                                       right_projection_map_KNOWS_k2,
                                                       delim_types_KNOWS_k2, 0);


    vector<LogicalType> result_types{LogicalType::VARCHAR};
    vector<unique_ptr<Expression>> select_list;
    auto result_col0 = make_uniq<BoundReferenceExpression>("t_name", LogicalType::VARCHAR, 1);
    select_list.push_back(move(result_col0));
    auto projection = make_uniq<PhysicalProjection>(result_types, move(select_list), 0);
    projection->children.push_back(move(join_KNOWS_k2));

    return projection;
}

unique_ptr<PhysicalOperator> ClientContext::GenerateIC51PlanGLogue() {
    vector<idx_t> left_projection_map, right_projection_map;

    string table_vertex_person = "person";
    string table_vertex_forum = "forum";
    string table_vertex_post = "post";
    string table_edge_knows = "knows";
    string table_edge_forum_person = "forum_person";
    idx_t table_index_person1 = 6;
    idx_t table_index_forum = 10;
    idx_t table_index_person2 = 8;
    idx_t table_index_post = 12;
    idx_t table_index_knows = 7;
    idx_t table_index_forum_person = 13;


    auto table_or_view_person = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                  table_vertex_person, OnEntryNotFound::RETURN_NULL);
    auto &table_person = table_or_view_person->Cast<TableCatalogEntry>();

    auto table_or_view_forum = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                 table_vertex_forum, OnEntryNotFound::RETURN_NULL);
    auto &table_forum = table_or_view_forum->Cast<TableCatalogEntry>();

    auto table_or_view_post = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                table_vertex_post, OnEntryNotFound::RETURN_NULL);
    auto &table_post = table_or_view_post->Cast<TableCatalogEntry>();

    auto table_or_view_knows = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                 table_edge_knows, OnEntryNotFound::RETURN_NULL);
    auto &table_knows = table_or_view_knows->Cast<TableCatalogEntry>();

    auto table_or_view_forum_person = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                        table_edge_forum_person, OnEntryNotFound::RETURN_NULL);
    auto &table_forum_person = table_or_view_forum_person->Cast<TableCatalogEntry>();


    vector<idx_t> person2_ids{COLUMN_IDENTIFIER_ROW_ID};
    vector<LogicalType> get_person2_types{LogicalType::BIGINT};
    string alias_person2 = "p2";
    vector<LogicalType> table_types_person2;
    vector<unique_ptr<Expression>> filter_person2;
    unique_ptr<LogicalGet> get_op_person2 = move(
            getLogicalGet(*this, table_person, alias_person2, table_index_person2, table_types_person2));
    unique_ptr<TableFilterSet> table_filters_person2 = NULL;
    unique_ptr<PhysicalTableScan> scan_person2 = make_uniq<PhysicalTableScan>(get_person2_types,
                                                                              get_op_person2->function,
                                                                              get_op_person2->table_index,
                                                                              move(get_op_person2->bind_data),
                                                                              table_types_person2, person2_ids,
                                                                              move(filter_person2), vector<column_t>(),
                                                                              get_op_person2->names,
                                                                              std::move(table_filters_person2),
                                                                              get_op_person2->estimated_cardinality,
                                                                              get_op_person2->extra_info);

    idx_t p_person_id = atoll(paras->data()[0].c_str()); // 933;
    Value p_person = Value::BIGINT(p_person_id);
    vector<idx_t> person1_ids{0, COLUMN_IDENTIFIER_ROW_ID};
    vector<LogicalType> get_person1_types{LogicalType::BIGINT, LogicalType::BIGINT};
    string alias_person1 = "p1";
    vector<LogicalType> table_types_person1;
    unique_ptr<LogicalGet> get_op_person1 = move(
            getLogicalGet(*this, table_person, alias_person1, table_index_person1, table_types_person1));
    vector<unique_ptr<Expression>> filter_person1;
    unique_ptr<TableFilterSet> table_filters_person1 = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL,
                                                                                   p_person);
    table_filters_person1->filters[0] = move(constant_filter);
    unique_ptr<PhysicalTableScan> scan_person1 = make_uniq<PhysicalTableScan>(get_person1_types,
                                                                              get_op_person1->function,
                                                                              get_op_person1->table_index,
                                                                              move(get_op_person1->bind_data),
                                                                              table_types_person1, person1_ids,
                                                                              move(filter_person1), vector<column_t>(),
                                                                              get_op_person1->names,
                                                                              std::move(table_filters_person1),
                                                                              get_op_person1->estimated_cardinality,
                                                                              get_op_person1->extra_info);

    vector<JoinCondition> cond_knows;
    JoinCondition join_condition_knows;
    join_condition_knows.left = make_uniq<BoundReferenceExpression>("person_rowid", LogicalType::BIGINT, 0);
    join_condition_knows.right = make_uniq<BoundReferenceExpression>("person_rowid", LogicalType::BIGINT, 1);
    join_condition_knows.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_knows = make_uniq<RAIInfo>();
    rai_info_knows->rai = table_knows.GetStorage().info->rais[0].get();
    rai_info_knows->rai_type = RAIType::TARGET_EDGE;
    rai_info_knows->forward = true;
    rai_info_knows->vertex = &table_person;
    rai_info_knows->vertex_id = table_index_person2;
    rai_info_knows->passing_tables[0] = table_index_person2;
    rai_info_knows->left_cardinalities[0] = table_person.GetStorage().info->cardinality;
    // rai_info_knows->compact_list = &rai_info_knows->rai->alist->compact_backward_list;

    join_condition_knows.rais.push_back(move(rai_info_knows));
    cond_knows.push_back(move(join_condition_knows));

    LogicalComparisonJoin join_knows_op(JoinType::INNER);
    vector<LogicalType> output_knows_types{LogicalType::BIGINT, LogicalType::BIGINT};
    join_knows_op.types = output_knows_types;
    vector<idx_t> right_projection_map_knows{1};
    vector<idx_t> merge_project_map;
    vector<LogicalType> delim_types;
    auto join_knows = make_uniq<PhysicalMergeSIPJoin>(join_knows_op, move(scan_person2), move(scan_person1),
                                                      move(cond_knows),
                                                      JoinType::INNER, left_projection_map, right_projection_map_knows,
                                                      merge_project_map, delim_types, 0);

    // join post with person-person
    vector<idx_t> post_ids{11, COLUMN_IDENTIFIER_ROW_ID, 13};
    vector<LogicalType> get_post_types{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::BIGINT};
    string alias_post = "m";
    vector<LogicalType> table_types_post;
    vector<unique_ptr<Expression>> filter_post;
    unique_ptr<LogicalGet> get_op_post = move(
            getLogicalGet(*this, table_post, alias_post, table_index_post, table_types_post));
    unique_ptr<TableFilterSet> table_filters_post = NULL;
    unique_ptr<PhysicalTableScan> scan_post = make_uniq<PhysicalTableScan>(get_post_types, get_op_post->function,
                                                                           get_op_post->table_index,
                                                                           move(get_op_post->bind_data),
                                                                           table_types_post, post_ids,
                                                                           move(filter_post), vector<column_t>(),
                                                                           get_op_post->names,
                                                                           std::move(table_filters_post),
                                                                           get_op_post->estimated_cardinality,
                                                                           get_op_post->extra_info);

    vector<JoinCondition> cond_post;
    JoinCondition join_condition_post;
    join_condition_post.left = make_uniq<BoundReferenceExpression>("m_creatorid_rowid", LogicalType::BIGINT, 0);
    join_condition_post.right = make_uniq<BoundReferenceExpression>("person_rowid", LogicalType::BIGINT, 0);
    join_condition_post.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_post = make_uniq<RAIInfo>();
    rai_info_post->rai = table_post.GetStorage().info->rais[0].get();
    rai_info_post->rai_type = RAIType::EDGE_SOURCE;
    rai_info_post->forward = true;
    rai_info_post->vertex = &table_person;
    rai_info_post->vertex_id = table_index_person2;
    rai_info_post->passing_tables[0] = table_index_post;
    rai_info_post->left_cardinalities[0] = table_post.GetStorage().info->cardinality;
    rai_info_post->compact_list = &rai_info_post->rai->alist->compact_forward_list;

    join_condition_post.rais.push_back(move(rai_info_post));
    cond_post.push_back(move(join_condition_post));

    LogicalComparisonJoin join_post_op(JoinType::INNER);
    vector<LogicalType> output_post_types{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::BIGINT,
                                          LogicalType::BIGINT};
    join_post_op.types = output_post_types;
    vector<idx_t> right_projection_map_post{0};
    vector<idx_t> merge_project_map_post;
    vector<LogicalType> delim_types_post;
    auto join_post = make_uniq<PhysicalSIPJoin>(join_post_op, move(scan_post), move(join_knows), move(cond_post),
                                                JoinType::INNER, left_projection_map, right_projection_map_post,
                                                delim_types_post, 0);

    // join forum with person-person-post
    vector<idx_t> forum_ids{1, COLUMN_IDENTIFIER_ROW_ID};
    vector<LogicalType> get_forum_types{LogicalType::VARCHAR, LogicalType::BIGINT};
    string alias_forum = "f";
    vector<LogicalType> table_types_forum;
    vector<unique_ptr<Expression>> filter_forum;
    unique_ptr<LogicalGet> get_op_forum = move(
            getLogicalGet(*this, table_forum, alias_forum, table_index_forum, table_types_forum));
    unique_ptr<TableFilterSet> table_filters_forum = NULL;
    unique_ptr<PhysicalTableScan> scan_forum = make_uniq<PhysicalTableScan>(get_forum_types, get_op_forum->function,
                                                                            get_op_forum->table_index,
                                                                            move(get_op_forum->bind_data),
                                                                            table_types_forum, forum_ids,
                                                                            move(filter_forum), vector<column_t>(),
                                                                            get_op_forum->names,
                                                                            std::move(table_filters_forum),
                                                                            get_op_forum->estimated_cardinality,
                                                                            get_op_forum->extra_info);

    vector<JoinCondition> cond_forum;
    JoinCondition join_condition_forum;
    join_condition_forum.left = make_uniq<BoundReferenceExpression>("forum_rowid", LogicalType::BIGINT, 1);
    join_condition_forum.right = make_uniq<BoundReferenceExpression>("m_ps_forumid_rowid", LogicalType::BIGINT, 2);
    join_condition_forum.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_forum = make_uniq<RAIInfo>();
    rai_info_forum->rai = table_post.GetStorage().info->rais[2].get();
    rai_info_forum->rai_type = RAIType::TARGET_EDGE;
    rai_info_forum->forward = true;
    rai_info_forum->vertex = &table_forum;
    rai_info_forum->vertex_id = table_index_forum;
    rai_info_forum->passing_tables[0] = table_index_forum;
    rai_info_forum->left_cardinalities[0] = table_forum.GetStorage().info->cardinality;
    // rai_info_forum->compact_list = &rai_info_forum->rai->alist->compact_forward_list;

    join_condition_forum.rais.push_back(move(rai_info_forum));
    cond_forum.push_back(move(join_condition_forum));

    LogicalComparisonJoin join_forum_op(JoinType::INNER);
    vector<LogicalType> output_forum_types{LogicalType::VARCHAR, LogicalType::BIGINT, LogicalType::BIGINT};
    join_forum_op.types = output_forum_types;
    vector<idx_t> right_projection_map_forum{3};
    vector<idx_t> merge_project_map_forum;
    vector<LogicalType> delim_types_forum;
    auto join_forum = make_uniq<PhysicalSIPJoin>(join_forum_op, move(scan_forum), move(join_post), move(cond_forum),
                                                 JoinType::INNER, left_projection_map, right_projection_map_forum,
                                                 delim_types_forum, 0);


    // join person_forum with person-person-post-forum
    idx_t p_forum_person_joindate = atoll(paras->data()[1].c_str());
    Value p_joindate = Value::BIGINT(p_forum_person_joindate);
    vector<idx_t> forum_person_ids{4, 3, 2};
    vector<LogicalType> get_forum_person_types{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::BIGINT};
    string alias_forum_person = "fp";
    vector<LogicalType> table_types_forum_person;
    vector<unique_ptr<Expression>> filter_forum_person;
    unique_ptr<LogicalGet> get_op_forum_person = move(
            getLogicalGet(*this, table_forum_person, alias_forum_person, table_index_forum_person,
                          table_types_forum_person));
    unique_ptr<TableFilterSet> table_filters_forum_person = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_forum_person = duckdb::make_uniq<ConstantFilter>(
            ExpressionType::COMPARE_GREATERTHANOREQUALTO, p_joindate);
    table_filters_forum_person->filters[2] = move(constant_filter_forum_person);
    unique_ptr<PhysicalTableScan> scan_forum_person = make_uniq<PhysicalTableScan>(get_forum_person_types,
                                                                                   get_op_forum_person->function,
                                                                                   get_op_forum_person->table_index,
                                                                                   move(get_op_forum_person->bind_data),
                                                                                   table_types_forum_person,
                                                                                   forum_person_ids,
                                                                                   move(filter_forum_person),
                                                                                   vector<column_t>(),
                                                                                   get_op_forum_person->names,
                                                                                   std::move(
                                                                                           table_filters_forum_person),
                                                                                   get_op_forum_person->estimated_cardinality,
                                                                                   get_op_forum_person->extra_info);

    vector<JoinCondition> cond_forum_person;
    JoinCondition join_condition_forum_person, join_condition_forum_person_2;
    join_condition_forum_person.left = make_uniq<BoundReferenceExpression>("fp_forumid_rowid", LogicalType::BIGINT, 0);
    join_condition_forum_person.right = make_uniq<BoundReferenceExpression>("forum_rowid", LogicalType::BIGINT, 1);
    join_condition_forum_person.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_forum_person = make_uniq<RAIInfo>();
    rai_info_forum_person->rai = table_forum_person.GetStorage().info->rais[0].get();
    rai_info_forum_person->rai_type = RAIType::EDGE_TARGET;
    rai_info_forum_person->forward = false;
    rai_info_forum_person->vertex = &table_forum;
    rai_info_forum_person->vertex_id = table_index_forum;
    rai_info_forum_person->passing_tables[0] = table_index_forum_person;
    rai_info_forum_person->left_cardinalities[0] = table_forum_person.GetStorage().info->cardinality;
    rai_info_forum_person->compact_list = &rai_info_forum_person->rai->alist->compact_backward_list;

    join_condition_forum_person.rais.push_back(move(rai_info_forum_person));

    join_condition_forum_person_2.left = make_uniq<BoundReferenceExpression>("fp_personid_rowid", LogicalType::BIGINT,
                                                                             1);
    join_condition_forum_person_2.right = make_uniq<BoundReferenceExpression>("person_rowid", LogicalType::BIGINT, 2);
    join_condition_forum_person_2.comparison = ExpressionType::COMPARE_EQUAL;

    cond_forum_person.push_back(move(join_condition_forum_person));
    cond_forum_person.push_back(move(join_condition_forum_person_2));

    LogicalComparisonJoin join_forum_person_op(JoinType::INNER);
    vector<LogicalType> output_forum_person_types{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::BIGINT,
                                                  LogicalType::VARCHAR};
    join_forum_person_op.types = output_forum_person_types;
    vector<idx_t> right_projection_map_forum_person{0};
    vector<idx_t> merge_project_map_forum_person;
    vector<LogicalType> delim_types_forum_person;
    auto join_forum_person = make_uniq<PhysicalSIPJoin>(join_forum_person_op, move(scan_forum_person), move(join_forum),
                                                        move(cond_forum_person),
                                                        JoinType::INNER, left_projection_map,
                                                        right_projection_map_forum_person,
                                                        delim_types_forum_person, 0);


    // project
    vector<LogicalType> result_types{LogicalType::VARCHAR};
    vector<unique_ptr<Expression>> select_list;
    auto result_col0 = make_uniq<BoundReferenceExpression>("f_title", LogicalType::VARCHAR, 3);
    select_list.push_back(move(result_col0));
    auto projection = make_uniq<PhysicalProjection>(result_types, move(select_list), 0);
    projection->children.push_back(move(join_forum_person));

    return projection;
}

unique_ptr<PhysicalOperator> ClientContext::GenerateIC51PlanGLogueEI() {
        vector<idx_t> left_projection_map, right_projection_map;

        string table_vertex_person = "person";
        string table_vertex_forum = "forum";
        string table_vertex_post = "post";
        string table_edge_knows = "knows";
        string table_edge_forum_person = "forum_person";
        idx_t table_index_person1 = 6;
        idx_t table_index_forum = 10;
        idx_t table_index_person2 = 8;
        idx_t table_index_post = 12;
        idx_t table_index_knows = 7;
        idx_t table_index_forum_person = 13;


        auto table_or_view_person = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                      table_vertex_person, OnEntryNotFound::RETURN_NULL);
        auto &table_person = table_or_view_person->Cast<TableCatalogEntry>();

        auto table_or_view_forum = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                     table_vertex_forum, OnEntryNotFound::RETURN_NULL);
        auto &table_forum = table_or_view_forum->Cast<TableCatalogEntry>();

        auto table_or_view_post = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                    table_vertex_post, OnEntryNotFound::RETURN_NULL);
        auto &table_post = table_or_view_post->Cast<TableCatalogEntry>();

        auto table_or_view_knows = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                     table_edge_knows, OnEntryNotFound::RETURN_NULL);
        auto &table_knows = table_or_view_knows->Cast<TableCatalogEntry>();

        auto table_or_view_forum_person = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                            table_edge_forum_person, OnEntryNotFound::RETURN_NULL);
        auto &table_forum_person = table_or_view_forum_person->Cast<TableCatalogEntry>();


        vector<idx_t> person2_ids{COLUMN_IDENTIFIER_ROW_ID};
        vector<LogicalType> get_person2_types{LogicalType::BIGINT};
        string alias_person2 = "p2";
        vector<LogicalType> table_types_person2;
        vector<unique_ptr<Expression>> filter_person2;
        unique_ptr<LogicalGet> get_op_person2 = move(
                getLogicalGet(*this, table_person, alias_person2, table_index_person2, table_types_person2));
        unique_ptr<TableFilterSet> table_filters_person2 = NULL;
        unique_ptr<PhysicalTableScan> scan_person2 = make_uniq<PhysicalTableScan>(get_person2_types,
                                                                                  get_op_person2->function,
                                                                                  get_op_person2->table_index,
                                                                                  move(get_op_person2->bind_data),
                                                                                  table_types_person2, person2_ids,
                                                                                  move(filter_person2), vector<column_t>(),
                                                                                  get_op_person2->names,
                                                                                  std::move(table_filters_person2),
                                                                                  get_op_person2->estimated_cardinality,
                                                                                  get_op_person2->extra_info);

        idx_t p_person_id = atoll(paras->data()[0].c_str()); // 933;
        Value p_person = Value::BIGINT(p_person_id);
        vector<idx_t> person1_ids{0, COLUMN_IDENTIFIER_ROW_ID};
        vector<LogicalType> get_person1_types{LogicalType::BIGINT, LogicalType::BIGINT};
        string alias_person1 = "p1";
        vector<LogicalType> table_types_person1;
        unique_ptr<LogicalGet> get_op_person1 = move(
                getLogicalGet(*this, table_person, alias_person1, table_index_person1, table_types_person1));
        vector<unique_ptr<Expression>> filter_person1;
        unique_ptr<TableFilterSet> table_filters_person1 = make_uniq<TableFilterSet>();
        unique_ptr<ConstantFilter> constant_filter = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL,
                                                                                       p_person);
        table_filters_person1->filters[0] = move(constant_filter);
        unique_ptr<PhysicalTableScan> scan_person1 = make_uniq<PhysicalTableScan>(get_person1_types,
                                                                                  get_op_person1->function,
                                                                                  get_op_person1->table_index,
                                                                                  move(get_op_person1->bind_data),
                                                                                  table_types_person1, person1_ids,
                                                                                  move(filter_person1), vector<column_t>(),
                                                                                  get_op_person1->names,
                                                                                  std::move(table_filters_person1),
                                                                                  get_op_person1->estimated_cardinality,
                                                                                  get_op_person1->extra_info);

        vector<JoinCondition> cond_knows;
        JoinCondition join_condition_knows;
        join_condition_knows.left = make_uniq<BoundReferenceExpression>("person_rowid", LogicalType::BIGINT, 0);
        join_condition_knows.right = make_uniq<BoundReferenceExpression>("person_rowid", LogicalType::BIGINT, 1);
        join_condition_knows.comparison = ExpressionType::COMPARE_EQUAL;

        auto rai_info_knows = make_uniq<RAIInfo>();
        rai_info_knows->rai = table_knows.GetStorage().info->rais[0].get();
        rai_info_knows->rai_type = RAIType::TARGET_EDGE;
        rai_info_knows->forward = true;
        rai_info_knows->vertex = &table_person;
        rai_info_knows->vertex_id = table_index_person2;
        rai_info_knows->passing_tables[0] = table_index_person2;
        rai_info_knows->left_cardinalities[0] = table_person.GetStorage().info->cardinality;
        // rai_info_knows->compact_list = &rai_info_knows->rai->alist->compact_backward_list;

        join_condition_knows.rais.push_back(move(rai_info_knows));
        cond_knows.push_back(move(join_condition_knows));

        LogicalComparisonJoin join_knows_op(JoinType::INNER);
        vector<LogicalType> output_knows_types{LogicalType::BIGINT, LogicalType::BIGINT};
        join_knows_op.types = output_knows_types;
        vector<idx_t> right_projection_map_knows{1};
        vector<idx_t> merge_project_map;
        vector<LogicalType> delim_types;
        auto join_knows = make_uniq<PhysicalMergeSIPJoin>(join_knows_op, move(scan_person2), move(scan_person1),
                                                          move(cond_knows),
                                                          JoinType::INNER, left_projection_map, right_projection_map_knows,
                                                          merge_project_map, delim_types, 0);

        // join post with person-person
        vector<idx_t> post_ids{11, COLUMN_IDENTIFIER_ROW_ID, 13};
        vector<LogicalType> get_post_types{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::BIGINT};
        string alias_post = "m";
        vector<LogicalType> table_types_post;
        vector<unique_ptr<Expression>> filter_post;
        unique_ptr<LogicalGet> get_op_post = move(
                getLogicalGet(*this, table_post, alias_post, table_index_post, table_types_post));
        unique_ptr<TableFilterSet> table_filters_post = NULL;
        unique_ptr<PhysicalTableScan> scan_post = make_uniq<PhysicalTableScan>(get_post_types, get_op_post->function,
                                                                               get_op_post->table_index,
                                                                               move(get_op_post->bind_data),
                                                                               table_types_post, post_ids,
                                                                               move(filter_post), vector<column_t>(),
                                                                               get_op_post->names,
                                                                               std::move(table_filters_post),
                                                                               get_op_post->estimated_cardinality,
                                                                               get_op_post->extra_info);

        vector<JoinCondition> cond_post;
        JoinCondition join_condition_post;
        join_condition_post.left = make_uniq<BoundReferenceExpression>("m_creatorid_rowid", LogicalType::BIGINT, 0);
        join_condition_post.right = make_uniq<BoundReferenceExpression>("person_rowid", LogicalType::BIGINT, 0);
        join_condition_post.comparison = ExpressionType::COMPARE_EQUAL;

        auto rai_info_post = make_uniq<RAIInfo>();
        rai_info_post->rai = table_post.GetStorage().info->rais[0].get();
        rai_info_post->rai_type = RAIType::EDGE_SOURCE;
        rai_info_post->forward = true;
        rai_info_post->vertex = &table_person;
        rai_info_post->vertex_id = table_index_person2;
        rai_info_post->passing_tables[0] = table_index_post;
        rai_info_post->left_cardinalities[0] = table_post.GetStorage().info->cardinality;
        rai_info_post->compact_list = &rai_info_post->rai->alist->compact_forward_list;

        join_condition_post.rais.push_back(move(rai_info_post));
        cond_post.push_back(move(join_condition_post));

        LogicalComparisonJoin join_post_op(JoinType::INNER);
        vector<LogicalType> output_post_types{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::BIGINT,
                                              LogicalType::BIGINT};
        join_post_op.types = output_post_types;
        vector<idx_t> right_projection_map_post{0};
        vector<idx_t> merge_project_map_post;
        vector<LogicalType> delim_types_post;
        auto join_post = make_uniq<PhysicalSIPJoin>(join_post_op, move(scan_post), move(join_knows), move(cond_post),
                                                    JoinType::INNER, left_projection_map, right_projection_map_post,
                                                    delim_types_post, 0);

        // join forum with person-person-post
        vector<idx_t> forum_ids{1, COLUMN_IDENTIFIER_ROW_ID};
        vector<LogicalType> get_forum_types{LogicalType::VARCHAR, LogicalType::BIGINT};
        string alias_forum = "f";
        vector<LogicalType> table_types_forum;
        vector<unique_ptr<Expression>> filter_forum;
        unique_ptr<LogicalGet> get_op_forum = move(
                getLogicalGet(*this, table_forum, alias_forum, table_index_forum, table_types_forum));
        unique_ptr<TableFilterSet> table_filters_forum = NULL;
        unique_ptr<PhysicalTableScan> scan_forum = make_uniq<PhysicalTableScan>(get_forum_types, get_op_forum->function,
                                                                                get_op_forum->table_index,
                                                                                move(get_op_forum->bind_data),
                                                                                table_types_forum, forum_ids,
                                                                                move(filter_forum), vector<column_t>(),
                                                                                get_op_forum->names,
                                                                                std::move(table_filters_forum),
                                                                                get_op_forum->estimated_cardinality,
                                                                                get_op_forum->extra_info);

        vector<JoinCondition> cond_forum_merge, cond_forum_pkfk;
        JoinCondition join_condition_forum;
        join_condition_forum.left = make_uniq<BoundReferenceExpression>("forum_rowid", LogicalType::BIGINT, 1);
        join_condition_forum.right = make_uniq<BoundReferenceExpression>("m_ps_forumid_rowid", LogicalType::BIGINT, 2);
        join_condition_forum.comparison = ExpressionType::COMPARE_EQUAL;

        auto rai_info_forum = make_uniq<RAIInfo>();
        rai_info_forum->rai = table_post.GetStorage().info->rais[2].get();
        rai_info_forum->rai_type = RAIType::TARGET_EDGE;
        rai_info_forum->forward = true;
        rai_info_forum->vertex = &table_forum;
        rai_info_forum->vertex_id = table_index_forum;
        rai_info_forum->passing_tables[0] = table_index_forum;
        rai_info_forum->left_cardinalities[0] = table_forum.GetStorage().info->cardinality;
        // rai_info_forum->compact_list = &rai_info_forum->rai->alist->compact_forward_list;

        join_condition_forum.rais.push_back(move(rai_info_forum));
        cond_forum_pkfk.push_back(move(join_condition_forum));

        JoinCondition join_condition_forum_person;
        join_condition_forum_person.left = make_uniq<BoundReferenceExpression>("forum_rowid", LogicalType::BIGINT, 1);
        join_condition_forum_person.right = make_uniq<BoundReferenceExpression>("person_rowid", LogicalType::BIGINT, 3);
        join_condition_forum_person.comparison = ExpressionType::COMPARE_EQUAL;

        auto rai_info_forum_person = make_uniq<RAIInfo>();
        rai_info_forum_person->rai = table_forum_person.GetStorage().info->rais[0].get();
        rai_info_forum_person->rai_type = RAIType::TARGET_EDGE;
        rai_info_forum_person->forward = true;
        rai_info_forum_person->vertex = &table_forum;
        rai_info_forum_person->vertex_id = table_index_forum;
        rai_info_forum_person->passing_tables[0] = table_index_forum;
        rai_info_forum_person->left_cardinalities[0] = table_forum.GetStorage().info->cardinality;
        // rai_info_forum_person->compact_list = &rai_info_forum_person->rai->alist->compact_backward_list;

        join_condition_forum_person.rais.push_back(move(rai_info_forum_person));
        cond_forum_merge.push_back(move(join_condition_forum_person));

        LogicalComparisonJoin join_forum_person_op(JoinType::INNER);
        vector<LogicalType> output_forum_person_types{LogicalType::VARCHAR, LogicalType::BIGINT, LogicalType::BIGINT};
        join_forum_person_op.types = output_forum_person_types;
        vector<idx_t> right_projection_map_forum_person{0};
        vector<idx_t> merge_project_map_forum_person;
        vector<LogicalType> delim_types_forum_person;
        auto join_forum_person = make_uniq<PhysicalExtendIntersect>(join_forum_person_op, move(scan_forum), move(join_post),
                                                            move(cond_forum_merge), move(cond_forum_pkfk),
                                                            JoinType::INNER, left_projection_map,
                                                            right_projection_map_forum_person,
                                                            merge_project_map_forum_person,
                                                            delim_types_forum_person, 0);

        // project
        vector<LogicalType> result_types{LogicalType::VARCHAR};
        vector<unique_ptr<Expression>> select_list;
        auto result_col0 = make_uniq<BoundReferenceExpression>("f_title", LogicalType::VARCHAR, 0);
        select_list.push_back(move(result_col0));
        auto projection = make_uniq<PhysicalProjection>(result_types, move(select_list), 0);
        projection->children.push_back(move(join_forum_person));

        return projection;
    }

unique_ptr<PhysicalOperator> ClientContext::GenerateIC51PlanAnother() {
    vector<idx_t> left_projection_map, right_projection_map;

    string table_vertex_person = "person";
    string table_vertex_forum = "forum";
    string table_vertex_post = "post";
    string table_edge_knows = "knows";
    string table_edge_forum_person = "forum_person";
    idx_t table_index_person1 = 6;
    idx_t table_index_forum = 10;
    idx_t table_index_person2 = 8;
    idx_t table_index_person3 = 9;
    idx_t table_index_post = 12;
    idx_t table_index_knows = 7;
    idx_t table_index_forum_person = 13;


    auto table_or_view_person = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                  table_vertex_person, OnEntryNotFound::RETURN_NULL);
    auto &table_person = table_or_view_person->Cast<TableCatalogEntry>();

    auto table_or_view_forum = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                 table_vertex_forum, OnEntryNotFound::RETURN_NULL);
    auto &table_forum = table_or_view_forum->Cast<TableCatalogEntry>();

    auto table_or_view_post = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                table_vertex_post, OnEntryNotFound::RETURN_NULL);
    auto &table_post = table_or_view_post->Cast<TableCatalogEntry>();

    auto table_or_view_knows = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                 table_edge_knows, OnEntryNotFound::RETURN_NULL);
    auto &table_knows = table_or_view_knows->Cast<TableCatalogEntry>();

    auto table_or_view_forum_person = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                        table_edge_forum_person, OnEntryNotFound::RETURN_NULL);
    auto &table_forum_person = table_or_view_forum_person->Cast<TableCatalogEntry>();


    vector<idx_t> person2_ids{COLUMN_IDENTIFIER_ROW_ID};
    vector<LogicalType> get_person2_types{LogicalType::BIGINT};
    string alias_person2 = "p2";
    vector<LogicalType> table_types_person2;
    vector<unique_ptr<Expression>> filter_person2;
    unique_ptr<LogicalGet> get_op_person2 = move(
            getLogicalGet(*this, table_person, alias_person2, table_index_person2, table_types_person2));
    unique_ptr<TableFilterSet> table_filters_person2 = NULL;
    unique_ptr<PhysicalTableScan> scan_person2 = make_uniq<PhysicalTableScan>(get_person2_types,
                                                                              get_op_person2->function,
                                                                              get_op_person2->table_index,
                                                                              move(get_op_person2->bind_data),
                                                                              table_types_person2, person2_ids,
                                                                              move(filter_person2), vector<column_t>(),
                                                                              get_op_person2->names,
                                                                              std::move(table_filters_person2),
                                                                              get_op_person2->estimated_cardinality,
                                                                              get_op_person2->extra_info);

    idx_t p_person_id = atoll(paras->data()[0].c_str()); // 933;
    Value p_person = Value::BIGINT(p_person_id);
    vector<idx_t> person1_ids{0, COLUMN_IDENTIFIER_ROW_ID};
    vector<LogicalType> get_person1_types{LogicalType::BIGINT, LogicalType::BIGINT};
    string alias_person1 = "p1";
    vector<LogicalType> table_types_person1;
    unique_ptr<LogicalGet> get_op_person1 = move(
            getLogicalGet(*this, table_person, alias_person1, table_index_person1, table_types_person1));
    vector<unique_ptr<Expression>> filter_person1;
    unique_ptr<TableFilterSet> table_filters_person1 = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL,
                                                                                   p_person);
    table_filters_person1->filters[0] = move(constant_filter);
    unique_ptr<PhysicalTableScan> scan_person1 = make_uniq<PhysicalTableScan>(get_person1_types,
                                                                              get_op_person1->function,
                                                                              get_op_person1->table_index,
                                                                              move(get_op_person1->bind_data),
                                                                              table_types_person1, person1_ids,
                                                                              move(filter_person1), vector<column_t>(),
                                                                              get_op_person1->names,
                                                                              std::move(table_filters_person1),
                                                                              get_op_person1->estimated_cardinality,
                                                                              get_op_person1->extra_info);

    vector<JoinCondition> cond_knows;
    JoinCondition join_condition_knows;
    join_condition_knows.left = make_uniq<BoundReferenceExpression>("person_rowid", LogicalType::BIGINT, 0);
    join_condition_knows.right = make_uniq<BoundReferenceExpression>("person_rowid", LogicalType::BIGINT, 1);
    join_condition_knows.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_knows = make_uniq<RAIInfo>();
    rai_info_knows->rai = table_knows.GetStorage().info->rais[0].get();
    rai_info_knows->rai_type = RAIType::TARGET_EDGE;
    rai_info_knows->forward = true;
    rai_info_knows->vertex = &table_person;
    rai_info_knows->vertex_id = table_index_person2;
    rai_info_knows->passing_tables[0] = table_index_person2;
    rai_info_knows->left_cardinalities[0] = table_person.GetStorage().info->cardinality;
    // rai_info_knows->compact_list = &rai_info_knows->rai->alist->compact_backward_list;

    join_condition_knows.rais.push_back(move(rai_info_knows));
    cond_knows.push_back(move(join_condition_knows));

    LogicalComparisonJoin join_knows_op(JoinType::INNER);
    vector<LogicalType> output_knows_types{LogicalType::BIGINT, LogicalType::BIGINT};
    join_knows_op.types = output_knows_types;
    vector<idx_t> right_projection_map_knows{1};
    vector<idx_t> merge_project_map;
    vector<LogicalType> delim_types;
    auto join_knows = make_uniq<PhysicalMergeSIPJoin>(join_knows_op, move(scan_person2), move(scan_person1),
                                                      move(cond_knows),
                                                      JoinType::INNER, left_projection_map, right_projection_map_knows,
                                                      merge_project_map, delim_types, 0);


    // join person_forum with person-person
    idx_t p_forum_person_joindate = atoll(paras->data()[1].c_str());
    Value p_joindate = Value::BIGINT(p_forum_person_joindate);
    vector<idx_t> forum_person_ids{4, 3, 2};
    vector<LogicalType> get_forum_person_types{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::BIGINT};
    string alias_forum_person = "fp";
    vector<LogicalType> table_types_forum_person;
    vector<unique_ptr<Expression>> filter_forum_person;
    unique_ptr<LogicalGet> get_op_forum_person = move(
            getLogicalGet(*this, table_forum_person, alias_forum_person, table_index_forum_person,
                          table_types_forum_person));
    unique_ptr<TableFilterSet> table_filters_forum_person = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_forum_person = duckdb::make_uniq<ConstantFilter>(
            ExpressionType::COMPARE_GREATERTHANOREQUALTO, p_joindate);
    table_filters_forum_person->filters[2] = move(constant_filter_forum_person);
    unique_ptr<PhysicalTableScan> scan_forum_person = make_uniq<PhysicalTableScan>(get_forum_person_types,
                                                                                   get_op_forum_person->function,
                                                                                   get_op_forum_person->table_index,
                                                                                   move(get_op_forum_person->bind_data),
                                                                                   table_types_forum_person,
                                                                                   forum_person_ids,
                                                                                   move(filter_forum_person),
                                                                                   vector<column_t>(),
                                                                                   get_op_forum_person->names,
                                                                                   std::move(
                                                                                           table_filters_forum_person),
                                                                                   get_op_forum_person->estimated_cardinality,
                                                                                   get_op_forum_person->extra_info);

    vector<JoinCondition> cond_forum_person;
    JoinCondition join_condition_forum_person;
    join_condition_forum_person.left = make_uniq<BoundReferenceExpression>("fp_personid_rowid", LogicalType::BIGINT, 1);
    join_condition_forum_person.right = make_uniq<BoundReferenceExpression>("person_rowid", LogicalType::BIGINT, 0);
    join_condition_forum_person.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_forum_person = make_uniq<RAIInfo>();
    rai_info_forum_person->rai = table_forum_person.GetStorage().info->rais[0].get();
    rai_info_forum_person->rai_type = RAIType::EDGE_SOURCE;
    rai_info_forum_person->forward = true;
    rai_info_forum_person->vertex = &table_person;
    rai_info_forum_person->vertex_id = table_index_person3;
    rai_info_forum_person->passing_tables[0] = table_index_forum_person;
    rai_info_forum_person->left_cardinalities[0] = table_forum_person.GetStorage().info->cardinality;
    rai_info_forum_person->compact_list = &rai_info_forum_person->rai->alist->compact_forward_list;

    join_condition_forum_person.rais.push_back(move(rai_info_forum_person));

    cond_forum_person.push_back(move(join_condition_forum_person));

    LogicalComparisonJoin join_forum_person_op(JoinType::INNER);
    vector<LogicalType> output_forum_person_types{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::BIGINT,
                                                  LogicalType::BIGINT};
    join_forum_person_op.types = output_forum_person_types;
    vector<idx_t> right_projection_map_forum_person{0};
    vector<idx_t> merge_project_map_forum_person;
    vector<LogicalType> delim_types_forum_person;
    auto join_forum_person = make_uniq<PhysicalSIPJoin>(join_forum_person_op, move(scan_forum_person),
                                                        move(join_knows),
                                                        move(cond_forum_person),
                                                        JoinType::INNER, left_projection_map,
                                                        right_projection_map_forum_person,
                                                        delim_types_forum_person, 0);

    // join forum with person-person-fp
    vector<idx_t> forum_ids{1, COLUMN_IDENTIFIER_ROW_ID};
    vector<LogicalType> get_forum_types{LogicalType::VARCHAR, LogicalType::BIGINT};
    string alias_forum = "f";
    vector<LogicalType> table_types_forum;
    vector<unique_ptr<Expression>> filter_forum;
    unique_ptr<LogicalGet> get_op_forum = move(
            getLogicalGet(*this, table_forum, alias_forum, table_index_forum, table_types_forum));
    unique_ptr<TableFilterSet> table_filters_forum = NULL;
    unique_ptr<PhysicalTableScan> scan_forum = make_uniq<PhysicalTableScan>(get_forum_types, get_op_forum->function,
                                                                            get_op_forum->table_index,
                                                                            move(get_op_forum->bind_data),
                                                                            table_types_forum, forum_ids,
                                                                            move(filter_forum), vector<column_t>(),
                                                                            get_op_forum->names,
                                                                            std::move(table_filters_forum),
                                                                            get_op_forum->estimated_cardinality,
                                                                            get_op_forum->extra_info);

    vector<JoinCondition> cond_forum;
    JoinCondition join_condition_forum;
    join_condition_forum.left = make_uniq<BoundReferenceExpression>("forum_rowid", LogicalType::BIGINT, 1);
    join_condition_forum.right = make_uniq<BoundReferenceExpression>("fp_forumid_rowid", LogicalType::BIGINT, 0);
    join_condition_forum.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_forum = make_uniq<RAIInfo>();
    rai_info_forum->rai = table_forum_person.GetStorage().info->rais[0].get();
    rai_info_forum->rai_type = RAIType::TARGET_EDGE;
    rai_info_forum->forward = true;
    rai_info_forum->vertex = &table_forum;
    rai_info_forum->vertex_id = table_index_forum;
    rai_info_forum->passing_tables[0] = table_index_forum;
    rai_info_forum->left_cardinalities[0] = table_forum.GetStorage().info->cardinality;
    // rai_info_forum->compact_list = &rai_info_forum->rai->alist->compact_forward_list;

    join_condition_forum.rais.push_back(move(rai_info_forum));
    cond_forum.push_back(move(join_condition_forum));

    LogicalComparisonJoin join_forum_op(JoinType::INNER);
    vector<LogicalType> output_forum_types{LogicalType::VARCHAR, LogicalType::BIGINT, LogicalType::BIGINT};
    join_forum_op.types = output_forum_types;
    vector<idx_t> right_projection_map_forum{3};
    vector<idx_t> merge_project_map_forum;
    vector<LogicalType> delim_types_forum;
    auto join_forum = make_uniq<PhysicalSIPJoin>(join_forum_op, move(scan_forum), move(join_forum_person),
                                                 move(cond_forum),
                                                 JoinType::INNER, left_projection_map, right_projection_map_forum,
                                                 delim_types_forum, 0);

    // join post with person-person-forum
    vector<idx_t> post_ids{11, COLUMN_IDENTIFIER_ROW_ID, 13};
    vector<LogicalType> get_post_types{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::BIGINT};
    string alias_post = "m";
    vector<LogicalType> table_types_post;
    vector<unique_ptr<Expression>> filter_post;
    unique_ptr<LogicalGet> get_op_post = move(
            getLogicalGet(*this, table_post, alias_post, table_index_post, table_types_post));
    unique_ptr<TableFilterSet> table_filters_post = NULL;
    unique_ptr<PhysicalTableScan> scan_post = make_uniq<PhysicalTableScan>(get_post_types, get_op_post->function,
                                                                           get_op_post->table_index,
                                                                           move(get_op_post->bind_data),
                                                                           table_types_post, post_ids,
                                                                           move(filter_post), vector<column_t>(),
                                                                           get_op_post->names,
                                                                           std::move(table_filters_post),
                                                                           get_op_post->estimated_cardinality,
                                                                           get_op_post->extra_info);

    vector<JoinCondition> cond_post;
    JoinCondition join_condition_post, join_condition_post_2;
    join_condition_post.left = make_uniq<BoundReferenceExpression>("m_creatorid_rowid", LogicalType::BIGINT, 0);
    join_condition_post.right = make_uniq<BoundReferenceExpression>("person_rowid", LogicalType::BIGINT, 2);
    join_condition_post.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_post = make_uniq<RAIInfo>();
    rai_info_post->rai = table_post.GetStorage().info->rais[0].get();
    rai_info_post->rai_type = RAIType::EDGE_SOURCE;
    rai_info_post->forward = true;
    rai_info_post->vertex = &table_person;
    rai_info_post->vertex_id = table_index_person3;
    rai_info_post->passing_tables[0] = table_index_post;
    rai_info_post->left_cardinalities[0] = table_post.GetStorage().info->cardinality;
    rai_info_post->compact_list = &rai_info_post->rai->alist->compact_forward_list;

    join_condition_post_2.left = make_uniq<BoundReferenceExpression>("m_ps_forumid_rowid", LogicalType::BIGINT, 2);
    join_condition_post_2.right = make_uniq<BoundReferenceExpression>("forum_rowid", LogicalType::BIGINT, 1);
    join_condition_post_2.comparison = ExpressionType::COMPARE_EQUAL;

    join_condition_post.rais.push_back(move(rai_info_post));
    cond_post.push_back(move(join_condition_post));
    cond_post.push_back(move(join_condition_post_2));

    LogicalComparisonJoin join_post_op(JoinType::INNER);
    vector<LogicalType> output_post_types{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::BIGINT,
                                          LogicalType::VARCHAR};
    join_post_op.types = output_post_types;
    vector<idx_t> right_projection_map_post{0};
    vector<idx_t> merge_project_map_post;
    vector<LogicalType> delim_types_post;
    auto join_post = make_uniq<PhysicalSIPJoin>(join_post_op, move(scan_post), move(join_forum), move(cond_post),
                                                JoinType::INNER, left_projection_map, right_projection_map_post,
                                                delim_types_post, 0);



    // project
    vector<LogicalType> result_types{LogicalType::VARCHAR};
    vector<unique_ptr<Expression>> select_list;
    auto result_col0 = make_uniq<BoundReferenceExpression>("f_title", LogicalType::VARCHAR, 3);
    select_list.push_back(move(result_col0));
    auto projection = make_uniq<PhysicalProjection>(result_types, move(select_list), 0);
    projection->children.push_back(move(join_post));

    return projection;
}

unique_ptr<PhysicalOperator> ClientContext::GenerateIC52PlanGLogue() {
    vector<idx_t> left_projection_map, right_projection_map;

    string table_vertex_person = "person";
    string table_vertex_forum = "forum";
    string table_vertex_post = "post";
    string table_edge_knows = "knows";
    string table_edge_forum_person = "forum_person";
    idx_t table_index_person1 = 6;
    idx_t table_index_forum = 10;
    idx_t table_index_person2 = 8;
    idx_t table_index_person3 = 9;
    idx_t table_index_post = 12;
    idx_t table_index_knows = 7;
    idx_t table_index_forum_person = 13;


    auto table_or_view_person = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                  table_vertex_person, OnEntryNotFound::RETURN_NULL);
    auto &table_person = table_or_view_person->Cast<TableCatalogEntry>();

    auto table_or_view_forum = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                 table_vertex_forum, OnEntryNotFound::RETURN_NULL);
    auto &table_forum = table_or_view_forum->Cast<TableCatalogEntry>();

    auto table_or_view_post = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                table_vertex_post, OnEntryNotFound::RETURN_NULL);
    auto &table_post = table_or_view_post->Cast<TableCatalogEntry>();

    auto table_or_view_knows = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                 table_edge_knows, OnEntryNotFound::RETURN_NULL);
    auto &table_knows = table_or_view_knows->Cast<TableCatalogEntry>();

    auto table_or_view_forum_person = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                        table_edge_forum_person, OnEntryNotFound::RETURN_NULL);
    auto &table_forum_person = table_or_view_forum_person->Cast<TableCatalogEntry>();


    vector<idx_t> person2_ids{COLUMN_IDENTIFIER_ROW_ID};
    vector<LogicalType> get_person2_types{LogicalType::BIGINT};
    string alias_person2 = "p2";
    vector<LogicalType> table_types_person2;
    vector<unique_ptr<Expression>> filter_person2;
    unique_ptr<LogicalGet> get_op_person2 = move(
            getLogicalGet(*this, table_person, alias_person2, table_index_person2, table_types_person2));
    unique_ptr<TableFilterSet> table_filters_person2 = NULL;
    unique_ptr<PhysicalTableScan> scan_person2 = make_uniq<PhysicalTableScan>(get_person2_types,
                                                                              get_op_person2->function,
                                                                              get_op_person2->table_index,
                                                                              move(get_op_person2->bind_data),
                                                                              table_types_person2, person2_ids,
                                                                              move(filter_person2), vector<column_t>(),
                                                                              get_op_person2->names,
                                                                              std::move(table_filters_person2),
                                                                              get_op_person2->estimated_cardinality,
                                                                              get_op_person2->extra_info);

    idx_t p_person_id = atoll(paras->data()[0].c_str()); // 933;
    Value p_person = Value::BIGINT(p_person_id);
    vector<idx_t> person1_ids{0, COLUMN_IDENTIFIER_ROW_ID};
    vector<LogicalType> get_person1_types{LogicalType::BIGINT, LogicalType::BIGINT};
    string alias_person1 = "p1";
    vector<LogicalType> table_types_person1;
    unique_ptr<LogicalGet> get_op_person1 = move(
            getLogicalGet(*this, table_person, alias_person1, table_index_person1, table_types_person1));
    vector<unique_ptr<Expression>> filter_person1;
    unique_ptr<TableFilterSet> table_filters_person1 = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL,
                                                                                   p_person);
    table_filters_person1->filters[0] = move(constant_filter);
    unique_ptr<PhysicalTableScan> scan_person1 = make_uniq<PhysicalTableScan>(get_person1_types,
                                                                              get_op_person1->function,
                                                                              get_op_person1->table_index,
                                                                              move(get_op_person1->bind_data),
                                                                              table_types_person1, person1_ids,
                                                                              move(filter_person1), vector<column_t>(),
                                                                              get_op_person1->names,
                                                                              std::move(table_filters_person1),
                                                                              get_op_person1->estimated_cardinality,
                                                                              get_op_person1->extra_info);

    vector<JoinCondition> cond_knows;
    JoinCondition join_condition_knows;
    join_condition_knows.left = make_uniq<BoundReferenceExpression>("person_rowid", LogicalType::BIGINT, 0);
    join_condition_knows.right = make_uniq<BoundReferenceExpression>("person_rowid", LogicalType::BIGINT, 1);
    join_condition_knows.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_knows = make_uniq<RAIInfo>();
    rai_info_knows->rai = table_knows.GetStorage().info->rais[0].get();
    rai_info_knows->rai_type = RAIType::TARGET_EDGE;
    rai_info_knows->forward = true;
    rai_info_knows->vertex = &table_person;
    rai_info_knows->vertex_id = table_index_person2;
    rai_info_knows->passing_tables[0] = table_index_person2;
    rai_info_knows->left_cardinalities[0] = table_person.GetStorage().info->cardinality;
    // rai_info_knows->compact_list = &rai_info_knows->rai->alist->compact_backward_list;

    join_condition_knows.rais.push_back(move(rai_info_knows));
    cond_knows.push_back(move(join_condition_knows));

    LogicalComparisonJoin join_knows_op(JoinType::INNER);
    vector<LogicalType> output_knows_types{LogicalType::BIGINT, LogicalType::BIGINT};
    join_knows_op.types = output_knows_types;
    vector<idx_t> right_projection_map_knows{1};
    vector<idx_t> merge_project_map;
    vector<LogicalType> delim_types;
    auto join_knows = make_uniq<PhysicalMergeSIPJoin>(join_knows_op, move(scan_person2), move(scan_person1),
                                                      move(cond_knows),
                                                      JoinType::INNER, left_projection_map, right_projection_map_knows,
                                                      merge_project_map, delim_types, 0);

    // join the 2-hop neighbors
    vector<idx_t> person3_ids{COLUMN_IDENTIFIER_ROW_ID};
    vector<LogicalType> get_person3_types{LogicalType::BIGINT};
    string alias_person3 = "p3";
    vector<LogicalType> table_types_person3;
    vector<unique_ptr<Expression>> filter_person3;
    unique_ptr<LogicalGet> get_op_person3 = move(
            getLogicalGet(*this, table_person, alias_person3, table_index_person3, table_types_person3));
    unique_ptr<TableFilterSet> table_filters_person3 = NULL;
    unique_ptr<PhysicalTableScan> scan_person3 = make_uniq<PhysicalTableScan>(get_person3_types,
                                                                              get_op_person3->function,
                                                                              get_op_person3->table_index,
                                                                              move(get_op_person3->bind_data),
                                                                              table_types_person3, person3_ids,
                                                                              move(filter_person3), vector<column_t>(),
                                                                              get_op_person3->names,
                                                                              std::move(table_filters_person3),
                                                                              get_op_person3->estimated_cardinality,
                                                                              get_op_person3->extra_info);

    vector<JoinCondition> cond_knows_2;
    JoinCondition join_condition_knows_2;
    join_condition_knows_2.left = make_uniq<BoundReferenceExpression>("person_rowid", LogicalType::BIGINT, 0);
    join_condition_knows_2.right = make_uniq<BoundReferenceExpression>("person_rowid", LogicalType::BIGINT, 0);
    join_condition_knows_2.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_knows_2 = make_uniq<RAIInfo>();
    rai_info_knows_2->rai = table_knows.GetStorage().info->rais[0].get();
    rai_info_knows_2->rai_type = RAIType::TARGET_EDGE;
    rai_info_knows_2->forward = true;
    rai_info_knows_2->vertex = &table_person;
    rai_info_knows_2->vertex_id = table_index_person3;
    rai_info_knows_2->passing_tables[0] = table_index_person3;
    rai_info_knows_2->left_cardinalities[0] = table_person.GetStorage().info->cardinality;
    // rai_info_knows->compact_list = &rai_info_knows->rai->alist->compact_backward_list;

    join_condition_knows_2.rais.push_back(move(rai_info_knows_2));
    cond_knows_2.push_back(move(join_condition_knows_2));

    LogicalComparisonJoin join_knows_op_2(JoinType::INNER);
    vector<LogicalType> output_knows_types_2{LogicalType::BIGINT, LogicalType::BIGINT};
    join_knows_op_2.types = output_knows_types_2;
    vector<idx_t> right_projection_map_knows_2{0};
    vector<idx_t> merge_project_map_2;
    vector<LogicalType> delim_types_2;
    auto join_knows_2 = make_uniq<PhysicalMergeSIPJoin>(join_knows_op_2, move(scan_person3), move(join_knows),
                                                      move(cond_knows_2),
                                                      JoinType::INNER, left_projection_map, right_projection_map_knows_2,
                                                      merge_project_map_2, delim_types_2, 0);

    // join post with person-person
    vector<idx_t> post_ids{11, COLUMN_IDENTIFIER_ROW_ID, 13};
    vector<LogicalType> get_post_types{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::BIGINT};
    string alias_post = "m";
    vector<LogicalType> table_types_post;
    vector<unique_ptr<Expression>> filter_post;
    unique_ptr<LogicalGet> get_op_post = move(
            getLogicalGet(*this, table_post, alias_post, table_index_post, table_types_post));
    unique_ptr<TableFilterSet> table_filters_post = NULL;
    unique_ptr<PhysicalTableScan> scan_post = make_uniq<PhysicalTableScan>(get_post_types, get_op_post->function,
                                                                           get_op_post->table_index,
                                                                           move(get_op_post->bind_data),
                                                                           table_types_post, post_ids,
                                                                           move(filter_post), vector<column_t>(),
                                                                           get_op_post->names,
                                                                           std::move(table_filters_post),
                                                                           get_op_post->estimated_cardinality,
                                                                           get_op_post->extra_info);

    vector<JoinCondition> cond_post;
    JoinCondition join_condition_post;
    join_condition_post.left = make_uniq<BoundReferenceExpression>("m_creatorid_rowid", LogicalType::BIGINT, 0);
    join_condition_post.right = make_uniq<BoundReferenceExpression>("person_rowid", LogicalType::BIGINT, 0);
    join_condition_post.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_post = make_uniq<RAIInfo>();
    rai_info_post->rai = table_post.GetStorage().info->rais[0].get();
    rai_info_post->rai_type = RAIType::EDGE_SOURCE;
    rai_info_post->forward = true;
    rai_info_post->vertex = &table_person;
    rai_info_post->vertex_id = table_index_person2;
    rai_info_post->passing_tables[0] = table_index_post;
    rai_info_post->left_cardinalities[0] = table_post.GetStorage().info->cardinality;
    rai_info_post->compact_list = &rai_info_post->rai->alist->compact_forward_list;

    join_condition_post.rais.push_back(move(rai_info_post));
    cond_post.push_back(move(join_condition_post));

    LogicalComparisonJoin join_post_op(JoinType::INNER);
    vector<LogicalType> output_post_types{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::BIGINT,
                                          LogicalType::BIGINT};
    join_post_op.types = output_post_types;
    vector<idx_t> right_projection_map_post{0};
    vector<idx_t> merge_project_map_post;
    vector<LogicalType> delim_types_post;
    auto join_post = make_uniq<PhysicalSIPJoin>(join_post_op, move(scan_post), move(join_knows_2), move(cond_post),
                                                JoinType::INNER, left_projection_map, right_projection_map_post,
                                                delim_types_post, 0);

    // join forum with person-person-post
    vector<idx_t> forum_ids{1, COLUMN_IDENTIFIER_ROW_ID};
    vector<LogicalType> get_forum_types{LogicalType::VARCHAR, LogicalType::BIGINT};
    string alias_forum = "f";
    vector<LogicalType> table_types_forum;
    vector<unique_ptr<Expression>> filter_forum;
    unique_ptr<LogicalGet> get_op_forum = move(
            getLogicalGet(*this, table_forum, alias_forum, table_index_forum, table_types_forum));
    unique_ptr<TableFilterSet> table_filters_forum = NULL;
    unique_ptr<PhysicalTableScan> scan_forum = make_uniq<PhysicalTableScan>(get_forum_types, get_op_forum->function,
                                                                            get_op_forum->table_index,
                                                                            move(get_op_forum->bind_data),
                                                                            table_types_forum, forum_ids,
                                                                            move(filter_forum), vector<column_t>(),
                                                                            get_op_forum->names,
                                                                            std::move(table_filters_forum),
                                                                            get_op_forum->estimated_cardinality,
                                                                            get_op_forum->extra_info);

    vector<JoinCondition> cond_forum;
    JoinCondition join_condition_forum;
    join_condition_forum.left = make_uniq<BoundReferenceExpression>("forum_rowid", LogicalType::BIGINT, 1);
    join_condition_forum.right = make_uniq<BoundReferenceExpression>("m_ps_forumid_rowid", LogicalType::BIGINT, 2);
    join_condition_forum.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_forum = make_uniq<RAIInfo>();
    rai_info_forum->rai = table_post.GetStorage().info->rais[2].get();
    rai_info_forum->rai_type = RAIType::TARGET_EDGE;
    rai_info_forum->forward = true;
    rai_info_forum->vertex = &table_forum;
    rai_info_forum->vertex_id = table_index_forum;
    rai_info_forum->passing_tables[0] = table_index_forum;
    rai_info_forum->left_cardinalities[0] = table_forum.GetStorage().info->cardinality;
    // rai_info_forum->compact_list = &rai_info_forum->rai->alist->compact_forward_list;

    join_condition_forum.rais.push_back(move(rai_info_forum));
    cond_forum.push_back(move(join_condition_forum));

    LogicalComparisonJoin join_forum_op(JoinType::INNER);
    vector<LogicalType> output_forum_types{LogicalType::VARCHAR, LogicalType::BIGINT, LogicalType::BIGINT};
    join_forum_op.types = output_forum_types;
    vector<idx_t> right_projection_map_forum{3};
    vector<idx_t> merge_project_map_forum;
    vector<LogicalType> delim_types_forum;
    auto join_forum = make_uniq<PhysicalSIPJoin>(join_forum_op, move(scan_forum), move(join_post), move(cond_forum),
                                                 JoinType::INNER, left_projection_map, right_projection_map_forum,
                                                 delim_types_forum, 0);


    // join person_forum with person-person-post-forum
    idx_t p_forum_person_joindate = atoll(paras->data()[1].c_str());
    Value p_joindate = Value::BIGINT(p_forum_person_joindate);
    vector<idx_t> forum_person_ids{4, 3, 2};
    vector<LogicalType> get_forum_person_types{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::BIGINT};
    string alias_forum_person = "fp";
    vector<LogicalType> table_types_forum_person;
    vector<unique_ptr<Expression>> filter_forum_person;
    unique_ptr<LogicalGet> get_op_forum_person = move(
            getLogicalGet(*this, table_forum_person, alias_forum_person, table_index_forum_person,
                          table_types_forum_person));
    unique_ptr<TableFilterSet> table_filters_forum_person = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_forum_person = duckdb::make_uniq<ConstantFilter>(
            ExpressionType::COMPARE_GREATERTHANOREQUALTO, p_joindate);
    table_filters_forum_person->filters[2] = move(constant_filter_forum_person);
    unique_ptr<PhysicalTableScan> scan_forum_person = make_uniq<PhysicalTableScan>(get_forum_person_types,
                                                                                   get_op_forum_person->function,
                                                                                   get_op_forum_person->table_index,
                                                                                   move(get_op_forum_person->bind_data),
                                                                                   table_types_forum_person,
                                                                                   forum_person_ids,
                                                                                   move(filter_forum_person),
                                                                                   vector<column_t>(),
                                                                                   get_op_forum_person->names,
                                                                                   std::move(
                                                                                           table_filters_forum_person),
                                                                                   get_op_forum_person->estimated_cardinality,
                                                                                   get_op_forum_person->extra_info);

    vector<JoinCondition> cond_forum_person;
    JoinCondition join_condition_forum_person, join_condition_forum_person_2;
    join_condition_forum_person.left = make_uniq<BoundReferenceExpression>("fp_forumid_rowid", LogicalType::BIGINT, 0);
    join_condition_forum_person.right = make_uniq<BoundReferenceExpression>("forum_rowid", LogicalType::BIGINT, 1);
    join_condition_forum_person.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_forum_person = make_uniq<RAIInfo>();
    rai_info_forum_person->rai = table_forum_person.GetStorage().info->rais[0].get();
    rai_info_forum_person->rai_type = RAIType::EDGE_TARGET;
    rai_info_forum_person->forward = false;
    rai_info_forum_person->vertex = &table_forum;
    rai_info_forum_person->vertex_id = table_index_forum;
    rai_info_forum_person->passing_tables[0] = table_index_forum_person;
    rai_info_forum_person->left_cardinalities[0] = table_forum_person.GetStorage().info->cardinality;
    rai_info_forum_person->compact_list = &rai_info_forum_person->rai->alist->compact_backward_list;

    join_condition_forum_person.rais.push_back(move(rai_info_forum_person));

    join_condition_forum_person_2.left = make_uniq<BoundReferenceExpression>("fp_personid_rowid", LogicalType::BIGINT,
                                                                             1);
    join_condition_forum_person_2.right = make_uniq<BoundReferenceExpression>("person_rowid", LogicalType::BIGINT, 2);
    join_condition_forum_person_2.comparison = ExpressionType::COMPARE_EQUAL;

    cond_forum_person.push_back(move(join_condition_forum_person));
    cond_forum_person.push_back(move(join_condition_forum_person_2));

    LogicalComparisonJoin join_forum_person_op(JoinType::INNER);
    vector<LogicalType> output_forum_person_types{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::BIGINT,
                                                  LogicalType::VARCHAR};
    join_forum_person_op.types = output_forum_person_types;
    vector<idx_t> right_projection_map_forum_person{0};
    vector<idx_t> merge_project_map_forum_person;
    vector<LogicalType> delim_types_forum_person;
    auto join_forum_person = make_uniq<PhysicalSIPJoin>(join_forum_person_op, move(scan_forum_person), move(join_forum),
                                                        move(cond_forum_person),
                                                        JoinType::INNER, left_projection_map,
                                                        right_projection_map_forum_person,
                                                        delim_types_forum_person, 0);


    // project
    vector<LogicalType> result_types{LogicalType::VARCHAR};
    vector<unique_ptr<Expression>> select_list;
    auto result_col0 = make_uniq<BoundReferenceExpression>("f_title", LogicalType::VARCHAR, 3);
    select_list.push_back(move(result_col0));
    auto projection = make_uniq<PhysicalProjection>(result_types, move(select_list), 0);
    projection->children.push_back(move(join_forum_person));

    return projection;
}

unique_ptr<PhysicalOperator> ClientContext::GenerateIC52PlanGLogueEI() {
    vector<idx_t> left_projection_map, right_projection_map;

    string table_vertex_person = "person";
    string table_vertex_forum = "forum";
    string table_vertex_post = "post";
    string table_edge_knows = "knows";
    string table_edge_forum_person = "forum_person";
    idx_t table_index_person1 = 6;
    idx_t table_index_forum = 10;
    idx_t table_index_person2 = 8;
    idx_t table_index_person3 = 9;
    idx_t table_index_post = 12;
    idx_t table_index_knows = 7;
    idx_t table_index_forum_person = 13;


    auto table_or_view_person = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                  table_vertex_person, OnEntryNotFound::RETURN_NULL);
    auto &table_person = table_or_view_person->Cast<TableCatalogEntry>();

    auto table_or_view_forum = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                 table_vertex_forum, OnEntryNotFound::RETURN_NULL);
    auto &table_forum = table_or_view_forum->Cast<TableCatalogEntry>();

    auto table_or_view_post = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                table_vertex_post, OnEntryNotFound::RETURN_NULL);
    auto &table_post = table_or_view_post->Cast<TableCatalogEntry>();

    auto table_or_view_knows = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                 table_edge_knows, OnEntryNotFound::RETURN_NULL);
    auto &table_knows = table_or_view_knows->Cast<TableCatalogEntry>();

    auto table_or_view_forum_person = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                        table_edge_forum_person, OnEntryNotFound::RETURN_NULL);
    auto &table_forum_person = table_or_view_forum_person->Cast<TableCatalogEntry>();


    vector<idx_t> person2_ids{COLUMN_IDENTIFIER_ROW_ID};
    vector<LogicalType> get_person2_types{LogicalType::BIGINT};
    string alias_person2 = "p2";
    vector<LogicalType> table_types_person2;
    vector<unique_ptr<Expression>> filter_person2;
    unique_ptr<LogicalGet> get_op_person2 = move(
            getLogicalGet(*this, table_person, alias_person2, table_index_person2, table_types_person2));
    unique_ptr<TableFilterSet> table_filters_person2 = NULL;
    unique_ptr<PhysicalTableScan> scan_person2 = make_uniq<PhysicalTableScan>(get_person2_types,
                                                                              get_op_person2->function,
                                                                              get_op_person2->table_index,
                                                                              move(get_op_person2->bind_data),
                                                                              table_types_person2, person2_ids,
                                                                              move(filter_person2), vector<column_t>(),
                                                                              get_op_person2->names,
                                                                              std::move(table_filters_person2),
                                                                              get_op_person2->estimated_cardinality,
                                                                              get_op_person2->extra_info);

    idx_t p_person_id = atoll(paras->data()[0].c_str()); // 933;
    Value p_person = Value::BIGINT(p_person_id);
    vector<idx_t> person1_ids{0, COLUMN_IDENTIFIER_ROW_ID};
    vector<LogicalType> get_person1_types{LogicalType::BIGINT, LogicalType::BIGINT};
    string alias_person1 = "p1";
    vector<LogicalType> table_types_person1;
    unique_ptr<LogicalGet> get_op_person1 = move(
            getLogicalGet(*this, table_person, alias_person1, table_index_person1, table_types_person1));
    vector<unique_ptr<Expression>> filter_person1;
    unique_ptr<TableFilterSet> table_filters_person1 = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL,
                                                                                   p_person);
    table_filters_person1->filters[0] = move(constant_filter);
    unique_ptr<PhysicalTableScan> scan_person1 = make_uniq<PhysicalTableScan>(get_person1_types,
                                                                              get_op_person1->function,
                                                                              get_op_person1->table_index,
                                                                              move(get_op_person1->bind_data),
                                                                              table_types_person1, person1_ids,
                                                                              move(filter_person1), vector<column_t>(),
                                                                              get_op_person1->names,
                                                                              std::move(table_filters_person1),
                                                                              get_op_person1->estimated_cardinality,
                                                                              get_op_person1->extra_info);

    vector<JoinCondition> cond_knows;
    JoinCondition join_condition_knows;
    join_condition_knows.left = make_uniq<BoundReferenceExpression>("person_rowid", LogicalType::BIGINT, 0);
    join_condition_knows.right = make_uniq<BoundReferenceExpression>("person_rowid", LogicalType::BIGINT, 1);
    join_condition_knows.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_knows = make_uniq<RAIInfo>();
    rai_info_knows->rai = table_knows.GetStorage().info->rais[0].get();
    rai_info_knows->rai_type = RAIType::TARGET_EDGE;
    rai_info_knows->forward = true;
    rai_info_knows->vertex = &table_person;
    rai_info_knows->vertex_id = table_index_person2;
    rai_info_knows->passing_tables[0] = table_index_person2;
    rai_info_knows->left_cardinalities[0] = table_person.GetStorage().info->cardinality;
    // rai_info_knows->compact_list = &rai_info_knows->rai->alist->compact_backward_list;

    join_condition_knows.rais.push_back(move(rai_info_knows));
    cond_knows.push_back(move(join_condition_knows));

    LogicalComparisonJoin join_knows_op(JoinType::INNER);
    vector<LogicalType> output_knows_types{LogicalType::BIGINT, LogicalType::BIGINT};
    join_knows_op.types = output_knows_types;
    vector<idx_t> right_projection_map_knows{1};
    vector<idx_t> merge_project_map;
    vector<LogicalType> delim_types;
    auto join_knows = make_uniq<PhysicalMergeSIPJoin>(join_knows_op, move(scan_person2), move(scan_person1),
                                                      move(cond_knows),
                                                      JoinType::INNER, left_projection_map, right_projection_map_knows,
                                                      merge_project_map, delim_types, 0);

    // join the 2-hop neighbors
    vector<idx_t> person3_ids{COLUMN_IDENTIFIER_ROW_ID};
    vector<LogicalType> get_person3_types{LogicalType::BIGINT};
    string alias_person3 = "p3";
    vector<LogicalType> table_types_person3;
    vector<unique_ptr<Expression>> filter_person3;
    unique_ptr<LogicalGet> get_op_person3 = move(
            getLogicalGet(*this, table_person, alias_person3, table_index_person3, table_types_person3));
    unique_ptr<TableFilterSet> table_filters_person3 = NULL;
    unique_ptr<PhysicalTableScan> scan_person3 = make_uniq<PhysicalTableScan>(get_person3_types,
                                                                              get_op_person3->function,
                                                                              get_op_person3->table_index,
                                                                              move(get_op_person3->bind_data),
                                                                              table_types_person3, person3_ids,
                                                                              move(filter_person3), vector<column_t>(),
                                                                              get_op_person3->names,
                                                                              std::move(table_filters_person3),
                                                                              get_op_person3->estimated_cardinality,
                                                                              get_op_person3->extra_info);

    vector<JoinCondition> cond_knows_2;
    JoinCondition join_condition_knows_2;
    join_condition_knows_2.left = make_uniq<BoundReferenceExpression>("person_rowid", LogicalType::BIGINT, 0);
    join_condition_knows_2.right = make_uniq<BoundReferenceExpression>("person_rowid", LogicalType::BIGINT, 0);
    join_condition_knows_2.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_knows_2 = make_uniq<RAIInfo>();
    rai_info_knows_2->rai = table_knows.GetStorage().info->rais[0].get();
    rai_info_knows_2->rai_type = RAIType::TARGET_EDGE;
    rai_info_knows_2->forward = true;
    rai_info_knows_2->vertex = &table_person;
    rai_info_knows_2->vertex_id = table_index_person3;
    rai_info_knows_2->passing_tables[0] = table_index_person3;
    rai_info_knows_2->left_cardinalities[0] = table_person.GetStorage().info->cardinality;
    // rai_info_knows->compact_list = &rai_info_knows->rai->alist->compact_backward_list;

    join_condition_knows_2.rais.push_back(move(rai_info_knows_2));
    cond_knows_2.push_back(move(join_condition_knows_2));

    LogicalComparisonJoin join_knows_op_2(JoinType::INNER);
    vector<LogicalType> output_knows_types_2{LogicalType::BIGINT, LogicalType::BIGINT};
    join_knows_op_2.types = output_knows_types_2;
    vector<idx_t> right_projection_map_knows_2{0};
    vector<idx_t> merge_project_map_2;
    vector<LogicalType> delim_types_2;
    auto join_knows_2 = make_uniq<PhysicalMergeSIPJoin>(join_knows_op_2, move(scan_person3), move(join_knows),
                                                        move(cond_knows_2),
                                                        JoinType::INNER, left_projection_map,
                                                        right_projection_map_knows_2,
                                                        merge_project_map_2, delim_types_2, 0);

    // join post with person-person
    vector<idx_t> post_ids{11, COLUMN_IDENTIFIER_ROW_ID, 13};
    vector<LogicalType> get_post_types{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::BIGINT};
    string alias_post = "m";
    vector<LogicalType> table_types_post;
    vector<unique_ptr<Expression>> filter_post;
    unique_ptr<LogicalGet> get_op_post = move(
            getLogicalGet(*this, table_post, alias_post, table_index_post, table_types_post));
    unique_ptr<TableFilterSet> table_filters_post = NULL;
    unique_ptr<PhysicalTableScan> scan_post = make_uniq<PhysicalTableScan>(get_post_types, get_op_post->function,
                                                                           get_op_post->table_index,
                                                                           move(get_op_post->bind_data),
                                                                           table_types_post, post_ids,
                                                                           move(filter_post), vector<column_t>(),
                                                                           get_op_post->names,
                                                                           std::move(table_filters_post),
                                                                           get_op_post->estimated_cardinality,
                                                                           get_op_post->extra_info);

    vector<JoinCondition> cond_post;
    JoinCondition join_condition_post;
    join_condition_post.left = make_uniq<BoundReferenceExpression>("m_creatorid_rowid", LogicalType::BIGINT, 0);
    join_condition_post.right = make_uniq<BoundReferenceExpression>("person_rowid", LogicalType::BIGINT, 0);
    join_condition_post.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_post = make_uniq<RAIInfo>();
    rai_info_post->rai = table_post.GetStorage().info->rais[0].get();
    rai_info_post->rai_type = RAIType::EDGE_SOURCE;
    rai_info_post->forward = true;
    rai_info_post->vertex = &table_person;
    rai_info_post->vertex_id = table_index_person2;
    rai_info_post->passing_tables[0] = table_index_post;
    rai_info_post->left_cardinalities[0] = table_post.GetStorage().info->cardinality;
    rai_info_post->compact_list = &rai_info_post->rai->alist->compact_forward_list;

    join_condition_post.rais.push_back(move(rai_info_post));
    cond_post.push_back(move(join_condition_post));

    LogicalComparisonJoin join_post_op(JoinType::INNER);
    vector<LogicalType> output_post_types{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::BIGINT,
                                          LogicalType::BIGINT};
    join_post_op.types = output_post_types;
    vector<idx_t> right_projection_map_post{0};
    vector<idx_t> merge_project_map_post;
    vector<LogicalType> delim_types_post;
    auto join_post = make_uniq<PhysicalSIPJoin>(join_post_op, move(scan_post), move(join_knows_2), move(cond_post),
                                                JoinType::INNER, left_projection_map, right_projection_map_post,
                                                delim_types_post, 0);

    // join forum with person-person-post
    vector<idx_t> forum_ids{1, COLUMN_IDENTIFIER_ROW_ID};
    vector<LogicalType> get_forum_types{LogicalType::VARCHAR, LogicalType::BIGINT};
    string alias_forum = "f";
    vector<LogicalType> table_types_forum;
    vector<unique_ptr<Expression>> filter_forum;
    unique_ptr<LogicalGet> get_op_forum = move(
            getLogicalGet(*this, table_forum, alias_forum, table_index_forum, table_types_forum));
    unique_ptr<TableFilterSet> table_filters_forum = NULL;
    unique_ptr<PhysicalTableScan> scan_forum = make_uniq<PhysicalTableScan>(get_forum_types, get_op_forum->function,
                                                                            get_op_forum->table_index,
                                                                            move(get_op_forum->bind_data),
                                                                            table_types_forum, forum_ids,
                                                                            move(filter_forum), vector<column_t>(),
                                                                            get_op_forum->names,
                                                                            std::move(table_filters_forum),
                                                                            get_op_forum->estimated_cardinality,
                                                                            get_op_forum->extra_info);

    vector<JoinCondition> cond_forum_merge, cond_forum_pkfk;
    JoinCondition join_condition_forum;
    join_condition_forum.left = make_uniq<BoundReferenceExpression>("forum_rowid", LogicalType::BIGINT, 1);
    join_condition_forum.right = make_uniq<BoundReferenceExpression>("m_ps_forumid_rowid", LogicalType::BIGINT, 2);
    join_condition_forum.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_forum = make_uniq<RAIInfo>();
    rai_info_forum->rai = table_post.GetStorage().info->rais[2].get();
    rai_info_forum->rai_type = RAIType::TARGET_EDGE;
    rai_info_forum->forward = true;
    rai_info_forum->vertex = &table_forum;
    rai_info_forum->vertex_id = table_index_forum;
    rai_info_forum->passing_tables[0] = table_index_forum;
    rai_info_forum->left_cardinalities[0] = table_forum.GetStorage().info->cardinality;
    // rai_info_forum->compact_list = &rai_info_forum->rai->alist->compact_forward_list;

    join_condition_forum.rais.push_back(move(rai_info_forum));
    cond_forum_pkfk.push_back(move(join_condition_forum));

    JoinCondition join_condition_forum_person;
    join_condition_forum_person.left = make_uniq<BoundReferenceExpression>("forum_rowid", LogicalType::BIGINT, 1);
    join_condition_forum_person.right = make_uniq<BoundReferenceExpression>("person_rowid", LogicalType::BIGINT, 3);
    join_condition_forum_person.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_forum_person = make_uniq<RAIInfo>();
    rai_info_forum_person->rai = table_forum_person.GetStorage().info->rais[0].get();
    rai_info_forum_person->rai_type = RAIType::TARGET_EDGE;
    rai_info_forum_person->forward = true;
    rai_info_forum_person->vertex = &table_forum;
    rai_info_forum_person->vertex_id = table_index_forum;
    rai_info_forum_person->passing_tables[0] = table_index_forum;
    rai_info_forum_person->left_cardinalities[0] = table_forum.GetStorage().info->cardinality;
    // rai_info_forum_person->compact_list = &rai_info_forum_person->rai->alist->compact_backward_list;

    join_condition_forum_person.rais.push_back(move(rai_info_forum_person));
    cond_forum_merge.push_back(move(join_condition_forum_person));

    LogicalComparisonJoin join_forum_person_op(JoinType::INNER);
    vector<LogicalType> output_forum_person_types{LogicalType::VARCHAR, LogicalType::BIGINT, LogicalType::BIGINT};
    join_forum_person_op.types = output_forum_person_types;
    vector<idx_t> right_projection_map_forum_person{0};
    vector<idx_t> merge_project_map_forum_person;
    vector<LogicalType> delim_types_forum_person;
    auto join_forum_person = make_uniq<PhysicalExtendIntersect>(join_forum_person_op, move(scan_forum), move(join_post),
                                                                move(cond_forum_merge), move(cond_forum_pkfk),
                                                                JoinType::INNER, left_projection_map,
                                                                right_projection_map_forum_person,
                                                                merge_project_map_forum_person,
                                                                delim_types_forum_person, 0);


    // project
    vector<LogicalType> result_types{LogicalType::VARCHAR};
    vector<unique_ptr<Expression>> select_list;
    auto result_col0 = make_uniq<BoundReferenceExpression>("f_title", LogicalType::VARCHAR, 0);
    select_list.push_back(move(result_col0));
    auto projection = make_uniq<PhysicalProjection>(result_types, move(select_list), 0);
    projection->children.push_back(move(join_forum_person));

    return projection;
}

unique_ptr<PhysicalOperator> ClientContext::GenerateIC52PlanSelf() {
    vector<idx_t> left_projection_map, right_projection_map;

    string table_vertex_person = "person";
    string table_vertex_forum = "forum";
    string table_vertex_post = "post";
    string table_edge_knows = "knows";
    string table_edge_forum_person = "forum_person";
    idx_t table_index_person1 = 6;
    idx_t table_index_forum = 10;
    idx_t table_index_person2 = 8;
    idx_t table_index_person3 = 9;
    idx_t table_index_post = 12;
    idx_t table_index_knows = 7;
    idx_t table_index_knows2 = 14;
    idx_t table_index_forum_person = 13;


    auto table_or_view_person = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                  table_vertex_person, OnEntryNotFound::RETURN_NULL);
    auto &table_person = table_or_view_person->Cast<TableCatalogEntry>();

    auto table_or_view_forum = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                 table_vertex_forum, OnEntryNotFound::RETURN_NULL);
    auto &table_forum = table_or_view_forum->Cast<TableCatalogEntry>();

    auto table_or_view_post = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                table_vertex_post, OnEntryNotFound::RETURN_NULL);
    auto &table_post = table_or_view_post->Cast<TableCatalogEntry>();

    auto table_or_view_knows = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                 table_edge_knows, OnEntryNotFound::RETURN_NULL);
    auto &table_knows = table_or_view_knows->Cast<TableCatalogEntry>();

    auto table_or_view_forum_person = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                        table_edge_forum_person, OnEntryNotFound::RETURN_NULL);
    auto &table_forum_person = table_or_view_forum_person->Cast<TableCatalogEntry>();


    vector<idx_t> knows_ids{3, 4};
    vector<LogicalType> get_knows_types{LogicalType::BIGINT, LogicalType::BIGINT};
    string alias_knows = "k1";
    vector<LogicalType> table_types_knows;
    vector<unique_ptr<Expression>> filter_knows;
    unique_ptr<LogicalGet> get_op_knows = move(
            getLogicalGet(*this, table_knows, alias_knows, table_index_knows, table_types_knows));
    unique_ptr<TableFilterSet> table_filters_knows = NULL;
    unique_ptr<PhysicalTableScan> scan_knows = make_uniq<PhysicalTableScan>(get_knows_types,
                                                                              get_op_knows->function,
                                                                              get_op_knows->table_index,
                                                                              move(get_op_knows->bind_data),
                                                                              table_types_knows, knows_ids,
                                                                              move(filter_knows), vector<column_t>(),
                                                                              get_op_knows->names,
                                                                              std::move(table_filters_knows),
                                                                              get_op_knows->estimated_cardinality,
                                                                              get_op_knows->extra_info);

    idx_t p_person_id = atoll(paras->data()[0].c_str()); // 933;
    Value p_person = Value::BIGINT(p_person_id);
    vector<idx_t> person1_ids{0, COLUMN_IDENTIFIER_ROW_ID};
    vector<LogicalType> get_person1_types{LogicalType::BIGINT, LogicalType::BIGINT};
    string alias_person1 = "p1";
    vector<LogicalType> table_types_person1;
    unique_ptr<LogicalGet> get_op_person1 = move(
            getLogicalGet(*this, table_person, alias_person1, table_index_person1, table_types_person1));
    vector<unique_ptr<Expression>> filter_person1;
    unique_ptr<TableFilterSet> table_filters_person1 = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL,
                                                                                   p_person);
    table_filters_person1->filters[0] = move(constant_filter);
    unique_ptr<PhysicalTableScan> scan_person1 = make_uniq<PhysicalTableScan>(get_person1_types,
                                                                              get_op_person1->function,
                                                                              get_op_person1->table_index,
                                                                              move(get_op_person1->bind_data),
                                                                              table_types_person1, person1_ids,
                                                                              move(filter_person1), vector<column_t>(),
                                                                              get_op_person1->names,
                                                                              std::move(table_filters_person1),
                                                                              get_op_person1->estimated_cardinality,
                                                                              get_op_person1->extra_info);

    vector<JoinCondition> cond_knows;
    JoinCondition join_condition_knows;
    join_condition_knows.left = make_uniq<BoundReferenceExpression>("k_person1id_rowid", LogicalType::BIGINT, 0);
    join_condition_knows.right = make_uniq<BoundReferenceExpression>("person_rowid", LogicalType::BIGINT, 1);
    join_condition_knows.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_knows = make_uniq<RAIInfo>();
    rai_info_knows->rai = table_knows.GetStorage().info->rais[0].get();
    rai_info_knows->rai_type = RAIType::EDGE_SOURCE;
    rai_info_knows->forward = true;
    rai_info_knows->vertex = &table_person;
    rai_info_knows->vertex_id = table_index_person1;
    rai_info_knows->passing_tables[0] = table_index_person1;
    rai_info_knows->left_cardinalities[0] = table_person.GetStorage().info->cardinality;
    rai_info_knows->compact_list = &rai_info_knows->rai->alist->compact_forward_list;

    join_condition_knows.rais.push_back(move(rai_info_knows));
    cond_knows.push_back(move(join_condition_knows));

    LogicalComparisonJoin join_knows_op(JoinType::INNER);
    vector<LogicalType> output_knows_types{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::BIGINT};
    join_knows_op.types = output_knows_types;
    vector<idx_t> right_projection_map_knows{1};
    vector<idx_t> merge_project_map;
    vector<LogicalType> delim_types;
    auto join_knows = make_uniq<PhysicalSIPJoin>(join_knows_op, move(scan_knows), move(scan_person1),
                                                      move(cond_knows),
                                                      JoinType::INNER, left_projection_map, right_projection_map_knows,
                                                      delim_types, 0);

    // join the two knows
    vector<idx_t> knows2_ids{3, 4};
    vector<LogicalType> get_knows2_types{LogicalType::BIGINT, LogicalType::BIGINT};
    string alias_knows2 = "k2";
    vector<LogicalType> table_types_knows2;
    vector<unique_ptr<Expression>> filter_knows2;
    unique_ptr<LogicalGet> get_op_knows2 = move(
            getLogicalGet(*this, table_knows, alias_knows2, table_index_knows2, table_types_knows2));
    unique_ptr<TableFilterSet> table_filters_knows2 = NULL;
    unique_ptr<PhysicalTableScan> scan_knows2 = make_uniq<PhysicalTableScan>(get_knows2_types,
                                                                              get_op_knows2->function,
                                                                              get_op_knows2->table_index,
                                                                              move(get_op_knows2->bind_data),
                                                                              table_types_knows2, knows2_ids,
                                                                              move(filter_knows2), vector<column_t>(),
                                                                              get_op_knows2->names,
                                                                              std::move(table_filters_knows2),
                                                                              get_op_knows2->estimated_cardinality,
                                                                              get_op_knows2->extra_info);

    vector<JoinCondition> cond_knows_2;
    JoinCondition join_condition_knows_2;
    join_condition_knows_2.left = make_uniq<BoundReferenceExpression>("k_person1id_rowid", LogicalType::BIGINT, 0);
    join_condition_knows_2.right = make_uniq<BoundReferenceExpression>("k_person2id_rowid", LogicalType::BIGINT, 1);
    join_condition_knows_2.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_knows_2 = make_uniq<RAIInfo>();
    rai_info_knows_2->rai = table_knows.GetStorage().info->rais[0].get();
    rai_info_knows_2->rai_type = RAIType::SELF;
    rai_info_knows_2->forward = true;
    rai_info_knows_2->vertex = &table_person;
    rai_info_knows_2->vertex_id = table_index_knows2;
    rai_info_knows_2->passing_tables[0] = table_index_knows2;
    rai_info_knows_2->left_cardinalities[0] = table_knows.GetStorage().info->cardinality;
    rai_info_knows_2->compact_list = &rai_info_knows_2->rai->alist->compact_forward_list;

    join_condition_knows_2.rais.push_back(move(rai_info_knows_2));
    cond_knows_2.push_back(move(join_condition_knows_2));

    LogicalComparisonJoin join_knows_op_2(JoinType::INNER);
    vector<LogicalType> output_knows_types_2{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::BIGINT};
    join_knows_op_2.types = output_knows_types_2;
    vector<idx_t> right_projection_map_knows_2{0};
    vector<idx_t> merge_project_map_2;
    vector<LogicalType> delim_types_2;
    auto join_knows_2 = make_uniq<PhysicalSIPJoin>(join_knows_op_2, move(scan_knows2), move(join_knows),
                                                        move(cond_knows_2),
                                                        JoinType::INNER, left_projection_map,
                                                        right_projection_map_knows_2,
                                                        delim_types_2, 0);


    vector<idx_t> person2_ids{COLUMN_IDENTIFIER_ROW_ID};
    vector<LogicalType> get_person2_types{LogicalType::BIGINT};
    string alias_person2 = "p2";
    vector<LogicalType> table_types_person2;
    unique_ptr<LogicalGet> get_op_person2 = move(
            getLogicalGet(*this, table_person, alias_person2, table_index_person2, table_types_person2));
    vector<unique_ptr<Expression>> filter_person2;
    unique_ptr<TableFilterSet> table_filters_person2 = NULL;
    unique_ptr<PhysicalTableScan> scan_person2 = make_uniq<PhysicalTableScan>(get_person2_types,
                                                                              get_op_person2->function,
                                                                              get_op_person2->table_index,
                                                                              move(get_op_person2->bind_data),
                                                                              table_types_person2, person2_ids,
                                                                              move(filter_person2), vector<column_t>(),
                                                                              get_op_person2->names,
                                                                              std::move(table_filters_person2),
                                                                              get_op_person2->estimated_cardinality,
                                                                              get_op_person2->extra_info);

    vector<JoinCondition> cond_knows_3;
    JoinCondition join_condition_knows_3;
    join_condition_knows_3.left = make_uniq<BoundReferenceExpression>("person_rowid", LogicalType::BIGINT, 0);
    join_condition_knows_3.right = make_uniq<BoundReferenceExpression>("k_person2id_rowid", LogicalType::BIGINT, 1);
    join_condition_knows_3.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_knows_3 = make_uniq<RAIInfo>();
    rai_info_knows_3->rai = table_knows.GetStorage().info->rais[0].get();
    rai_info_knows_3->rai_type = RAIType::TARGET_EDGE;
    rai_info_knows_3->forward = true;
    rai_info_knows_3->vertex = &table_person;
    rai_info_knows_3->vertex_id = table_index_person2;
    rai_info_knows_3->passing_tables[0] = table_index_person2;
    rai_info_knows_3->left_cardinalities[0] = table_person.GetStorage().info->cardinality;
    // rai_info_knows->compact_list = &rai_info_knows->rai->alist->compact_backward_list;

    join_condition_knows_3.rais.push_back(move(rai_info_knows_3));
    cond_knows_3.push_back(move(join_condition_knows_3));

    LogicalComparisonJoin join_knows_op_3(JoinType::INNER);
    vector<LogicalType> output_knows_types_3{LogicalType::BIGINT, LogicalType::BIGINT};
    join_knows_op_3.types = output_knows_types_3;
    vector<idx_t> right_projection_map_knows_3{0};
    vector<idx_t> merge_project_map_3;
    vector<LogicalType> delim_types_3;
    auto join_knows_3 = make_uniq<PhysicalSIPJoin>(join_knows_op_3, move(scan_person2), move(join_knows_2),
                                                        move(cond_knows_3),
                                                        JoinType::INNER, left_projection_map,
                                                        right_projection_map_knows_3,
                                                        delim_types_3, 0);

    // join post with person-person
    vector<idx_t> post_ids{11, COLUMN_IDENTIFIER_ROW_ID, 13};
    vector<LogicalType> get_post_types{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::BIGINT};
    string alias_post = "m";
    vector<LogicalType> table_types_post;
    vector<unique_ptr<Expression>> filter_post;
    unique_ptr<LogicalGet> get_op_post = move(
            getLogicalGet(*this, table_post, alias_post, table_index_post, table_types_post));
    unique_ptr<TableFilterSet> table_filters_post = NULL;
    unique_ptr<PhysicalTableScan> scan_post = make_uniq<PhysicalTableScan>(get_post_types, get_op_post->function,
                                                                           get_op_post->table_index,
                                                                           move(get_op_post->bind_data),
                                                                           table_types_post, post_ids,
                                                                           move(filter_post), vector<column_t>(),
                                                                           get_op_post->names,
                                                                           std::move(table_filters_post),
                                                                           get_op_post->estimated_cardinality,
                                                                           get_op_post->extra_info);

    vector<JoinCondition> cond_post;
    JoinCondition join_condition_post;
    join_condition_post.left = make_uniq<BoundReferenceExpression>("m_creatorid_rowid", LogicalType::BIGINT, 0);
    join_condition_post.right = make_uniq<BoundReferenceExpression>("person_rowid", LogicalType::BIGINT, 0);
    join_condition_post.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_post = make_uniq<RAIInfo>();
    rai_info_post->rai = table_post.GetStorage().info->rais[0].get();
    rai_info_post->rai_type = RAIType::EDGE_SOURCE;
    rai_info_post->forward = true;
    rai_info_post->vertex = &table_person;
    rai_info_post->vertex_id = table_index_person2;
    rai_info_post->passing_tables[0] = table_index_post;
    rai_info_post->left_cardinalities[0] = table_post.GetStorage().info->cardinality;
    rai_info_post->compact_list = &rai_info_post->rai->alist->compact_forward_list;

    join_condition_post.rais.push_back(move(rai_info_post));
    cond_post.push_back(move(join_condition_post));

    LogicalComparisonJoin join_post_op(JoinType::INNER);
    vector<LogicalType> output_post_types{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::BIGINT,
                                          LogicalType::BIGINT};
    join_post_op.types = output_post_types;
    vector<idx_t> right_projection_map_post{0};
    vector<idx_t> merge_project_map_post;
    vector<LogicalType> delim_types_post;
    auto join_post = make_uniq<PhysicalSIPJoin>(join_post_op, move(scan_post), move(join_knows_3), move(cond_post),
                                                JoinType::INNER, left_projection_map, right_projection_map_post,
                                                delim_types_post, 0);

    // join forum with person-person-post
    vector<idx_t> forum_ids{1, COLUMN_IDENTIFIER_ROW_ID};
    vector<LogicalType> get_forum_types{LogicalType::VARCHAR, LogicalType::BIGINT};
    string alias_forum = "f";
    vector<LogicalType> table_types_forum;
    vector<unique_ptr<Expression>> filter_forum;
    unique_ptr<LogicalGet> get_op_forum = move(
            getLogicalGet(*this, table_forum, alias_forum, table_index_forum, table_types_forum));
    unique_ptr<TableFilterSet> table_filters_forum = NULL;
    unique_ptr<PhysicalTableScan> scan_forum = make_uniq<PhysicalTableScan>(get_forum_types, get_op_forum->function,
                                                                            get_op_forum->table_index,
                                                                            move(get_op_forum->bind_data),
                                                                            table_types_forum, forum_ids,
                                                                            move(filter_forum), vector<column_t>(),
                                                                            get_op_forum->names,
                                                                            std::move(table_filters_forum),
                                                                            get_op_forum->estimated_cardinality,
                                                                            get_op_forum->extra_info);

    vector<JoinCondition> cond_forum;
    JoinCondition join_condition_forum;
    join_condition_forum.left = make_uniq<BoundReferenceExpression>("forum_rowid", LogicalType::BIGINT, 1);
    join_condition_forum.right = make_uniq<BoundReferenceExpression>("m_ps_forumid_rowid", LogicalType::BIGINT, 2);
    join_condition_forum.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_forum = make_uniq<RAIInfo>();
    rai_info_forum->rai = table_post.GetStorage().info->rais[2].get();
    rai_info_forum->rai_type = RAIType::TARGET_EDGE;
    rai_info_forum->forward = true;
    rai_info_forum->vertex = &table_forum;
    rai_info_forum->vertex_id = table_index_forum;
    rai_info_forum->passing_tables[0] = table_index_forum;
    rai_info_forum->left_cardinalities[0] = table_forum.GetStorage().info->cardinality;
    // rai_info_forum->compact_list = &rai_info_forum->rai->alist->compact_forward_list;

    join_condition_forum.rais.push_back(move(rai_info_forum));
    cond_forum.push_back(move(join_condition_forum));

    LogicalComparisonJoin join_forum_op(JoinType::INNER);
    vector<LogicalType> output_forum_types{LogicalType::VARCHAR, LogicalType::BIGINT, LogicalType::BIGINT};
    join_forum_op.types = output_forum_types;
    vector<idx_t> right_projection_map_forum{3};
    vector<idx_t> merge_project_map_forum;
    vector<LogicalType> delim_types_forum;
    auto join_forum = make_uniq<PhysicalSIPJoin>(join_forum_op, move(scan_forum), move(join_post), move(cond_forum),
                                                 JoinType::INNER, left_projection_map, right_projection_map_forum,
                                                 delim_types_forum, 0);


    // join person_forum with person-person-post-forum
    idx_t p_forum_person_joindate = atoll(paras->data()[1].c_str());
    Value p_joindate = Value::BIGINT(p_forum_person_joindate);
    vector<idx_t> forum_person_ids{4, 3, 2};
    vector<LogicalType> get_forum_person_types{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::BIGINT};
    string alias_forum_person = "fp";
    vector<LogicalType> table_types_forum_person;
    vector<unique_ptr<Expression>> filter_forum_person;
    unique_ptr<LogicalGet> get_op_forum_person = move(
            getLogicalGet(*this, table_forum_person, alias_forum_person, table_index_forum_person,
                          table_types_forum_person));
    unique_ptr<TableFilterSet> table_filters_forum_person = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_forum_person = duckdb::make_uniq<ConstantFilter>(
            ExpressionType::COMPARE_GREATERTHANOREQUALTO, p_joindate);
    table_filters_forum_person->filters[2] = move(constant_filter_forum_person);
    unique_ptr<PhysicalTableScan> scan_forum_person = make_uniq<PhysicalTableScan>(get_forum_person_types,
                                                                                   get_op_forum_person->function,
                                                                                   get_op_forum_person->table_index,
                                                                                   move(get_op_forum_person->bind_data),
                                                                                   table_types_forum_person,
                                                                                   forum_person_ids,
                                                                                   move(filter_forum_person),
                                                                                   vector<column_t>(),
                                                                                   get_op_forum_person->names,
                                                                                   std::move(
                                                                                           table_filters_forum_person),
                                                                                   get_op_forum_person->estimated_cardinality,
                                                                                   get_op_forum_person->extra_info);

    vector<JoinCondition> cond_forum_person;
    JoinCondition join_condition_forum_person, join_condition_forum_person_2;
    join_condition_forum_person.left = make_uniq<BoundReferenceExpression>("fp_forumid_rowid", LogicalType::BIGINT, 0);
    join_condition_forum_person.right = make_uniq<BoundReferenceExpression>("forum_rowid", LogicalType::BIGINT, 1);
    join_condition_forum_person.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_forum_person = make_uniq<RAIInfo>();
    rai_info_forum_person->rai = table_forum_person.GetStorage().info->rais[0].get();
    rai_info_forum_person->rai_type = RAIType::EDGE_TARGET;
    rai_info_forum_person->forward = false;
    rai_info_forum_person->vertex = &table_forum;
    rai_info_forum_person->vertex_id = table_index_forum;
    rai_info_forum_person->passing_tables[0] = table_index_forum_person;
    rai_info_forum_person->left_cardinalities[0] = table_forum_person.GetStorage().info->cardinality;
    rai_info_forum_person->compact_list = &rai_info_forum_person->rai->alist->compact_backward_list;

    join_condition_forum_person.rais.push_back(move(rai_info_forum_person));

    join_condition_forum_person_2.left = make_uniq<BoundReferenceExpression>("fp_personid_rowid", LogicalType::BIGINT,
                                                                             1);
    join_condition_forum_person_2.right = make_uniq<BoundReferenceExpression>("person_rowid", LogicalType::BIGINT, 2);
    join_condition_forum_person_2.comparison = ExpressionType::COMPARE_EQUAL;

    cond_forum_person.push_back(move(join_condition_forum_person));
    cond_forum_person.push_back(move(join_condition_forum_person_2));

    LogicalComparisonJoin join_forum_person_op(JoinType::INNER);
    vector<LogicalType> output_forum_person_types{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::BIGINT,
                                                  LogicalType::VARCHAR};
    join_forum_person_op.types = output_forum_person_types;
    vector<idx_t> right_projection_map_forum_person{0};
    vector<idx_t> merge_project_map_forum_person;
    vector<LogicalType> delim_types_forum_person;
    auto join_forum_person = make_uniq<PhysicalSIPJoin>(join_forum_person_op, move(scan_forum_person), move(join_forum),
                                                        move(cond_forum_person),
                                                        JoinType::INNER, left_projection_map,
                                                        right_projection_map_forum_person,
                                                        delim_types_forum_person, 0);


    // project
    vector<LogicalType> result_types{LogicalType::VARCHAR};
    vector<unique_ptr<Expression>> select_list;
    auto result_col0 = make_uniq<BoundReferenceExpression>("f_title", LogicalType::VARCHAR, 3);
    select_list.push_back(move(result_col0));
    auto projection = make_uniq<PhysicalProjection>(result_types, move(select_list), 0);
    projection->children.push_back(move(join_forum_person));

    return projection;
}

unique_ptr<PhysicalOperator> ClientContext::GenerateIC52PlanByPass() {
    vector<idx_t> left_projection_map, right_projection_map;

    string table_vertex_person = "person";
    string table_vertex_forum = "forum";
    string table_vertex_post = "post";
    string table_edge_knows = "knows";
    string table_edge_forum_person = "forum_person";
    idx_t table_index_person1 = 6;
    idx_t table_index_forum = 10;
    idx_t table_index_person2 = 8;
    idx_t table_index_person3 = 9;
    idx_t table_index_post = 12;
    idx_t table_index_knows = 7;
    idx_t table_index_forum_person = 13;


    auto table_or_view_person = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                  table_vertex_person, OnEntryNotFound::RETURN_NULL);
    auto &table_person = table_or_view_person->Cast<TableCatalogEntry>();

    auto table_or_view_forum = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                 table_vertex_forum, OnEntryNotFound::RETURN_NULL);
    auto &table_forum = table_or_view_forum->Cast<TableCatalogEntry>();

    auto table_or_view_post = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                table_vertex_post, OnEntryNotFound::RETURN_NULL);
    auto &table_post = table_or_view_post->Cast<TableCatalogEntry>();

    auto table_or_view_knows = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                 table_edge_knows, OnEntryNotFound::RETURN_NULL);
    auto &table_knows = table_or_view_knows->Cast<TableCatalogEntry>();

    auto table_or_view_forum_person = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                        table_edge_forum_person, OnEntryNotFound::RETURN_NULL);
    auto &table_forum_person = table_or_view_forum_person->Cast<TableCatalogEntry>();


    vector<idx_t> person2_ids{COLUMN_IDENTIFIER_ROW_ID};
    vector<LogicalType> get_person2_types{LogicalType::BIGINT};
    string alias_person2 = "p2";
    vector<LogicalType> table_types_person2;
    vector<unique_ptr<Expression>> filter_person2;
    unique_ptr<LogicalGet> get_op_person2 = move(
            getLogicalGet(*this, table_person, alias_person2, table_index_person2, table_types_person2));
    unique_ptr<TableFilterSet> table_filters_person2 = NULL;
    unique_ptr<PhysicalTableScan> scan_person2 = make_uniq<PhysicalTableScan>(get_person2_types,
                                                                              get_op_person2->function,
                                                                              get_op_person2->table_index,
                                                                              move(get_op_person2->bind_data),
                                                                              table_types_person2, person2_ids,
                                                                              move(filter_person2), vector<column_t>(),
                                                                              get_op_person2->names,
                                                                              std::move(table_filters_person2),
                                                                              get_op_person2->estimated_cardinality,
                                                                              get_op_person2->extra_info);

    idx_t p_person_id = atoll(paras->data()[0].c_str()); // 933;
    Value p_person = Value::BIGINT(p_person_id);
    vector<idx_t> person1_ids{0, COLUMN_IDENTIFIER_ROW_ID};
    vector<LogicalType> get_person1_types{LogicalType::BIGINT, LogicalType::BIGINT};
    string alias_person1 = "p1";
    vector<LogicalType> table_types_person1;
    unique_ptr<LogicalGet> get_op_person1 = move(
            getLogicalGet(*this, table_person, alias_person1, table_index_person1, table_types_person1));
    vector<unique_ptr<Expression>> filter_person1;
    unique_ptr<TableFilterSet> table_filters_person1 = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL,
                                                                                   p_person);
    table_filters_person1->filters[0] = move(constant_filter);
    unique_ptr<PhysicalTableScan> scan_person1 = make_uniq<PhysicalTableScan>(get_person1_types,
                                                                              get_op_person1->function,
                                                                              get_op_person1->table_index,
                                                                              move(get_op_person1->bind_data),
                                                                              table_types_person1, person1_ids,
                                                                              move(filter_person1), vector<column_t>(),
                                                                              get_op_person1->names,
                                                                              std::move(table_filters_person1),
                                                                              get_op_person1->estimated_cardinality,
                                                                              get_op_person1->extra_info);

    vector<JoinCondition> cond_knows;
    JoinCondition join_condition_knows;
    join_condition_knows.left = make_uniq<BoundReferenceExpression>("person_rowid", LogicalType::BIGINT, 0);
    join_condition_knows.right = make_uniq<BoundReferenceExpression>("person_rowid", LogicalType::BIGINT, 1);
    join_condition_knows.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_knows = make_uniq<RAIInfo>();
    rai_info_knows->rai = table_knows.GetStorage().info->rais[0].get();
    rai_info_knows->rai_type = RAIType::TARGET_EDGE;
    rai_info_knows->forward = true;
    rai_info_knows->vertex = &table_person;
    rai_info_knows->vertex_id = table_index_person2;
    rai_info_knows->passing_tables[0] = table_index_person2;
    rai_info_knows->left_cardinalities[0] = table_person.GetStorage().info->cardinality;
    // rai_info_knows->compact_list = &rai_info_knows->rai->alist->compact_backward_list;

    join_condition_knows.rais.push_back(move(rai_info_knows));
    cond_knows.push_back(move(join_condition_knows));

    LogicalComparisonJoin join_knows_op(JoinType::INNER);
    vector<LogicalType> output_knows_types{LogicalType::BIGINT, LogicalType::BIGINT};
    join_knows_op.types = output_knows_types;
    vector<idx_t> right_projection_map_knows{1};
    vector<idx_t> merge_project_map;
    vector<LogicalType> delim_types;
    auto join_knows = make_uniq<PhysicalMergeSIPJoin>(join_knows_op, move(scan_person2), move(scan_person1),
                                                      move(cond_knows),
                                                      JoinType::INNER, left_projection_map, right_projection_map_knows,
                                                      merge_project_map, delim_types, 0);

    // join the 2-hop neighbors
    vector<idx_t> person3_ids{COLUMN_IDENTIFIER_ROW_ID};
    vector<LogicalType> get_person3_types{LogicalType::BIGINT};
    string alias_person3 = "p3";
    vector<LogicalType> table_types_person3;
    vector<unique_ptr<Expression>> filter_person3;
    unique_ptr<LogicalGet> get_op_person3 = move(
            getLogicalGet(*this, table_person, alias_person3, table_index_person3, table_types_person3));
    unique_ptr<TableFilterSet> table_filters_person3 = NULL;
    unique_ptr<PhysicalTableScan> scan_person3 = make_uniq<PhysicalTableScan>(get_person3_types,
                                                                              get_op_person3->function,
                                                                              get_op_person3->table_index,
                                                                              move(get_op_person3->bind_data),
                                                                              table_types_person3, person3_ids,
                                                                              move(filter_person3), vector<column_t>(),
                                                                              get_op_person3->names,
                                                                              std::move(table_filters_person3),
                                                                              get_op_person3->estimated_cardinality,
                                                                              get_op_person3->extra_info);

    vector<JoinCondition> cond_knows_2;
    JoinCondition join_condition_knows_2;
    join_condition_knows_2.left = make_uniq<BoundReferenceExpression>("person_rowid", LogicalType::BIGINT, 0);
    join_condition_knows_2.right = make_uniq<BoundReferenceExpression>("person_rowid", LogicalType::BIGINT, 0);
    join_condition_knows_2.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_knows_2 = make_uniq<RAIInfo>();
    rai_info_knows_2->rai = table_knows.GetStorage().info->rais[0].get();
    rai_info_knows_2->rai_type = RAIType::TARGET_EDGE;
    rai_info_knows_2->forward = true;
    rai_info_knows_2->vertex = &table_person;
    rai_info_knows_2->vertex_id = table_index_person3;
    rai_info_knows_2->passing_tables[0] = table_index_person3;
    rai_info_knows_2->left_cardinalities[0] = table_person.GetStorage().info->cardinality;
    // rai_info_knows->compact_list = &rai_info_knows->rai->alist->compact_backward_list;

    join_condition_knows_2.rais.push_back(move(rai_info_knows_2));
    cond_knows_2.push_back(move(join_condition_knows_2));

    LogicalComparisonJoin join_knows_op_2(JoinType::INNER);
    vector<LogicalType> output_knows_types_2{LogicalType::BIGINT, LogicalType::BIGINT};
    join_knows_op_2.types = output_knows_types_2;
    vector<idx_t> right_projection_map_knows_2{0};
    vector<idx_t> merge_project_map_2;
    vector<LogicalType> delim_types_2;
    auto join_knows_2 = make_uniq<PhysicalMergeSIPJoin>(join_knows_op_2, move(scan_person3), move(join_knows),
                                                        move(cond_knows_2),
                                                        JoinType::INNER, left_projection_map,
                                                        right_projection_map_knows_2,
                                                        merge_project_map_2, delim_types_2, 0);

    // join person_forum with person-person
    idx_t p_forum_person_joindate = atoll(paras->data()[1].c_str());
    Value p_joindate = Value::BIGINT(p_forum_person_joindate);
    vector<idx_t> forum_person_ids{4, 3, 2};
    vector<LogicalType> get_forum_person_types{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::BIGINT};
    string alias_forum_person = "fp";
    vector<LogicalType> table_types_forum_person;
    vector<unique_ptr<Expression>> filter_forum_person;
    unique_ptr<LogicalGet> get_op_forum_person = move(
            getLogicalGet(*this, table_forum_person, alias_forum_person, table_index_forum_person,
                          table_types_forum_person));
    unique_ptr<TableFilterSet> table_filters_forum_person = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_forum_person = duckdb::make_uniq<ConstantFilter>(
            ExpressionType::COMPARE_GREATERTHANOREQUALTO, p_joindate);
    table_filters_forum_person->filters[2] = move(constant_filter_forum_person);
    unique_ptr<PhysicalTableScan> scan_forum_person = make_uniq<PhysicalTableScan>(get_forum_person_types,
                                                                                   get_op_forum_person->function,
                                                                                   get_op_forum_person->table_index,
                                                                                   move(get_op_forum_person->bind_data),
                                                                                   table_types_forum_person,
                                                                                   forum_person_ids,
                                                                                   move(filter_forum_person),
                                                                                   vector<column_t>(),
                                                                                   get_op_forum_person->names,
                                                                                   std::move(
                                                                                           table_filters_forum_person),
                                                                                   get_op_forum_person->estimated_cardinality,
                                                                                   get_op_forum_person->extra_info);

    vector<JoinCondition> cond_forum_person;
    JoinCondition join_condition_forum_person;
    join_condition_forum_person.left = make_uniq<BoundReferenceExpression>("fp_personid_rowid", LogicalType::BIGINT, 1);
    join_condition_forum_person.right = make_uniq<BoundReferenceExpression>("person_rowid", LogicalType::BIGINT, 0);
    join_condition_forum_person.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_forum_person = make_uniq<RAIInfo>();
    rai_info_forum_person->rai = table_forum_person.GetStorage().info->rais[0].get();
    rai_info_forum_person->rai_type = RAIType::EDGE_SOURCE;
    rai_info_forum_person->forward = true;
    rai_info_forum_person->vertex = &table_person;
    rai_info_forum_person->vertex_id = table_index_person3;
    rai_info_forum_person->passing_tables[0] = table_index_forum_person;
    rai_info_forum_person->left_cardinalities[0] = table_forum_person.GetStorage().info->cardinality;
    rai_info_forum_person->compact_list = &rai_info_forum_person->rai->alist->compact_forward_list;

    join_condition_forum_person.rais.push_back(move(rai_info_forum_person));

    cond_forum_person.push_back(move(join_condition_forum_person));

    LogicalComparisonJoin join_forum_person_op(JoinType::INNER);
    vector<LogicalType> output_forum_person_types{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::BIGINT,
                                                  LogicalType::BIGINT};
    join_forum_person_op.types = output_forum_person_types;
    vector<idx_t> right_projection_map_forum_person{0};
    vector<idx_t> merge_project_map_forum_person;
    vector<LogicalType> delim_types_forum_person;
    auto join_forum_person = make_uniq<PhysicalSIPJoin>(join_forum_person_op, move(scan_forum_person), move(join_knows_2),
                                                        move(cond_forum_person),
                                                        JoinType::INNER, left_projection_map,
                                                        right_projection_map_forum_person,
                                                        delim_types_forum_person, 0);

    // join forum with person-person-fp
    vector<idx_t> forum_ids{1, COLUMN_IDENTIFIER_ROW_ID};
    vector<LogicalType> get_forum_types{LogicalType::VARCHAR, LogicalType::BIGINT};
    string alias_forum = "f";
    vector<LogicalType> table_types_forum;
    vector<unique_ptr<Expression>> filter_forum;
    unique_ptr<LogicalGet> get_op_forum = move(
            getLogicalGet(*this, table_forum, alias_forum, table_index_forum, table_types_forum));
    unique_ptr<TableFilterSet> table_filters_forum = NULL;
    unique_ptr<PhysicalTableScan> scan_forum = make_uniq<PhysicalTableScan>(get_forum_types, get_op_forum->function,
                                                                            get_op_forum->table_index,
                                                                            move(get_op_forum->bind_data),
                                                                            table_types_forum, forum_ids,
                                                                            move(filter_forum), vector<column_t>(),
                                                                            get_op_forum->names,
                                                                            std::move(table_filters_forum),
                                                                            get_op_forum->estimated_cardinality,
                                                                            get_op_forum->extra_info);

    vector<JoinCondition> cond_forum;
    JoinCondition join_condition_forum;
    join_condition_forum.left = make_uniq<BoundReferenceExpression>("forum_rowid", LogicalType::BIGINT, 1);
    join_condition_forum.right = make_uniq<BoundReferenceExpression>("fp_forumid_rowid", LogicalType::BIGINT, 0);
    join_condition_forum.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_forum = make_uniq<RAIInfo>();
    rai_info_forum->rai = table_forum_person.GetStorage().info->rais[0].get();
    rai_info_forum->rai_type = RAIType::TARGET_EDGE;
    rai_info_forum->forward = true;
    rai_info_forum->vertex = &table_forum;
    rai_info_forum->vertex_id = table_index_forum;
    rai_info_forum->passing_tables[0] = table_index_forum;
    rai_info_forum->left_cardinalities[0] = table_forum.GetStorage().info->cardinality;
    // rai_info_forum->compact_list = &rai_info_forum->rai->alist->compact_forward_list;

    join_condition_forum.rais.push_back(move(rai_info_forum));
    cond_forum.push_back(move(join_condition_forum));

    LogicalComparisonJoin join_forum_op(JoinType::INNER);
    vector<LogicalType> output_forum_types{LogicalType::VARCHAR, LogicalType::BIGINT, LogicalType::BIGINT};
    join_forum_op.types = output_forum_types;
    vector<idx_t> right_projection_map_forum{3};
    vector<idx_t> merge_project_map_forum;
    vector<LogicalType> delim_types_forum;
    auto join_forum = make_uniq<PhysicalSIPJoin>(join_forum_op, move(scan_forum), move(join_forum_person), move(cond_forum),
                                                 JoinType::INNER, left_projection_map, right_projection_map_forum,
                                                 delim_types_forum, 0);

    // join post with person-person-forum
    vector<idx_t> post_ids{11, COLUMN_IDENTIFIER_ROW_ID, 13};
    vector<LogicalType> get_post_types{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::BIGINT};
    string alias_post = "m";
    vector<LogicalType> table_types_post;
    vector<unique_ptr<Expression>> filter_post;
    unique_ptr<LogicalGet> get_op_post = move(
            getLogicalGet(*this, table_post, alias_post, table_index_post, table_types_post));
    unique_ptr<TableFilterSet> table_filters_post = NULL;
    unique_ptr<PhysicalTableScan> scan_post = make_uniq<PhysicalTableScan>(get_post_types, get_op_post->function,
                                                                           get_op_post->table_index,
                                                                           move(get_op_post->bind_data),
                                                                           table_types_post, post_ids,
                                                                           move(filter_post), vector<column_t>(),
                                                                           get_op_post->names,
                                                                           std::move(table_filters_post),
                                                                           get_op_post->estimated_cardinality,
                                                                           get_op_post->extra_info);

    vector<JoinCondition> cond_post;
    JoinCondition join_condition_post, join_condition_post_2;
    join_condition_post.left = make_uniq<BoundReferenceExpression>("m_ps_forumid_rowid", LogicalType::BIGINT, 2);
    join_condition_post.right = make_uniq<BoundReferenceExpression>("forum_rowid", LogicalType::BIGINT, 1);
    join_condition_post.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_post = make_uniq<RAIInfo>();
    rai_info_post->rai = table_post.GetStorage().info->rais[2].get();
    rai_info_post->rai_type = RAIType::EDGE_SOURCE;
    rai_info_post->forward = true;
    rai_info_post->vertex = &table_forum;
    rai_info_post->vertex_id = table_index_forum;
    rai_info_post->passing_tables[0] = table_index_post;
    rai_info_post->left_cardinalities[0] = table_post.GetStorage().info->cardinality;
    rai_info_post->compact_list = &rai_info_post->rai->alist->compact_forward_list;

    join_condition_post_2.left = make_uniq<BoundReferenceExpression>("m_creatorid_rowid", LogicalType::BIGINT, 0);
    join_condition_post_2.right = make_uniq<BoundReferenceExpression>("person_rowid", LogicalType::BIGINT, 2);
    join_condition_post_2.comparison = ExpressionType::COMPARE_EQUAL;

    join_condition_post.rais.push_back(move(rai_info_post));
    cond_post.push_back(move(join_condition_post));
    cond_post.push_back(move(join_condition_post_2));

    LogicalComparisonJoin join_post_op(JoinType::INNER);
    vector<LogicalType> output_post_types{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::BIGINT,
                                          LogicalType::VARCHAR};
    join_post_op.types = output_post_types;
    vector<idx_t> right_projection_map_post{0};
    vector<idx_t> merge_project_map_post;
    vector<LogicalType> delim_types_post;
    auto join_post = make_uniq<PhysicalSIPJoin>(join_post_op, move(scan_post), move(join_forum), move(cond_post),
                                                JoinType::INNER, left_projection_map, right_projection_map_post,
                                                delim_types_post, 0);



    // project
    vector<LogicalType> result_types{LogicalType::VARCHAR};
    vector<unique_ptr<Expression>> select_list;
    auto result_col0 = make_uniq<BoundReferenceExpression>("f_title", LogicalType::VARCHAR, 3);
    select_list.push_back(move(result_col0));
    auto projection = make_uniq<PhysicalProjection>(result_types, move(select_list), 0);
    projection->children.push_back(move(join_post));

    return projection;
}

unique_ptr<PhysicalOperator> ClientContext::GenerateIC52PlanByPassFromPerson() {
    vector<idx_t> left_projection_map, right_projection_map;

    string table_vertex_person = "person";
    string table_vertex_forum = "forum";
    string table_vertex_post = "post";
    string table_edge_knows = "knows";
    string table_edge_forum_person = "forum_person";
    idx_t table_index_person1 = 6;
    idx_t table_index_forum = 10;
    idx_t table_index_person2 = 8;
    idx_t table_index_person3 = 9;
    idx_t table_index_post = 12;
    idx_t table_index_knows = 7;
    idx_t table_index_forum_person = 13;


    auto table_or_view_person = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                  table_vertex_person, OnEntryNotFound::RETURN_NULL);
    auto &table_person = table_or_view_person->Cast<TableCatalogEntry>();

    auto table_or_view_forum = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                 table_vertex_forum, OnEntryNotFound::RETURN_NULL);
    auto &table_forum = table_or_view_forum->Cast<TableCatalogEntry>();

    auto table_or_view_post = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                table_vertex_post, OnEntryNotFound::RETURN_NULL);
    auto &table_post = table_or_view_post->Cast<TableCatalogEntry>();

    auto table_or_view_knows = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                 table_edge_knows, OnEntryNotFound::RETURN_NULL);
    auto &table_knows = table_or_view_knows->Cast<TableCatalogEntry>();

    auto table_or_view_forum_person = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                        table_edge_forum_person, OnEntryNotFound::RETURN_NULL);
    auto &table_forum_person = table_or_view_forum_person->Cast<TableCatalogEntry>();


    vector<idx_t> person2_ids{COLUMN_IDENTIFIER_ROW_ID};
    vector<LogicalType> get_person2_types{LogicalType::BIGINT};
    string alias_person2 = "p2";
    vector<LogicalType> table_types_person2;
    vector<unique_ptr<Expression>> filter_person2;
    unique_ptr<LogicalGet> get_op_person2 = move(
            getLogicalGet(*this, table_person, alias_person2, table_index_person2, table_types_person2));
    unique_ptr<TableFilterSet> table_filters_person2 = NULL;
    unique_ptr<PhysicalTableScan> scan_person2 = make_uniq<PhysicalTableScan>(get_person2_types,
                                                                              get_op_person2->function,
                                                                              get_op_person2->table_index,
                                                                              move(get_op_person2->bind_data),
                                                                              table_types_person2, person2_ids,
                                                                              move(filter_person2), vector<column_t>(),
                                                                              get_op_person2->names,
                                                                              std::move(table_filters_person2),
                                                                              get_op_person2->estimated_cardinality,
                                                                              get_op_person2->extra_info);

    idx_t p_person_id = atoll(paras->data()[0].c_str()); // 933;
    Value p_person = Value::BIGINT(p_person_id);
    vector<idx_t> person1_ids{0, COLUMN_IDENTIFIER_ROW_ID};
    vector<LogicalType> get_person1_types{LogicalType::BIGINT, LogicalType::BIGINT};
    string alias_person1 = "p1";
    vector<LogicalType> table_types_person1;
    unique_ptr<LogicalGet> get_op_person1 = move(
            getLogicalGet(*this, table_person, alias_person1, table_index_person1, table_types_person1));
    vector<unique_ptr<Expression>> filter_person1;
    unique_ptr<TableFilterSet> table_filters_person1 = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL,
                                                                                   p_person);
    table_filters_person1->filters[0] = move(constant_filter);
    unique_ptr<PhysicalTableScan> scan_person1 = make_uniq<PhysicalTableScan>(get_person1_types,
                                                                              get_op_person1->function,
                                                                              get_op_person1->table_index,
                                                                              move(get_op_person1->bind_data),
                                                                              table_types_person1, person1_ids,
                                                                              move(filter_person1), vector<column_t>(),
                                                                              get_op_person1->names,
                                                                              std::move(table_filters_person1),
                                                                              get_op_person1->estimated_cardinality,
                                                                              get_op_person1->extra_info);

    vector<JoinCondition> cond_knows;
    JoinCondition join_condition_knows;
    join_condition_knows.left = make_uniq<BoundReferenceExpression>("person_rowid", LogicalType::BIGINT, 0);
    join_condition_knows.right = make_uniq<BoundReferenceExpression>("person_rowid", LogicalType::BIGINT, 1);
    join_condition_knows.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_knows = make_uniq<RAIInfo>();
    rai_info_knows->rai = table_knows.GetStorage().info->rais[0].get();
    rai_info_knows->rai_type = RAIType::TARGET_EDGE;
    rai_info_knows->forward = true;
    rai_info_knows->vertex = &table_person;
    rai_info_knows->vertex_id = table_index_person2;
    rai_info_knows->passing_tables[0] = table_index_person2;
    rai_info_knows->left_cardinalities[0] = table_person.GetStorage().info->cardinality;
    // rai_info_knows->compact_list = &rai_info_knows->rai->alist->compact_backward_list;

    join_condition_knows.rais.push_back(move(rai_info_knows));
    cond_knows.push_back(move(join_condition_knows));

    LogicalComparisonJoin join_knows_op(JoinType::INNER);
    vector<LogicalType> output_knows_types{LogicalType::BIGINT, LogicalType::BIGINT};
    join_knows_op.types = output_knows_types;
    vector<idx_t> right_projection_map_knows{1};
    vector<idx_t> merge_project_map;
    vector<LogicalType> delim_types;
    auto join_knows = make_uniq<PhysicalMergeSIPJoin>(join_knows_op, move(scan_person2), move(scan_person1),
                                                      move(cond_knows),
                                                      JoinType::INNER, left_projection_map, right_projection_map_knows,
                                                      merge_project_map, delim_types, 0);

    // join the 2-hop neighbors
    vector<idx_t> person3_ids{COLUMN_IDENTIFIER_ROW_ID};
    vector<LogicalType> get_person3_types{LogicalType::BIGINT};
    string alias_person3 = "p3";
    vector<LogicalType> table_types_person3;
    vector<unique_ptr<Expression>> filter_person3;
    unique_ptr<LogicalGet> get_op_person3 = move(
            getLogicalGet(*this, table_person, alias_person3, table_index_person3, table_types_person3));
    unique_ptr<TableFilterSet> table_filters_person3 = NULL;
    unique_ptr<PhysicalTableScan> scan_person3 = make_uniq<PhysicalTableScan>(get_person3_types,
                                                                              get_op_person3->function,
                                                                              get_op_person3->table_index,
                                                                              move(get_op_person3->bind_data),
                                                                              table_types_person3, person3_ids,
                                                                              move(filter_person3), vector<column_t>(),
                                                                              get_op_person3->names,
                                                                              std::move(table_filters_person3),
                                                                              get_op_person3->estimated_cardinality,
                                                                              get_op_person3->extra_info);

    vector<JoinCondition> cond_knows_2;
    JoinCondition join_condition_knows_2;
    join_condition_knows_2.left = make_uniq<BoundReferenceExpression>("person_rowid", LogicalType::BIGINT, 0);
    join_condition_knows_2.right = make_uniq<BoundReferenceExpression>("person_rowid", LogicalType::BIGINT, 0);
    join_condition_knows_2.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_knows_2 = make_uniq<RAIInfo>();
    rai_info_knows_2->rai = table_knows.GetStorage().info->rais[0].get();
    rai_info_knows_2->rai_type = RAIType::TARGET_EDGE;
    rai_info_knows_2->forward = true;
    rai_info_knows_2->vertex = &table_person;
    rai_info_knows_2->vertex_id = table_index_person3;
    rai_info_knows_2->passing_tables[0] = table_index_person3;
    rai_info_knows_2->left_cardinalities[0] = table_person.GetStorage().info->cardinality;
    // rai_info_knows->compact_list = &rai_info_knows->rai->alist->compact_backward_list;

    join_condition_knows_2.rais.push_back(move(rai_info_knows_2));
    cond_knows_2.push_back(move(join_condition_knows_2));

    LogicalComparisonJoin join_knows_op_2(JoinType::INNER);
    vector<LogicalType> output_knows_types_2{LogicalType::BIGINT, LogicalType::BIGINT};
    join_knows_op_2.types = output_knows_types_2;
    vector<idx_t> right_projection_map_knows_2{0};
    vector<idx_t> merge_project_map_2;
    vector<LogicalType> delim_types_2;
    auto join_knows_2 = make_uniq<PhysicalMergeSIPJoin>(join_knows_op_2, move(scan_person3), move(join_knows),
                                                        move(cond_knows_2),
                                                        JoinType::INNER, left_projection_map,
                                                        right_projection_map_knows_2,
                                                        merge_project_map_2, delim_types_2, 0);

    // join person_forum with person-person
    idx_t p_forum_person_joindate = atoll(paras->data()[1].c_str());
    Value p_joindate = Value::BIGINT(p_forum_person_joindate);
    vector<idx_t> forum_person_ids{4, 3, 2};
    vector<LogicalType> get_forum_person_types{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::BIGINT};
    string alias_forum_person = "fp";
    vector<LogicalType> table_types_forum_person;
    vector<unique_ptr<Expression>> filter_forum_person;
    unique_ptr<LogicalGet> get_op_forum_person = move(
            getLogicalGet(*this, table_forum_person, alias_forum_person, table_index_forum_person,
                          table_types_forum_person));
    unique_ptr<TableFilterSet> table_filters_forum_person = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_forum_person = duckdb::make_uniq<ConstantFilter>(
            ExpressionType::COMPARE_GREATERTHANOREQUALTO, p_joindate);
    table_filters_forum_person->filters[2] = move(constant_filter_forum_person);
    unique_ptr<PhysicalTableScan> scan_forum_person = make_uniq<PhysicalTableScan>(get_forum_person_types,
                                                                                   get_op_forum_person->function,
                                                                                   get_op_forum_person->table_index,
                                                                                   move(get_op_forum_person->bind_data),
                                                                                   table_types_forum_person,
                                                                                   forum_person_ids,
                                                                                   move(filter_forum_person),
                                                                                   vector<column_t>(),
                                                                                   get_op_forum_person->names,
                                                                                   std::move(
                                                                                           table_filters_forum_person),
                                                                                   get_op_forum_person->estimated_cardinality,
                                                                                   get_op_forum_person->extra_info);

    vector<JoinCondition> cond_forum_person;
    JoinCondition join_condition_forum_person;
    join_condition_forum_person.left = make_uniq<BoundReferenceExpression>("fp_personid_rowid", LogicalType::BIGINT, 1);
    join_condition_forum_person.right = make_uniq<BoundReferenceExpression>("person_rowid", LogicalType::BIGINT, 0);
    join_condition_forum_person.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_forum_person = make_uniq<RAIInfo>();
    rai_info_forum_person->rai = table_forum_person.GetStorage().info->rais[0].get();
    rai_info_forum_person->rai_type = RAIType::EDGE_SOURCE;
    rai_info_forum_person->forward = true;
    rai_info_forum_person->vertex = &table_person;
    rai_info_forum_person->vertex_id = table_index_person3;
    rai_info_forum_person->passing_tables[0] = table_index_forum_person;
    rai_info_forum_person->left_cardinalities[0] = table_forum_person.GetStorage().info->cardinality;
    rai_info_forum_person->compact_list = &rai_info_forum_person->rai->alist->compact_forward_list;

    join_condition_forum_person.rais.push_back(move(rai_info_forum_person));

    cond_forum_person.push_back(move(join_condition_forum_person));

    LogicalComparisonJoin join_forum_person_op(JoinType::INNER);
    vector<LogicalType> output_forum_person_types{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::BIGINT,
                                                  LogicalType::BIGINT};
    join_forum_person_op.types = output_forum_person_types;
    vector<idx_t> right_projection_map_forum_person{0};
    vector<idx_t> merge_project_map_forum_person;
    vector<LogicalType> delim_types_forum_person;
    auto join_forum_person = make_uniq<PhysicalSIPJoin>(join_forum_person_op, move(scan_forum_person),
                                                        move(join_knows_2),
                                                        move(cond_forum_person),
                                                        JoinType::INNER, left_projection_map,
                                                        right_projection_map_forum_person,
                                                        delim_types_forum_person, 0);

    // join forum with person-person-fp
    vector<idx_t> forum_ids{1, COLUMN_IDENTIFIER_ROW_ID};
    vector<LogicalType> get_forum_types{LogicalType::VARCHAR, LogicalType::BIGINT};
    string alias_forum = "f";
    vector<LogicalType> table_types_forum;
    vector<unique_ptr<Expression>> filter_forum;
    unique_ptr<LogicalGet> get_op_forum = move(
            getLogicalGet(*this, table_forum, alias_forum, table_index_forum, table_types_forum));
    unique_ptr<TableFilterSet> table_filters_forum = NULL;
    unique_ptr<PhysicalTableScan> scan_forum = make_uniq<PhysicalTableScan>(get_forum_types, get_op_forum->function,
                                                                            get_op_forum->table_index,
                                                                            move(get_op_forum->bind_data),
                                                                            table_types_forum, forum_ids,
                                                                            move(filter_forum), vector<column_t>(),
                                                                            get_op_forum->names,
                                                                            std::move(table_filters_forum),
                                                                            get_op_forum->estimated_cardinality,
                                                                            get_op_forum->extra_info);

    vector<JoinCondition> cond_forum;
    JoinCondition join_condition_forum;
    join_condition_forum.left = make_uniq<BoundReferenceExpression>("forum_rowid", LogicalType::BIGINT, 1);
    join_condition_forum.right = make_uniq<BoundReferenceExpression>("fp_forumid_rowid", LogicalType::BIGINT, 0);
    join_condition_forum.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_forum = make_uniq<RAIInfo>();
    rai_info_forum->rai = table_forum_person.GetStorage().info->rais[0].get();
    rai_info_forum->rai_type = RAIType::TARGET_EDGE;
    rai_info_forum->forward = true;
    rai_info_forum->vertex = &table_forum;
    rai_info_forum->vertex_id = table_index_forum;
    rai_info_forum->passing_tables[0] = table_index_forum;
    rai_info_forum->left_cardinalities[0] = table_forum.GetStorage().info->cardinality;
    // rai_info_forum->compact_list = &rai_info_forum->rai->alist->compact_forward_list;

    join_condition_forum.rais.push_back(move(rai_info_forum));
    cond_forum.push_back(move(join_condition_forum));

    LogicalComparisonJoin join_forum_op(JoinType::INNER);
    vector<LogicalType> output_forum_types{LogicalType::VARCHAR, LogicalType::BIGINT, LogicalType::BIGINT};
    join_forum_op.types = output_forum_types;
    vector<idx_t> right_projection_map_forum{3};
    vector<idx_t> merge_project_map_forum;
    vector<LogicalType> delim_types_forum;
    auto join_forum = make_uniq<PhysicalSIPJoin>(join_forum_op, move(scan_forum), move(join_forum_person),
                                                 move(cond_forum),
                                                 JoinType::INNER, left_projection_map, right_projection_map_forum,
                                                 delim_types_forum, 0);

    // join post with person-person-forum
    vector<idx_t> post_ids{11, COLUMN_IDENTIFIER_ROW_ID, 13};
    vector<LogicalType> get_post_types{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::BIGINT};
    string alias_post = "m";
    vector<LogicalType> table_types_post;
    vector<unique_ptr<Expression>> filter_post;
    unique_ptr<LogicalGet> get_op_post = move(
            getLogicalGet(*this, table_post, alias_post, table_index_post, table_types_post));
    unique_ptr<TableFilterSet> table_filters_post = NULL;
    unique_ptr<PhysicalTableScan> scan_post = make_uniq<PhysicalTableScan>(get_post_types, get_op_post->function,
                                                                           get_op_post->table_index,
                                                                           move(get_op_post->bind_data),
                                                                           table_types_post, post_ids,
                                                                           move(filter_post), vector<column_t>(),
                                                                           get_op_post->names,
                                                                           std::move(table_filters_post),
                                                                           get_op_post->estimated_cardinality,
                                                                           get_op_post->extra_info);

    vector<JoinCondition> cond_post;
    JoinCondition join_condition_post, join_condition_post_2;
    join_condition_post.left = make_uniq<BoundReferenceExpression>("m_creatorid_rowid", LogicalType::BIGINT, 0);
    join_condition_post.right = make_uniq<BoundReferenceExpression>("person_rowid", LogicalType::BIGINT, 2);
    join_condition_post.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_post = make_uniq<RAIInfo>();
    rai_info_post->rai = table_post.GetStorage().info->rais[0].get();
    rai_info_post->rai_type = RAIType::EDGE_SOURCE;
    rai_info_post->forward = true;
    rai_info_post->vertex = &table_person;
    rai_info_post->vertex_id = table_index_person3;
    rai_info_post->passing_tables[0] = table_index_post;
    rai_info_post->left_cardinalities[0] = table_post.GetStorage().info->cardinality;
    rai_info_post->compact_list = &rai_info_post->rai->alist->compact_forward_list;

    join_condition_post_2.left = make_uniq<BoundReferenceExpression>("m_ps_forumid_rowid", LogicalType::BIGINT, 2);
    join_condition_post_2.right = make_uniq<BoundReferenceExpression>("forum_rowid", LogicalType::BIGINT, 1);
    join_condition_post_2.comparison = ExpressionType::COMPARE_EQUAL;

    join_condition_post.rais.push_back(move(rai_info_post));
    cond_post.push_back(move(join_condition_post));
    cond_post.push_back(move(join_condition_post_2));

    LogicalComparisonJoin join_post_op(JoinType::INNER);
    vector<LogicalType> output_post_types{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::BIGINT,
                                          LogicalType::VARCHAR};
    join_post_op.types = output_post_types;
    vector<idx_t> right_projection_map_post{0};
    vector<idx_t> merge_project_map_post;
    vector<LogicalType> delim_types_post;
    auto join_post = make_uniq<PhysicalSIPJoin>(join_post_op, move(scan_post), move(join_forum), move(cond_post),
                                                JoinType::INNER, left_projection_map, right_projection_map_post,
                                                delim_types_post, 0);



    // project
    vector<LogicalType> result_types{LogicalType::VARCHAR};
    vector<unique_ptr<Expression>> select_list;
    auto result_col0 = make_uniq<BoundReferenceExpression>("f_title", LogicalType::VARCHAR, 3);
    select_list.push_back(move(result_col0));
    auto projection = make_uniq<PhysicalProjection>(result_types, move(select_list), 0);
    projection->children.push_back(move(join_post));

    return projection;
}

unique_ptr<PhysicalOperator> ClientContext::GenerateIC61PlanGLogue() {
    vector<idx_t> left_projection_map, right_projection_map;

    string table_vertex_PERSON_p1 = "PERSON";
    string table_vertex_PERSON_p2 = "PERSON";
    string table_vertex_POST_m = "POST";
    string table_vertex_TAG_t1 = "TAG";
    string table_vertex_TAG_t2 = "TAG";
    string table_vertex_KNOWS_ = "KNOWS";
    string table_vertex_HASTAG_ = "POST_TAG";

    idx_t table_index_PERSON_p1 = 1;
    idx_t table_index_PERSON_p2 = 2;
    idx_t table_index_POST_m = 3;
    idx_t table_index_TAG_t1 = 4;
    idx_t table_index_TAG_t2 = 5;
    idx_t table_index_KNOWS_ = 6;
    idx_t table_index_HASTAG_ = 9;

    auto table_or_view_PERSON = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_PERSON_p1,
                                                  OnEntryNotFound::RETURN_NULL);
    auto &table_PERSON = table_or_view_PERSON->Cast<TableCatalogEntry>();
    auto table_or_view_POST = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_POST_m,
                                                OnEntryNotFound::RETURN_NULL);
    auto &table_POST = table_or_view_POST->Cast<TableCatalogEntry>();
    auto table_or_view_TAG = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_TAG_t1,
                                               OnEntryNotFound::RETURN_NULL);
    auto &table_TAG = table_or_view_TAG->Cast<TableCatalogEntry>();
    auto table_or_view_KNOWS = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_KNOWS_,
                                                 OnEntryNotFound::RETURN_NULL);
    auto &table_KNOWS = table_or_view_KNOWS->Cast<TableCatalogEntry>();
    auto table_or_view_HASTAG = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_HASTAG_,
                                                  OnEntryNotFound::RETURN_NULL);
    auto &table_HASTAG = table_or_view_HASTAG->Cast<TableCatalogEntry>();

    idx_t p_person_id = atoll(paras->data()[0].c_str()); // 933;
    Value p_person = Value::BIGINT(p_person_id);
    vector<idx_t> PERSON_p1_ids{0, COLUMN_IDENTIFIER_ROW_ID};
    vector<LogicalType> get_PERSON_p1_types{LogicalType::BIGINT, LogicalType::BIGINT};
    string alias_PERSON_p1 = "p1";
    vector<LogicalType> table_types_PERSON_p1;
    vector<unique_ptr<Expression>> filter_PERSON_p1;
    unique_ptr<LogicalGet> get_op_PERSON_p1 = move(
            getLogicalGet(*this, table_PERSON, alias_PERSON_p1, table_index_PERSON_p1, table_types_PERSON_p1));
    unique_ptr<TableFilterSet> table_filters_PERSON_p1 = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL,
                                                                                   p_person);
    table_filters_PERSON_p1->filters[0] = move(constant_filter);
    unique_ptr<PhysicalTableScan> scan_PERSON_p1 = make_uniq<PhysicalTableScan>(get_PERSON_p1_types,
                                                                                get_op_PERSON_p1->function,
                                                                                get_op_PERSON_p1->table_index,
                                                                                move(get_op_PERSON_p1->bind_data),
                                                                                table_types_PERSON_p1, PERSON_p1_ids,
                                                                                move(filter_PERSON_p1),
                                                                                vector<column_t>(),
                                                                                get_op_PERSON_p1->names,
                                                                                std::move(table_filters_PERSON_p1),
                                                                                get_op_PERSON_p1->estimated_cardinality,
                                                                                get_op_PERSON_p1->extra_info);


    vector<idx_t> PERSON_p2_ids{COLUMN_IDENTIFIER_ROW_ID};
    vector<LogicalType> get_PERSON_p2_types{LogicalType::BIGINT};
    string alias_PERSON_p2 = "p2";
    vector<LogicalType> table_types_PERSON_p2;
    vector<unique_ptr<Expression>> filter_PERSON_p2;
    unique_ptr<LogicalGet> get_op_PERSON_p2 = move(
            getLogicalGet(*this, table_PERSON, alias_PERSON_p2, table_index_PERSON_p2, table_types_PERSON_p2));
    unique_ptr<TableFilterSet> table_filters_PERSON_p2 = NULL;
    unique_ptr<PhysicalTableScan> scan_PERSON_p2 = make_uniq<PhysicalTableScan>(get_PERSON_p2_types,
                                                                                get_op_PERSON_p2->function,
                                                                                get_op_PERSON_p2->table_index,
                                                                                move(get_op_PERSON_p2->bind_data),
                                                                                table_types_PERSON_p2, PERSON_p2_ids,
                                                                                move(filter_PERSON_p2),
                                                                                vector<column_t>(),
                                                                                get_op_PERSON_p2->names,
                                                                                std::move(table_filters_PERSON_p2),
                                                                                get_op_PERSON_p2->estimated_cardinality,
                                                                                get_op_PERSON_p2->extra_info);


    vector<JoinCondition> cond_KNOWS_;
    JoinCondition join_condition_KNOWS_;
    join_condition_KNOWS_.left = make_uniq<BoundReferenceExpression>("person_rowid", LogicalType::BIGINT, 0);
    join_condition_KNOWS_.right = make_uniq<BoundReferenceExpression>("person_rowid", LogicalType::BIGINT, 1);
    join_condition_KNOWS_.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_KNOWS_ = make_uniq<RAIInfo>();
    rai_info_KNOWS_->rai = table_KNOWS.GetStorage().info->rais[0].get();
    rai_info_KNOWS_->rai_type = RAIType::TARGET_EDGE;
    rai_info_KNOWS_->forward = true;
    rai_info_KNOWS_->vertex = &table_PERSON;
    rai_info_KNOWS_->vertex_id = table_index_PERSON_p2;
    rai_info_KNOWS_->passing_tables[0] = table_index_PERSON_p2;
    rai_info_KNOWS_->left_cardinalities[0] = table_PERSON.GetStorage().info->cardinality;
    // rai_info_KNOWS_->compact_list = &rai_info_KNOWS_->rai->alist->compact__list;

    join_condition_KNOWS_.rais.push_back(move(rai_info_KNOWS_));
    cond_KNOWS_.push_back(move(join_condition_KNOWS_));

    LogicalComparisonJoin join_KNOWS__op(JoinType::INNER);
    vector<LogicalType> output_KNOWS__types{LogicalType::BIGINT, LogicalType::BIGINT};
    join_KNOWS__op.types = output_KNOWS__types;
    vector<idx_t> right_projection_map_KNOWS_{1};
    vector<idx_t> merge_project_map_KNOWS_;
    vector<LogicalType> delim_types_KNOWS_;
    auto join_KNOWS_ = make_uniq<PhysicalMergeSIPJoin>(join_KNOWS__op, move(scan_PERSON_p2), move(scan_PERSON_p1), move(cond_KNOWS_),
                                                       JoinType::INNER, left_projection_map,
                                                       right_projection_map_KNOWS_, merge_project_map_KNOWS_,
                                                       delim_types_KNOWS_, 0);


    vector<idx_t> POST_m_ids{COLUMN_IDENTIFIER_ROW_ID, 11};
    vector<LogicalType> get_POST_m_types{LogicalType::BIGINT, LogicalType::BIGINT};
    string alias_POST_m = "m";
    vector<LogicalType> table_types_POST_m;
    vector<unique_ptr<Expression>> filter_POST_m;
    unique_ptr<LogicalGet> get_op_POST_m = move(
            getLogicalGet(*this, table_POST, alias_POST_m, table_index_POST_m, table_types_POST_m));
    unique_ptr<TableFilterSet> table_filters_POST_m = NULL;
    unique_ptr<PhysicalTableScan> scan_POST_m = make_uniq<PhysicalTableScan>(get_POST_m_types, get_op_POST_m->function,
                                                                             get_op_POST_m->table_index,
                                                                             move(get_op_POST_m->bind_data),
                                                                             table_types_POST_m, POST_m_ids,
                                                                             move(filter_POST_m), vector<column_t>(),
                                                                             get_op_POST_m->names,
                                                                             std::move(table_filters_POST_m),
                                                                             get_op_POST_m->estimated_cardinality,
                                                                             get_op_POST_m->extra_info);


    vector<JoinCondition> cond_HASCREATOR_;
    JoinCondition join_condition_HASCREATOR_;
    join_condition_HASCREATOR_.left = make_uniq<BoundReferenceExpression>("m_creatorid_rowid", LogicalType::BIGINT, 1);
    join_condition_HASCREATOR_.right = make_uniq<BoundReferenceExpression>("person_rowid", LogicalType::BIGINT, 0);
    join_condition_HASCREATOR_.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_HASCREATOR_ = make_uniq<RAIInfo>();
    rai_info_HASCREATOR_->rai = table_POST.GetStorage().info->rais[0].get();
    rai_info_HASCREATOR_->rai_type = RAIType::EDGE_SOURCE;
    rai_info_HASCREATOR_->forward = true;
    rai_info_HASCREATOR_->vertex = &table_PERSON;
    rai_info_HASCREATOR_->vertex_id = table_index_PERSON_p2;
    rai_info_HASCREATOR_->passing_tables[0] = table_index_POST_m;
    rai_info_HASCREATOR_->left_cardinalities[0] = table_POST.GetStorage().info->cardinality;
    rai_info_HASCREATOR_->compact_list = &rai_info_HASCREATOR_->rai->alist->compact_forward_list;

    join_condition_HASCREATOR_.rais.push_back(move(rai_info_HASCREATOR_));
    cond_HASCREATOR_.push_back(move(join_condition_HASCREATOR_));

    LogicalComparisonJoin join_HASCREATOR__op(JoinType::INNER);
    vector<LogicalType> output_HASCREATOR__types{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::BIGINT};
    join_HASCREATOR__op.types = output_HASCREATOR__types;
    vector<idx_t> right_projection_map_HASCREATOR_{0};
    vector<idx_t> merge_project_map_HASCREATOR_;
    vector<LogicalType> delim_types_HASCREATOR_;
    auto join_HASCREATOR_ = make_uniq<PhysicalSIPJoin>(join_HASCREATOR__op, move(scan_POST_m), move(join_KNOWS_), move(cond_HASCREATOR_),
                                                            JoinType::INNER, left_projection_map,
                                                            right_projection_map_HASCREATOR_,
                                                            delim_types_HASCREATOR_, 0);

    string p_tag_name = paras->data()[1].c_str(); // 933;
    Value p_tag = Value(p_tag_name);
    vector<idx_t> TAG_t1_ids{COLUMN_IDENTIFIER_ROW_ID, 1};
    vector<LogicalType> get_TAG_t1_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_TAG_t1 = "t1";
    vector<LogicalType> table_types_TAG_t1;
    vector<unique_ptr<Expression>> filter_TAG_t1;
    unique_ptr<LogicalGet> get_op_TAG_t1 = move(
            getLogicalGet(*this, table_TAG, alias_TAG_t1, table_index_TAG_t1, table_types_TAG_t1));
    unique_ptr<TableFilterSet> table_filters_TAG_t1 = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_TAG_t1 = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL,
                                                                                   p_tag_name);
    table_filters_TAG_t1->filters[1] = move(constant_filter_TAG_t1);
    unique_ptr<PhysicalTableScan> scan_TAG_t1 = make_uniq<PhysicalTableScan>(get_TAG_t1_types, get_op_TAG_t1->function,
                                                                             get_op_TAG_t1->table_index,
                                                                             move(get_op_TAG_t1->bind_data),
                                                                             table_types_TAG_t1, TAG_t1_ids,
                                                                             move(filter_TAG_t1), vector<column_t>(),
                                                                             get_op_TAG_t1->names,
                                                                             std::move(table_filters_TAG_t1),
                                                                             get_op_TAG_t1->estimated_cardinality,
                                                                             get_op_TAG_t1->extra_info);


    vector<JoinCondition> cond_HASTAG_;
    JoinCondition join_condition_HASTAG_;
    join_condition_HASTAG_.left = make_uniq<BoundReferenceExpression>("tag_rowid", LogicalType::BIGINT, 0);
    join_condition_HASTAG_.right = make_uniq<BoundReferenceExpression>("post_rowid", LogicalType::BIGINT, 0);
    join_condition_HASTAG_.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_HASTAG_ = make_uniq<RAIInfo>();
    rai_info_HASTAG_->rai = table_HASTAG.GetStorage().info->rais[0].get();
    rai_info_HASTAG_->rai_type = RAIType::TARGET_EDGE;
    rai_info_HASTAG_->forward = true;
    rai_info_HASTAG_->vertex = &table_TAG;
    rai_info_HASTAG_->vertex_id = table_index_TAG_t1;
    rai_info_HASTAG_->passing_tables[0] = table_index_TAG_t1;
    rai_info_HASTAG_->left_cardinalities[0] = table_TAG.GetStorage().info->cardinality;
    // rai_info_HASTAG_->compact_list = &rai_info_HASTAG_->rai->alist->compact__list;

    join_condition_HASTAG_.rais.push_back(move(rai_info_HASTAG_));
    cond_HASTAG_.push_back(move(join_condition_HASTAG_));

    LogicalComparisonJoin join_HASTAG__op(JoinType::INNER);
    vector<LogicalType> output_HASTAG__types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::BIGINT};
    join_HASTAG__op.types = output_HASTAG__types;
    vector<idx_t> right_projection_map_HASTAG_{0};
    vector<idx_t> merge_project_map_HASTAG_;
    vector<LogicalType> delim_types_HASTAG_;
    auto join_HASTAG_ = make_uniq<PhysicalMergeSIPJoin>(join_HASTAG__op, move(scan_TAG_t1), move(join_HASCREATOR_), move(cond_HASTAG_),
                                                        JoinType::INNER, left_projection_map,
                                                        right_projection_map_HASTAG_, merge_project_map_HASTAG_,
                                                        delim_types_HASTAG_, 0);


    vector<idx_t> TAG_t2_ids{COLUMN_IDENTIFIER_ROW_ID, 1};
    vector<LogicalType> get_TAG_t2_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_TAG_t2 = "t2";
    vector<LogicalType> table_types_TAG_t2;
    vector<unique_ptr<Expression>> filter_TAG_t2;
    unique_ptr<LogicalGet> get_op_TAG_t2 = move(
            getLogicalGet(*this, table_TAG, alias_TAG_t2, table_index_TAG_t2, table_types_TAG_t2));
    unique_ptr<TableFilterSet> table_filters_TAG_t2 = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_TAG_t2 = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_NOTEQUAL,
                                                                                          p_tag_name);
    table_filters_TAG_t2->filters[1] = move(constant_filter_TAG_t2);
    unique_ptr<PhysicalTableScan> scan_TAG_t2 = make_uniq<PhysicalTableScan>(get_TAG_t2_types, get_op_TAG_t2->function,
                                                                             get_op_TAG_t2->table_index,
                                                                             move(get_op_TAG_t2->bind_data),
                                                                             table_types_TAG_t2, TAG_t2_ids,
                                                                             move(filter_TAG_t2), vector<column_t>(),
                                                                             get_op_TAG_t2->names,
                                                                             std::move(table_filters_TAG_t2),
                                                                             get_op_TAG_t2->estimated_cardinality,
                                                                             get_op_TAG_t2->extra_info);


    vector<JoinCondition> cond_TAG_t2;
    JoinCondition join_condition_TAG_t2;
    join_condition_TAG_t2.left = make_uniq<BoundReferenceExpression>("tag_rowid", LogicalType::BIGINT, 0);
    join_condition_TAG_t2.right = make_uniq<BoundReferenceExpression>("post_rowid", LogicalType::BIGINT, 2);
    join_condition_TAG_t2.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_TAG_t2 = make_uniq<RAIInfo>();
    rai_info_TAG_t2->rai = table_HASTAG.GetStorage().info->rais[0].get();
    rai_info_TAG_t2->rai_type = RAIType::TARGET_EDGE;
    rai_info_TAG_t2->forward = true;
    rai_info_TAG_t2->vertex = &table_TAG;
    rai_info_TAG_t2->vertex_id = table_index_TAG_t2;
    rai_info_TAG_t2->passing_tables[0] = table_index_TAG_t2;
    rai_info_TAG_t2->left_cardinalities[0] = table_TAG.GetStorage().info->cardinality;
    // rai_info_TAG_t2->compact_list = &rai_info_TAG_t2->rai->alist->compact__list;

    join_condition_TAG_t2.rais.push_back(move(rai_info_TAG_t2));
    cond_TAG_t2.push_back(move(join_condition_TAG_t2));

    LogicalComparisonJoin join_TAG_t2_op(JoinType::INNER);
    vector<LogicalType> output_TAG_t2_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::BIGINT};
    join_TAG_t2_op.types = output_TAG_t2_types;
    vector<idx_t> right_projection_map_TAG_t2{0};
    vector<idx_t> merge_project_map_TAG_t2;
    vector<LogicalType> delim_types_TAG_t2;
    auto join_TAG_t2 = make_uniq<PhysicalMergeSIPJoin>(join_TAG_t2_op, move(scan_TAG_t2), move(join_HASTAG_), move(cond_TAG_t2), JoinType::INNER,
                                                       left_projection_map, right_projection_map_TAG_t2,
                                                       merge_project_map_TAG_t2, delim_types_TAG_t2,
                                                       0);


    vector<LogicalType> result_types{LogicalType::VARCHAR};
    vector<unique_ptr<Expression>> select_list;
    auto result_col0 = make_uniq<BoundReferenceExpression>("t_name", LogicalType::VARCHAR, 1);
    select_list.push_back(move(result_col0));
    auto projection = make_uniq<PhysicalProjection>(result_types, move(select_list), 0);
    projection->children.push_back(move(join_TAG_t2));

    return projection;
}

unique_ptr<PhysicalOperator> ClientContext::GenerateIC62PlanGLogue() {
    vector<idx_t> left_projection_map, right_projection_map;

    string table_vertex_PERSON_p1 = "PERSON";
    string table_vertex_PERSON_p2 = "PERSON";
    string table_vertex_PERSON_p3 = "PERSON";
    string table_vertex_POST_m = "POST";
    string table_vertex_TAG_t1 = "TAG";
    string table_vertex_TAG_t2 = "TAG";
    string table_vertex_KNOWS_ = "KNOWS";
    string table_vertex_HASTAG_ = "POST_TAG";

    idx_t table_index_PERSON_p1 = 1;
    idx_t table_index_PERSON_p2 = 2;
    idx_t table_index_PERSON_p3 = 7;
    idx_t table_index_POST_m = 3;
    idx_t table_index_TAG_t1 = 4;
    idx_t table_index_TAG_t2 = 5;
    idx_t table_index_KNOWS_ = 6;
    idx_t table_index_HASTAG_ = 9;

    auto table_or_view_PERSON = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_PERSON_p1,
                                                  OnEntryNotFound::RETURN_NULL);
    auto &table_PERSON = table_or_view_PERSON->Cast<TableCatalogEntry>();
    auto table_or_view_POST = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_POST_m,
                                                OnEntryNotFound::RETURN_NULL);
    auto &table_POST = table_or_view_POST->Cast<TableCatalogEntry>();
    auto table_or_view_TAG = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_TAG_t1,
                                               OnEntryNotFound::RETURN_NULL);
    auto &table_TAG = table_or_view_TAG->Cast<TableCatalogEntry>();
    auto table_or_view_KNOWS = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_KNOWS_,
                                                 OnEntryNotFound::RETURN_NULL);
    auto &table_KNOWS = table_or_view_KNOWS->Cast<TableCatalogEntry>();
    auto table_or_view_HASTAG = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_HASTAG_,
                                                  OnEntryNotFound::RETURN_NULL);
    auto &table_HASTAG = table_or_view_HASTAG->Cast<TableCatalogEntry>();

    idx_t p_person_id = atoll(paras->data()[0].c_str()); // 933;
    Value p_person = Value::BIGINT(p_person_id);
    vector<idx_t> PERSON_p1_ids{0, COLUMN_IDENTIFIER_ROW_ID};
    vector<LogicalType> get_PERSON_p1_types{LogicalType::BIGINT, LogicalType::BIGINT};
    string alias_PERSON_p1 = "p1";
    vector<LogicalType> table_types_PERSON_p1;
    vector<unique_ptr<Expression>> filter_PERSON_p1;
    unique_ptr<LogicalGet> get_op_PERSON_p1 = move(
            getLogicalGet(*this, table_PERSON, alias_PERSON_p1, table_index_PERSON_p1, table_types_PERSON_p1));
    unique_ptr<TableFilterSet> table_filters_PERSON_p1 = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL,
                                                                                   p_person);
    table_filters_PERSON_p1->filters[0] = move(constant_filter);
    unique_ptr<PhysicalTableScan> scan_PERSON_p1 = make_uniq<PhysicalTableScan>(get_PERSON_p1_types,
                                                                                get_op_PERSON_p1->function,
                                                                                get_op_PERSON_p1->table_index,
                                                                                move(get_op_PERSON_p1->bind_data),
                                                                                table_types_PERSON_p1, PERSON_p1_ids,
                                                                                move(filter_PERSON_p1),
                                                                                vector<column_t>(),
                                                                                get_op_PERSON_p1->names,
                                                                                std::move(table_filters_PERSON_p1),
                                                                                get_op_PERSON_p1->estimated_cardinality,
                                                                                get_op_PERSON_p1->extra_info);


    vector<idx_t> PERSON_p2_ids{COLUMN_IDENTIFIER_ROW_ID};
    vector<LogicalType> get_PERSON_p2_types{LogicalType::BIGINT};
    string alias_PERSON_p2 = "p2";
    vector<LogicalType> table_types_PERSON_p2;
    vector<unique_ptr<Expression>> filter_PERSON_p2;
    unique_ptr<LogicalGet> get_op_PERSON_p2 = move(
            getLogicalGet(*this, table_PERSON, alias_PERSON_p2, table_index_PERSON_p2, table_types_PERSON_p2));
    unique_ptr<TableFilterSet> table_filters_PERSON_p2 = NULL;
    unique_ptr<PhysicalTableScan> scan_PERSON_p2 = make_uniq<PhysicalTableScan>(get_PERSON_p2_types,
                                                                                get_op_PERSON_p2->function,
                                                                                get_op_PERSON_p2->table_index,
                                                                                move(get_op_PERSON_p2->bind_data),
                                                                                table_types_PERSON_p2, PERSON_p2_ids,
                                                                                move(filter_PERSON_p2),
                                                                                vector<column_t>(),
                                                                                get_op_PERSON_p2->names,
                                                                                std::move(table_filters_PERSON_p2),
                                                                                get_op_PERSON_p2->estimated_cardinality,
                                                                                get_op_PERSON_p2->extra_info);


    vector<JoinCondition> cond_KNOWS_;
    JoinCondition join_condition_KNOWS_;
    join_condition_KNOWS_.left = make_uniq<BoundReferenceExpression>("person_rowid", LogicalType::BIGINT, 0);
    join_condition_KNOWS_.right = make_uniq<BoundReferenceExpression>("person_rowid", LogicalType::BIGINT, 1);
    join_condition_KNOWS_.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_KNOWS_ = make_uniq<RAIInfo>();
    rai_info_KNOWS_->rai = table_KNOWS.GetStorage().info->rais[0].get();
    rai_info_KNOWS_->rai_type = RAIType::TARGET_EDGE;
    rai_info_KNOWS_->forward = true;
    rai_info_KNOWS_->vertex = &table_PERSON;
    rai_info_KNOWS_->vertex_id = table_index_PERSON_p2;
    rai_info_KNOWS_->passing_tables[0] = table_index_PERSON_p2;
    rai_info_KNOWS_->left_cardinalities[0] = table_PERSON.GetStorage().info->cardinality;
    // rai_info_KNOWS_->compact_list = &rai_info_KNOWS_->rai->alist->compact__list;

    join_condition_KNOWS_.rais.push_back(move(rai_info_KNOWS_));
    cond_KNOWS_.push_back(move(join_condition_KNOWS_));

    LogicalComparisonJoin join_KNOWS__op(JoinType::INNER);
    vector<LogicalType> output_KNOWS__types{LogicalType::BIGINT, LogicalType::BIGINT};
    join_KNOWS__op.types = output_KNOWS__types;
    vector<idx_t> right_projection_map_KNOWS_{1};
    vector<idx_t> merge_project_map_KNOWS_;
    vector<LogicalType> delim_types_KNOWS_;
    auto join_KNOWS_ = make_uniq<PhysicalMergeSIPJoin>(join_KNOWS__op, move(scan_PERSON_p2), move(scan_PERSON_p1),
                                                       move(cond_KNOWS_),
                                                       JoinType::INNER, left_projection_map,
                                                       right_projection_map_KNOWS_, merge_project_map_KNOWS_,
                                                       delim_types_KNOWS_, 0);

    vector<idx_t> PERSON_p3_ids{COLUMN_IDENTIFIER_ROW_ID};
    vector<LogicalType> get_PERSON_p3_types{LogicalType::BIGINT};
    string alias_PERSON_p3 = "p3";
    vector<LogicalType> table_types_PERSON_p3;
    vector<unique_ptr<Expression>> filter_PERSON_p3;
    unique_ptr<LogicalGet> get_op_PERSON_p3 = move(
            getLogicalGet(*this, table_PERSON, alias_PERSON_p3, table_index_PERSON_p3, table_types_PERSON_p3));
    unique_ptr<TableFilterSet> table_filters_PERSON_p3 = NULL;
    unique_ptr<PhysicalTableScan> scan_PERSON_p3 = make_uniq<PhysicalTableScan>(get_PERSON_p3_types,
                                                                                get_op_PERSON_p3->function,
                                                                                get_op_PERSON_p3->table_index,
                                                                                move(get_op_PERSON_p3->bind_data),
                                                                                table_types_PERSON_p3, PERSON_p3_ids,
                                                                                move(filter_PERSON_p3),
                                                                                vector<column_t>(),
                                                                                get_op_PERSON_p3->names,
                                                                                std::move(table_filters_PERSON_p3),
                                                                                get_op_PERSON_p3->estimated_cardinality,
                                                                                get_op_PERSON_p3->extra_info);


    vector<JoinCondition> cond_KNOWS_k2;
    JoinCondition join_condition_KNOWS_k2;
    join_condition_KNOWS_k2.left = make_uniq<BoundReferenceExpression>("person_rowid", LogicalType::BIGINT, 0);
    join_condition_KNOWS_k2.right = make_uniq<BoundReferenceExpression>("person_rowid", LogicalType::BIGINT, 0);
    join_condition_KNOWS_k2.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_KNOWS_k2 = make_uniq<RAIInfo>();
    rai_info_KNOWS_k2->rai = table_KNOWS.GetStorage().info->rais[0].get();
    rai_info_KNOWS_k2->rai_type = RAIType::TARGET_EDGE;
    rai_info_KNOWS_k2->forward = true;
    rai_info_KNOWS_k2->vertex = &table_PERSON;
    rai_info_KNOWS_k2->vertex_id = table_index_PERSON_p3;
    rai_info_KNOWS_k2->passing_tables[0] = table_index_PERSON_p3;
    rai_info_KNOWS_k2->left_cardinalities[0] = table_PERSON.GetStorage().info->cardinality;
    // rai_info_KNOWS_->compact_list = &rai_info_KNOWS_->rai->alist->compact__list;

    join_condition_KNOWS_k2.rais.push_back(move(rai_info_KNOWS_k2));
    cond_KNOWS_k2.push_back(move(join_condition_KNOWS_k2));

    LogicalComparisonJoin join_KNOWS_k2_op(JoinType::INNER);
    vector<LogicalType> output_KNOWS_k2_types{LogicalType::BIGINT, LogicalType::BIGINT};
    join_KNOWS_k2_op.types = output_KNOWS_k2_types;
    vector<idx_t> right_projection_map_KNOWS_k2{1};
    vector<idx_t> merge_project_map_KNOWS_k2;
    vector<LogicalType> delim_types_KNOWS_k2;
    auto join_KNOWS_k2 = make_uniq<PhysicalMergeSIPJoin>(join_KNOWS_k2_op, move(scan_PERSON_p3), move(join_KNOWS_),
                                                       move(cond_KNOWS_k2),
                                                       JoinType::INNER, left_projection_map,
                                                       right_projection_map_KNOWS_k2, merge_project_map_KNOWS_k2,
                                                       delim_types_KNOWS_k2, 0);


    vector<idx_t> POST_m_ids{COLUMN_IDENTIFIER_ROW_ID, 11};
    vector<LogicalType> get_POST_m_types{LogicalType::BIGINT, LogicalType::BIGINT};
    string alias_POST_m = "m";
    vector<LogicalType> table_types_POST_m;
    vector<unique_ptr<Expression>> filter_POST_m;
    unique_ptr<LogicalGet> get_op_POST_m = move(
            getLogicalGet(*this, table_POST, alias_POST_m, table_index_POST_m, table_types_POST_m));
    unique_ptr<TableFilterSet> table_filters_POST_m = NULL;
    unique_ptr<PhysicalTableScan> scan_POST_m = make_uniq<PhysicalTableScan>(get_POST_m_types, get_op_POST_m->function,
                                                                             get_op_POST_m->table_index,
                                                                             move(get_op_POST_m->bind_data),
                                                                             table_types_POST_m, POST_m_ids,
                                                                             move(filter_POST_m), vector<column_t>(),
                                                                             get_op_POST_m->names,
                                                                             std::move(table_filters_POST_m),
                                                                             get_op_POST_m->estimated_cardinality,
                                                                             get_op_POST_m->extra_info);


    vector<JoinCondition> cond_HASCREATOR_;
    JoinCondition join_condition_HASCREATOR_;
    join_condition_HASCREATOR_.left = make_uniq<BoundReferenceExpression>("m_creatorid_rowid", LogicalType::BIGINT, 1);
    join_condition_HASCREATOR_.right = make_uniq<BoundReferenceExpression>("person_rowid", LogicalType::BIGINT, 0);
    join_condition_HASCREATOR_.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_HASCREATOR_ = make_uniq<RAIInfo>();
    rai_info_HASCREATOR_->rai = table_POST.GetStorage().info->rais[0].get();
    rai_info_HASCREATOR_->rai_type = RAIType::EDGE_SOURCE;
    rai_info_HASCREATOR_->forward = true;
    rai_info_HASCREATOR_->vertex = &table_PERSON;
    rai_info_HASCREATOR_->vertex_id = table_index_PERSON_p2;
    rai_info_HASCREATOR_->passing_tables[0] = table_index_POST_m;
    rai_info_HASCREATOR_->left_cardinalities[0] = table_POST.GetStorage().info->cardinality;
    rai_info_HASCREATOR_->compact_list = &rai_info_HASCREATOR_->rai->alist->compact_forward_list;

    join_condition_HASCREATOR_.rais.push_back(move(rai_info_HASCREATOR_));
    cond_HASCREATOR_.push_back(move(join_condition_HASCREATOR_));

    LogicalComparisonJoin join_HASCREATOR__op(JoinType::INNER);
    vector<LogicalType> output_HASCREATOR__types{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::BIGINT};
    join_HASCREATOR__op.types = output_HASCREATOR__types;
    vector<idx_t> right_projection_map_HASCREATOR_{0};
    vector<idx_t> merge_project_map_HASCREATOR_;
    vector<LogicalType> delim_types_HASCREATOR_;
    auto join_HASCREATOR_ = make_uniq<PhysicalSIPJoin>(join_HASCREATOR__op, move(scan_POST_m), move(join_KNOWS_k2),
                                                       move(cond_HASCREATOR_),
                                                       JoinType::INNER, left_projection_map,
                                                       right_projection_map_HASCREATOR_,
                                                       delim_types_HASCREATOR_, 0);

    string p_tag_name = paras->data()[1].c_str(); // 933;
    Value p_tag = Value(p_tag_name);
    vector<idx_t> TAG_t1_ids{COLUMN_IDENTIFIER_ROW_ID, 1};
    vector<LogicalType> get_TAG_t1_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_TAG_t1 = "t1";
    vector<LogicalType> table_types_TAG_t1;
    vector<unique_ptr<Expression>> filter_TAG_t1;
    unique_ptr<LogicalGet> get_op_TAG_t1 = move(
            getLogicalGet(*this, table_TAG, alias_TAG_t1, table_index_TAG_t1, table_types_TAG_t1));
    unique_ptr<TableFilterSet> table_filters_TAG_t1 = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_TAG_t1 = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL,
                                                                                          p_tag_name);
    table_filters_TAG_t1->filters[1] = move(constant_filter_TAG_t1);
    unique_ptr<PhysicalTableScan> scan_TAG_t1 = make_uniq<PhysicalTableScan>(get_TAG_t1_types, get_op_TAG_t1->function,
                                                                             get_op_TAG_t1->table_index,
                                                                             move(get_op_TAG_t1->bind_data),
                                                                             table_types_TAG_t1, TAG_t1_ids,
                                                                             move(filter_TAG_t1), vector<column_t>(),
                                                                             get_op_TAG_t1->names,
                                                                             std::move(table_filters_TAG_t1),
                                                                             get_op_TAG_t1->estimated_cardinality,
                                                                             get_op_TAG_t1->extra_info);


    vector<JoinCondition> cond_HASTAG_;
    JoinCondition join_condition_HASTAG_;
    join_condition_HASTAG_.left = make_uniq<BoundReferenceExpression>("tag_rowid", LogicalType::BIGINT, 0);
    join_condition_HASTAG_.right = make_uniq<BoundReferenceExpression>("post_rowid", LogicalType::BIGINT, 0);
    join_condition_HASTAG_.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_HASTAG_ = make_uniq<RAIInfo>();
    rai_info_HASTAG_->rai = table_HASTAG.GetStorage().info->rais[0].get();
    rai_info_HASTAG_->rai_type = RAIType::TARGET_EDGE;
    rai_info_HASTAG_->forward = true;
    rai_info_HASTAG_->vertex = &table_TAG;
    rai_info_HASTAG_->vertex_id = table_index_TAG_t1;
    rai_info_HASTAG_->passing_tables[0] = table_index_TAG_t1;
    rai_info_HASTAG_->left_cardinalities[0] = table_TAG.GetStorage().info->cardinality;
    // rai_info_HASTAG_->compact_list = &rai_info_HASTAG_->rai->alist->compact__list;

    join_condition_HASTAG_.rais.push_back(move(rai_info_HASTAG_));
    cond_HASTAG_.push_back(move(join_condition_HASTAG_));

    LogicalComparisonJoin join_HASTAG__op(JoinType::INNER);
    vector<LogicalType> output_HASTAG__types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::BIGINT};
    join_HASTAG__op.types = output_HASTAG__types;
    vector<idx_t> right_projection_map_HASTAG_{0};
    vector<idx_t> merge_project_map_HASTAG_;
    vector<LogicalType> delim_types_HASTAG_;
    auto join_HASTAG_ = make_uniq<PhysicalMergeSIPJoin>(join_HASTAG__op, move(scan_TAG_t1), move(join_HASCREATOR_),
                                                        move(cond_HASTAG_),
                                                        JoinType::INNER, left_projection_map,
                                                        right_projection_map_HASTAG_, merge_project_map_HASTAG_,
                                                        delim_types_HASTAG_, 0);


    vector<idx_t> TAG_t2_ids{COLUMN_IDENTIFIER_ROW_ID, 1};
    vector<LogicalType> get_TAG_t2_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_TAG_t2 = "t2";
    vector<LogicalType> table_types_TAG_t2;
    vector<unique_ptr<Expression>> filter_TAG_t2;
    unique_ptr<LogicalGet> get_op_TAG_t2 = move(
            getLogicalGet(*this, table_TAG, alias_TAG_t2, table_index_TAG_t2, table_types_TAG_t2));
    unique_ptr<TableFilterSet> table_filters_TAG_t2 = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_TAG_t2 = duckdb::make_uniq<ConstantFilter>(
            ExpressionType::COMPARE_NOTEQUAL,
            p_tag_name);
    table_filters_TAG_t2->filters[1] = move(constant_filter_TAG_t2);
    unique_ptr<PhysicalTableScan> scan_TAG_t2 = make_uniq<PhysicalTableScan>(get_TAG_t2_types, get_op_TAG_t2->function,
                                                                             get_op_TAG_t2->table_index,
                                                                             move(get_op_TAG_t2->bind_data),
                                                                             table_types_TAG_t2, TAG_t2_ids,
                                                                             move(filter_TAG_t2), vector<column_t>(),
                                                                             get_op_TAG_t2->names,
                                                                             std::move(table_filters_TAG_t2),
                                                                             get_op_TAG_t2->estimated_cardinality,
                                                                             get_op_TAG_t2->extra_info);


    vector<JoinCondition> cond_TAG_t2;
    JoinCondition join_condition_TAG_t2;
    join_condition_TAG_t2.left = make_uniq<BoundReferenceExpression>("tag_rowid", LogicalType::BIGINT, 0);
    join_condition_TAG_t2.right = make_uniq<BoundReferenceExpression>("post_rowid", LogicalType::BIGINT, 2);
    join_condition_TAG_t2.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_TAG_t2 = make_uniq<RAIInfo>();
    rai_info_TAG_t2->rai = table_HASTAG.GetStorage().info->rais[0].get();
    rai_info_TAG_t2->rai_type = RAIType::TARGET_EDGE;
    rai_info_TAG_t2->forward = true;
    rai_info_TAG_t2->vertex = &table_TAG;
    rai_info_TAG_t2->vertex_id = table_index_TAG_t2;
    rai_info_TAG_t2->passing_tables[0] = table_index_TAG_t2;
    rai_info_TAG_t2->left_cardinalities[0] = table_TAG.GetStorage().info->cardinality;
    // rai_info_TAG_t2->compact_list = &rai_info_TAG_t2->rai->alist->compact__list;

    join_condition_TAG_t2.rais.push_back(move(rai_info_TAG_t2));
    cond_TAG_t2.push_back(move(join_condition_TAG_t2));

    LogicalComparisonJoin join_TAG_t2_op(JoinType::INNER);
    vector<LogicalType> output_TAG_t2_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::BIGINT};
    join_TAG_t2_op.types = output_TAG_t2_types;
    vector<idx_t> right_projection_map_TAG_t2{0};
    vector<idx_t> merge_project_map_TAG_t2;
    vector<LogicalType> delim_types_TAG_t2;
    auto join_TAG_t2 = make_uniq<PhysicalMergeSIPJoin>(join_TAG_t2_op, move(scan_TAG_t2), move(join_HASTAG_),
                                                       move(cond_TAG_t2), JoinType::INNER,
                                                       left_projection_map, right_projection_map_TAG_t2,
                                                       merge_project_map_TAG_t2, delim_types_TAG_t2,
                                                       0);


    vector<LogicalType> result_types{LogicalType::VARCHAR};
    vector<unique_ptr<Expression>> select_list;
    auto result_col0 = make_uniq<BoundReferenceExpression>("t_name", LogicalType::VARCHAR, 1);
    select_list.push_back(move(result_col0));
    auto projection = make_uniq<PhysicalProjection>(result_types, move(select_list), 0);
    projection->children.push_back(move(join_TAG_t2));

    return projection;
}

unique_ptr<PhysicalOperator> ClientContext::GenerateIC71PlanGLogue() {
    vector<idx_t> left_projection_map, right_projection_map;

    string table_vertex_person = "person";
    string table_edge_knows = "knows";
    string table_vertex_comment = "comment";
    string table_edge_likes_comment = "likes_comment";

    idx_t table_index_person1 = 6;
    idx_t table_index_person2 = 8;
    idx_t table_index_knows = 7;
    idx_t table_index_comment = 11;
    idx_t table_index_likes_comment = 12;


    auto table_or_view_person = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                  table_vertex_person, OnEntryNotFound::RETURN_NULL);
    auto &table_person = table_or_view_person->Cast<TableCatalogEntry>();

    auto table_or_view_knows = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                 table_edge_knows, OnEntryNotFound::RETURN_NULL);
    auto &table_knows = table_or_view_knows->Cast<TableCatalogEntry>();

    auto table_or_view_comment = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                 table_vertex_comment, OnEntryNotFound::RETURN_NULL);
    auto &table_comment = table_or_view_comment->Cast<TableCatalogEntry>();

    auto table_or_view_likes_comment = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                   table_edge_likes_comment, OnEntryNotFound::RETURN_NULL);
    auto &table_likes_comment = table_or_view_likes_comment->Cast<TableCatalogEntry>();


    vector<idx_t> comment_ids{COLUMN_IDENTIFIER_ROW_ID, 10, 4};
    vector<LogicalType> get_comment_types{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_comment = "c";
    vector<LogicalType> table_types_comment;
    vector<unique_ptr<Expression>> filter_comment;
    unique_ptr<LogicalGet> get_op_comment = move(
            getLogicalGet(*this, table_comment, alias_comment, table_index_comment, table_types_comment));
    unique_ptr<TableFilterSet> table_filters_comment = NULL;
    unique_ptr<PhysicalTableScan> scan_comment = make_uniq<PhysicalTableScan>(get_comment_types,
                                                                              get_op_comment->function,
                                                                              get_op_comment->table_index,
                                                                              move(get_op_comment->bind_data),
                                                                              table_types_comment, comment_ids,
                                                                              move(filter_comment), vector<column_t>(),
                                                                              get_op_comment->names,
                                                                              std::move(table_filters_comment),
                                                                              get_op_comment->estimated_cardinality,
                                                                              get_op_comment->extra_info);

    idx_t p_person_id = atoll(paras->data()[0].c_str()); // 933;
    Value p_person = Value::BIGINT(p_person_id);
    vector<idx_t> person1_ids{0, COLUMN_IDENTIFIER_ROW_ID};
    vector<LogicalType> get_person1_types{LogicalType::BIGINT, LogicalType::BIGINT};
    string alias_person1 = "p1";
    vector<LogicalType> table_types_person1;
    unique_ptr<LogicalGet> get_op_person1 = move(
            getLogicalGet(*this, table_person, alias_person1, table_index_person1, table_types_person1));
    vector<unique_ptr<Expression>> filter_person1;
    unique_ptr<TableFilterSet> table_filters_person1 = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL,
                                                                                   p_person);
    table_filters_person1->filters[0] = move(constant_filter);
    unique_ptr<PhysicalTableScan> scan_person1 = make_uniq<PhysicalTableScan>(get_person1_types,
                                                                              get_op_person1->function,
                                                                              get_op_person1->table_index,
                                                                              move(get_op_person1->bind_data),
                                                                              table_types_person1, person1_ids,
                                                                              move(filter_person1), vector<column_t>(),
                                                                              get_op_person1->names,
                                                                              std::move(table_filters_person1),
                                                                              get_op_person1->estimated_cardinality,
                                                                              get_op_person1->extra_info);

    vector<JoinCondition> cond_hascreator;
    JoinCondition join_condition_hascreator;
    join_condition_hascreator.left = make_uniq<BoundReferenceExpression>("m_creator_rowid", LogicalType::BIGINT, 1);
    join_condition_hascreator.right = make_uniq<BoundReferenceExpression>("person_rowid", LogicalType::BIGINT, 1);
    join_condition_hascreator.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_hascreator = make_uniq<RAIInfo>();
    rai_info_hascreator->rai = table_comment.GetStorage().info->rais[0].get();
    rai_info_hascreator->rai_type = RAIType::EDGE_SOURCE;
    rai_info_hascreator->forward = true;
    rai_info_hascreator->vertex = &table_person;
    rai_info_hascreator->vertex_id = table_index_person2;
    rai_info_hascreator->passing_tables[0] = table_index_comment;
    rai_info_hascreator->left_cardinalities[0] = table_comment.GetStorage().info->cardinality;
    rai_info_hascreator->compact_list = &rai_info_hascreator->rai->alist->compact_forward_list;

    join_condition_hascreator.rais.push_back(move(rai_info_hascreator));
    cond_hascreator.push_back(move(join_condition_hascreator));

    LogicalComparisonJoin join_hascreator_op(JoinType::INNER);
    vector<LogicalType> output_hascreator_types{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::VARCHAR,
                                           LogicalType::BIGINT};
    join_hascreator_op.types = output_hascreator_types;
    vector<idx_t> right_projection_map_hascreator{1};
    vector<idx_t> merge_project_map_hascreator;
    vector<LogicalType> delim_types_hascreator;
    auto join_hascreator = make_uniq<PhysicalSIPJoin>(join_hascreator_op, move(scan_comment), move(scan_person1),
                                                      move(cond_hascreator),
                                                      JoinType::INNER, left_projection_map, right_projection_map_hascreator,
                                                      delim_types_hascreator, 0);

    vector<idx_t> person2_ids{COLUMN_IDENTIFIER_ROW_ID, 0, 1, 2};
    vector<LogicalType> get_person2_types{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::VARCHAR,
                                          LogicalType::VARCHAR};
    string alias_person2 = "p2";
    vector<LogicalType> table_types_person2;
    vector<unique_ptr<Expression>> filter_person2;
    unique_ptr<LogicalGet> get_op_person2 = move(
            getLogicalGet(*this, table_person, alias_person2, table_index_person2, table_types_person2));
    unique_ptr<TableFilterSet> table_filters_person2 = NULL;
    unique_ptr<PhysicalTableScan> scan_person2 = make_uniq<PhysicalTableScan>(get_person2_types,
                                                                              get_op_person2->function,
                                                                              get_op_person2->table_index,
                                                                              move(get_op_person2->bind_data),
                                                                              table_types_person2, person2_ids,
                                                                              move(filter_person2), vector<column_t>(),
                                                                              get_op_person2->names,
                                                                              std::move(table_filters_person2),
                                                                              get_op_person2->estimated_cardinality,
                                                                              get_op_person2->extra_info);

    vector<JoinCondition> cond_merge, cond_pkfk;
    JoinCondition join_condition_knows;
    join_condition_knows.left = make_uniq<BoundReferenceExpression>("person_rowid", LogicalType::BIGINT, 0);
    join_condition_knows.right = make_uniq<BoundReferenceExpression>("person_rowid", LogicalType::BIGINT, 3);
    join_condition_knows.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_knows = make_uniq<RAIInfo>();
    rai_info_knows->rai = table_knows.GetStorage().info->rais[0].get();
    rai_info_knows->rai_type = RAIType::TARGET_EDGE;
    rai_info_knows->forward = true;
    rai_info_knows->vertex = &table_person;
    rai_info_knows->vertex_id = table_index_person2;
    rai_info_knows->passing_tables[0] = table_index_person2;
    rai_info_knows->left_cardinalities[0] = table_person.GetStorage().info->cardinality;
    // rai_info_knows->compact_list = &rai_info_knows->rai->alist->compact_backward_list;

    join_condition_knows.rais.push_back(move(rai_info_knows));
    cond_merge.push_back(move(join_condition_knows));

    JoinCondition join_condition_likes_comment;
    join_condition_likes_comment.left = make_uniq<BoundReferenceExpression>("person_rowid", LogicalType::BIGINT, 0);
    join_condition_likes_comment.right = make_uniq<BoundReferenceExpression>("comment_rowid", LogicalType::BIGINT, 0);
    join_condition_likes_comment.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_likes_comment = make_uniq<RAIInfo>();
    rai_info_likes_comment->rai = table_likes_comment.GetStorage().info->rais[0].get();
    rai_info_likes_comment->rai_type = RAIType::SOURCE_EDGE;
    rai_info_likes_comment->forward = false;
    rai_info_likes_comment->vertex = &table_person;
    rai_info_likes_comment->vertex_id = table_index_person2;
    rai_info_likes_comment->passing_tables[0] = table_index_person2;
    rai_info_likes_comment->left_cardinalities[0] = table_person.GetStorage().info->cardinality;
    // rai_info_knows->compact_list = &rai_info_knows->rai->alist->compact_backward_list;

    join_condition_likes_comment.rais.push_back(move(rai_info_likes_comment));
    cond_merge.push_back(move(join_condition_likes_comment));

    LogicalComparisonJoin join_person2_op(JoinType::INNER);
    vector<LogicalType> output_person2_types{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::VARCHAR,
                                           LogicalType::VARCHAR, LogicalType::VARCHAR};
    join_person2_op.types = output_person2_types;
    vector<idx_t> right_projection_map_person2{2};
    vector<idx_t> merge_project_map_person2;
    vector<LogicalType> delim_types_person2;
    auto join_person2 = make_uniq<PhysicalExtendIntersect>(join_person2_op, move(scan_person2), move(join_hascreator),
                                                      move(cond_merge), move(cond_pkfk),
                                                      JoinType::INNER, left_projection_map, right_projection_map_person2,
                                                      merge_project_map_person2, delim_types_person2, 0);


    // project
    vector<LogicalType> result_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::VARCHAR,
                                     LogicalType::VARCHAR};
    vector<unique_ptr<Expression>> select_list;
    auto result_col0 = make_uniq<BoundReferenceExpression>("p_personid", LogicalType::BIGINT, 1);
    auto result_col1 = make_uniq<BoundReferenceExpression>("p_firstname", LogicalType::VARCHAR, 2);
    auto result_col2 = make_uniq<BoundReferenceExpression>("p_lastname", LogicalType::VARCHAR, 3);
    auto result_col3 = make_uniq<BoundReferenceExpression>("m_content", LogicalType::VARCHAR, 4);

    select_list.push_back(move(result_col0));
    select_list.push_back(move(result_col1));
    select_list.push_back(move(result_col2));
    select_list.push_back(move(result_col3));

    auto projection = make_uniq<PhysicalProjection>(result_types, move(select_list), 0);
    projection->children.push_back(move(join_person2));

    return projection;
}

unique_ptr<PhysicalOperator> ClientContext::GenerateIC71PlanGLogueNoIntersect() {
    vector<idx_t> left_projection_map, right_projection_map;

    string table_vertex_person = "person";
    string table_edge_knows = "knows";
    string table_vertex_comment = "comment";
    string table_edge_likes_comment = "likes_comment";

    idx_t table_index_person1 = 6;
    idx_t table_index_person2 = 8;
    idx_t table_index_knows = 7;
    idx_t table_index_comment = 11;
    idx_t table_index_likes_comment = 12;


    auto table_or_view_person = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                  table_vertex_person, OnEntryNotFound::RETURN_NULL);
    auto &table_person = table_or_view_person->Cast<TableCatalogEntry>();

    auto table_or_view_knows = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                 table_edge_knows, OnEntryNotFound::RETURN_NULL);
    auto &table_knows = table_or_view_knows->Cast<TableCatalogEntry>();

    auto table_or_view_comment = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                   table_vertex_comment, OnEntryNotFound::RETURN_NULL);
    auto &table_comment = table_or_view_comment->Cast<TableCatalogEntry>();

    auto table_or_view_likes_comment = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                         table_edge_likes_comment, OnEntryNotFound::RETURN_NULL);
    auto &table_likes_comment = table_or_view_likes_comment->Cast<TableCatalogEntry>();


    vector<idx_t> comment_ids{COLUMN_IDENTIFIER_ROW_ID, 10, 4};
    vector<LogicalType> get_comment_types{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_comment = "c";
    vector<LogicalType> table_types_comment;
    vector<unique_ptr<Expression>> filter_comment;
    unique_ptr<LogicalGet> get_op_comment = move(
            getLogicalGet(*this, table_comment, alias_comment, table_index_comment, table_types_comment));
    unique_ptr<TableFilterSet> table_filters_comment = NULL;
    unique_ptr<PhysicalTableScan> scan_comment = make_uniq<PhysicalTableScan>(get_comment_types,
                                                                              get_op_comment->function,
                                                                              get_op_comment->table_index,
                                                                              move(get_op_comment->bind_data),
                                                                              table_types_comment, comment_ids,
                                                                              move(filter_comment), vector<column_t>(),
                                                                              get_op_comment->names,
                                                                              std::move(table_filters_comment),
                                                                              get_op_comment->estimated_cardinality,
                                                                              get_op_comment->extra_info);

    idx_t p_person_id = atoll(paras->data()[0].c_str()); // 933;
    Value p_person = Value::BIGINT(p_person_id);
    vector<idx_t> person1_ids{0, COLUMN_IDENTIFIER_ROW_ID};
    vector<LogicalType> get_person1_types{LogicalType::BIGINT, LogicalType::BIGINT};
    string alias_person1 = "p1";
    vector<LogicalType> table_types_person1;
    unique_ptr<LogicalGet> get_op_person1 = move(
            getLogicalGet(*this, table_person, alias_person1, table_index_person1, table_types_person1));
    vector<unique_ptr<Expression>> filter_person1;
    unique_ptr<TableFilterSet> table_filters_person1 = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL,
                                                                                   p_person);
    table_filters_person1->filters[0] = move(constant_filter);
    unique_ptr<PhysicalTableScan> scan_person1 = make_uniq<PhysicalTableScan>(get_person1_types,
                                                                              get_op_person1->function,
                                                                              get_op_person1->table_index,
                                                                              move(get_op_person1->bind_data),
                                                                              table_types_person1, person1_ids,
                                                                              move(filter_person1), vector<column_t>(),
                                                                              get_op_person1->names,
                                                                              std::move(table_filters_person1),
                                                                              get_op_person1->estimated_cardinality,
                                                                              get_op_person1->extra_info);

    vector<JoinCondition> cond_hascreator;
    JoinCondition join_condition_hascreator;
    join_condition_hascreator.left = make_uniq<BoundReferenceExpression>("m_creator_rowid", LogicalType::BIGINT, 1);
    join_condition_hascreator.right = make_uniq<BoundReferenceExpression>("person_rowid", LogicalType::BIGINT, 1);
    join_condition_hascreator.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_hascreator = make_uniq<RAIInfo>();
    rai_info_hascreator->rai = table_comment.GetStorage().info->rais[0].get();
    rai_info_hascreator->rai_type = RAIType::EDGE_SOURCE;
    rai_info_hascreator->forward = true;
    rai_info_hascreator->vertex = &table_person;
    rai_info_hascreator->vertex_id = table_index_person2;
    rai_info_hascreator->passing_tables[0] = table_index_comment;
    rai_info_hascreator->left_cardinalities[0] = table_comment.GetStorage().info->cardinality;
    rai_info_hascreator->compact_list = &rai_info_hascreator->rai->alist->compact_forward_list;

    join_condition_hascreator.rais.push_back(move(rai_info_hascreator));
    cond_hascreator.push_back(move(join_condition_hascreator));

    LogicalComparisonJoin join_hascreator_op(JoinType::INNER);
    vector<LogicalType> output_hascreator_types{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::VARCHAR,
                                                LogicalType::BIGINT};
    join_hascreator_op.types = output_hascreator_types;
    vector<idx_t> right_projection_map_hascreator{1};
    vector<idx_t> merge_project_map_hascreator;
    vector<LogicalType> delim_types_hascreator;
    auto join_hascreator = make_uniq<PhysicalSIPJoin>(join_hascreator_op, move(scan_comment), move(scan_person1),
                                                      move(cond_hascreator),
                                                      JoinType::INNER, left_projection_map,
                                                      right_projection_map_hascreator,
                                                      delim_types_hascreator, 0);

    vector<idx_t> person2_ids{COLUMN_IDENTIFIER_ROW_ID, 0, 1, 2};
    vector<LogicalType> get_person2_types{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::VARCHAR,
                                          LogicalType::VARCHAR};
    string alias_person2 = "p2";
    vector<LogicalType> table_types_person2;
    vector<unique_ptr<Expression>> filter_person2;
    unique_ptr<LogicalGet> get_op_person2 = move(
            getLogicalGet(*this, table_person, alias_person2, table_index_person2, table_types_person2));
    unique_ptr<TableFilterSet> table_filters_person2 = NULL;
    unique_ptr<PhysicalTableScan> scan_person2 = make_uniq<PhysicalTableScan>(get_person2_types,
                                                                              get_op_person2->function,
                                                                              get_op_person2->table_index,
                                                                              move(get_op_person2->bind_data),
                                                                              table_types_person2, person2_ids,
                                                                              move(filter_person2), vector<column_t>(),
                                                                              get_op_person2->names,
                                                                              std::move(table_filters_person2),
                                                                              get_op_person2->estimated_cardinality,
                                                                              get_op_person2->extra_info);

    vector<JoinCondition> cond_likes_comment;
    JoinCondition join_condition_likes_comment;
    join_condition_likes_comment.left = make_uniq<BoundReferenceExpression>("person_rowid", LogicalType::BIGINT, 0);
    join_condition_likes_comment.right = make_uniq<BoundReferenceExpression>("comment_rowid", LogicalType::BIGINT, 0);
    join_condition_likes_comment.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_likes_comment = make_uniq<RAIInfo>();
    rai_info_likes_comment->rai = table_likes_comment.GetStorage().info->rais[0].get();
    rai_info_likes_comment->rai_type = RAIType::SOURCE_EDGE;
    rai_info_likes_comment->forward = false;
    rai_info_likes_comment->vertex = &table_person;
    rai_info_likes_comment->vertex_id = table_index_person2;
    rai_info_likes_comment->passing_tables[0] = table_index_person2;
    rai_info_likes_comment->left_cardinalities[0] = table_person.GetStorage().info->cardinality;
    // rai_info_likes_comment->compact_list = &rai_info_likes_comment->rai->alist->compact_forward_list;

    join_condition_likes_comment.rais.push_back(move(rai_info_likes_comment));
    cond_likes_comment.push_back(move(join_condition_likes_comment));

    LogicalComparisonJoin join_likes_comment_op(JoinType::INNER);
    vector<LogicalType> output_likes_comment_types{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::VARCHAR,
                                                   LogicalType::VARCHAR, LogicalType::VARCHAR, LogicalType::BIGINT};
    join_likes_comment_op.types = output_likes_comment_types;
    vector<idx_t> right_projection_map_likes_comment{2, 3};
    vector<idx_t> merge_project_map_likes_comment;
    vector<LogicalType> delim_types_likes_comment;
    auto join_likes_comment = make_uniq<PhysicalMergeSIPJoin>(join_likes_comment_op, move(scan_person2),
                                                         move(join_hascreator), move(cond_likes_comment),
                                                         JoinType::INNER, left_projection_map,
                                                         right_projection_map_likes_comment, merge_project_map_likes_comment,
                                                         delim_types_likes_comment, 0);

    vector<idx_t> knows_ids{3, 4};
    vector<LogicalType> get_knows_types{LogicalType::BIGINT, LogicalType::BIGINT};
    string alias_knows = "l";
    vector<LogicalType> table_types_knows;
    vector<unique_ptr<Expression>> filter_knows;
    unique_ptr<LogicalGet> get_op_knows = move(
            getLogicalGet(*this, table_knows, alias_knows, table_index_knows, table_types_knows));
    unique_ptr<TableFilterSet> table_filters_knows = NULL;
    unique_ptr<PhysicalTableScan> scan_knows = make_uniq<PhysicalTableScan>(get_knows_types,
                                                                            get_op_knows->function,
                                                                            get_op_knows->table_index,
                                                                            move(get_op_knows->bind_data),
                                                                            table_types_knows, knows_ids,
                                                                            move(filter_knows), vector<column_t>(),
                                                                            get_op_knows->names,
                                                                            std::move(table_filters_knows),
                                                                            get_op_knows->estimated_cardinality,
                                                                            get_op_knows->extra_info);


    vector<JoinCondition> cond_knows;
    JoinCondition join_condition_knows, join_condition_knows_2;
    join_condition_knows.left = make_uniq<BoundReferenceExpression>("k_person1id_rowid", LogicalType::BIGINT, 0);
    join_condition_knows.right = make_uniq<BoundReferenceExpression>("person_rowid", LogicalType::BIGINT, 5);
    join_condition_knows.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_knows = make_uniq<RAIInfo>();
    rai_info_knows->rai = table_knows.GetStorage().info->rais[0].get();
    rai_info_knows->rai_type = RAIType::EDGE_SOURCE;
    rai_info_knows->forward = true;
    rai_info_knows->vertex = &table_person;
    rai_info_knows->vertex_id = table_index_person1;
    rai_info_knows->passing_tables[0] = table_index_knows;
    rai_info_knows->left_cardinalities[0] = table_knows.GetStorage().info->cardinality;
    rai_info_knows->compact_list = &rai_info_knows->rai->alist->compact_forward_list;

    join_condition_knows.rais.push_back(move(rai_info_knows));
    cond_knows.push_back(move(join_condition_knows));

    join_condition_knows_2.left = make_uniq<BoundReferenceExpression>("k_person2id_rowid", LogicalType::BIGINT, 1);
    join_condition_knows_2.right = make_uniq<BoundReferenceExpression>("person_rowid", LogicalType::BIGINT, 0);
    join_condition_knows_2.comparison = ExpressionType::COMPARE_EQUAL;
    cond_knows.push_back(move(join_condition_knows_2));

    LogicalComparisonJoin join_knows_op(JoinType::INNER);
    vector<LogicalType> output_knows_types{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::BIGINT,
                                             LogicalType::VARCHAR, LogicalType::VARCHAR, LogicalType::VARCHAR};
    join_knows_op.types = output_knows_types;
    vector<idx_t> right_projection_map_knows{1, 2, 3, 4};
    vector<idx_t> merge_project_map_knows;
    vector<LogicalType> delim_types_knows;
    auto join_knows = make_uniq<PhysicalSIPJoin>(join_knows_op, move(scan_knows), move(join_likes_comment),
                                                           move(cond_knows), JoinType::INNER, left_projection_map,
                                                           right_projection_map_knows,
                                                           delim_types_knows, 0);


    // project
    vector<LogicalType> result_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::VARCHAR,
                                     LogicalType::VARCHAR};
    vector<unique_ptr<Expression>> select_list;
    auto result_col0 = make_uniq<BoundReferenceExpression>("p_personid", LogicalType::BIGINT, 2);
    auto result_col1 = make_uniq<BoundReferenceExpression>("p_firstname", LogicalType::VARCHAR, 3);
    auto result_col2 = make_uniq<BoundReferenceExpression>("p_lastname", LogicalType::VARCHAR, 4);
    auto result_col3 = make_uniq<BoundReferenceExpression>("m_content", LogicalType::VARCHAR, 5);

    select_list.push_back(move(result_col0));
    select_list.push_back(move(result_col1));
    select_list.push_back(move(result_col2));
    select_list.push_back(move(result_col3));

    auto projection = make_uniq<PhysicalProjection>(result_types, move(select_list), 0);
    projection->children.push_back(move(join_knows));

    return projection;
}

unique_ptr<PhysicalOperator> ClientContext::GenerateIC81PlanGLogue() {
    vector<idx_t> left_projection_map, right_projection_map;

    string table_vertex_PERSON_p1 = "PERSON";
    string table_vertex_POST_ps = "POST";
    string table_vertex_COMMENT_c = "COMMENT";
    string table_vertex_PERSON_p2 = "PERSON";

    idx_t table_index_PERSON_p1 = 1;
    idx_t table_index_POST_ps = 2;
    idx_t table_index_COMMENT_c = 3;
    idx_t table_index_PERSON_p2 = 4;

    auto table_or_view_PERSON = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_PERSON_p1, OnEntryNotFound::RETURN_NULL);
    auto &table_PERSON = table_or_view_PERSON->Cast<TableCatalogEntry>();
    auto table_or_view_POST = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_POST_ps, OnEntryNotFound::RETURN_NULL);
    auto &table_POST = table_or_view_POST->Cast<TableCatalogEntry>();
    auto table_or_view_COMMENT = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_COMMENT_c, OnEntryNotFound::RETURN_NULL);
    auto &table_COMMENT = table_or_view_COMMENT->Cast<TableCatalogEntry>();

    idx_t p_person_id = atoll(paras->data()[0].c_str()); // 933;
    Value p_person = Value::BIGINT(p_person_id);
    vector<idx_t> PERSON_p1_ids{0, COLUMN_IDENTIFIER_ROW_ID};
    vector<LogicalType> get_PERSON_p1_types{LogicalType::BIGINT, LogicalType::BIGINT};
    string alias_PERSON_p1 = "p1";
    vector<LogicalType> table_types_PERSON_p1;
    vector<unique_ptr<Expression>> filter_PERSON_p1;
    unique_ptr<LogicalGet> get_op_PERSON_p1 = move(getLogicalGet(*this, table_PERSON, alias_PERSON_p1, table_index_PERSON_p1, table_types_PERSON_p1));
    unique_ptr<TableFilterSet> table_filters_PERSON_p1 = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL,
                                                                                   p_person);
    table_filters_PERSON_p1->filters[0] = move(constant_filter);
    unique_ptr<PhysicalTableScan> scan_PERSON_p1 = make_uniq<PhysicalTableScan>(get_PERSON_p1_types, get_op_PERSON_p1->function, get_op_PERSON_p1->table_index, move(get_op_PERSON_p1->bind_data), table_types_PERSON_p1, PERSON_p1_ids, move(filter_PERSON_p1), vector<column_t>(), get_op_PERSON_p1->names, std::move(table_filters_PERSON_p1), get_op_PERSON_p1->estimated_cardinality, get_op_PERSON_p1->extra_info);


    vector<idx_t> POST_ps_ids{11, COLUMN_IDENTIFIER_ROW_ID};
    vector<LogicalType> get_POST_ps_types{LogicalType::BIGINT, LogicalType::BIGINT};
    string alias_POST_ps = "ps";
    vector<LogicalType> table_types_POST_ps;
    vector<unique_ptr<Expression>> filter_POST_ps;
    unique_ptr<LogicalGet> get_op_POST_ps = move(getLogicalGet(*this, table_POST, alias_POST_ps, table_index_POST_ps, table_types_POST_ps));
    unique_ptr<TableFilterSet> table_filters_POST_ps = NULL;
    unique_ptr<PhysicalTableScan> scan_POST_ps = make_uniq<PhysicalTableScan>(get_POST_ps_types, get_op_POST_ps->function, get_op_POST_ps->table_index, move(get_op_POST_ps->bind_data), table_types_POST_ps, POST_ps_ids, move(filter_POST_ps), vector<column_t>(), get_op_POST_ps->names, std::move(table_filters_POST_ps), get_op_POST_ps->estimated_cardinality, get_op_POST_ps->extra_info);


    vector<JoinCondition> cond_HASCREATOR_;
    JoinCondition join_condition_HASCREATOR_;
    join_condition_HASCREATOR_.left = make_uniq<BoundReferenceExpression>("m_creatorid_rowid", LogicalType::BIGINT, 0);
    join_condition_HASCREATOR_.right = make_uniq<BoundReferenceExpression>("person_rowid", LogicalType::BIGINT, 1);
    join_condition_HASCREATOR_.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_HASCREATOR_ = make_uniq<RAIInfo>();
    rai_info_HASCREATOR_->rai = table_POST.GetStorage().info->rais[0].get();
    rai_info_HASCREATOR_->rai_type = RAIType::EDGE_SOURCE;
    rai_info_HASCREATOR_->forward = true;
    rai_info_HASCREATOR_->vertex = &table_PERSON;
    rai_info_HASCREATOR_->vertex_id = table_index_PERSON_p1;
    rai_info_HASCREATOR_->passing_tables[0] = table_index_POST_ps;
    rai_info_HASCREATOR_->left_cardinalities[0] = table_POST.GetStorage().info->cardinality;
    rai_info_HASCREATOR_->compact_list = &rai_info_HASCREATOR_->rai->alist->compact_forward_list;

    join_condition_HASCREATOR_.rais.push_back(move(rai_info_HASCREATOR_));
    cond_HASCREATOR_.push_back(move(join_condition_HASCREATOR_));

    LogicalComparisonJoin join_HASCREATOR__op(JoinType::INNER);
    vector<LogicalType> output_HASCREATOR__types{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::BIGINT};
    join_HASCREATOR__op.types = output_HASCREATOR__types;
    vector<idx_t> right_projection_map_HASCREATOR_{1};
    vector<idx_t> merge_project_map_HASCREATOR_;
    vector<LogicalType> delim_types_HASCREATOR_;
    auto join_HASCREATOR_ = make_uniq<PhysicalSIPJoin>(join_HASCREATOR__op, move(scan_POST_ps),
                                                            move(scan_PERSON_p1), move(cond_HASCREATOR_),
                                                            JoinType::INNER, left_projection_map,
                                                            right_projection_map_HASCREATOR_,
                                                            delim_types_HASCREATOR_, 0);


    vector<idx_t> COMMENT_c_ids{10, 13, 1, 0, 4};
    vector<LogicalType> get_COMMENT_c_types{LogicalType::BIGINT, LogicalType::BIGINT,
                                            LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_COMMENT_c = "c";
    vector<LogicalType> table_types_COMMENT_c;
    vector<unique_ptr<Expression>> filter_COMMENT_c;
    unique_ptr<LogicalGet> get_op_COMMENT_c = move(getLogicalGet(*this, table_COMMENT, alias_COMMENT_c, table_index_COMMENT_c, table_types_COMMENT_c));
    unique_ptr<TableFilterSet> table_filters_COMMENT_c = NULL;
    unique_ptr<PhysicalTableScan> scan_COMMENT_c = make_uniq<PhysicalTableScan>(get_COMMENT_c_types, get_op_COMMENT_c->function, get_op_COMMENT_c->table_index, move(get_op_COMMENT_c->bind_data), table_types_COMMENT_c, COMMENT_c_ids, move(filter_COMMENT_c), vector<column_t>(), get_op_COMMENT_c->names, std::move(table_filters_COMMENT_c), get_op_COMMENT_c->estimated_cardinality, get_op_COMMENT_c->extra_info);


    vector<JoinCondition> cond_REPLYOF_;
    JoinCondition join_condition_REPLYOF_;
    join_condition_REPLYOF_.left = make_uniq<BoundReferenceExpression>("m_replyof_post_rowid", LogicalType::BIGINT, 1);
    join_condition_REPLYOF_.right = make_uniq<BoundReferenceExpression>("post_rowid", LogicalType::BIGINT, 1);
    join_condition_REPLYOF_.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_REPLYOF_ = make_uniq<RAIInfo>();
    rai_info_REPLYOF_->rai = table_COMMENT.GetStorage().info->rais[3].get();
    rai_info_REPLYOF_->rai_type = RAIType::EDGE_SOURCE;
    rai_info_REPLYOF_->forward = true;
    rai_info_REPLYOF_->vertex = &table_POST;
    rai_info_REPLYOF_->vertex_id = table_index_POST_ps;
    rai_info_REPLYOF_->passing_tables[0] = table_index_COMMENT_c;
    rai_info_REPLYOF_->left_cardinalities[0] = table_COMMENT.GetStorage().info->cardinality;
    rai_info_REPLYOF_->compact_list = &rai_info_REPLYOF_->rai->alist->compact_forward_list;

    join_condition_REPLYOF_.rais.push_back(move(rai_info_REPLYOF_));
    cond_REPLYOF_.push_back(move(join_condition_REPLYOF_));

    LogicalComparisonJoin join_REPLYOF__op(JoinType::INNER);
    vector<LogicalType> output_REPLYOF__types{LogicalType::BIGINT, LogicalType::BIGINT,
                                            LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::VARCHAR,
                                            LogicalType::BIGINT};
    join_REPLYOF__op.types = output_REPLYOF__types;
    vector<idx_t> right_projection_map_REPLYOF_{1};
    vector<idx_t> merge_project_map_REPLYOF_;
    vector<LogicalType> delim_types_REPLYOF_;
    auto join_REPLYOF_ = make_uniq<PhysicalSIPJoin>(join_REPLYOF__op, move(scan_COMMENT_c), move(join_HASCREATOR_), move(cond_REPLYOF_), JoinType::INNER, left_projection_map, right_projection_map_REPLYOF_, delim_types_REPLYOF_, 0);


    vector<idx_t> PERSON_p2_ids{COLUMN_IDENTIFIER_ROW_ID, 0, 1, 2};
    vector<LogicalType> get_PERSON_p2_types{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::VARCHAR};
    string alias_PERSON_p2 = "p2";
    vector<LogicalType> table_types_PERSON_p2;
    vector<unique_ptr<Expression>> filter_PERSON_p2;
    unique_ptr<LogicalGet> get_op_PERSON_p2 = move(getLogicalGet(*this, table_PERSON, alias_PERSON_p2, table_index_PERSON_p2, table_types_PERSON_p2));
    unique_ptr<TableFilterSet> table_filters_PERSON_p2 = NULL;
    unique_ptr<PhysicalTableScan> scan_PERSON_p2 = make_uniq<PhysicalTableScan>(get_PERSON_p2_types, get_op_PERSON_p2->function, get_op_PERSON_p2->table_index, move(get_op_PERSON_p2->bind_data), table_types_PERSON_p2, PERSON_p2_ids, move(filter_PERSON_p2), vector<column_t>(), get_op_PERSON_p2->names, std::move(table_filters_PERSON_p2), get_op_PERSON_p2->estimated_cardinality, get_op_PERSON_p2->extra_info);


    vector<JoinCondition> cond_HASCREATOR_h2;
    JoinCondition join_condition_HASCREATOR_h2;
    join_condition_HASCREATOR_h2.left = make_uniq<BoundReferenceExpression>("person_rowid", LogicalType::BIGINT, 0);
    join_condition_HASCREATOR_h2.right = make_uniq<BoundReferenceExpression>("m_creator_rowid", LogicalType::BIGINT, 0);
    join_condition_HASCREATOR_h2.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_HASCREATOR_h2 = make_uniq<RAIInfo>();
    rai_info_HASCREATOR_h2->rai = table_COMMENT.GetStorage().info->rais[0].get();
    rai_info_HASCREATOR_h2->rai_type = RAIType::TARGET_EDGE;
    rai_info_HASCREATOR_h2->forward = true;
    rai_info_HASCREATOR_h2->vertex = &table_PERSON;
    rai_info_HASCREATOR_h2->vertex_id = table_index_PERSON_p2;
    rai_info_HASCREATOR_h2->passing_tables[0] = table_index_PERSON_p2;
    rai_info_HASCREATOR_h2->left_cardinalities[0] = table_PERSON.GetStorage().info->cardinality;
    // rai_info_HASCREATOR_h2->compact_list = &rai_info_HASCREATOR_h2->rai->alist->compact__list;

    join_condition_HASCREATOR_h2.rais.push_back(move(rai_info_HASCREATOR_h2));
    cond_HASCREATOR_h2.push_back(move(join_condition_HASCREATOR_h2));

    LogicalComparisonJoin join_HASCREATOR_h2_op(JoinType::INNER);
    vector<LogicalType> output_HASCREATOR_h2_types{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::VARCHAR,
                                                   LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::VARCHAR};
    join_HASCREATOR_h2_op.types = output_HASCREATOR_h2_types;
    vector<idx_t> right_projection_map_HASCREATOR_h2{2, 3, 4};
    vector<idx_t> merge_project_map_HASCREATOR_h2;
    vector<LogicalType> delim_types_HASCREATOR_h2;
    auto join_HASCREATOR_h2 = make_uniq<PhysicalSIPJoin>(join_HASCREATOR_h2_op, move(scan_PERSON_p2), move(join_REPLYOF_),
                                                         move(cond_HASCREATOR_h2), JoinType::INNER, left_projection_map,
                                                         right_projection_map_HASCREATOR_h2, delim_types_HASCREATOR_h2, 0);


    vector<LogicalType> result_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::VARCHAR,
                                     LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::VARCHAR};
    vector<unique_ptr<Expression>> select_list;
    auto result_col0 = make_uniq<BoundReferenceExpression>("p_personid", LogicalType::BIGINT, 1);
    auto result_col1 = make_uniq<BoundReferenceExpression>("p_firstname", LogicalType::VARCHAR, 2);
    auto result_col2 = make_uniq<BoundReferenceExpression>("p_lastname", LogicalType::VARCHAR, 3);
    auto result_col3 = make_uniq<BoundReferenceExpression>("m_creationdate", LogicalType::BIGINT, 4);
    auto result_col4 = make_uniq<BoundReferenceExpression>("m_messageid", LogicalType::BIGINT, 5);
    auto result_col5 = make_uniq<BoundReferenceExpression>("m_content", LogicalType::VARCHAR, 6);
    select_list.push_back(move(result_col0));
    select_list.push_back(move(result_col1));
    select_list.push_back(move(result_col2));
    select_list.push_back(move(result_col3));
    select_list.push_back(move(result_col4));
    select_list.push_back(move(result_col5));
    auto projection = make_uniq<PhysicalProjection>(result_types, move(select_list), 0);
    projection->children.push_back(move(join_HASCREATOR_h2));

    return projection;
}

unique_ptr<PhysicalOperator> ClientContext::GenerateIC91PlanGLogue() {
    vector<idx_t> left_projection_map, right_projection_map;

    string table_vertex_PERSON_p1 = "PERSON";
    string table_vertex_PERSON_p2 = "PERSON";
    string table_vertex_COMMENT_c = "COMMENT";
    string table_vertex_KNOWS_ = "KNOWS";

    idx_t table_index_PERSON_p1 = 1;
    idx_t table_index_PERSON_p2 = 2;
    idx_t table_index_COMMENT_c = 3;
    idx_t table_index_KNOWS_ = 4;
    idx_t table_index_HASCREATOR_ = 5;
    auto table_or_view_PERSON = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_PERSON_p1,
                                                  OnEntryNotFound::RETURN_NULL);
    auto &table_PERSON = table_or_view_PERSON->Cast<TableCatalogEntry>();
    auto table_or_view_COMMENT = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_COMMENT_c,
                                                   OnEntryNotFound::RETURN_NULL);
    auto &table_COMMENT = table_or_view_COMMENT->Cast<TableCatalogEntry>();
    auto table_or_view_KNOWS = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_KNOWS_,
                                                 OnEntryNotFound::RETURN_NULL);
    auto &table_KNOWS = table_or_view_KNOWS->Cast<TableCatalogEntry>();

    idx_t p_person_id = atoll(paras->data()[0].c_str()); // 933;
    Value p_person = Value::BIGINT(p_person_id);
    vector<idx_t> PERSON_p1_ids{0, COLUMN_IDENTIFIER_ROW_ID};
    vector<LogicalType> get_PERSON_p1_types{LogicalType::BIGINT, LogicalType::BIGINT};
    string alias_PERSON_p1 = "p1";
    vector<LogicalType> table_types_PERSON_p1;
    vector<unique_ptr<Expression>> filter_PERSON_p1;
    unique_ptr<LogicalGet> get_op_PERSON_p1 = move(
            getLogicalGet(*this, table_PERSON, alias_PERSON_p1, table_index_PERSON_p1, table_types_PERSON_p1));
    unique_ptr<TableFilterSet> table_filters_PERSON_p1 = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL,
                                                                                   p_person);
    table_filters_PERSON_p1->filters[0] = move(constant_filter);
    unique_ptr<PhysicalTableScan> scan_PERSON_p1 = make_uniq<PhysicalTableScan>(get_PERSON_p1_types,
                                                                                get_op_PERSON_p1->function,
                                                                                get_op_PERSON_p1->table_index,
                                                                                move(get_op_PERSON_p1->bind_data),
                                                                                table_types_PERSON_p1, PERSON_p1_ids,
                                                                                move(filter_PERSON_p1),
                                                                                vector<column_t>(),
                                                                                get_op_PERSON_p1->names,
                                                                                std::move(table_filters_PERSON_p1),
                                                                                get_op_PERSON_p1->estimated_cardinality,
                                                                                get_op_PERSON_p1->extra_info);


    vector<idx_t> PERSON_p2_ids{1, 2, COLUMN_IDENTIFIER_ROW_ID};
    vector<LogicalType> get_PERSON_p2_types{LogicalType::VARCHAR, LogicalType::VARCHAR, LogicalType::BIGINT};
    string alias_PERSON_p2 = "p2";
    vector<LogicalType> table_types_PERSON_p2;
    vector<unique_ptr<Expression>> filter_PERSON_p2;
    unique_ptr<LogicalGet> get_op_PERSON_p2 = move(
            getLogicalGet(*this, table_PERSON, alias_PERSON_p2, table_index_PERSON_p2, table_types_PERSON_p2));
    unique_ptr<TableFilterSet> table_filters_PERSON_p2 = NULL;
    unique_ptr<PhysicalTableScan> scan_PERSON_p2 = make_uniq<PhysicalTableScan>(get_PERSON_p2_types,
                                                                                get_op_PERSON_p2->function,
                                                                                get_op_PERSON_p2->table_index,
                                                                                move(get_op_PERSON_p2->bind_data),
                                                                                table_types_PERSON_p2, PERSON_p2_ids,
                                                                                move(filter_PERSON_p2),
                                                                                vector<column_t>(),
                                                                                get_op_PERSON_p2->names,
                                                                                std::move(table_filters_PERSON_p2),
                                                                                get_op_PERSON_p2->estimated_cardinality,
                                                                                get_op_PERSON_p2->extra_info);


    vector<JoinCondition> cond_KNOWS_;
    JoinCondition join_condition_KNOWS_;
    join_condition_KNOWS_.left = make_uniq<BoundReferenceExpression>("person_rowid", LogicalType::BIGINT, 2);
    join_condition_KNOWS_.right = make_uniq<BoundReferenceExpression>("person_rowid", LogicalType::BIGINT, 1);
    join_condition_KNOWS_.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_KNOWS_ = make_uniq<RAIInfo>();
    rai_info_KNOWS_->rai = table_KNOWS.GetStorage().info->rais[0].get();
    rai_info_KNOWS_->rai_type = RAIType::TARGET_EDGE;
    rai_info_KNOWS_->forward = true;
    rai_info_KNOWS_->vertex = &table_PERSON;
    rai_info_KNOWS_->vertex_id = table_index_PERSON_p2;
    rai_info_KNOWS_->passing_tables[0] = table_index_PERSON_p2;
    rai_info_KNOWS_->left_cardinalities[0] = table_PERSON.GetStorage().info->cardinality;
    // rai_info_KNOWS_->compact_list = &rai_info_KNOWS_->rai->alist->compact__list;

    join_condition_KNOWS_.rais.push_back(move(rai_info_KNOWS_));
    cond_KNOWS_.push_back(move(join_condition_KNOWS_));

    LogicalComparisonJoin join_KNOWS__op(JoinType::INNER);
    vector<LogicalType> output_KNOWS__types{LogicalType::VARCHAR, LogicalType::VARCHAR,
                                            LogicalType::BIGINT, LogicalType::BIGINT};
    join_KNOWS__op.types = output_KNOWS__types;
    vector<idx_t> right_projection_map_KNOWS_{1};
    vector<idx_t> merge_project_map_KNOWS_;
    vector<LogicalType> delim_types_KNOWS_;
    auto join_KNOWS_ = make_uniq<PhysicalMergeSIPJoin>(join_KNOWS__op, move(scan_PERSON_p2), move(scan_PERSON_p1), move(cond_KNOWS_),
                                                       JoinType::INNER, left_projection_map,
                                                       right_projection_map_KNOWS_, merge_project_map_KNOWS_,
                                                       delim_types_KNOWS_, 0);

    idx_t m_comment_date = atoll(paras->data()[1].c_str()); // 933;
    Value comment_date = Value::BIGINT(m_comment_date);
    vector<idx_t> COMMENT_c_ids{1, 10, COLUMN_IDENTIFIER_ROW_ID};
    vector<LogicalType> get_COMMENT_c_types{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::BIGINT};
    string alias_COMMENT_c = "c";
    vector<LogicalType> table_types_COMMENT_c;
    vector<unique_ptr<Expression>> filter_COMMENT_c;
    unique_ptr<LogicalGet> get_op_COMMENT_c = move(
            getLogicalGet(*this, table_COMMENT, alias_COMMENT_c, table_index_COMMENT_c, table_types_COMMENT_c));
    unique_ptr<TableFilterSet> table_filters_COMMENT_c = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_comment = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_LESSTHAN,
                                                                                   comment_date);
    table_filters_COMMENT_c->filters[0] = move(constant_filter_comment);
    unique_ptr<PhysicalTableScan> scan_COMMENT_c = make_uniq<PhysicalTableScan>(get_COMMENT_c_types,
                                                                                get_op_COMMENT_c->function,
                                                                                get_op_COMMENT_c->table_index,
                                                                                move(get_op_COMMENT_c->bind_data),
                                                                                table_types_COMMENT_c, COMMENT_c_ids,
                                                                                move(filter_COMMENT_c),
                                                                                vector<column_t>(),
                                                                                get_op_COMMENT_c->names,
                                                                                std::move(table_filters_COMMENT_c),
                                                                                get_op_COMMENT_c->estimated_cardinality,
                                                                                get_op_COMMENT_c->extra_info);


    vector<JoinCondition> cond_HASCREATOR_;
    JoinCondition join_condition_HASCREATOR_;
    join_condition_HASCREATOR_.left = make_uniq<BoundReferenceExpression>("m_creatorid_rowid", LogicalType::BIGINT, 1);
    join_condition_HASCREATOR_.right = make_uniq<BoundReferenceExpression>("person_rowid", LogicalType::BIGINT, 2);
    join_condition_HASCREATOR_.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_HASCREATOR_ = make_uniq<RAIInfo>();
    rai_info_HASCREATOR_->rai = table_COMMENT.GetStorage().info->rais[0].get();
    rai_info_HASCREATOR_->rai_type = RAIType::EDGE_SOURCE;
    rai_info_HASCREATOR_->forward = true;
    rai_info_HASCREATOR_->vertex = &table_PERSON;
    rai_info_HASCREATOR_->vertex_id = table_index_PERSON_p2;
    rai_info_HASCREATOR_->passing_tables[0] = table_index_COMMENT_c;
    rai_info_HASCREATOR_->left_cardinalities[0] = table_COMMENT.GetStorage().info->cardinality;
    rai_info_HASCREATOR_->compact_list = &rai_info_HASCREATOR_->rai->alist->compact_forward_list;

    join_condition_HASCREATOR_.rais.push_back(move(rai_info_HASCREATOR_));
    cond_HASCREATOR_.push_back(move(join_condition_HASCREATOR_));

    LogicalComparisonJoin join_HASCREATOR__op(JoinType::INNER);
    vector<LogicalType> output_HASCREATOR__types{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::BIGINT,
                                                 LogicalType::VARCHAR, LogicalType::VARCHAR};
    join_HASCREATOR__op.types = output_HASCREATOR__types;
    vector<idx_t> right_projection_map_HASCREATOR_{0, 1};
    vector<idx_t> merge_project_map_HASCREATOR_;
    vector<LogicalType> delim_types_HASCREATOR_;
    auto join_HASCREATOR_ = make_uniq<PhysicalSIPJoin>(join_HASCREATOR__op, move(scan_COMMENT_c), move(join_KNOWS_), move(cond_HASCREATOR_),
                                                            JoinType::INNER, left_projection_map,
                                                            right_projection_map_HASCREATOR_,
                                                            delim_types_HASCREATOR_, 0);

    vector<LogicalType> result_types{LogicalType::VARCHAR, LogicalType::VARCHAR, LogicalType::BIGINT};
    vector<unique_ptr<Expression>> select_list;
    auto result_col0 = make_uniq<BoundReferenceExpression>("p_firstname", LogicalType::VARCHAR, 3);
    auto result_col1 = make_uniq<BoundReferenceExpression>("p_secondname", LogicalType::VARCHAR, 4);
    auto result_col2 = make_uniq<BoundReferenceExpression>("m_creationdate", LogicalType::BIGINT, 1);
    select_list.push_back(move(result_col0));
    select_list.push_back(move(result_col1));
    select_list.push_back(move(result_col2));
    auto projection = make_uniq<PhysicalProjection>(result_types, move(select_list), 0);
    projection->children.push_back(move(join_HASCREATOR_));

    return projection;
}

unique_ptr<PhysicalOperator> ClientContext::GenerateIC92PlanGLogue() {
    vector<idx_t> left_projection_map, right_projection_map;

    string table_vertex_PERSON_p1 = "PERSON";
    string table_vertex_PERSON_p2 = "PERSON";
    string table_vertex_COMMENT_c = "COMMENT";
    string table_vertex_KNOWS_ = "KNOWS";

    idx_t table_index_PERSON_p1 = 1;
    idx_t table_index_PERSON_p2 = 2;
    idx_t table_index_PERSON_p3 = 6;
    idx_t table_index_COMMENT_c = 3;
    idx_t table_index_KNOWS_ = 4;
    idx_t table_index_HASCREATOR_ = 5;
    auto table_or_view_PERSON = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_PERSON_p1,
                                                  OnEntryNotFound::RETURN_NULL);
    auto &table_PERSON = table_or_view_PERSON->Cast<TableCatalogEntry>();
    auto table_or_view_COMMENT = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_COMMENT_c,
                                                   OnEntryNotFound::RETURN_NULL);
    auto &table_COMMENT = table_or_view_COMMENT->Cast<TableCatalogEntry>();
    auto table_or_view_KNOWS = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_KNOWS_,
                                                 OnEntryNotFound::RETURN_NULL);
    auto &table_KNOWS = table_or_view_KNOWS->Cast<TableCatalogEntry>();

    idx_t p_person_id = atoll(paras->data()[0].c_str()); // 933;
    Value p_person = Value::BIGINT(p_person_id);
    vector<idx_t> PERSON_p1_ids{0, COLUMN_IDENTIFIER_ROW_ID};
    vector<LogicalType> get_PERSON_p1_types{LogicalType::BIGINT, LogicalType::BIGINT};
    string alias_PERSON_p1 = "p1";
    vector<LogicalType> table_types_PERSON_p1;
    vector<unique_ptr<Expression>> filter_PERSON_p1;
    unique_ptr<LogicalGet> get_op_PERSON_p1 = move(
            getLogicalGet(*this, table_PERSON, alias_PERSON_p1, table_index_PERSON_p1, table_types_PERSON_p1));
    unique_ptr<TableFilterSet> table_filters_PERSON_p1 = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL,
                                                                                   p_person);
    table_filters_PERSON_p1->filters[0] = move(constant_filter);
    unique_ptr<PhysicalTableScan> scan_PERSON_p1 = make_uniq<PhysicalTableScan>(get_PERSON_p1_types,
                                                                                get_op_PERSON_p1->function,
                                                                                get_op_PERSON_p1->table_index,
                                                                                move(get_op_PERSON_p1->bind_data),
                                                                                table_types_PERSON_p1, PERSON_p1_ids,
                                                                                move(filter_PERSON_p1),
                                                                                vector<column_t>(),
                                                                                get_op_PERSON_p1->names,
                                                                                std::move(table_filters_PERSON_p1),
                                                                                get_op_PERSON_p1->estimated_cardinality,
                                                                                get_op_PERSON_p1->extra_info);

    vector<idx_t> PERSON_p3_ids{COLUMN_IDENTIFIER_ROW_ID};
    vector<LogicalType> get_PERSON_p3_types{LogicalType::BIGINT};
    string alias_PERSON_p3 = "p3";
    vector<LogicalType> table_types_PERSON_p3;
    vector<unique_ptr<Expression>> filter_PERSON_p3;
    unique_ptr<LogicalGet> get_op_PERSON_p3 = move(
            getLogicalGet(*this, table_PERSON, alias_PERSON_p3, table_index_PERSON_p3, table_types_PERSON_p3));
    unique_ptr<TableFilterSet> table_filters_PERSON_p3 = NULL;
    unique_ptr<PhysicalTableScan> scan_PERSON_p3 = make_uniq<PhysicalTableScan>(get_PERSON_p3_types,
                                                                                get_op_PERSON_p3->function,
                                                                                get_op_PERSON_p3->table_index,
                                                                                move(get_op_PERSON_p3->bind_data),
                                                                                table_types_PERSON_p3, PERSON_p3_ids,
                                                                                move(filter_PERSON_p3),
                                                                                vector<column_t>(),
                                                                                get_op_PERSON_p3->names,
                                                                                std::move(table_filters_PERSON_p3),
                                                                                get_op_PERSON_p3->estimated_cardinality,
                                                                                get_op_PERSON_p3->extra_info);


    vector<JoinCondition> cond_KNOWS_k2;
    JoinCondition join_condition_KNOWS_k2;
    join_condition_KNOWS_k2.left = make_uniq<BoundReferenceExpression>("person_rowid", LogicalType::BIGINT, 0);
    join_condition_KNOWS_k2.right = make_uniq<BoundReferenceExpression>("person_rowid", LogicalType::BIGINT, 1);
    join_condition_KNOWS_k2.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_KNOWS_k2 = make_uniq<RAIInfo>();
    rai_info_KNOWS_k2->rai = table_KNOWS.GetStorage().info->rais[0].get();
    rai_info_KNOWS_k2->rai_type = RAIType::TARGET_EDGE;
    rai_info_KNOWS_k2->forward = true;
    rai_info_KNOWS_k2->vertex = &table_PERSON;
    rai_info_KNOWS_k2->vertex_id = table_index_PERSON_p2;
    rai_info_KNOWS_k2->passing_tables[0] = table_index_PERSON_p2;
    rai_info_KNOWS_k2->left_cardinalities[0] = table_PERSON.GetStorage().info->cardinality;
    // rai_info_KNOWS_->compact_list = &rai_info_KNOWS_->rai->alist->compact__list;

    join_condition_KNOWS_k2.rais.push_back(move(rai_info_KNOWS_k2));
    cond_KNOWS_k2.push_back(move(join_condition_KNOWS_k2));

    LogicalComparisonJoin join_KNOWS_k2_op(JoinType::INNER);
    vector<LogicalType> output_KNOWS_k2_types{LogicalType::BIGINT, LogicalType::BIGINT};
    join_KNOWS_k2_op.types = output_KNOWS_k2_types;
    vector<idx_t> right_projection_map_KNOWS_k2{1};
    vector<idx_t> merge_project_map_KNOWS_k2;
    vector<LogicalType> delim_types_KNOWS_k2;
    auto join_KNOWS_k2 = make_uniq<PhysicalMergeSIPJoin>(join_KNOWS_k2_op, move(scan_PERSON_p3), move(scan_PERSON_p1), move(cond_KNOWS_k2),
                                                       JoinType::INNER, left_projection_map,
                                                       right_projection_map_KNOWS_k2, merge_project_map_KNOWS_k2,
                                                       delim_types_KNOWS_k2, 0);

    vector<idx_t> PERSON_p2_ids{1, 2, COLUMN_IDENTIFIER_ROW_ID};
    vector<LogicalType> get_PERSON_p2_types{LogicalType::VARCHAR, LogicalType::VARCHAR, LogicalType::BIGINT};
    string alias_PERSON_p2 = "p2";
    vector<LogicalType> table_types_PERSON_p2;
    vector<unique_ptr<Expression>> filter_PERSON_p2;
    unique_ptr<LogicalGet> get_op_PERSON_p2 = move(
            getLogicalGet(*this, table_PERSON, alias_PERSON_p2, table_index_PERSON_p2, table_types_PERSON_p2));
    unique_ptr<TableFilterSet> table_filters_PERSON_p2 = NULL;
    unique_ptr<PhysicalTableScan> scan_PERSON_p2 = make_uniq<PhysicalTableScan>(get_PERSON_p2_types,
                                                                                get_op_PERSON_p2->function,
                                                                                get_op_PERSON_p2->table_index,
                                                                                move(get_op_PERSON_p2->bind_data),
                                                                                table_types_PERSON_p2, PERSON_p2_ids,
                                                                                move(filter_PERSON_p2),
                                                                                vector<column_t>(),
                                                                                get_op_PERSON_p2->names,
                                                                                std::move(table_filters_PERSON_p2),
                                                                                get_op_PERSON_p2->estimated_cardinality,
                                                                                get_op_PERSON_p2->extra_info);


    vector<JoinCondition> cond_KNOWS_;
    JoinCondition join_condition_KNOWS_;
    join_condition_KNOWS_.left = make_uniq<BoundReferenceExpression>("person_rowid", LogicalType::BIGINT, 2);
    join_condition_KNOWS_.right = make_uniq<BoundReferenceExpression>("person_rowid", LogicalType::BIGINT, 0);
    join_condition_KNOWS_.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_KNOWS_ = make_uniq<RAIInfo>();
    rai_info_KNOWS_->rai = table_KNOWS.GetStorage().info->rais[0].get();
    rai_info_KNOWS_->rai_type = RAIType::TARGET_EDGE;
    rai_info_KNOWS_->forward = true;
    rai_info_KNOWS_->vertex = &table_PERSON;
    rai_info_KNOWS_->vertex_id = table_index_PERSON_p2;
    rai_info_KNOWS_->passing_tables[0] = table_index_PERSON_p2;
    rai_info_KNOWS_->left_cardinalities[0] = table_PERSON.GetStorage().info->cardinality;
    // rai_info_KNOWS_->compact_list = &rai_info_KNOWS_->rai->alist->compact__list;

    join_condition_KNOWS_.rais.push_back(move(rai_info_KNOWS_));
    cond_KNOWS_.push_back(move(join_condition_KNOWS_));

    LogicalComparisonJoin join_KNOWS__op(JoinType::INNER);
    vector<LogicalType> output_KNOWS__types{LogicalType::VARCHAR, LogicalType::VARCHAR,
                                            LogicalType::BIGINT, LogicalType::BIGINT};
    join_KNOWS__op.types = output_KNOWS__types;
    vector<idx_t> right_projection_map_KNOWS_{1};
    vector<idx_t> merge_project_map_KNOWS_;
    vector<LogicalType> delim_types_KNOWS_;
    auto join_KNOWS_ = make_uniq<PhysicalMergeSIPJoin>(join_KNOWS__op, move(scan_PERSON_p2), move(join_KNOWS_k2), move(cond_KNOWS_),
                                                       JoinType::INNER, left_projection_map,
                                                       right_projection_map_KNOWS_, merge_project_map_KNOWS_,
                                                       delim_types_KNOWS_, 0);

    idx_t m_comment_date = atoll(paras->data()[1].c_str()); // 933;
    Value comment_date = Value::BIGINT(m_comment_date);
    vector<idx_t> COMMENT_c_ids{1, 10, COLUMN_IDENTIFIER_ROW_ID};
    vector<LogicalType> get_COMMENT_c_types{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::BIGINT};
    string alias_COMMENT_c = "c";
    vector<LogicalType> table_types_COMMENT_c;
    vector<unique_ptr<Expression>> filter_COMMENT_c;
    unique_ptr<LogicalGet> get_op_COMMENT_c = move(
            getLogicalGet(*this, table_COMMENT, alias_COMMENT_c, table_index_COMMENT_c, table_types_COMMENT_c));
    unique_ptr<TableFilterSet> table_filters_COMMENT_c = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_comment = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_LESSTHAN,
                                                                                           comment_date);
    table_filters_COMMENT_c->filters[0] = move(constant_filter_comment);
    unique_ptr<PhysicalTableScan> scan_COMMENT_c = make_uniq<PhysicalTableScan>(get_COMMENT_c_types,
                                                                                get_op_COMMENT_c->function,
                                                                                get_op_COMMENT_c->table_index,
                                                                                move(get_op_COMMENT_c->bind_data),
                                                                                table_types_COMMENT_c, COMMENT_c_ids,
                                                                                move(filter_COMMENT_c),
                                                                                vector<column_t>(),
                                                                                get_op_COMMENT_c->names,
                                                                                std::move(table_filters_COMMENT_c),
                                                                                get_op_COMMENT_c->estimated_cardinality,
                                                                                get_op_COMMENT_c->extra_info);


    vector<JoinCondition> cond_HASCREATOR_;
    JoinCondition join_condition_HASCREATOR_;
    join_condition_HASCREATOR_.left = make_uniq<BoundReferenceExpression>("m_creatorid_rowid", LogicalType::BIGINT, 1);
    join_condition_HASCREATOR_.right = make_uniq<BoundReferenceExpression>("person_rowid", LogicalType::BIGINT, 2);
    join_condition_HASCREATOR_.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_HASCREATOR_ = make_uniq<RAIInfo>();
    rai_info_HASCREATOR_->rai = table_COMMENT.GetStorage().info->rais[0].get();
    rai_info_HASCREATOR_->rai_type = RAIType::EDGE_SOURCE;
    rai_info_HASCREATOR_->forward = true;
    rai_info_HASCREATOR_->vertex = &table_PERSON;
    rai_info_HASCREATOR_->vertex_id = table_index_PERSON_p2;
    rai_info_HASCREATOR_->passing_tables[0] = table_index_COMMENT_c;
    rai_info_HASCREATOR_->left_cardinalities[0] = table_COMMENT.GetStorage().info->cardinality;
    rai_info_HASCREATOR_->compact_list = &rai_info_HASCREATOR_->rai->alist->compact_forward_list;

    join_condition_HASCREATOR_.rais.push_back(move(rai_info_HASCREATOR_));
    cond_HASCREATOR_.push_back(move(join_condition_HASCREATOR_));

    LogicalComparisonJoin join_HASCREATOR__op(JoinType::INNER);
    vector<LogicalType> output_HASCREATOR__types{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::BIGINT,
                                                 LogicalType::VARCHAR, LogicalType::VARCHAR};
    join_HASCREATOR__op.types = output_HASCREATOR__types;
    vector<idx_t> right_projection_map_HASCREATOR_{0, 1};
    vector<idx_t> merge_project_map_HASCREATOR_;
    vector<LogicalType> delim_types_HASCREATOR_;
    auto join_HASCREATOR_ = make_uniq<PhysicalSIPJoin>(join_HASCREATOR__op, move(scan_COMMENT_c), move(join_KNOWS_), move(cond_HASCREATOR_),
                                                       JoinType::INNER, left_projection_map,
                                                       right_projection_map_HASCREATOR_,
                                                       delim_types_HASCREATOR_, 0);

    vector<LogicalType> result_types{LogicalType::VARCHAR, LogicalType::VARCHAR, LogicalType::BIGINT};
    vector<unique_ptr<Expression>> select_list;
    auto result_col0 = make_uniq<BoundReferenceExpression>("p_firstname", LogicalType::VARCHAR, 3);
    auto result_col1 = make_uniq<BoundReferenceExpression>("p_secondname", LogicalType::VARCHAR, 4);
    auto result_col2 = make_uniq<BoundReferenceExpression>("m_creationdate", LogicalType::BIGINT, 1);
    select_list.push_back(move(result_col0));
    select_list.push_back(move(result_col1));
    select_list.push_back(move(result_col2));
    auto projection = make_uniq<PhysicalProjection>(result_types, move(select_list), 0);
    projection->children.push_back(move(join_HASCREATOR_));

    return projection;
}

unique_ptr<PhysicalOperator> ClientContext::GenerateIC111PlanGLogue() {
    vector<idx_t> left_projection_map, right_projection_map;

    string table_vertex_PERSON_p1 = "PERSON";
    string table_vertex_PERSON_p2 = "PERSON";
    string table_vertex_ORGANISATION_o = "ORGANISATION";
    string table_vertex_PLACE_pl = "PLACE";
    string table_vertex_KNOWS_ = "KNOWS";
    string table_vertex_WORKAT_pc = "PERSON_COMPANY";

    idx_t table_index_PERSON_p1 = 1;
    idx_t table_index_PERSON_p2 = 2;
    idx_t table_index_ORGANISATION_o = 3;
    idx_t table_index_PLACE_pl = 4;
    idx_t table_index_KNOWS_ = 5;
    idx_t table_index_WORKAT_pc = 6;

    auto table_or_view_PERSON = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_PERSON_p1, OnEntryNotFound::RETURN_NULL);
    auto &table_PERSON = table_or_view_PERSON->Cast<TableCatalogEntry>();
    auto table_or_view_ORGANISATION = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_ORGANISATION_o, OnEntryNotFound::RETURN_NULL);
    auto &table_ORGANISATION = table_or_view_ORGANISATION->Cast<TableCatalogEntry>();
    auto table_or_view_PLACE = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_PLACE_pl, OnEntryNotFound::RETURN_NULL);
    auto &table_PLACE = table_or_view_PLACE->Cast<TableCatalogEntry>();
    auto table_or_view_KNOWS = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_KNOWS_, OnEntryNotFound::RETURN_NULL);
    auto &table_KNOWS = table_or_view_KNOWS->Cast<TableCatalogEntry>();
    auto table_or_view_WORKAT = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_WORKAT_pc, OnEntryNotFound::RETURN_NULL);
    auto &table_WORKAT = table_or_view_WORKAT->Cast<TableCatalogEntry>();

    idx_t p_person_id = atoll(paras->data()[0].c_str()); // 933;
    Value p_person = Value::BIGINT(p_person_id);
    vector<idx_t> PERSON_p1_ids{0, COLUMN_IDENTIFIER_ROW_ID};
    vector<LogicalType> get_PERSON_p1_types{LogicalType::BIGINT, LogicalType::BIGINT};
    string alias_PERSON_p1 = "p1";
    vector<LogicalType> table_types_PERSON_p1;
    vector<unique_ptr<Expression>> filter_PERSON_p1;
    unique_ptr<LogicalGet> get_op_PERSON_p1 = move(getLogicalGet(*this, table_PERSON, alias_PERSON_p1, table_index_PERSON_p1, table_types_PERSON_p1));
    unique_ptr<TableFilterSet> table_filters_PERSON_p1 = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL,
                                                                                   p_person);
    table_filters_PERSON_p1->filters[0] = move(constant_filter);
    unique_ptr<PhysicalTableScan> scan_PERSON_p1 = make_uniq<PhysicalTableScan>(get_PERSON_p1_types, get_op_PERSON_p1->function, get_op_PERSON_p1->table_index, move(get_op_PERSON_p1->bind_data), table_types_PERSON_p1, PERSON_p1_ids, move(filter_PERSON_p1), vector<column_t>(), get_op_PERSON_p1->names, std::move(table_filters_PERSON_p1), get_op_PERSON_p1->estimated_cardinality, get_op_PERSON_p1->extra_info);


    vector<idx_t> PERSON_p2_ids{0, 1, 2, COLUMN_IDENTIFIER_ROW_ID};
    vector<LogicalType> get_PERSON_p2_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::VARCHAR,
                                            LogicalType::BIGINT};
    string alias_PERSON_p2 = "p2";
    vector<LogicalType> table_types_PERSON_p2;
    vector<unique_ptr<Expression>> filter_PERSON_p2;
    unique_ptr<LogicalGet> get_op_PERSON_p2 = move(getLogicalGet(*this, table_PERSON, alias_PERSON_p2, table_index_PERSON_p2, table_types_PERSON_p2));
    unique_ptr<TableFilterSet> table_filters_PERSON_p2 = NULL;
    unique_ptr<PhysicalTableScan> scan_PERSON_p2 = make_uniq<PhysicalTableScan>(get_PERSON_p2_types, get_op_PERSON_p2->function, get_op_PERSON_p2->table_index, move(get_op_PERSON_p2->bind_data), table_types_PERSON_p2, PERSON_p2_ids, move(filter_PERSON_p2), vector<column_t>(), get_op_PERSON_p2->names, std::move(table_filters_PERSON_p2), get_op_PERSON_p2->estimated_cardinality, get_op_PERSON_p2->extra_info);


    vector<JoinCondition> cond_KNOWS_;
    JoinCondition join_condition_KNOWS_;
    join_condition_KNOWS_.left = make_uniq<BoundReferenceExpression>("person_rowid", LogicalType::BIGINT, 3);
    join_condition_KNOWS_.right = make_uniq<BoundReferenceExpression>("person_rowid", LogicalType::BIGINT, 1);
    join_condition_KNOWS_.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_KNOWS_ = make_uniq<RAIInfo>();
    rai_info_KNOWS_->rai = table_KNOWS.GetStorage().info->rais[0].get();
    rai_info_KNOWS_->rai_type = RAIType::TARGET_EDGE;
    rai_info_KNOWS_->forward = true;
    rai_info_KNOWS_->vertex = &table_PERSON;
    rai_info_KNOWS_->vertex_id = table_index_PERSON_p2;
    rai_info_KNOWS_->passing_tables[0] = table_index_PERSON_p2;
    rai_info_KNOWS_->left_cardinalities[0] = table_PERSON.GetStorage().info->cardinality;
    // rai_info_KNOWS_->compact_list = &rai_info_KNOWS_->rai->alist->compact__list;

    join_condition_KNOWS_.rais.push_back(move(rai_info_KNOWS_));
    cond_KNOWS_.push_back(move(join_condition_KNOWS_));

    LogicalComparisonJoin join_KNOWS__op(JoinType::INNER);
    vector<LogicalType> output_KNOWS__types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::VARCHAR,
                                            LogicalType::BIGINT, LogicalType::BIGINT};
    join_KNOWS__op.types = output_KNOWS__types;
    vector<idx_t> right_projection_map_KNOWS_{1};
    vector<idx_t> merge_project_map_KNOWS_;
    vector<LogicalType> delim_types_KNOWS_;
    auto join_KNOWS_ = make_uniq<PhysicalMergeSIPJoin>(join_KNOWS__op, move(scan_PERSON_p2), move(scan_PERSON_p1),
                                                       move(cond_KNOWS_), JoinType::INNER, left_projection_map,
                                                       right_projection_map_KNOWS_, merge_project_map_KNOWS_, delim_types_KNOWS_, 0);


    idx_t work_from_id = atoi(paras->data()[2].c_str()); // 933;
    Value work_from = Value::INTEGER(work_from_id);
    vector<idx_t> WORKAT_pc_ids{2, 3, 4};
    vector<LogicalType> get_WORKAT_pc_types{LogicalType::INTEGER, LogicalType::BIGINT, LogicalType::BIGINT};
    string alias_WORKAT_pc = "pc";
    vector<LogicalType> table_types_WORKAT_pc;
    vector<unique_ptr<Expression>> filter_WORKAT_pc;
    unique_ptr<LogicalGet> get_op_WORKAT_pc = move(getLogicalGet(*this, table_WORKAT, alias_WORKAT_pc, table_index_WORKAT_pc, table_types_WORKAT_pc));
    unique_ptr<TableFilterSet> table_filters_WORKAT_pc = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_WORKAT = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_LESSTHAN,
                                                                                   work_from);
    table_filters_WORKAT_pc->filters[0] = move(constant_filter_WORKAT);
    unique_ptr<PhysicalTableScan> scan_WORKAT_pc = make_uniq<PhysicalTableScan>(get_WORKAT_pc_types, get_op_WORKAT_pc->function, get_op_WORKAT_pc->table_index, move(get_op_WORKAT_pc->bind_data), table_types_WORKAT_pc, WORKAT_pc_ids, move(filter_WORKAT_pc), vector<column_t>(), get_op_WORKAT_pc->names, std::move(table_filters_WORKAT_pc), get_op_WORKAT_pc->estimated_cardinality, get_op_WORKAT_pc->extra_info);

    vector<JoinCondition> cond_WORKAT_pc;
    JoinCondition join_condition_WORKAT_pc;
    join_condition_WORKAT_pc.left = make_uniq<BoundReferenceExpression>("pc_personid_rowid", LogicalType::BIGINT, 1);
    join_condition_WORKAT_pc.right = make_uniq<BoundReferenceExpression>("person_rowid", LogicalType::BIGINT, 3);
    join_condition_WORKAT_pc.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_WORKAT_pc = make_uniq<RAIInfo>();
    rai_info_WORKAT_pc->rai = table_WORKAT.GetStorage().info->rais[0].get();
    rai_info_WORKAT_pc->rai_type = RAIType::EDGE_SOURCE;
    rai_info_WORKAT_pc->forward = true;
    rai_info_WORKAT_pc->vertex = &table_PERSON;
    rai_info_WORKAT_pc->vertex_id = table_index_PERSON_p2;
    rai_info_WORKAT_pc->passing_tables[0] = table_index_WORKAT_pc;
    rai_info_WORKAT_pc->left_cardinalities[0] = table_WORKAT.GetStorage().info->cardinality;
    rai_info_WORKAT_pc->compact_list = &rai_info_WORKAT_pc->rai->alist->compact_forward_list;

    join_condition_WORKAT_pc.rais.push_back(move(rai_info_WORKAT_pc));
    cond_WORKAT_pc.push_back(move(join_condition_WORKAT_pc));

    LogicalComparisonJoin join_WORKAT_pc_op(JoinType::INNER);
    vector<LogicalType> output_WORKAT_pc_types{LogicalType::INTEGER, LogicalType::BIGINT, LogicalType::BIGINT,
                                               LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::VARCHAR};
    join_WORKAT_pc_op.types = output_WORKAT_pc_types;
    vector<idx_t> right_projection_map_WORKAT_pc{0, 1, 2};
    vector<idx_t> merge_project_map_WORKAT_pc;
    vector<LogicalType> delim_types_WORKAT_pc;
    auto join_WORKAT_pc = make_uniq<PhysicalSIPJoin>(join_WORKAT_pc_op, move(scan_WORKAT_pc), move(join_KNOWS_), move(cond_WORKAT_pc), JoinType::INNER, left_projection_map, right_projection_map_WORKAT_pc, delim_types_WORKAT_pc, 0);

    vector<idx_t> ORGANISATION_o_ids{2, 5, COLUMN_IDENTIFIER_ROW_ID};
    vector<LogicalType> get_ORGANISATION_o_types{LogicalType::VARCHAR, LogicalType::BIGINT, LogicalType::BIGINT};
    string alias_ORGANISATION_o = "o";
    vector<LogicalType> table_types_ORGANISATION_o;
    vector<unique_ptr<Expression>> filter_ORGANISATION_o;
    unique_ptr<LogicalGet> get_op_ORGANISATION_o = move(getLogicalGet(*this, table_ORGANISATION, alias_ORGANISATION_o, table_index_ORGANISATION_o, table_types_ORGANISATION_o));
    unique_ptr<TableFilterSet> table_filters_ORGANISATION_o = NULL;
    unique_ptr<PhysicalTableScan> scan_ORGANISATION_o = make_uniq<PhysicalTableScan>(get_ORGANISATION_o_types, get_op_ORGANISATION_o->function, get_op_ORGANISATION_o->table_index, move(get_op_ORGANISATION_o->bind_data), table_types_ORGANISATION_o, ORGANISATION_o_ids, move(filter_ORGANISATION_o), vector<column_t>(), get_op_ORGANISATION_o->names, std::move(table_filters_ORGANISATION_o), get_op_ORGANISATION_o->estimated_cardinality, get_op_ORGANISATION_o->extra_info);

    vector<JoinCondition> cond_ORGANISATION_o;
    JoinCondition join_condition_ORGANISATION_o;
    join_condition_ORGANISATION_o.left = make_uniq<BoundReferenceExpression>("organisation_rowid", LogicalType::BIGINT, 2);
    join_condition_ORGANISATION_o.right = make_uniq<BoundReferenceExpression>("pc_organisationid_rowid", LogicalType::BIGINT, 2);
    join_condition_ORGANISATION_o.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_ORGANISATION_o = make_uniq<RAIInfo>();
    rai_info_ORGANISATION_o->rai = table_WORKAT.GetStorage().info->rais[0].get();
    rai_info_ORGANISATION_o->rai_type = RAIType::TARGET_EDGE;
    rai_info_ORGANISATION_o->forward = true;
    rai_info_ORGANISATION_o->vertex = &table_ORGANISATION;
    rai_info_ORGANISATION_o->vertex_id = table_index_ORGANISATION_o;
    rai_info_ORGANISATION_o->passing_tables[0] = table_index_ORGANISATION_o;
    rai_info_ORGANISATION_o->left_cardinalities[0] = table_ORGANISATION.GetStorage().info->cardinality;
    // rai_info_ORGANISATION_o->compact_list = &rai_info_ORGANISATION_o->rai->alist->compact__list;

    join_condition_ORGANISATION_o.rais.push_back(move(rai_info_ORGANISATION_o));
    cond_ORGANISATION_o.push_back(move(join_condition_ORGANISATION_o));

    LogicalComparisonJoin join_ORGANISATION_o_op(JoinType::INNER);
    vector<LogicalType> output_ORGANISATION_o_types{LogicalType::VARCHAR, LogicalType::BIGINT, LogicalType::BIGINT,
                                                    LogicalType::INTEGER, LogicalType::BIGINT, LogicalType::VARCHAR,
                                                    LogicalType::VARCHAR};
    join_ORGANISATION_o_op.types = output_ORGANISATION_o_types;
    vector<idx_t> right_projection_map_ORGANISATION_o{0, 3, 4, 5};
    vector<idx_t> merge_project_map_ORGANISATION_o;
    vector<LogicalType> delim_types_ORGANISATION_o;
    auto join_ORGANISATION_o = make_uniq<PhysicalSIPJoin>(join_ORGANISATION_o_op, move(scan_ORGANISATION_o), move(join_WORKAT_pc),
                                                          move(cond_ORGANISATION_o), JoinType::INNER, left_projection_map,
                                                          right_projection_map_ORGANISATION_o, delim_types_ORGANISATION_o, 0);

    string p_place_name = paras->data()[1]; // 933;
    Value p_place = Value(p_place_name);
    vector<idx_t> PLACE_pl_ids{1, COLUMN_IDENTIFIER_ROW_ID};
    vector<LogicalType> get_PLACE_pl_types{LogicalType::VARCHAR, LogicalType::BIGINT};
    string alias_PLACE_pl = "pl";
    vector<LogicalType> table_types_PLACE_pl;
    vector<unique_ptr<Expression>> filter_PLACE_pl;
    unique_ptr<LogicalGet> get_op_PLACE_pl = move(getLogicalGet(*this, table_PLACE, alias_PLACE_pl, table_index_PLACE_pl, table_types_PLACE_pl));
    unique_ptr<TableFilterSet> table_filters_PLACE_pl = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_PLACE = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL,
                                                                                          p_place);
    table_filters_PLACE_pl->filters[0] = move(constant_filter_PLACE);
    unique_ptr<PhysicalTableScan> scan_PLACE_pl = make_uniq<PhysicalTableScan>(get_PLACE_pl_types, get_op_PLACE_pl->function, get_op_PLACE_pl->table_index, move(get_op_PLACE_pl->bind_data), table_types_PLACE_pl, PLACE_pl_ids, move(filter_PLACE_pl), vector<column_t>(), get_op_PLACE_pl->names, std::move(table_filters_PLACE_pl), get_op_PLACE_pl->estimated_cardinality, get_op_PLACE_pl->extra_info);


    vector<JoinCondition> cond_ISLOCATEDIN_;
    JoinCondition join_condition_ISLOCATEDIN_;
    join_condition_ISLOCATEDIN_.left = make_uniq<BoundReferenceExpression>("place_rowid", LogicalType::BIGINT, 1);
    join_condition_ISLOCATEDIN_.right = make_uniq<BoundReferenceExpression>("o_placeid_rowid", LogicalType::BIGINT, 1);
    join_condition_ISLOCATEDIN_.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_ISLOCATEDIN_ = make_uniq<RAIInfo>();
    rai_info_ISLOCATEDIN_->rai = table_ORGANISATION.GetStorage().info->rais[0].get();
    rai_info_ISLOCATEDIN_->rai_type = RAIType::TARGET_EDGE;
    rai_info_ISLOCATEDIN_->forward = true;
    rai_info_ISLOCATEDIN_->vertex = &table_PLACE;
    rai_info_ISLOCATEDIN_->vertex_id = table_index_PLACE_pl;
    rai_info_ISLOCATEDIN_->passing_tables[0] = table_index_PLACE_pl;
    rai_info_ISLOCATEDIN_->left_cardinalities[0] = table_PLACE.GetStorage().info->cardinality;
    // rai_info_ISLOCATEDIN_->compact_list = &rai_info_ISLOCATEDIN_->rai->alist->compact__list;

    join_condition_ISLOCATEDIN_.rais.push_back(move(rai_info_ISLOCATEDIN_));
    cond_ISLOCATEDIN_.push_back(move(join_condition_ISLOCATEDIN_));

    LogicalComparisonJoin join_ISLOCATEDIN__op(JoinType::INNER);
    vector<LogicalType> output_ISLOCATEDIN__types{LogicalType::VARCHAR, LogicalType::BIGINT, LogicalType::VARCHAR,
                                                  LogicalType::INTEGER, LogicalType::BIGINT, LogicalType::VARCHAR,
                                                  LogicalType::VARCHAR};
    join_ISLOCATEDIN__op.types = output_ISLOCATEDIN__types;
    vector<idx_t> right_projection_map_ISLOCATEDIN_{0, 3, 4, 5, 6};
    vector<idx_t> merge_project_map_ISLOCATEDIN_;
    vector<LogicalType> delim_types_ISLOCATEDIN_;
    auto join_ISLOCATEDIN_ = make_uniq<PhysicalSIPJoin>(join_ISLOCATEDIN__op, move(scan_PLACE_pl), move(join_ORGANISATION_o), move(cond_ISLOCATEDIN_), JoinType::INNER, left_projection_map, right_projection_map_ISLOCATEDIN_, delim_types_ISLOCATEDIN_, 0);


    vector<LogicalType> result_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::VARCHAR,
                                     LogicalType::VARCHAR, LogicalType::INTEGER};
    vector<unique_ptr<Expression>> select_list;
    auto result_col0 = make_uniq<BoundReferenceExpression>("p_personid", LogicalType::BIGINT, 4);
    auto result_col1 = make_uniq<BoundReferenceExpression>("p_firstname", LogicalType::VARCHAR, 5);
    auto result_col2 = make_uniq<BoundReferenceExpression>("p_lastname", LogicalType::VARCHAR, 6);
    auto result_col3 = make_uniq<BoundReferenceExpression>("o_name", LogicalType::VARCHAR, 2);
    auto result_col4 = make_uniq<BoundReferenceExpression>("pc_workfrom", LogicalType::INTEGER, 3);
    select_list.push_back(move(result_col0));
    select_list.push_back(move(result_col1));
    select_list.push_back(move(result_col2));
    select_list.push_back(move(result_col3));
    select_list.push_back(move(result_col4));
    auto projection = make_uniq<PhysicalProjection>(result_types, move(select_list), 0);
    projection->children.push_back(move(join_ISLOCATEDIN_));

    return projection;
}

unique_ptr<PhysicalOperator> ClientContext::GenerateIC112PlanGLogue() {
    vector<idx_t> left_projection_map, right_projection_map;

    string table_vertex_PERSON_p1 = "PERSON";
    string table_vertex_PERSON_p2 = "PERSON";
    string table_vertex_PERSON_p3 = "PERSON";
    string table_vertex_ORGANISATION_o = "ORGANISATION";
    string table_vertex_PLACE_pl = "PLACE";
    string table_vertex_KNOWS_ = "KNOWS";
    string table_vertex_WORKAT_pc = "PERSON_COMPANY";

    idx_t table_index_PERSON_p1 = 1;
    idx_t table_index_PERSON_p2 = 2;
    idx_t table_index_PERSON_p3 = 7;
    idx_t table_index_ORGANISATION_o = 3;
    idx_t table_index_PLACE_pl = 4;
    idx_t table_index_KNOWS_ = 5;
    idx_t table_index_WORKAT_pc = 6;

    auto table_or_view_PERSON = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_PERSON_p1,
                                                  OnEntryNotFound::RETURN_NULL);
    auto &table_PERSON = table_or_view_PERSON->Cast<TableCatalogEntry>();
    auto table_or_view_ORGANISATION = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                        table_vertex_ORGANISATION_o, OnEntryNotFound::RETURN_NULL);
    auto &table_ORGANISATION = table_or_view_ORGANISATION->Cast<TableCatalogEntry>();
    auto table_or_view_PLACE = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_PLACE_pl,
                                                 OnEntryNotFound::RETURN_NULL);
    auto &table_PLACE = table_or_view_PLACE->Cast<TableCatalogEntry>();
    auto table_or_view_KNOWS = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_KNOWS_,
                                                 OnEntryNotFound::RETURN_NULL);
    auto &table_KNOWS = table_or_view_KNOWS->Cast<TableCatalogEntry>();
    auto table_or_view_WORKAT = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_WORKAT_pc,
                                                  OnEntryNotFound::RETURN_NULL);
    auto &table_WORKAT = table_or_view_WORKAT->Cast<TableCatalogEntry>();

    idx_t p_person_id = atoll(paras->data()[0].c_str()); // 933;
    Value p_person = Value::BIGINT(p_person_id);
    vector<idx_t> PERSON_p1_ids{0, COLUMN_IDENTIFIER_ROW_ID};
    vector<LogicalType> get_PERSON_p1_types{LogicalType::BIGINT, LogicalType::BIGINT};
    string alias_PERSON_p1 = "p1";
    vector<LogicalType> table_types_PERSON_p1;
    vector<unique_ptr<Expression>> filter_PERSON_p1;
    unique_ptr<LogicalGet> get_op_PERSON_p1 = move(
            getLogicalGet(*this, table_PERSON, alias_PERSON_p1, table_index_PERSON_p1, table_types_PERSON_p1));
    unique_ptr<TableFilterSet> table_filters_PERSON_p1 = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL,
                                                                                   p_person);
    table_filters_PERSON_p1->filters[0] = move(constant_filter);
    unique_ptr<PhysicalTableScan> scan_PERSON_p1 = make_uniq<PhysicalTableScan>(get_PERSON_p1_types,
                                                                                get_op_PERSON_p1->function,
                                                                                get_op_PERSON_p1->table_index,
                                                                                move(get_op_PERSON_p1->bind_data),
                                                                                table_types_PERSON_p1, PERSON_p1_ids,
                                                                                move(filter_PERSON_p1),
                                                                                vector<column_t>(),
                                                                                get_op_PERSON_p1->names,
                                                                                std::move(table_filters_PERSON_p1),
                                                                                get_op_PERSON_p1->estimated_cardinality,
                                                                                get_op_PERSON_p1->extra_info);


    vector<idx_t> PERSON_p3_ids{COLUMN_IDENTIFIER_ROW_ID};
    vector<LogicalType> get_PERSON_p3_types{LogicalType::BIGINT};
    string alias_PERSON_p3 = "p3";
    vector<LogicalType> table_types_PERSON_p3;
    vector<unique_ptr<Expression>> filter_PERSON_p3;
    unique_ptr<LogicalGet> get_op_PERSON_p3 = move(
            getLogicalGet(*this, table_PERSON, alias_PERSON_p3, table_index_PERSON_p3, table_types_PERSON_p3));
    unique_ptr<TableFilterSet> table_filters_PERSON_p3 = NULL;
    unique_ptr<PhysicalTableScan> scan_PERSON_p3 = make_uniq<PhysicalTableScan>(get_PERSON_p3_types,
                                                                                get_op_PERSON_p3->function,
                                                                                get_op_PERSON_p3->table_index,
                                                                                move(get_op_PERSON_p3->bind_data),
                                                                                table_types_PERSON_p3, PERSON_p3_ids,
                                                                                move(filter_PERSON_p3),
                                                                                vector<column_t>(),
                                                                                get_op_PERSON_p3->names,
                                                                                std::move(table_filters_PERSON_p3),
                                                                                get_op_PERSON_p3->estimated_cardinality,
                                                                                get_op_PERSON_p3->extra_info);


    vector<JoinCondition> cond_KNOWS_k2;
    JoinCondition join_condition_KNOWS_k2;
    join_condition_KNOWS_k2.left = make_uniq<BoundReferenceExpression>("person_rowid", LogicalType::BIGINT, 0);
    join_condition_KNOWS_k2.right = make_uniq<BoundReferenceExpression>("person_rowid", LogicalType::BIGINT, 1);
    join_condition_KNOWS_k2.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_KNOWS_k2 = make_uniq<RAIInfo>();
    rai_info_KNOWS_k2->rai = table_KNOWS.GetStorage().info->rais[0].get();
    rai_info_KNOWS_k2->rai_type = RAIType::TARGET_EDGE;
    rai_info_KNOWS_k2->forward = true;
    rai_info_KNOWS_k2->vertex = &table_PERSON;
    rai_info_KNOWS_k2->vertex_id = table_index_PERSON_p3;
    rai_info_KNOWS_k2->passing_tables[0] = table_index_PERSON_p3;
    rai_info_KNOWS_k2->left_cardinalities[0] = table_PERSON.GetStorage().info->cardinality;
    // rai_info_KNOWS_->compact_list = &rai_info_KNOWS_->rai->alist->compact__list;

    join_condition_KNOWS_k2.rais.push_back(move(rai_info_KNOWS_k2));
    cond_KNOWS_k2.push_back(move(join_condition_KNOWS_k2));

    LogicalComparisonJoin join_KNOWS_k2_op(JoinType::INNER);
    vector<LogicalType> output_KNOWS_k2_types{LogicalType::BIGINT, LogicalType::BIGINT};
    join_KNOWS_k2_op.types = output_KNOWS_k2_types;
    vector<idx_t> right_projection_map_KNOWS_k2{1};
    vector<idx_t> merge_project_map_KNOWS_k2;
    vector<LogicalType> delim_types_KNOWS_k2;
    auto join_KNOWS_k2 = make_uniq<PhysicalMergeSIPJoin>(join_KNOWS_k2_op, move(scan_PERSON_p3), move(scan_PERSON_p1),
                                                       move(cond_KNOWS_k2), JoinType::INNER, left_projection_map,
                                                       right_projection_map_KNOWS_k2, merge_project_map_KNOWS_k2,
                                                       delim_types_KNOWS_k2, 0);


    vector<idx_t> PERSON_p2_ids{0, 1, 2, COLUMN_IDENTIFIER_ROW_ID};
    vector<LogicalType> get_PERSON_p2_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::VARCHAR,
                                            LogicalType::BIGINT};
    string alias_PERSON_p2 = "p2";
    vector<LogicalType> table_types_PERSON_p2;
    vector<unique_ptr<Expression>> filter_PERSON_p2;
    unique_ptr<LogicalGet> get_op_PERSON_p2 = move(
            getLogicalGet(*this, table_PERSON, alias_PERSON_p2, table_index_PERSON_p2, table_types_PERSON_p2));
    unique_ptr<TableFilterSet> table_filters_PERSON_p2 = NULL;
    unique_ptr<PhysicalTableScan> scan_PERSON_p2 = make_uniq<PhysicalTableScan>(get_PERSON_p2_types,
                                                                                get_op_PERSON_p2->function,
                                                                                get_op_PERSON_p2->table_index,
                                                                                move(get_op_PERSON_p2->bind_data),
                                                                                table_types_PERSON_p2, PERSON_p2_ids,
                                                                                move(filter_PERSON_p2),
                                                                                vector<column_t>(),
                                                                                get_op_PERSON_p2->names,
                                                                                std::move(table_filters_PERSON_p2),
                                                                                get_op_PERSON_p2->estimated_cardinality,
                                                                                get_op_PERSON_p2->extra_info);


    vector<JoinCondition> cond_KNOWS_;
    JoinCondition join_condition_KNOWS_;
    join_condition_KNOWS_.left = make_uniq<BoundReferenceExpression>("person_rowid", LogicalType::BIGINT, 3);
    join_condition_KNOWS_.right = make_uniq<BoundReferenceExpression>("person_rowid", LogicalType::BIGINT, 0);
    join_condition_KNOWS_.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_KNOWS_ = make_uniq<RAIInfo>();
    rai_info_KNOWS_->rai = table_KNOWS.GetStorage().info->rais[0].get();
    rai_info_KNOWS_->rai_type = RAIType::TARGET_EDGE;
    rai_info_KNOWS_->forward = true;
    rai_info_KNOWS_->vertex = &table_PERSON;
    rai_info_KNOWS_->vertex_id = table_index_PERSON_p2;
    rai_info_KNOWS_->passing_tables[0] = table_index_PERSON_p2;
    rai_info_KNOWS_->left_cardinalities[0] = table_PERSON.GetStorage().info->cardinality;
    // rai_info_KNOWS_->compact_list = &rai_info_KNOWS_->rai->alist->compact__list;

    join_condition_KNOWS_.rais.push_back(move(rai_info_KNOWS_));
    cond_KNOWS_.push_back(move(join_condition_KNOWS_));

    LogicalComparisonJoin join_KNOWS__op(JoinType::INNER);
    vector<LogicalType> output_KNOWS__types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::VARCHAR,
                                            LogicalType::BIGINT, LogicalType::BIGINT};
    join_KNOWS__op.types = output_KNOWS__types;
    vector<idx_t> right_projection_map_KNOWS_{1};
    vector<idx_t> merge_project_map_KNOWS_;
    vector<LogicalType> delim_types_KNOWS_;
    auto join_KNOWS_ = make_uniq<PhysicalMergeSIPJoin>(join_KNOWS__op, move(scan_PERSON_p2), move(join_KNOWS_k2),
                                                       move(cond_KNOWS_), JoinType::INNER, left_projection_map,
                                                       right_projection_map_KNOWS_, merge_project_map_KNOWS_,
                                                       delim_types_KNOWS_, 0);


    idx_t work_from_id = atoi(paras->data()[2].c_str()); // 933;
    Value work_from = Value::INTEGER(work_from_id);
    vector<idx_t> WORKAT_pc_ids{2, 3, 4};
    vector<LogicalType> get_WORKAT_pc_types{LogicalType::INTEGER, LogicalType::BIGINT, LogicalType::BIGINT};
    string alias_WORKAT_pc = "pc";
    vector<LogicalType> table_types_WORKAT_pc;
    vector<unique_ptr<Expression>> filter_WORKAT_pc;
    unique_ptr<LogicalGet> get_op_WORKAT_pc = move(
            getLogicalGet(*this, table_WORKAT, alias_WORKAT_pc, table_index_WORKAT_pc, table_types_WORKAT_pc));
    unique_ptr<TableFilterSet> table_filters_WORKAT_pc = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_WORKAT = duckdb::make_uniq<ConstantFilter>(
            ExpressionType::COMPARE_LESSTHAN,
            work_from);
    table_filters_WORKAT_pc->filters[0] = move(constant_filter_WORKAT);
    unique_ptr<PhysicalTableScan> scan_WORKAT_pc = make_uniq<PhysicalTableScan>(get_WORKAT_pc_types,
                                                                                get_op_WORKAT_pc->function,
                                                                                get_op_WORKAT_pc->table_index,
                                                                                move(get_op_WORKAT_pc->bind_data),
                                                                                table_types_WORKAT_pc, WORKAT_pc_ids,
                                                                                move(filter_WORKAT_pc),
                                                                                vector<column_t>(),
                                                                                get_op_WORKAT_pc->names,
                                                                                std::move(table_filters_WORKAT_pc),
                                                                                get_op_WORKAT_pc->estimated_cardinality,
                                                                                get_op_WORKAT_pc->extra_info);

    vector<JoinCondition> cond_WORKAT_pc;
    JoinCondition join_condition_WORKAT_pc;
    join_condition_WORKAT_pc.left = make_uniq<BoundReferenceExpression>("pc_personid_rowid", LogicalType::BIGINT, 1);
    join_condition_WORKAT_pc.right = make_uniq<BoundReferenceExpression>("person_rowid", LogicalType::BIGINT, 3);
    join_condition_WORKAT_pc.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_WORKAT_pc = make_uniq<RAIInfo>();
    rai_info_WORKAT_pc->rai = table_WORKAT.GetStorage().info->rais[0].get();
    rai_info_WORKAT_pc->rai_type = RAIType::EDGE_SOURCE;
    rai_info_WORKAT_pc->forward = true;
    rai_info_WORKAT_pc->vertex = &table_PERSON;
    rai_info_WORKAT_pc->vertex_id = table_index_PERSON_p2;
    rai_info_WORKAT_pc->passing_tables[0] = table_index_WORKAT_pc;
    rai_info_WORKAT_pc->left_cardinalities[0] = table_WORKAT.GetStorage().info->cardinality;
    rai_info_WORKAT_pc->compact_list = &rai_info_WORKAT_pc->rai->alist->compact_forward_list;

    join_condition_WORKAT_pc.rais.push_back(move(rai_info_WORKAT_pc));
    cond_WORKAT_pc.push_back(move(join_condition_WORKAT_pc));

    LogicalComparisonJoin join_WORKAT_pc_op(JoinType::INNER);
    vector<LogicalType> output_WORKAT_pc_types{LogicalType::INTEGER, LogicalType::BIGINT, LogicalType::BIGINT,
                                               LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::VARCHAR};
    join_WORKAT_pc_op.types = output_WORKAT_pc_types;
    vector<idx_t> right_projection_map_WORKAT_pc{0, 1, 2};
    vector<idx_t> merge_project_map_WORKAT_pc;
    vector<LogicalType> delim_types_WORKAT_pc;
    auto join_WORKAT_pc = make_uniq<PhysicalSIPJoin>(join_WORKAT_pc_op, move(scan_WORKAT_pc), move(join_KNOWS_),
                                                     move(cond_WORKAT_pc), JoinType::INNER, left_projection_map,
                                                     right_projection_map_WORKAT_pc, delim_types_WORKAT_pc, 0);

    vector<idx_t> ORGANISATION_o_ids{2, 5, COLUMN_IDENTIFIER_ROW_ID};
    vector<LogicalType> get_ORGANISATION_o_types{LogicalType::VARCHAR, LogicalType::BIGINT, LogicalType::BIGINT};
    string alias_ORGANISATION_o = "o";
    vector<LogicalType> table_types_ORGANISATION_o;
    vector<unique_ptr<Expression>> filter_ORGANISATION_o;
    unique_ptr<LogicalGet> get_op_ORGANISATION_o = move(
            getLogicalGet(*this, table_ORGANISATION, alias_ORGANISATION_o, table_index_ORGANISATION_o,
                          table_types_ORGANISATION_o));
    unique_ptr<TableFilterSet> table_filters_ORGANISATION_o = NULL;
    unique_ptr<PhysicalTableScan> scan_ORGANISATION_o = make_uniq<PhysicalTableScan>(get_ORGANISATION_o_types,
                                                                                     get_op_ORGANISATION_o->function,
                                                                                     get_op_ORGANISATION_o->table_index,
                                                                                     move(get_op_ORGANISATION_o->bind_data),
                                                                                     table_types_ORGANISATION_o,
                                                                                     ORGANISATION_o_ids,
                                                                                     move(filter_ORGANISATION_o),
                                                                                     vector<column_t>(),
                                                                                     get_op_ORGANISATION_o->names,
                                                                                     std::move(
                                                                                             table_filters_ORGANISATION_o),
                                                                                     get_op_ORGANISATION_o->estimated_cardinality,
                                                                                     get_op_ORGANISATION_o->extra_info);

    vector<JoinCondition> cond_ORGANISATION_o;
    JoinCondition join_condition_ORGANISATION_o;
    join_condition_ORGANISATION_o.left = make_uniq<BoundReferenceExpression>("organisation_rowid", LogicalType::BIGINT,
                                                                             2);
    join_condition_ORGANISATION_o.right = make_uniq<BoundReferenceExpression>("pc_organisationid_rowid",
                                                                              LogicalType::BIGINT, 2);
    join_condition_ORGANISATION_o.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_ORGANISATION_o = make_uniq<RAIInfo>();
    rai_info_ORGANISATION_o->rai = table_WORKAT.GetStorage().info->rais[0].get();
    rai_info_ORGANISATION_o->rai_type = RAIType::TARGET_EDGE;
    rai_info_ORGANISATION_o->forward = true;
    rai_info_ORGANISATION_o->vertex = &table_ORGANISATION;
    rai_info_ORGANISATION_o->vertex_id = table_index_ORGANISATION_o;
    rai_info_ORGANISATION_o->passing_tables[0] = table_index_ORGANISATION_o;
    rai_info_ORGANISATION_o->left_cardinalities[0] = table_ORGANISATION.GetStorage().info->cardinality;
    // rai_info_ORGANISATION_o->compact_list = &rai_info_ORGANISATION_o->rai->alist->compact__list;

    join_condition_ORGANISATION_o.rais.push_back(move(rai_info_ORGANISATION_o));
    cond_ORGANISATION_o.push_back(move(join_condition_ORGANISATION_o));

    LogicalComparisonJoin join_ORGANISATION_o_op(JoinType::INNER);
    vector<LogicalType> output_ORGANISATION_o_types{LogicalType::VARCHAR, LogicalType::BIGINT, LogicalType::BIGINT,
                                                    LogicalType::INTEGER, LogicalType::BIGINT, LogicalType::VARCHAR,
                                                    LogicalType::VARCHAR};
    join_ORGANISATION_o_op.types = output_ORGANISATION_o_types;
    vector<idx_t> right_projection_map_ORGANISATION_o{0, 3, 4, 5};
    vector<idx_t> merge_project_map_ORGANISATION_o;
    vector<LogicalType> delim_types_ORGANISATION_o;
    auto join_ORGANISATION_o = make_uniq<PhysicalSIPJoin>(join_ORGANISATION_o_op, move(scan_ORGANISATION_o),
                                                          move(join_WORKAT_pc),
                                                          move(cond_ORGANISATION_o), JoinType::INNER,
                                                          left_projection_map,
                                                          right_projection_map_ORGANISATION_o,
                                                          delim_types_ORGANISATION_o, 0);

    string p_place_name = paras->data()[1]; // 933;
    Value p_place = Value(p_place_name);
    vector<idx_t> PLACE_pl_ids{1, COLUMN_IDENTIFIER_ROW_ID};
    vector<LogicalType> get_PLACE_pl_types{LogicalType::VARCHAR, LogicalType::BIGINT};
    string alias_PLACE_pl = "pl";
    vector<LogicalType> table_types_PLACE_pl;
    vector<unique_ptr<Expression>> filter_PLACE_pl;
    unique_ptr<LogicalGet> get_op_PLACE_pl = move(
            getLogicalGet(*this, table_PLACE, alias_PLACE_pl, table_index_PLACE_pl, table_types_PLACE_pl));
    unique_ptr<TableFilterSet> table_filters_PLACE_pl = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_PLACE = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL,
                                                                                         p_place);
    table_filters_PLACE_pl->filters[0] = move(constant_filter_PLACE);
    unique_ptr<PhysicalTableScan> scan_PLACE_pl = make_uniq<PhysicalTableScan>(get_PLACE_pl_types,
                                                                               get_op_PLACE_pl->function,
                                                                               get_op_PLACE_pl->table_index,
                                                                               move(get_op_PLACE_pl->bind_data),
                                                                               table_types_PLACE_pl, PLACE_pl_ids,
                                                                               move(filter_PLACE_pl),
                                                                               vector<column_t>(),
                                                                               get_op_PLACE_pl->names,
                                                                               std::move(table_filters_PLACE_pl),
                                                                               get_op_PLACE_pl->estimated_cardinality,
                                                                               get_op_PLACE_pl->extra_info);


    vector<JoinCondition> cond_ISLOCATEDIN_;
    JoinCondition join_condition_ISLOCATEDIN_;
    join_condition_ISLOCATEDIN_.left = make_uniq<BoundReferenceExpression>("place_rowid", LogicalType::BIGINT, 1);
    join_condition_ISLOCATEDIN_.right = make_uniq<BoundReferenceExpression>("o_placeid_rowid", LogicalType::BIGINT, 1);
    join_condition_ISLOCATEDIN_.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_ISLOCATEDIN_ = make_uniq<RAIInfo>();
    rai_info_ISLOCATEDIN_->rai = table_ORGANISATION.GetStorage().info->rais[0].get();
    rai_info_ISLOCATEDIN_->rai_type = RAIType::TARGET_EDGE;
    rai_info_ISLOCATEDIN_->forward = true;
    rai_info_ISLOCATEDIN_->vertex = &table_PLACE;
    rai_info_ISLOCATEDIN_->vertex_id = table_index_PLACE_pl;
    rai_info_ISLOCATEDIN_->passing_tables[0] = table_index_PLACE_pl;
    rai_info_ISLOCATEDIN_->left_cardinalities[0] = table_PLACE.GetStorage().info->cardinality;
    // rai_info_ISLOCATEDIN_->compact_list = &rai_info_ISLOCATEDIN_->rai->alist->compact__list;

    join_condition_ISLOCATEDIN_.rais.push_back(move(rai_info_ISLOCATEDIN_));
    cond_ISLOCATEDIN_.push_back(move(join_condition_ISLOCATEDIN_));

    LogicalComparisonJoin join_ISLOCATEDIN__op(JoinType::INNER);
    vector<LogicalType> output_ISLOCATEDIN__types{LogicalType::VARCHAR, LogicalType::BIGINT, LogicalType::VARCHAR,
                                                  LogicalType::INTEGER, LogicalType::BIGINT, LogicalType::VARCHAR,
                                                  LogicalType::VARCHAR};
    join_ISLOCATEDIN__op.types = output_ISLOCATEDIN__types;
    vector<idx_t> right_projection_map_ISLOCATEDIN_{0, 3, 4, 5, 6};
    vector<idx_t> merge_project_map_ISLOCATEDIN_;
    vector<LogicalType> delim_types_ISLOCATEDIN_;
    auto join_ISLOCATEDIN_ = make_uniq<PhysicalSIPJoin>(join_ISLOCATEDIN__op, move(scan_PLACE_pl),
                                                        move(join_ORGANISATION_o), move(cond_ISLOCATEDIN_),
                                                        JoinType::INNER, left_projection_map,
                                                        right_projection_map_ISLOCATEDIN_, delim_types_ISLOCATEDIN_, 0);


    vector<LogicalType> result_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::VARCHAR,
                                     LogicalType::VARCHAR, LogicalType::INTEGER};
    vector<unique_ptr<Expression>> select_list;
    auto result_col0 = make_uniq<BoundReferenceExpression>("p_personid", LogicalType::BIGINT, 4);
    auto result_col1 = make_uniq<BoundReferenceExpression>("p_firstname", LogicalType::VARCHAR, 5);
    auto result_col2 = make_uniq<BoundReferenceExpression>("p_lastname", LogicalType::VARCHAR, 6);
    auto result_col3 = make_uniq<BoundReferenceExpression>("o_name", LogicalType::VARCHAR, 2);
    auto result_col4 = make_uniq<BoundReferenceExpression>("pc_workfrom", LogicalType::INTEGER, 3);
    select_list.push_back(move(result_col0));
    select_list.push_back(move(result_col1));
    select_list.push_back(move(result_col2));
    select_list.push_back(move(result_col3));
    select_list.push_back(move(result_col4));
    auto projection = make_uniq<PhysicalProjection>(result_types, move(select_list), 0);
    projection->children.push_back(move(join_ISLOCATEDIN_));

    return projection;
}

unique_ptr<PhysicalOperator> ClientContext::GenerateIC121PlanGLogue() {
    vector<idx_t> left_projection_map, right_projection_map;

    string table_vertex_PERSON_p1 = "PERSON";
    string table_vertex_PERSON_f = "PERSON";
    string table_vertex_COMMENT_c = "COMMENT";
    string table_vertex_POST_ps = "POST";
    string table_vertex_TAG_t = "TAG";
    string table_vertex_TAGCLASS_tc1 = "TAGCLASS";
    string table_vertex_TAGCLASS_tc2 = "TAGCLASS";
    string table_vertex_KNOWS_ = "KNOWS";
    string table_vertex_HASTAG_ = "POST_TAG";

    idx_t table_index_PERSON_p1 = 1;
    idx_t table_index_PERSON_f = 2;
    idx_t table_index_COMMENT_c = 3;
    idx_t table_index_POST_ps = 4;
    idx_t table_index_TAG_t = 5;
    idx_t table_index_TAGCLASS_tc1 = 6;
    idx_t table_index_TAGCLASS_tc2 = 7;
    idx_t table_index_KNOWS_ = 8;
    idx_t table_index_HASTAG_ = 11;

    auto table_or_view_PERSON = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_PERSON_p1,
                                                  OnEntryNotFound::RETURN_NULL);
    auto &table_PERSON = table_or_view_PERSON->Cast<TableCatalogEntry>();
    auto table_or_view_COMMENT = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_COMMENT_c,
                                                   OnEntryNotFound::RETURN_NULL);
    auto &table_COMMENT = table_or_view_COMMENT->Cast<TableCatalogEntry>();
    auto table_or_view_POST = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_POST_ps,
                                                OnEntryNotFound::RETURN_NULL);
    auto &table_POST = table_or_view_POST->Cast<TableCatalogEntry>();
    auto table_or_view_TAG = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_TAG_t,
                                               OnEntryNotFound::RETURN_NULL);
    auto &table_TAG = table_or_view_TAG->Cast<TableCatalogEntry>();
    auto table_or_view_TAGCLASS = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_TAGCLASS_tc1,
                                                    OnEntryNotFound::RETURN_NULL);
    auto &table_TAGCLASS = table_or_view_TAGCLASS->Cast<TableCatalogEntry>();
    auto table_or_view_KNOWS = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_KNOWS_,
                                                 OnEntryNotFound::RETURN_NULL);
    auto &table_KNOWS = table_or_view_KNOWS->Cast<TableCatalogEntry>();
    auto table_or_view_HASTAG = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_HASTAG_,
                                                  OnEntryNotFound::RETURN_NULL);
    auto &table_HASTAG = table_or_view_HASTAG->Cast<TableCatalogEntry>();


    idx_t p_person_id = atoll(paras->data()[0].c_str()); // 933;
    Value p_person = Value::BIGINT(p_person_id);
    vector<idx_t> PERSON_p1_ids{0, COLUMN_IDENTIFIER_ROW_ID};
    vector<LogicalType> get_PERSON_p1_types{LogicalType::BIGINT, LogicalType::BIGINT};
    string alias_PERSON_p1 = "p1";
    vector<LogicalType> table_types_PERSON_p1;
    vector<unique_ptr<Expression>> filter_PERSON_p1;
    unique_ptr<LogicalGet> get_op_PERSON_p1 = move(
            getLogicalGet(*this, table_PERSON, alias_PERSON_p1, table_index_PERSON_p1, table_types_PERSON_p1));
    unique_ptr<TableFilterSet> table_filters_PERSON_p1 = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL,
                                                                                   p_person);
    table_filters_PERSON_p1->filters[0] = move(constant_filter);
    unique_ptr<PhysicalTableScan> scan_PERSON_p1 = make_uniq<PhysicalTableScan>(get_PERSON_p1_types,
                                                                                get_op_PERSON_p1->function,
                                                                                get_op_PERSON_p1->table_index,
                                                                                move(get_op_PERSON_p1->bind_data),
                                                                                table_types_PERSON_p1, PERSON_p1_ids,
                                                                                move(filter_PERSON_p1),
                                                                                vector<column_t>(),
                                                                                get_op_PERSON_p1->names,
                                                                                std::move(table_filters_PERSON_p1),
                                                                                get_op_PERSON_p1->estimated_cardinality,
                                                                                get_op_PERSON_p1->extra_info);


    vector<idx_t> PERSON_f_ids{0, 1, 2, COLUMN_IDENTIFIER_ROW_ID};
    vector<LogicalType> get_PERSON_f_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::VARCHAR, LogicalType::BIGINT};
    string alias_PERSON_f = "f";
    vector<LogicalType> table_types_PERSON_f;
    vector<unique_ptr<Expression>> filter_PERSON_f;
    unique_ptr<LogicalGet> get_op_PERSON_f = move(
            getLogicalGet(*this, table_PERSON, alias_PERSON_f, table_index_PERSON_f, table_types_PERSON_f));
    unique_ptr<TableFilterSet> table_filters_PERSON_f = NULL;
    unique_ptr<PhysicalTableScan> scan_PERSON_f = make_uniq<PhysicalTableScan>(get_PERSON_f_types,
                                                                               get_op_PERSON_f->function,
                                                                               get_op_PERSON_f->table_index,
                                                                               move(get_op_PERSON_f->bind_data),
                                                                               table_types_PERSON_f, PERSON_f_ids,
                                                                               move(filter_PERSON_f),
                                                                               vector<column_t>(),
                                                                               get_op_PERSON_f->names,
                                                                               std::move(table_filters_PERSON_f),
                                                                               get_op_PERSON_f->estimated_cardinality,
                                                                               get_op_PERSON_f->extra_info);


    vector<JoinCondition> cond_KNOWS_;
    JoinCondition join_condition_KNOWS_;
    join_condition_KNOWS_.left = make_uniq<BoundReferenceExpression>("person_rowid", LogicalType::BIGINT, 3);
    join_condition_KNOWS_.right = make_uniq<BoundReferenceExpression>("person_rowid", LogicalType::BIGINT, 1);
    join_condition_KNOWS_.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_KNOWS_ = make_uniq<RAIInfo>();
    rai_info_KNOWS_->rai = table_KNOWS.GetStorage().info->rais[0].get();
    rai_info_KNOWS_->rai_type = RAIType::TARGET_EDGE;
    rai_info_KNOWS_->forward = true;
    rai_info_KNOWS_->vertex = &table_PERSON;
    rai_info_KNOWS_->vertex_id = table_index_PERSON_f;
    rai_info_KNOWS_->passing_tables[0] = table_index_PERSON_f;
    rai_info_KNOWS_->left_cardinalities[0] = table_PERSON.GetStorage().info->cardinality;
    // rai_info_KNOWS_->compact_list = &rai_info_KNOWS_->rai->alist->compact__list;

    join_condition_KNOWS_.rais.push_back(move(rai_info_KNOWS_));
    cond_KNOWS_.push_back(move(join_condition_KNOWS_));

    LogicalComparisonJoin join_KNOWS__op(JoinType::INNER);
    vector<LogicalType> output_KNOWS__types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::VARCHAR,
                                            LogicalType::BIGINT, LogicalType::BIGINT};
    join_KNOWS__op.types = output_KNOWS__types;
    vector<idx_t> right_projection_map_KNOWS_{1};
    vector<idx_t> merge_project_map_KNOWS_;
    vector<LogicalType> delim_types_KNOWS_;
    auto join_KNOWS_ = make_uniq<PhysicalMergeSIPJoin>(join_KNOWS__op, move(scan_PERSON_f), move(scan_PERSON_p1), move(cond_KNOWS_),
                                                       JoinType::INNER, left_projection_map,
                                                       right_projection_map_KNOWS_, merge_project_map_KNOWS_,
                                                       delim_types_KNOWS_, 0);


    vector<idx_t> COMMENT_c_ids{10, 13};
    vector<LogicalType> get_COMMENT_c_types{LogicalType::BIGINT, LogicalType::BIGINT};
    string alias_COMMENT_c = "c";
    vector<LogicalType> table_types_COMMENT_c;
    vector<unique_ptr<Expression>> filter_COMMENT_c;
    unique_ptr<LogicalGet> get_op_COMMENT_c = move(
            getLogicalGet(*this, table_COMMENT, alias_COMMENT_c, table_index_COMMENT_c, table_types_COMMENT_c));
    unique_ptr<TableFilterSet> table_filters_COMMENT_c = NULL;
    unique_ptr<PhysicalTableScan> scan_COMMENT_c = make_uniq<PhysicalTableScan>(get_COMMENT_c_types,
                                                                                get_op_COMMENT_c->function,
                                                                                get_op_COMMENT_c->table_index,
                                                                                move(get_op_COMMENT_c->bind_data),
                                                                                table_types_COMMENT_c, COMMENT_c_ids,
                                                                                move(filter_COMMENT_c),
                                                                                vector<column_t>(),
                                                                                get_op_COMMENT_c->names,
                                                                                std::move(table_filters_COMMENT_c),
                                                                                get_op_COMMENT_c->estimated_cardinality,
                                                                                get_op_COMMENT_c->extra_info);


    vector<JoinCondition> cond_HASCREATOR_;
    JoinCondition join_condition_HASCREATOR_;
    join_condition_HASCREATOR_.left = make_uniq<BoundReferenceExpression>("m_creator_rowid", LogicalType::BIGINT, 0);
    join_condition_HASCREATOR_.right = make_uniq<BoundReferenceExpression>("p_personid", LogicalType::BIGINT, 3);
    join_condition_HASCREATOR_.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_HASCREATOR_ = make_uniq<RAIInfo>();
    rai_info_HASCREATOR_->rai = table_COMMENT.GetStorage().info->rais[0].get();
    rai_info_HASCREATOR_->rai_type = RAIType::EDGE_SOURCE;
    rai_info_HASCREATOR_->forward = true;
    rai_info_HASCREATOR_->vertex = &table_PERSON;
    rai_info_HASCREATOR_->vertex_id = table_index_PERSON_f;
    rai_info_HASCREATOR_->passing_tables[0] = table_index_COMMENT_c;
    rai_info_HASCREATOR_->left_cardinalities[0] = table_COMMENT.GetStorage().info->cardinality;
    rai_info_HASCREATOR_->compact_list = &rai_info_HASCREATOR_->rai->alist->compact_forward_list;

    join_condition_HASCREATOR_.rais.push_back(move(rai_info_HASCREATOR_));
    cond_HASCREATOR_.push_back(move(join_condition_HASCREATOR_));

    LogicalComparisonJoin join_HASCREATOR__op(JoinType::INNER);
    vector<LogicalType> output_HASCREATOR__types{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::BIGINT,
                                                 LogicalType::VARCHAR, LogicalType::VARCHAR};
    join_HASCREATOR__op.types = output_HASCREATOR__types;
    vector<idx_t> right_projection_map_HASCREATOR_{0, 1, 2};
    vector<idx_t> merge_project_map_HASCREATOR_;
    vector<LogicalType> delim_types_HASCREATOR_;
    auto join_HASCREATOR_ = make_uniq<PhysicalSIPJoin>(join_HASCREATOR__op, move(scan_COMMENT_c), move(join_KNOWS_), move(cond_HASCREATOR_),
                                                            JoinType::INNER, left_projection_map,
                                                            right_projection_map_HASCREATOR_,
                                                            delim_types_HASCREATOR_, 0);


    vector<idx_t> POST_ps_ids{COLUMN_IDENTIFIER_ROW_ID};
    vector<LogicalType> get_POST_ps_types{LogicalType::BIGINT};
    string alias_POST_ps = "ps";
    vector<LogicalType> table_types_POST_ps;
    vector<unique_ptr<Expression>> filter_POST_ps;
    unique_ptr<LogicalGet> get_op_POST_ps = move(
            getLogicalGet(*this, table_POST, alias_POST_ps, table_index_POST_ps, table_types_POST_ps));
    unique_ptr<TableFilterSet> table_filters_POST_ps = NULL;
    unique_ptr<PhysicalTableScan> scan_POST_ps = make_uniq<PhysicalTableScan>(get_POST_ps_types,
                                                                              get_op_POST_ps->function,
                                                                              get_op_POST_ps->table_index,
                                                                              move(get_op_POST_ps->bind_data),
                                                                              table_types_POST_ps, POST_ps_ids,
                                                                              move(filter_POST_ps), vector<column_t>(),
                                                                              get_op_POST_ps->names,
                                                                              std::move(table_filters_POST_ps),
                                                                              get_op_POST_ps->estimated_cardinality,
                                                                              get_op_POST_ps->extra_info);


    vector<JoinCondition> cond_REPLYOF_;
    JoinCondition join_condition_REPLYOF_;
    join_condition_REPLYOF_.left = make_uniq<BoundReferenceExpression>("post_rowid", LogicalType::BIGINT, 0);
    join_condition_REPLYOF_.right = make_uniq<BoundReferenceExpression>("m_replyof_post_rowid", LogicalType::BIGINT, 1);
    join_condition_REPLYOF_.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_REPLYOF_ = make_uniq<RAIInfo>();
    rai_info_REPLYOF_->rai = table_COMMENT.GetStorage().info->rais[3].get();
    rai_info_REPLYOF_->rai_type = RAIType::TARGET_EDGE;
    rai_info_REPLYOF_->forward = true;
    rai_info_REPLYOF_->vertex = &table_POST;
    rai_info_REPLYOF_->vertex_id = table_index_POST_ps;
    rai_info_REPLYOF_->passing_tables[0] = table_index_POST_ps;
    rai_info_REPLYOF_->left_cardinalities[0] = table_POST.GetStorage().info->cardinality;
    // rai_info_REPLYOF_->compact_list = &rai_info_REPLYOF_->rai->alist->compact__list;

    join_condition_REPLYOF_.rais.push_back(move(rai_info_REPLYOF_));
    cond_REPLYOF_.push_back(move(join_condition_REPLYOF_));

    LogicalComparisonJoin join_REPLYOF__op(JoinType::INNER);
    vector<LogicalType> output_REPLYOF__types{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::VARCHAR,
                                              LogicalType::VARCHAR};
    join_REPLYOF__op.types = output_REPLYOF__types;
    vector<idx_t> right_projection_map_REPLYOF_{2, 3, 4};
    vector<idx_t> merge_project_map_REPLYOF_;
    vector<LogicalType> delim_types_REPLYOF_;
    auto join_REPLYOF_ = make_uniq<PhysicalSIPJoin>(join_REPLYOF__op, move(scan_POST_ps), move(join_HASCREATOR_), move(cond_REPLYOF_),
                                                         JoinType::INNER, left_projection_map,
                                                         right_projection_map_REPLYOF_,
                                                         delim_types_REPLYOF_, 0);


    vector<idx_t> TAG_t_ids{4, COLUMN_IDENTIFIER_ROW_ID};
    vector<LogicalType> get_TAG_t_types{LogicalType::BIGINT, LogicalType::BIGINT};
    string alias_TAG_t = "t";
    vector<LogicalType> table_types_TAG_t;
    vector<unique_ptr<Expression>> filter_TAG_t;
    unique_ptr<LogicalGet> get_op_TAG_t = move(
            getLogicalGet(*this, table_TAG, alias_TAG_t, table_index_TAG_t, table_types_TAG_t));
    unique_ptr<TableFilterSet> table_filters_TAG_t = NULL;
    unique_ptr<PhysicalTableScan> scan_TAG_t = make_uniq<PhysicalTableScan>(get_TAG_t_types, get_op_TAG_t->function,
                                                                            get_op_TAG_t->table_index,
                                                                            move(get_op_TAG_t->bind_data),
                                                                            table_types_TAG_t, TAG_t_ids,
                                                                            move(filter_TAG_t), vector<column_t>(),
                                                                            get_op_TAG_t->names,
                                                                            std::move(table_filters_TAG_t),
                                                                            get_op_TAG_t->estimated_cardinality,
                                                                            get_op_TAG_t->extra_info);


    vector<JoinCondition> cond_HASTAG_;
    JoinCondition join_condition_HASTAG_;
    join_condition_HASTAG_.left = make_uniq<BoundReferenceExpression>("tag_rowid", LogicalType::BIGINT, 1);
    join_condition_HASTAG_.right = make_uniq<BoundReferenceExpression>("post_rowid", LogicalType::BIGINT, 0);
    join_condition_HASTAG_.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_HASTAG_ = make_uniq<RAIInfo>();
    rai_info_HASTAG_->rai = table_HASTAG.GetStorage().info->rais[0].get();
    rai_info_HASTAG_->rai_type = RAIType::TARGET_EDGE;
    rai_info_HASTAG_->forward = true;
    rai_info_HASTAG_->vertex = &table_TAG;
    rai_info_HASTAG_->vertex_id = table_index_TAG_t;
    rai_info_HASTAG_->passing_tables[0] = table_index_TAG_t;
    rai_info_HASTAG_->left_cardinalities[0] = table_TAG.GetStorage().info->cardinality;
    // rai_info_HASTAG_->compact_list = &rai_info_HASTAG_->rai->alist->compact__list;

    join_condition_HASTAG_.rais.push_back(move(rai_info_HASTAG_));
    cond_HASTAG_.push_back(move(join_condition_HASTAG_));

    LogicalComparisonJoin join_HASTAG__op(JoinType::INNER);
    vector<LogicalType> output_HASTAG__types{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::BIGINT,
                                             LogicalType::VARCHAR, LogicalType::VARCHAR};
    join_HASTAG__op.types = output_HASTAG__types;
    vector<idx_t> right_projection_map_HASTAG_{1, 2, 3};
    vector<idx_t> merge_project_map_HASTAG_;
    vector<LogicalType> delim_types_HASTAG_;
    auto join_HASTAG_ = make_uniq<PhysicalMergeSIPJoin>(join_HASTAG__op, move(scan_TAG_t), move(join_REPLYOF_), move(cond_HASTAG_),
                                                        JoinType::INNER, left_projection_map,
                                                        right_projection_map_HASTAG_, merge_project_map_HASTAG_,
                                                        delim_types_HASTAG_, 0);


    vector<idx_t> TAGCLASS_tc1_ids{4, COLUMN_IDENTIFIER_ROW_ID};
    vector<LogicalType> get_TAGCLASS_tc1_types{LogicalType::BIGINT, LogicalType::BIGINT};
    string alias_TAGCLASS_tc1 = "tc1";
    vector<LogicalType> table_types_TAGCLASS_tc1;
    vector<unique_ptr<Expression>> filter_TAGCLASS_tc1;
    unique_ptr<LogicalGet> get_op_TAGCLASS_tc1 = move(
            getLogicalGet(*this, table_TAGCLASS, alias_TAGCLASS_tc1, table_index_TAGCLASS_tc1,
                          table_types_TAGCLASS_tc1));
    unique_ptr<TableFilterSet> table_filters_TAGCLASS_tc1 = NULL;
    unique_ptr<PhysicalTableScan> scan_TAGCLASS_tc1 = make_uniq<PhysicalTableScan>(get_TAGCLASS_tc1_types,
                                                                                   get_op_TAGCLASS_tc1->function,
                                                                                   get_op_TAGCLASS_tc1->table_index,
                                                                                   move(get_op_TAGCLASS_tc1->bind_data),
                                                                                   table_types_TAGCLASS_tc1,
                                                                                   TAGCLASS_tc1_ids,
                                                                                   move(filter_TAGCLASS_tc1),
                                                                                   vector<column_t>(),
                                                                                   get_op_TAGCLASS_tc1->names,
                                                                                   std::move(
                                                                                           table_filters_TAGCLASS_tc1),
                                                                                   get_op_TAGCLASS_tc1->estimated_cardinality,
                                                                                   get_op_TAGCLASS_tc1->extra_info);


    vector<JoinCondition> cond_HASTYPE_;
    JoinCondition join_condition_HASTYPE_;
    join_condition_HASTYPE_.left = make_uniq<BoundReferenceExpression>("tagclass_rowid", LogicalType::BIGINT, 1);
    join_condition_HASTYPE_.right = make_uniq<BoundReferenceExpression>("t_tagclassid_rowid", LogicalType::BIGINT, 0);
    join_condition_HASTYPE_.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_HASTYPE_ = make_uniq<RAIInfo>();
    rai_info_HASTYPE_->rai = table_TAG.GetStorage().info->rais[0].get();
    rai_info_HASTYPE_->rai_type = RAIType::TARGET_EDGE;
    rai_info_HASTYPE_->forward = true;
    rai_info_HASTYPE_->vertex = &table_TAGCLASS;
    rai_info_HASTYPE_->vertex_id = table_index_TAGCLASS_tc1;
    rai_info_HASTYPE_->passing_tables[0] = table_index_TAGCLASS_tc1;
    rai_info_HASTYPE_->left_cardinalities[0] = table_TAGCLASS.GetStorage().info->cardinality;
    // rai_info_HASTYPE_->compact_list = &rai_info_HASTYPE_->rai->alist->compact_forward_list;

    join_condition_HASTYPE_.rais.push_back(move(rai_info_HASTYPE_));
    cond_HASTYPE_.push_back(move(join_condition_HASTYPE_));

    LogicalComparisonJoin join_HASTYPE__op(JoinType::INNER);
    vector<LogicalType> output_HASTYPE__types{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::BIGINT,
                                              LogicalType::VARCHAR, LogicalType::VARCHAR};
    join_HASTYPE__op.types = output_HASTYPE__types;
    vector<idx_t> right_projection_map_HASTYPE_{2, 3, 4};
    vector<idx_t> merge_project_map_HASTYPE_;
    vector<LogicalType> delim_types_HASTYPE_;
    auto join_HASTYPE_ = make_uniq<PhysicalSIPJoin>(join_HASTYPE__op, move(scan_TAGCLASS_tc1), move(join_HASTAG_), move(cond_HASTYPE_),
                                                         JoinType::INNER, left_projection_map,
                                                         right_projection_map_HASTYPE_,
                                                         delim_types_HASTYPE_, 0);

    string tc_name_str = paras->data()[1]; // 933;
    Value tc_name = Value(tc_name_str);
    vector<idx_t> TAGCLASS_tc2_ids{1, COLUMN_IDENTIFIER_ROW_ID};
    vector<LogicalType> get_TAGCLASS_tc2_types{LogicalType::VARCHAR, LogicalType::BIGINT};
    string alias_TAGCLASS_tc2 = "tc2";
    vector<LogicalType> table_types_TAGCLASS_tc2;
    vector<unique_ptr<Expression>> filter_TAGCLASS_tc2;
    unique_ptr<LogicalGet> get_op_TAGCLASS_tc2 = move(
            getLogicalGet(*this, table_TAGCLASS, alias_TAGCLASS_tc2, table_index_TAGCLASS_tc2,
                          table_types_TAGCLASS_tc2));
    unique_ptr<TableFilterSet> table_filters_TAGCLASS_tc2 = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_tc2 = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL,
                                                                                   tc_name);
    table_filters_TAGCLASS_tc2->filters[0] = move(constant_filter_tc2);
    unique_ptr<PhysicalTableScan> scan_TAGCLASS_tc2 = make_uniq<PhysicalTableScan>(get_TAGCLASS_tc2_types,
                                                                                   get_op_TAGCLASS_tc2->function,
                                                                                   get_op_TAGCLASS_tc2->table_index,
                                                                                   move(get_op_TAGCLASS_tc2->bind_data),
                                                                                   table_types_TAGCLASS_tc2,
                                                                                   TAGCLASS_tc2_ids,
                                                                                   move(filter_TAGCLASS_tc2),
                                                                                   vector<column_t>(),
                                                                                   get_op_TAGCLASS_tc2->names,
                                                                                   std::move(
                                                                                           table_filters_TAGCLASS_tc2),
                                                                                   get_op_TAGCLASS_tc2->estimated_cardinality,
                                                                                   get_op_TAGCLASS_tc2->extra_info);


    vector<JoinCondition> cond_ISSUBCLASSOF_;
    JoinCondition join_condition_ISSUBCLASSOF_;
    join_condition_ISSUBCLASSOF_.left = make_uniq<BoundReferenceExpression>("tagclass_rowid", LogicalType::BIGINT, 1);
    join_condition_ISSUBCLASSOF_.right = make_uniq<BoundReferenceExpression>("tc_subclassoftagclassid_rowid", LogicalType::BIGINT, 0);
    join_condition_ISSUBCLASSOF_.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_ISSUBCLASSOF_ = make_uniq<RAIInfo>();
    rai_info_ISSUBCLASSOF_->rai = table_TAGCLASS.GetStorage().info->rais[0].get();
    rai_info_ISSUBCLASSOF_->rai_type = RAIType::TARGET_EDGE;
    rai_info_ISSUBCLASSOF_->forward = true;
    rai_info_ISSUBCLASSOF_->vertex = &table_TAGCLASS;
    rai_info_ISSUBCLASSOF_->vertex_id = table_index_TAGCLASS_tc1;
    rai_info_ISSUBCLASSOF_->passing_tables[0] = table_index_TAGCLASS_tc2;
    rai_info_ISSUBCLASSOF_->left_cardinalities[0] = table_TAGCLASS.GetStorage().info->cardinality;
    // rai_info_ISSUBCLASSOF_->compact_list = &rai_info_ISSUBCLASSOF_->rai->alist->compact__list;

    join_condition_ISSUBCLASSOF_.rais.push_back(move(rai_info_ISSUBCLASSOF_));
    cond_ISSUBCLASSOF_.push_back(move(join_condition_ISSUBCLASSOF_));

    LogicalComparisonJoin join_ISSUBCLASSOF__op(JoinType::INNER);
    vector<LogicalType> output_ISSUBCLASSOF__types{LogicalType::VARCHAR, LogicalType::BIGINT, LogicalType::BIGINT,
                                                   LogicalType::VARCHAR, LogicalType::VARCHAR};
    join_ISSUBCLASSOF__op.types = output_ISSUBCLASSOF__types;
    vector<idx_t> right_projection_map_ISSUBCLASSOF_{2, 3, 4};
    vector<idx_t> merge_project_map_ISSUBCLASSOF_;
    vector<LogicalType> delim_types_ISSUBCLASSOF_;
    auto join_ISSUBCLASSOF_ = make_uniq<PhysicalSIPJoin>(join_ISSUBCLASSOF__op, move(scan_TAGCLASS_tc2), move(join_HASTYPE_),
                                                              move(cond_ISSUBCLASSOF_), JoinType::INNER,
                                                              left_projection_map, right_projection_map_ISSUBCLASSOF_,
                                                              delim_types_ISSUBCLASSOF_, 0);


    vector<LogicalType> result_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::VARCHAR};
    vector<unique_ptr<Expression>> select_list;
    auto result_col0 = make_uniq<BoundReferenceExpression>("p_personid", LogicalType::BIGINT, 2);
    auto result_col1 = make_uniq<BoundReferenceExpression>("p_firstname", LogicalType::VARCHAR, 3);
    auto result_col2 = make_uniq<BoundReferenceExpression>("p_lastname", LogicalType::VARCHAR, 4);
    select_list.push_back(move(result_col0));
    select_list.push_back(move(result_col1));
    select_list.push_back(move(result_col2));
    auto projection = make_uniq<PhysicalProjection>(result_types, move(select_list), 0);
    projection->children.push_back(move(join_ISSUBCLASSOF_));

    return projection;
}

unique_ptr<PhysicalOperator> ClientContext::GenerateJOB1aPlan(ClientContext& context) {
    vector<idx_t> left_projection_map, right_projection_map;
    //QueryErrorContext error_context_unlike1(NULL, NULL);
    //auto contains_func1 = Catalog::GetEntry(context, CatalogType::SCALAR_FUNCTION_ENTRY, "", "",
    //                                       "contains", OnEntryNotFound::RETURN_NULL, error_context_unlike1);

    string table_vertex_company_type = "company_type";
    string table_vertex_movie_companies = "movie_companies";
    string table_vertex_title = "title";
    string table_vertex_movie_info_idx = "movie_info_idx";
    string table_vertex_info_type = "info_type";
    idx_t table_index_company_type = 6;
    idx_t table_index_movie_companies = 7;
    idx_t table_index_title = 8;
    idx_t table_index_movie_info_idx = 9;
    idx_t table_index_info_type = 10;


    auto table_or_view_company_type = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                  table_vertex_company_type, OnEntryNotFound::RETURN_NULL);
    auto &table_company_type = table_or_view_company_type->Cast<TableCatalogEntry>();

    auto table_or_view_movie_companies = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                 table_vertex_movie_companies, OnEntryNotFound::RETURN_NULL);
    auto &table_movie_companies = table_or_view_movie_companies->Cast<TableCatalogEntry>();

    auto table_or_view_title = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                table_vertex_title, OnEntryNotFound::RETURN_NULL);
    auto &table_title = table_or_view_title->Cast<TableCatalogEntry>();

    auto table_or_view_movie_info_idx= Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                 table_vertex_movie_info_idx, OnEntryNotFound::RETURN_NULL);
    auto &table_movie_info_idx = table_or_view_movie_info_idx->Cast<TableCatalogEntry>();

    auto table_or_view_info_type = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                        table_vertex_info_type, OnEntryNotFound::RETURN_NULL);
    auto &table_info_type = table_or_view_info_type->Cast<TableCatalogEntry>();


    Value p_info_type = Value("top 250 rank");
    vector<idx_t> info_type_ids{COLUMN_IDENTIFIER_ROW_ID, 1};
    vector<LogicalType> get_info_type{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_info_type = "it";
    vector<LogicalType> table_types_info_type;
    vector<unique_ptr<Expression>> filter_info_type;
    unique_ptr<LogicalGet> get_op_info_type = move(
            getLogicalGet(*this, table_info_type, alias_info_type, table_index_info_type, table_types_info_type));
    unique_ptr<TableFilterSet> table_filters_info_type = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_info_type = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL,
                                                                                   p_info_type);
    table_filters_info_type->filters[1] = move(constant_info_type);
    unique_ptr<PhysicalTableScan> scan_info_type = make_uniq<PhysicalTableScan>(get_info_type,
                                                                              get_op_info_type->function,
                                                                                get_op_info_type->table_index,
                                                                              move(get_op_info_type->bind_data),
                                                                              table_types_info_type, info_type_ids,
                                                                              move(filter_info_type),
                                                                              vector<column_t>(),
                                                                              get_op_info_type->names,
                                                                              std::move(table_filters_info_type),
                                                                              get_op_info_type->estimated_cardinality,
                                                                              get_op_info_type->extra_info);


    vector<idx_t> movie_info_idx_ids{1, 5};
    vector<LogicalType> get_movie_info_idx_type{LogicalType::BIGINT, LogicalType::BIGINT};
    string alias_movie_info_idx = "mi";
    vector<LogicalType> table_types_movie_info_idx;
    vector<unique_ptr<Expression>> filter_movie_info_idx;
    unique_ptr<LogicalGet> get_op_movie_info_idx = move(
            getLogicalGet(*this, table_movie_info_idx, alias_movie_info_idx, table_index_movie_info_idx, table_types_movie_info_idx));
    unique_ptr<TableFilterSet> table_filters_movie_info_idx = NULL;
    unique_ptr<PhysicalTableScan> scan_movie_info_idx = make_uniq<PhysicalTableScan>(get_movie_info_idx_type,
                                                                                get_op_movie_info_idx->function,
                                                                                get_op_movie_info_idx->table_index,
                                                                                move(get_op_movie_info_idx->bind_data),
                                                                                table_types_movie_info_idx, movie_info_idx_ids,
                                                                                move(filter_movie_info_idx),
                                                                                vector<column_t>(),
                                                                                get_op_movie_info_idx->names,
                                                                                std::move(table_filters_movie_info_idx),
                                                                                get_op_movie_info_idx->estimated_cardinality,
                                                                                get_op_movie_info_idx->extra_info);

    vector<JoinCondition> cond_movie_info_idx;
    JoinCondition join_condition_movie_info_idx;
    join_condition_movie_info_idx.left = make_uniq<BoundReferenceExpression>("info_type_id_rowid", LogicalType::BIGINT, 1);
    join_condition_movie_info_idx.right = make_uniq<BoundReferenceExpression>("info_type_rowid", LogicalType::BIGINT, 0);
    join_condition_movie_info_idx.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_movie_info_idx = make_uniq<RAIInfo>();
    rai_info_movie_info_idx->rai = table_movie_info_idx.GetStorage().info->rais[0].get();
    rai_info_movie_info_idx->rai_type = RAIType::EDGE_SOURCE;
    rai_info_movie_info_idx->forward = true;
    rai_info_movie_info_idx->vertex = &table_info_type;
    rai_info_movie_info_idx->vertex_id = table_index_info_type;
    rai_info_movie_info_idx->passing_tables[0] = table_index_movie_info_idx;
    rai_info_movie_info_idx->left_cardinalities[0] = table_movie_info_idx.GetStorage().info->cardinality;
    rai_info_movie_info_idx->compact_list = &rai_info_movie_info_idx->rai->alist->compact_forward_list;

    join_condition_movie_info_idx.rais.push_back(move(rai_info_movie_info_idx));
    cond_movie_info_idx.push_back(move(join_condition_movie_info_idx));

    LogicalComparisonJoin join_movie_info_idx_op(JoinType::INNER);
    vector<LogicalType> output_movie_info_idx_types{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::BIGINT};
    join_movie_info_idx_op.types = output_movie_info_idx_types;
    vector<idx_t> right_projection_map_movie_info_idx{0};
    vector<LogicalType> delim_types_movie_info_idx;
    auto join_movie_info_idx = make_uniq<PhysicalSIPJoin>(join_movie_info_idx_op, move(scan_movie_info_idx), move(scan_info_type),
                                                      move(cond_movie_info_idx),
                                                      JoinType::INNER, left_projection_map,
                                                      right_projection_map_movie_info_idx,
                                                      delim_types_movie_info_idx, 0);

    Value p_mc_unlike = Value("(as Metro-Goldwyn-Mayer Pictures)");
    Value p_mc_like_1 = Value("(co-production)");
    Value p_mc_like_2 = Value("(presents)");
    vector<idx_t> mc_ids{1, 7, 4, 6};
    vector<LogicalType> get_mc_types{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::BIGINT};
    string alias_mc = "mc";
    vector<LogicalType> table_types_mc;
    unique_ptr<LogicalGet> get_op_mc = move(
            getLogicalGet(*this, table_movie_companies, alias_mc, table_index_movie_companies, table_types_mc));
    vector<unique_ptr<Expression>> filter_mc;
    unique_ptr<TableFilterSet> table_filters_mc = NULL;
    unique_ptr<PhysicalTableScan> scan_mc = make_uniq<PhysicalTableScan>(get_mc_types,
                                                                              get_op_mc->function,
                                                                              get_op_mc->table_index,
                                                                              move(get_op_mc->bind_data),
                                                                              table_types_mc, mc_ids,
                                                                              move(filter_mc),
                                                                              vector<column_t>(),
                                                                              get_op_mc->names,
                                                                              std::move(table_filters_mc),
                                                                              get_op_mc->estimated_cardinality,
                                                                              get_op_mc->extra_info);

    vector<LogicalType> filter_mc_types{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::BIGINT};
    vector<unique_ptr<Expression>> select_list;
    auto unlike_expression_left = make_uniq<BoundReferenceExpression>("note", LogicalType::VARCHAR, 2);
    auto unlike_expression_value = make_uniq<BoundConstantExpression>(p_mc_unlike);
    vector<unique_ptr<Expression>> unlike_arguments;
    unlike_arguments.push_back(move(unlike_expression_left));
    unlike_arguments.push_back(move(unlike_expression_value));

    QueryErrorContext error_context_unlike(NULL, NULL);
    ScalarFunction bound_function_contains = ContainsFun::GetFunction();
    unique_ptr<FunctionData> bind_data_contains = NULL;
    /*auto contains_func = Catalog::GetEntry(context, CatalogType::SCALAR_FUNCTION_ENTRY, "", "",
                                      "contains", OnEntryNotFound::RETURN_NULL, error_context_unlike);
    ScalarFunctionCatalogEntry& contains_func_set = contains_func->Cast<ScalarFunctionCatalogEntry>();
    // bind the aggregate
    string contain_name = "contains";
    string contain_error = "";
    FunctionBinder function_binder_contains(context);
    vector<LogicalType> types_contains;

    types_contains.push_back(LogicalType::BOOLEAN);
    idx_t best_function_contains_idx = function_binder_contains.BindFunction(contain_name, contains_func_set.functions, types_contains, contain_error);
    std::cout << best_function_contains_idx << " " << contains_func_set.functions.functions.size() << std::endl;
    ScalarFunction bound_function_contains = contains_func_set.functions.GetFunctionByOffset(best_function_contains_idx);*/

    auto unlike_bound_function = make_uniq<BoundFunctionExpression>(LogicalType::BOOLEAN,
                                                                    bound_function_contains,
                                                                    move(unlike_arguments),
                                                                    move(bind_data_contains), false);

    auto not_unlike_bound_function = make_uniq<BoundOperatorExpression>(ExpressionType::OPERATOR_NOT,
                                                                        LogicalType::BOOLEAN);
    not_unlike_bound_function->children.push_back(move(unlike_bound_function));

    auto like_bound_function = make_uniq<BoundConjunctionExpression>(ExpressionType::CONJUNCTION_OR);

    auto like_expression_left_exp = make_uniq<BoundReferenceExpression>("note", LogicalType::VARCHAR, 2);
    auto like_expression_left_value = make_uniq<BoundConstantExpression>(p_mc_like_1);
    vector<unique_ptr<Expression>> like_arguments_left;
    like_arguments_left.push_back(move(like_expression_left_exp));
    like_arguments_left.push_back(move(like_expression_left_value));
    auto like_bound_function_left = make_uniq<BoundFunctionExpression>(LogicalType::BOOLEAN,
                                                                    bound_function_contains,
                                                                    move(like_arguments_left),
                                                                    move(bind_data_contains), false);

    auto like_expression_right_exp = make_uniq<BoundReferenceExpression>("note", LogicalType::VARCHAR, 2);
    auto like_expression_right_value = make_uniq<BoundConstantExpression>(p_mc_like_2);
    vector<unique_ptr<Expression>> like_arguments_right;
    like_arguments_right.push_back(move(like_expression_right_exp));
    like_arguments_right.push_back(move(like_expression_right_value));
    auto like_bound_function_right = make_uniq<BoundFunctionExpression>(LogicalType::BOOLEAN,
                                                                       bound_function_contains,
                                                                       move(like_arguments_right),
                                                                       move(bind_data_contains), false);

    like_bound_function->children.push_back(move(like_bound_function_left));
    like_bound_function->children.push_back(move(like_bound_function_right));

    auto and_conjunction = make_uniq<BoundConjunctionExpression>(ExpressionType::CONJUNCTION_AND);
    and_conjunction->children.push_back(move(not_unlike_bound_function));
    and_conjunction->children.push_back(move(like_bound_function));

    select_list.push_back(move(and_conjunction));
    unique_ptr<PhysicalFilter> filter_mc_contains = make_uniq<PhysicalFilter>(filter_mc_types, move(select_list), 0);
    filter_mc_contains->children.push_back(move(scan_mc));


    vector<JoinCondition> cond_mc;
    JoinCondition join_condition_mc;
    join_condition_mc.left = make_uniq<BoundReferenceExpression>("movie_id", LogicalType::BIGINT, 0);
    join_condition_mc.right = make_uniq<BoundReferenceExpression>("movie_id", LogicalType::BIGINT, 0);
    join_condition_mc.comparison = ExpressionType::COMPARE_EQUAL;

    cond_mc.push_back(move(join_condition_mc));

    LogicalComparisonJoin join_mc_op(JoinType::INNER);
    vector<LogicalType> output_mc_types{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::VARCHAR,
                                        LogicalType::BIGINT, LogicalType::BIGINT};
    join_mc_op.types = output_mc_types;
    vector<idx_t> right_projection_map_mc{0};
    vector<LogicalType> delim_types;
    PerfectHashJoinStats perfect_stat;
    auto join_mc = make_uniq<PhysicalHashJoin>(join_mc_op, move(filter_mc_contains), move(join_movie_info_idx),
                                                      move(cond_mc),
                                                      JoinType::INNER, left_projection_map,
                                                      right_projection_map_mc, delim_types, 0, perfect_stat);

    Value p_company_type("production companies");
    vector<idx_t> company_type_ids{COLUMN_IDENTIFIER_ROW_ID, 1};
    vector<LogicalType> get_company_type_type{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_company_type = "ct";
    vector<LogicalType> table_types_company_type;
    vector<unique_ptr<Expression>> filter_company_type;
    unique_ptr<LogicalGet> get_op_company_type = move(
            getLogicalGet(*this, table_company_type, alias_company_type, table_index_company_type, table_types_company_type));
    unique_ptr<TableFilterSet> table_filters_company_type = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_company_type = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL,
                                                                                      p_company_type);
    table_filters_company_type->filters[1] = move(constant_company_type);
    unique_ptr<PhysicalTableScan> scan_company_type = make_uniq<PhysicalTableScan>(get_company_type_type,
                                                                                     get_op_company_type->function,
                                                                                     get_op_company_type->table_index,
                                                                                     move(get_op_company_type->bind_data),
                                                                                     table_types_company_type, company_type_ids,
                                                                                     move(filter_company_type),
                                                                                     vector<column_t>(),
                                                                                     get_op_company_type->names,
                                                                                     std::move(table_filters_company_type),
                                                                                     get_op_company_type->estimated_cardinality,
                                                                                     get_op_company_type->extra_info);

    vector<JoinCondition> cond_company_type;
    JoinCondition join_condition_company_type;
    join_condition_company_type.left = make_uniq<BoundReferenceExpression>("company_type_rowid", LogicalType::BIGINT, 0);
    join_condition_company_type.right = make_uniq<BoundReferenceExpression>("company_type_id_rowid", LogicalType::BIGINT, 1);
    join_condition_company_type.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_company_type = make_uniq<RAIInfo>();
    rai_info_company_type->rai = table_movie_companies.GetStorage().info->rais[1].get();
    rai_info_company_type->rai_type = RAIType::SOURCE_EDGE;
    rai_info_company_type->forward = false;
    rai_info_company_type->vertex = &table_company_type;
    rai_info_company_type->vertex_id = table_index_company_type;
    rai_info_company_type->passing_tables[0] = table_index_company_type;
    rai_info_company_type->left_cardinalities[0] = table_company_type.GetStorage().info->cardinality;
    // rai_info_company_type->compact_list = &rai_info_company_type->rai->alist->compact_forward_list;

    join_condition_company_type.rais.push_back(move(rai_info_company_type));
    cond_company_type.push_back(move(join_condition_company_type));

    LogicalComparisonJoin join_company_type_op(JoinType::INNER);
    vector<LogicalType> output_company_type_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::BIGINT, LogicalType::VARCHAR};
    join_company_type_op.types = output_company_type_types;
    vector<idx_t> right_projection_map_company_type{3, 2};
    vector<LogicalType> delim_types_company_type;
    auto join_company_type = make_uniq<PhysicalSIPJoin>(join_company_type_op, move(scan_company_type), move(join_mc),
                                                          move(cond_company_type),
                                                          JoinType::INNER, left_projection_map,
                                                          right_projection_map_company_type,
                                                          delim_types_company_type, 0);

    // join the 2-hop neighbors
    vector<idx_t> title_ids{COLUMN_IDENTIFIER_ROW_ID, 1, 4};
    vector<LogicalType> get_title_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::BIGINT};
    string alias_title = "t";
    vector<LogicalType> table_types_title;
    vector<unique_ptr<Expression>> filter_title;
    unique_ptr<LogicalGet> get_op_title = move(
            getLogicalGet(*this, table_title, alias_title, table_index_title, table_types_title));
    unique_ptr<TableFilterSet> table_filters_title = NULL;
    unique_ptr<PhysicalTableScan> scan_title = make_uniq<PhysicalTableScan>(get_title_types,
                                                                              get_op_title->function,
                                                                              get_op_title->table_index,
                                                                              move(get_op_title->bind_data),
                                                                              table_types_title, title_ids,
                                                                              move(filter_title),
                                                                              vector<column_t>(),
                                                                              get_op_title->names,
                                                                              std::move(table_filters_title),
                                                                              get_op_title->estimated_cardinality,
                                                                              get_op_title->extra_info);

    vector<JoinCondition> cond_title;
    JoinCondition join_condition_title;
    join_condition_title.left = make_uniq<BoundReferenceExpression>("title_rowid", LogicalType::BIGINT, 0);
    join_condition_title.right = make_uniq<BoundReferenceExpression>("movie_id_rowid", LogicalType::BIGINT, 2);
    join_condition_title.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_title = make_uniq<RAIInfo>();
    rai_info_title->rai = table_movie_companies.GetStorage().info->rais[1].get();
    rai_info_title->rai_type = RAIType::TARGET_EDGE;
    rai_info_title->forward = true;
    rai_info_title->vertex = &table_title;
    rai_info_title->vertex_id = table_index_title;
    rai_info_title->passing_tables[0] = table_index_title;
    rai_info_title->left_cardinalities[0] = table_title.GetStorage().info->cardinality;
    // rai_info_title->compact_list = &rai_info_title->rai->alist->compact_backward_list;

    join_condition_title.rais.push_back(move(rai_info_title));
    cond_title.push_back(move(join_condition_title));

    LogicalComparisonJoin join_title_op(JoinType::INNER);
    vector<LogicalType> output_title_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::BIGINT, LogicalType::VARCHAR};
    join_title_op.types = output_title_types;
    vector<idx_t> right_projection_map_title{3};
    vector<LogicalType> delim_types_title;
    auto join_title = make_uniq<PhysicalSIPJoin>(join_title_op, move(scan_title), move(join_company_type),
                                                        move(cond_title),
                                                        JoinType::INNER, left_projection_map,
                                                        right_projection_map_title,
                                                        delim_types_title, 0);

    // project
    vector<LogicalType> result_types{LogicalType::VARCHAR, LogicalType::VARCHAR, LogicalType::BIGINT};
    vector<unique_ptr<Expression>> project_select_list;
    auto result_col0 = make_uniq<BoundReferenceExpression>("note", LogicalType::VARCHAR, 3);
    auto result_col1 = make_uniq<BoundReferenceExpression>("title", LogicalType::VARCHAR, 1);
    auto result_col2 = make_uniq<BoundReferenceExpression>("production_year", LogicalType::BIGINT, 2);
    project_select_list.push_back(move(result_col0));
    project_select_list.push_back(move(result_col1));
    project_select_list.push_back(move(result_col2));
    auto projection = make_uniq<PhysicalProjection>(result_types, move(project_select_list), 0);
    projection->children.push_back(move(join_title));

    // aggregate
    string agg_name = "min";
    string agg_error = "";
    QueryErrorContext error_context(NULL, NULL);
    auto min_func = Catalog::GetEntry(context, CatalogType::SCALAR_FUNCTION_ENTRY, "", "",
                                      "min", OnEntryNotFound::RETURN_NULL, error_context);
    auto& min_func_set = min_func->Cast<AggregateFunctionCatalogEntry>();
    // bind the aggregate
    FunctionBinder function_binder(context);
    vector<LogicalType> types;
    types.push_back(LogicalType::VARCHAR);
    idx_t best_function_varchar = function_binder.BindFunction(agg_name, min_func_set.functions, types, agg_error);
    auto bound_function_min_varchar = min_func_set.functions.GetFunctionByOffset(best_function_varchar);

    vector<LogicalType> types_bigint;
    types_bigint.push_back(LogicalType::BIGINT);
    idx_t best_function_bigint = function_binder.BindFunction(agg_name, min_func_set.functions, types_bigint, agg_error);
    auto bound_function_min_bigint = min_func_set.functions.GetFunctionByOffset(best_function_bigint);

    auto first_children = make_uniq<BoundReferenceExpression>("production_note", LogicalType::VARCHAR, 0);
    vector<unique_ptr<Expression>> childrenlist1;
    childrenlist1.push_back(move(first_children));
    auto aggregate1 =
            function_binder.BindAggregateFunction(bound_function_min_varchar, std::move(childrenlist1), nullptr, AggregateType::NON_DISTINCT);

    auto second_children = make_uniq<BoundReferenceExpression>("movie_title", LogicalType::VARCHAR, 1);
    vector<unique_ptr<Expression>> childrenlist2;
    childrenlist2.push_back(move(second_children));
    auto aggregate2 =
            function_binder.BindAggregateFunction(bound_function_min_varchar, std::move(childrenlist2), nullptr, AggregateType::NON_DISTINCT);

    auto third_children = make_uniq<BoundReferenceExpression>("movie_year", LogicalType::BIGINT, 2);
    vector<unique_ptr<Expression>> childrenlist3;
    childrenlist3.push_back(move(third_children));
    auto aggregate3 =
            function_binder.BindAggregateFunction(bound_function_min_bigint, std::move(childrenlist3), nullptr, AggregateType::NON_DISTINCT);

    vector<unique_ptr<Expression>> aggregates;
    aggregates.push_back(move(aggregate1));
    aggregates.push_back(move(aggregate2));
    aggregates.push_back(move(aggregate3));

    vector<LogicalType> aggregate_types{LogicalType::VARCHAR, LogicalType::VARCHAR, LogicalType::BIGINT};
    auto ungrouped_aggregate = make_uniq<PhysicalUngroupedAggregate>(aggregate_types, move(aggregates), 0);
    ungrouped_aggregate->children.push_back(move(projection));

    return ungrouped_aggregate;
}

unique_ptr<PhysicalOperator> ClientContext::GenerateJOB1aPlanMerge(ClientContext& context) {
    vector<idx_t> left_projection_map, right_projection_map;
    //QueryErrorContext error_context_unlike1(NULL, NULL);
    //auto contains_func1 = Catalog::GetEntry(context, CatalogType::SCALAR_FUNCTION_ENTRY, "", "",
    //                                       "contains", OnEntryNotFound::RETURN_NULL, error_context_unlike1);

    string table_vertex_company_type = "company_type";
    string table_vertex_movie_companies = "movie_companies";
    string table_vertex_title = "title";
    string table_vertex_movie_info_idx = "movie_info_idx";
    string table_vertex_info_type = "info_type";
    idx_t table_index_company_type = 6;
    idx_t table_index_movie_companies = 7;
    idx_t table_index_title = 8;
    idx_t table_index_movie_info_idx = 9;
    idx_t table_index_info_type = 10;


    auto table_or_view_company_type = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                        table_vertex_company_type, OnEntryNotFound::RETURN_NULL);
    auto &table_company_type = table_or_view_company_type->Cast<TableCatalogEntry>();

    auto table_or_view_movie_companies = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                           table_vertex_movie_companies, OnEntryNotFound::RETURN_NULL);
    auto &table_movie_companies = table_or_view_movie_companies->Cast<TableCatalogEntry>();

    auto table_or_view_title = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                 table_vertex_title, OnEntryNotFound::RETURN_NULL);
    auto &table_title = table_or_view_title->Cast<TableCatalogEntry>();

    auto table_or_view_movie_info_idx = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                          table_vertex_movie_info_idx, OnEntryNotFound::RETURN_NULL);
    auto &table_movie_info_idx = table_or_view_movie_info_idx->Cast<TableCatalogEntry>();

    auto table_or_view_info_type = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                     table_vertex_info_type, OnEntryNotFound::RETURN_NULL);
    auto &table_info_type = table_or_view_info_type->Cast<TableCatalogEntry>();


    Value p_info_type = Value("top 250 rank");
    vector<idx_t> info_type_ids{COLUMN_IDENTIFIER_ROW_ID, 1};
    vector<LogicalType> get_info_type{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_info_type = "it";
    vector<LogicalType> table_types_info_type;
    vector<unique_ptr<Expression>> filter_info_type;
    unique_ptr<LogicalGet> get_op_info_type = move(
            getLogicalGet(*this, table_info_type, alias_info_type, table_index_info_type, table_types_info_type));
    unique_ptr<TableFilterSet> table_filters_info_type = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_info_type = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL,
                                                                                      p_info_type);
    table_filters_info_type->filters[1] = move(constant_info_type);
    unique_ptr<PhysicalTableScan> scan_info_type = make_uniq<PhysicalTableScan>(get_info_type,
                                                                                get_op_info_type->function,
                                                                                get_op_info_type->table_index,
                                                                                move(get_op_info_type->bind_data),
                                                                                table_types_info_type, info_type_ids,
                                                                                move(filter_info_type),
                                                                                vector<column_t>(),
                                                                                get_op_info_type->names,
                                                                                std::move(table_filters_info_type),
                                                                                get_op_info_type->estimated_cardinality,
                                                                                get_op_info_type->extra_info);

    vector<idx_t> title_ids{COLUMN_IDENTIFIER_ROW_ID, 1, 4};
    vector<LogicalType> get_title_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::BIGINT};
    string alias_title = "t";
    vector<LogicalType> table_types_title;
    vector<unique_ptr<Expression>> filter_title;
    unique_ptr<LogicalGet> get_op_title = move(
            getLogicalGet(*this, table_title, alias_title, table_index_title, table_types_title));
    unique_ptr<TableFilterSet> table_filters_title = NULL;
    unique_ptr<PhysicalTableScan> scan_title = make_uniq<PhysicalTableScan>(get_title_types,
                                                                            get_op_title->function,
                                                                            get_op_title->table_index,
                                                                            move(get_op_title->bind_data),
                                                                            table_types_title, title_ids,
                                                                            move(filter_title),
                                                                            vector<column_t>(),
                                                                            get_op_title->names,
                                                                            std::move(table_filters_title),
                                                                            get_op_title->estimated_cardinality,
                                                                            get_op_title->extra_info);

    vector<JoinCondition> cond_movie_info_idx;
    JoinCondition join_condition_movie_info_idx;
    join_condition_movie_info_idx.left = make_uniq<BoundReferenceExpression>("title_rowid", LogicalType::BIGINT,
                                                                             0);
    join_condition_movie_info_idx.right = make_uniq<BoundReferenceExpression>("info_type_rowid", LogicalType::BIGINT,
                                                                              0);
    join_condition_movie_info_idx.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_movie_info_idx = make_uniq<RAIInfo>();
    rai_info_movie_info_idx->rai = table_movie_info_idx.GetStorage().info->rais[0].get();
    rai_info_movie_info_idx->rai_type = RAIType::TARGET_EDGE;
    rai_info_movie_info_idx->forward = true;
    rai_info_movie_info_idx->vertex = &table_title;
    rai_info_movie_info_idx->vertex_id = table_index_title;
    rai_info_movie_info_idx->passing_tables[0] = table_index_title;
    rai_info_movie_info_idx->left_cardinalities[0] = table_title.GetStorage().info->cardinality;
    // rai_info_movie_info_idx->compact_list = &rai_info_movie_info_idx->rai->alist->compact_forward_list;

    join_condition_movie_info_idx.rais.push_back(move(rai_info_movie_info_idx));
    cond_movie_info_idx.push_back(move(join_condition_movie_info_idx));

    LogicalComparisonJoin join_movie_info_idx_op(JoinType::INNER);
    vector<LogicalType> output_movie_info_idx_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::BIGINT, LogicalType::BIGINT};
    join_movie_info_idx_op.types = output_movie_info_idx_types;
    vector<idx_t> right_projection_map_movie_info_idx{0};
    vector<idx_t> merge_movie_info_idx;
    vector<LogicalType> delim_types_movie_info_idx;
    auto join_movie_info_idx = make_uniq<PhysicalMergeSIPJoin>(join_movie_info_idx_op, move(scan_title),
                                                          move(scan_info_type),
                                                          move(cond_movie_info_idx),
                                                          JoinType::INNER, left_projection_map,
                                                          right_projection_map_movie_info_idx, merge_movie_info_idx,
                                                          delim_types_movie_info_idx, 0);

    Value p_mc_unlike = Value("(as Metro-Goldwyn-Mayer Pictures)");
    Value p_mc_like_1 = Value("(co-production)");
    Value p_mc_like_2 = Value("(presents)");
    vector<idx_t> mc_ids{7, 4, 6};
    vector<LogicalType> get_mc_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::BIGINT};
    string alias_mc = "mc";
    vector<LogicalType> table_types_mc;
    unique_ptr<LogicalGet> get_op_mc = move(
            getLogicalGet(*this, table_movie_companies, alias_mc, table_index_movie_companies, table_types_mc));
    vector<unique_ptr<Expression>> filter_mc;
    unique_ptr<TableFilterSet> table_filters_mc = NULL;
    unique_ptr<PhysicalTableScan> scan_mc = make_uniq<PhysicalTableScan>(get_mc_types,
                                                                         get_op_mc->function,
                                                                         get_op_mc->table_index,
                                                                         move(get_op_mc->bind_data),
                                                                         table_types_mc, mc_ids,
                                                                         move(filter_mc),
                                                                         vector<column_t>(),
                                                                         get_op_mc->names,
                                                                         std::move(table_filters_mc),
                                                                         get_op_mc->estimated_cardinality,
                                                                         get_op_mc->extra_info);

    vector<LogicalType> filter_mc_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::BIGINT};
    vector<unique_ptr<Expression>> select_list;
    auto unlike_expression_left = make_uniq<BoundReferenceExpression>("note", LogicalType::VARCHAR, 1);
    auto unlike_expression_value = make_uniq<BoundConstantExpression>(p_mc_unlike);
    vector<unique_ptr<Expression>> unlike_arguments;
    unlike_arguments.push_back(move(unlike_expression_left));
    unlike_arguments.push_back(move(unlike_expression_value));

    QueryErrorContext error_context_unlike(NULL, NULL);
    ScalarFunction bound_function_contains = ContainsFun::GetFunction();
    unique_ptr<FunctionData> bind_data_contains = NULL;
    /*auto contains_func = Catalog::GetEntry(context, CatalogType::SCALAR_FUNCTION_ENTRY, "", "",
                                      "contains", OnEntryNotFound::RETURN_NULL, error_context_unlike);
    ScalarFunctionCatalogEntry& contains_func_set = contains_func->Cast<ScalarFunctionCatalogEntry>();
    // bind the aggregate
    string contain_name = "contains";
    string contain_error = "";
    FunctionBinder function_binder_contains(context);
    vector<LogicalType> types_contains;

    types_contains.push_back(LogicalType::BOOLEAN);
    idx_t best_function_contains_idx = function_binder_contains.BindFunction(contain_name, contains_func_set.functions, types_contains, contain_error);
    std::cout << best_function_contains_idx << " " << contains_func_set.functions.functions.size() << std::endl;
    ScalarFunction bound_function_contains = contains_func_set.functions.GetFunctionByOffset(best_function_contains_idx);*/

    auto unlike_bound_function = make_uniq<BoundFunctionExpression>(LogicalType::BOOLEAN,
                                                                    bound_function_contains,
                                                                    move(unlike_arguments),
                                                                    move(bind_data_contains), false);

    auto not_unlike_bound_function = make_uniq<BoundOperatorExpression>(ExpressionType::OPERATOR_NOT,
                                                                        LogicalType::BOOLEAN);
    not_unlike_bound_function->children.push_back(move(unlike_bound_function));

    auto like_bound_function = make_uniq<BoundConjunctionExpression>(ExpressionType::CONJUNCTION_OR);

    auto like_expression_left_exp = make_uniq<BoundReferenceExpression>("note", LogicalType::VARCHAR, 1);
    auto like_expression_left_value = make_uniq<BoundConstantExpression>(p_mc_like_1);
    vector<unique_ptr<Expression>> like_arguments_left;
    like_arguments_left.push_back(move(like_expression_left_exp));
    like_arguments_left.push_back(move(like_expression_left_value));
    auto like_bound_function_left = make_uniq<BoundFunctionExpression>(LogicalType::BOOLEAN,
                                                                       bound_function_contains,
                                                                       move(like_arguments_left),
                                                                       move(bind_data_contains), false);

    auto like_expression_right_exp = make_uniq<BoundReferenceExpression>("note", LogicalType::VARCHAR, 1);
    auto like_expression_right_value = make_uniq<BoundConstantExpression>(p_mc_like_2);
    vector<unique_ptr<Expression>> like_arguments_right;
    like_arguments_right.push_back(move(like_expression_right_exp));
    like_arguments_right.push_back(move(like_expression_right_value));
    auto like_bound_function_right = make_uniq<BoundFunctionExpression>(LogicalType::BOOLEAN,
                                                                        bound_function_contains,
                                                                        move(like_arguments_right),
                                                                        move(bind_data_contains), false);

    like_bound_function->children.push_back(move(like_bound_function_left));
    like_bound_function->children.push_back(move(like_bound_function_right));

    auto and_conjunction = make_uniq<BoundConjunctionExpression>(ExpressionType::CONJUNCTION_AND);
    and_conjunction->children.push_back(move(not_unlike_bound_function));
    and_conjunction->children.push_back(move(like_bound_function));

    select_list.push_back(move(and_conjunction));
    unique_ptr<PhysicalFilter> filter_mc_contains = make_uniq<PhysicalFilter>(filter_mc_types, move(select_list), 0);
    filter_mc_contains->children.push_back(move(scan_mc));


    vector<JoinCondition> cond_mc;
    JoinCondition join_condition_mc;
    join_condition_mc.left = make_uniq<BoundReferenceExpression>("movie_id_rowid", LogicalType::BIGINT, 2);
    join_condition_mc.right = make_uniq<BoundReferenceExpression>("title_rowid", LogicalType::BIGINT, 0);
    join_condition_mc.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_movie_companies = make_uniq<RAIInfo>();
    rai_info_movie_companies->rai = table_movie_companies.GetStorage().info->rais[1].get();
    rai_info_movie_companies->rai_type = RAIType::EDGE_TARGET;
    rai_info_movie_companies->forward = false;
    rai_info_movie_companies->vertex = &table_title;
    rai_info_movie_companies->vertex_id = table_index_title;
    rai_info_movie_companies->passing_tables[0] = table_index_movie_companies;
    rai_info_movie_companies->left_cardinalities[0] = table_movie_companies.GetStorage().info->cardinality;
    rai_info_movie_companies->compact_list = &rai_info_movie_companies->rai->alist->compact_backward_list;

    join_condition_mc.rais.push_back(move(rai_info_movie_companies));
    cond_mc.push_back(move(join_condition_mc));

    LogicalComparisonJoin join_mc_op(JoinType::INNER);
    vector<LogicalType> output_mc_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::BIGINT,
                                        LogicalType::VARCHAR, LogicalType::BIGINT};
    join_mc_op.types = output_mc_types;
    vector<idx_t> right_projection_map_mc{1, 2};
    vector<LogicalType> delim_types;
    auto join_mc = make_uniq<PhysicalSIPJoin>(join_mc_op, move(filter_mc_contains), move(join_movie_info_idx),
                                               move(cond_mc),
                                               JoinType::INNER, left_projection_map,
                                               right_projection_map_mc, delim_types, 0);

    Value p_company_type("production companies");
    vector<idx_t> company_type_ids{COLUMN_IDENTIFIER_ROW_ID, 1};
    vector<LogicalType> get_company_type_type{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_company_type = "ct";
    vector<LogicalType> table_types_company_type;
    vector<unique_ptr<Expression>> filter_company_type;
    unique_ptr<LogicalGet> get_op_company_type = move(
            getLogicalGet(*this, table_company_type, alias_company_type, table_index_company_type,
                          table_types_company_type));
    unique_ptr<TableFilterSet> table_filters_company_type = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_company_type = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL,
                                                                                         p_company_type);
    table_filters_company_type->filters[1] = move(constant_company_type);
    unique_ptr<PhysicalTableScan> scan_company_type = make_uniq<PhysicalTableScan>(get_company_type_type,
                                                                                   get_op_company_type->function,
                                                                                   get_op_company_type->table_index,
                                                                                   move(get_op_company_type->bind_data),
                                                                                   table_types_company_type,
                                                                                   company_type_ids,
                                                                                   move(filter_company_type),
                                                                                   vector<column_t>(),
                                                                                   get_op_company_type->names,
                                                                                   std::move(
                                                                                           table_filters_company_type),
                                                                                   get_op_company_type->estimated_cardinality,
                                                                                   get_op_company_type->extra_info);

    vector<JoinCondition> cond_company_type;
    JoinCondition join_condition_company_type;
    join_condition_company_type.left = make_uniq<BoundReferenceExpression>("company_type_id_rowid", LogicalType::BIGINT,
                                                                           0);
    join_condition_company_type.right = make_uniq<BoundReferenceExpression>("company_type_rowid",
                                                                            LogicalType::BIGINT, 0);
    join_condition_company_type.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_company_type = make_uniq<RAIInfo>();
    rai_info_company_type->rai = table_movie_companies.GetStorage().info->rais[1].get();
    rai_info_company_type->rai_type = RAIType::EDGE_SOURCE;
    rai_info_company_type->forward = true;
    rai_info_company_type->vertex = &table_company_type;
    rai_info_company_type->vertex_id = table_index_company_type;
    rai_info_company_type->passing_tables[0] = table_index_movie_companies;
    rai_info_company_type->left_cardinalities[0] = table_movie_companies.GetStorage().info->cardinality;
    rai_info_company_type->compact_list = &rai_info_company_type->rai->alist->compact_forward_list;

    join_condition_company_type.rais.push_back(move(rai_info_company_type));
    cond_company_type.push_back(move(join_condition_company_type));

    LogicalComparisonJoin join_company_type_op(JoinType::INNER);
    vector<LogicalType> output_company_type_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::BIGINT,
                                                  LogicalType::VARCHAR, LogicalType::BIGINT, LogicalType::BIGINT};
    join_company_type_op.types = output_company_type_types;
    vector<idx_t> right_projection_map_company_type{0};
    vector<LogicalType> delim_types_company_type;
    auto join_company_type = make_uniq<PhysicalSIPJoin>(join_company_type_op, move(join_mc), move(scan_company_type),
                                                        move(cond_company_type),
                                                        JoinType::INNER, left_projection_map,
                                                        right_projection_map_company_type,
                                                        delim_types_company_type, 0);

    // project
    vector<LogicalType> result_types{LogicalType::VARCHAR, LogicalType::VARCHAR, LogicalType::BIGINT};
    vector<unique_ptr<Expression>> project_select_list;
    auto result_col0 = make_uniq<BoundReferenceExpression>("note", LogicalType::VARCHAR, 1);
    auto result_col1 = make_uniq<BoundReferenceExpression>("title", LogicalType::VARCHAR, 3);
    auto result_col2 = make_uniq<BoundReferenceExpression>("production_year", LogicalType::BIGINT, 4);
    project_select_list.push_back(move(result_col0));
    project_select_list.push_back(move(result_col1));
    project_select_list.push_back(move(result_col2));
    auto projection = make_uniq<PhysicalProjection>(result_types, move(project_select_list), 0);
    projection->children.push_back(move(join_company_type));

    // aggregate
    string agg_name = "min";
    string agg_error = "";
    QueryErrorContext error_context(NULL, NULL);
    auto min_func = Catalog::GetEntry(context, CatalogType::SCALAR_FUNCTION_ENTRY, "", "",
                                      "min", OnEntryNotFound::RETURN_NULL, error_context);
    auto &min_func_set = min_func->Cast<AggregateFunctionCatalogEntry>();
    // bind the aggregate
    FunctionBinder function_binder(context);
    vector<LogicalType> types;
    types.push_back(LogicalType::VARCHAR);
    idx_t best_function_varchar = function_binder.BindFunction(agg_name, min_func_set.functions, types, agg_error);
    auto bound_function_min_varchar = min_func_set.functions.GetFunctionByOffset(best_function_varchar);

    vector<LogicalType> types_bigint;
    types_bigint.push_back(LogicalType::BIGINT);
    idx_t best_function_bigint = function_binder.BindFunction(agg_name, min_func_set.functions, types_bigint,
                                                              agg_error);
    auto bound_function_min_bigint = min_func_set.functions.GetFunctionByOffset(best_function_bigint);

    auto first_children = make_uniq<BoundReferenceExpression>("production_note", LogicalType::VARCHAR, 0);
    vector<unique_ptr<Expression>> childrenlist1;
    childrenlist1.push_back(move(first_children));
    auto aggregate1 =
            function_binder.BindAggregateFunction(bound_function_min_varchar, std::move(childrenlist1), nullptr,
                                                  AggregateType::NON_DISTINCT);

    auto second_children = make_uniq<BoundReferenceExpression>("movie_title", LogicalType::VARCHAR, 1);
    vector<unique_ptr<Expression>> childrenlist2;
    childrenlist2.push_back(move(second_children));
    auto aggregate2 =
            function_binder.BindAggregateFunction(bound_function_min_varchar, std::move(childrenlist2), nullptr,
                                                  AggregateType::NON_DISTINCT);

    auto third_children = make_uniq<BoundReferenceExpression>("movie_year", LogicalType::BIGINT, 2);
    vector<unique_ptr<Expression>> childrenlist3;
    childrenlist3.push_back(move(third_children));
    auto aggregate3 =
            function_binder.BindAggregateFunction(bound_function_min_bigint, std::move(childrenlist3), nullptr,
                                                  AggregateType::NON_DISTINCT);

    vector<unique_ptr<Expression>> aggregates;
    aggregates.push_back(move(aggregate1));
    aggregates.push_back(move(aggregate2));
    aggregates.push_back(move(aggregate3));

    vector<LogicalType> aggregate_types{LogicalType::VARCHAR, LogicalType::VARCHAR, LogicalType::BIGINT};
    auto ungrouped_aggregate = make_uniq<PhysicalUngroupedAggregate>(aggregate_types, move(aggregates), 0);
    ungrouped_aggregate->children.push_back(move(projection));

    return ungrouped_aggregate;
}

unique_ptr<PhysicalOperator> ClientContext::GenerateJOB2aPlan(duckdb::ClientContext &context) {
    vector<idx_t> left_projection_map, right_projection_map;

    string table_vertex_company_name_cn = "company_name";
    string table_vertex_title_t = "title";
    string table_vertex_keyword_k = "keyword";
    string table_vertex_movie_companies_ = "movie_companies";
    string table_vertex_movie_keyword_ = "movie_keyword";

    idx_t table_index_company_name_cn = 1;
    idx_t table_index_title_t = 2;
    idx_t table_index_keyword_k = 3;
    idx_t table_index_movie_companies_ = 4;
    idx_t table_index_movie_keyword_ = 5;
    auto table_or_view_company_name = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                        table_vertex_company_name_cn, OnEntryNotFound::RETURN_NULL);
    auto &table_company_name = table_or_view_company_name->Cast<TableCatalogEntry>();
    auto table_or_view_title = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_title_t,
                                                 OnEntryNotFound::RETURN_NULL);
    auto &table_title = table_or_view_title->Cast<TableCatalogEntry>();
    auto table_or_view_keyword = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_keyword_k,
                                                   OnEntryNotFound::RETURN_NULL);
    auto &table_keyword = table_or_view_keyword->Cast<TableCatalogEntry>();
    auto table_or_view_movie_companies = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                           table_vertex_movie_companies_, OnEntryNotFound::RETURN_NULL);
    auto &table_movie_companies = table_or_view_movie_companies->Cast<TableCatalogEntry>();
    auto table_or_view_movie_keyword = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                         table_vertex_movie_keyword_, OnEntryNotFound::RETURN_NULL);
    auto &table_movie_keyword = table_or_view_movie_keyword->Cast<TableCatalogEntry>();

    string p_company_code = "[de]"; // 933;
    Value p_country_code = Value(p_company_code);
    vector<idx_t> company_name_cn_ids{COLUMN_IDENTIFIER_ROW_ID, 2};
    vector<LogicalType> get_company_name_cn_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_company_name_cn = "cn";
    vector<LogicalType> table_types_company_name_cn;
    vector<unique_ptr<Expression>> filter_company_name_cn;
    unique_ptr<LogicalGet> get_op_company_name_cn = move(
            getLogicalGet(*this, table_company_name, alias_company_name_cn, table_index_company_name_cn,
                          table_types_company_name_cn));
    unique_ptr<TableFilterSet> table_filters_company_name_cn = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL,
                                                                                   p_country_code);
    table_filters_company_name_cn->filters[1] = move(constant_filter);
    unique_ptr<PhysicalTableScan> scan_company_name_cn = make_uniq<PhysicalTableScan>(get_company_name_cn_types,
                                                                                      get_op_company_name_cn->function,
                                                                                      get_op_company_name_cn->table_index,
                                                                                      move(get_op_company_name_cn->bind_data),
                                                                                      table_types_company_name_cn,
                                                                                      company_name_cn_ids,
                                                                                      move(filter_company_name_cn),
                                                                                      vector<column_t>(),
                                                                                      get_op_company_name_cn->names,
                                                                                      std::move(
                                                                                              table_filters_company_name_cn),
                                                                                      get_op_company_name_cn->estimated_cardinality,
                                                                                      get_op_company_name_cn->extra_info);


    vector<idx_t> title_t_ids{COLUMN_IDENTIFIER_ROW_ID, 1};
    vector<LogicalType> get_title_t_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_title_t = "t";
    vector<LogicalType> table_types_title_t;
    vector<unique_ptr<Expression>> filter_title_t;
    unique_ptr<LogicalGet> get_op_title_t = move(
            getLogicalGet(*this, table_title, alias_title_t, table_index_title_t, table_types_title_t));
    unique_ptr<TableFilterSet> table_filters_title_t = NULL;
    unique_ptr<PhysicalTableScan> scan_title_t = make_uniq<PhysicalTableScan>(get_title_t_types,
                                                                              get_op_title_t->function,
                                                                              get_op_title_t->table_index,
                                                                              move(get_op_title_t->bind_data),
                                                                              table_types_title_t, title_t_ids,
                                                                              move(filter_title_t), vector<column_t>(),
                                                                              get_op_title_t->names,
                                                                              std::move(table_filters_title_t),
                                                                              get_op_title_t->estimated_cardinality,
                                                                              get_op_title_t->extra_info);


    vector<JoinCondition> cond_movie_companies_;
    JoinCondition join_condition_movie_companies_;
    join_condition_movie_companies_.left = make_uniq<BoundReferenceExpression>("title_rowid", LogicalType::BIGINT, 0);
    join_condition_movie_companies_.right = make_uniq<BoundReferenceExpression>("company_name_rowid", LogicalType::BIGINT, 0);
    join_condition_movie_companies_.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_movie_companies_ = make_uniq<RAIInfo>();
    rai_info_movie_companies_->rai = table_movie_companies.GetStorage().info->rais[0].get();
    rai_info_movie_companies_->rai_type = RAIType::TARGET_EDGE;
    rai_info_movie_companies_->forward = true;
    rai_info_movie_companies_->vertex = &table_title;
    rai_info_movie_companies_->vertex_id = table_index_title_t;
    rai_info_movie_companies_->passing_tables[0] = table_index_title_t;
    rai_info_movie_companies_->left_cardinalities[0] = table_title.GetStorage().info->cardinality;
    // rai_info_movie_companies_->compact_list = &rai_info_movie_companies_->rai->alist->compact__list;

    join_condition_movie_companies_.rais.push_back(move(rai_info_movie_companies_));
    cond_movie_companies_.push_back(move(join_condition_movie_companies_));

    LogicalComparisonJoin join_movie_companies__op(JoinType::INNER);
    vector<LogicalType> output_movie_companies__types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::BIGINT};
    join_movie_companies__op.types = output_movie_companies__types;
    vector<idx_t> right_projection_map_movie_companies_{0};
    vector<idx_t> merge_project_map_movie_companies_;
    vector<LogicalType> delim_types_movie_companies_;
    auto join_movie_companies_ = make_uniq<PhysicalMergeSIPJoin>(join_movie_companies__op, move(scan_title_t), move(scan_company_name_cn),
                                                                 move(cond_movie_companies_), JoinType::INNER,
                                                                 left_projection_map,
                                                                 right_projection_map_movie_companies_,
                                                                 merge_project_map_movie_companies_,
                                                                 delim_types_movie_companies_, 0);


    string p_keyword_n = "character-name-in-title"; // 933;
    Value p_keyword = Value(p_keyword_n);
    vector<idx_t> keyword_k_ids{COLUMN_IDENTIFIER_ROW_ID, 1};
    vector<LogicalType> get_keyword_k_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_keyword_k = "k";
    vector<LogicalType> table_types_keyword_k;
    vector<unique_ptr<Expression>> filter_keyword_k;
    unique_ptr<LogicalGet> get_op_keyword_k = move(
            getLogicalGet(*this, table_keyword, alias_keyword_k, table_index_keyword_k, table_types_keyword_k));
    unique_ptr<TableFilterSet> table_filters_keyword_k = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_keyword = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL,
                                                                                   p_keyword);
    table_filters_keyword_k->filters[1] = move(constant_filter_keyword);
    unique_ptr<PhysicalTableScan> scan_keyword_k = make_uniq<PhysicalTableScan>(get_keyword_k_types,
                                                                                get_op_keyword_k->function,
                                                                                get_op_keyword_k->table_index,
                                                                                move(get_op_keyword_k->bind_data),
                                                                                table_types_keyword_k, keyword_k_ids,
                                                                                move(filter_keyword_k),
                                                                                vector<column_t>(),
                                                                                get_op_keyword_k->names,
                                                                                std::move(table_filters_keyword_k),
                                                                                get_op_keyword_k->estimated_cardinality,
                                                                                get_op_keyword_k->extra_info);


    vector<JoinCondition> cond_keyword_k;
    JoinCondition join_condition_keyword_k;
    join_condition_keyword_k.left = make_uniq<BoundReferenceExpression>("keyword_rowid", LogicalType::BIGINT, 0);
    join_condition_keyword_k.right = make_uniq<BoundReferenceExpression>("title_rowid", LogicalType::BIGINT, 0);
    join_condition_keyword_k.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_keyword_k = make_uniq<RAIInfo>();
    rai_info_keyword_k->rai = table_movie_keyword.GetStorage().info->rais[0].get();
    rai_info_keyword_k->rai_type = RAIType::SOURCE_EDGE;
    rai_info_keyword_k->forward = false;
    rai_info_keyword_k->vertex = &table_keyword;
    rai_info_keyword_k->vertex_id = table_index_keyword_k;
    rai_info_keyword_k->passing_tables[0] = table_index_keyword_k;
    rai_info_keyword_k->left_cardinalities[0] = table_keyword.GetStorage().info->cardinality;
    // rai_info_keyword_k->compact_list = &rai_info_keyword_k->rai->alist->compact__list;

    join_condition_keyword_k.rais.push_back(move(rai_info_keyword_k));
    cond_keyword_k.push_back(move(join_condition_keyword_k));

    LogicalComparisonJoin join_keyword_k_op(JoinType::INNER);
    vector<LogicalType> output_keyword_k_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::VARCHAR};
    join_keyword_k_op.types = output_keyword_k_types;
    vector<idx_t> right_projection_map_keyword_k{1};
    vector<idx_t> merge_project_map_keyword_k;
    vector<LogicalType> delim_types_keyword_k;
    auto join_keyword_k = make_uniq<PhysicalMergeSIPJoin>(join_keyword_k_op, move(scan_keyword_k), move(join_movie_companies_), move(cond_keyword_k),
                                                     JoinType::INNER, left_projection_map,
                                                     right_projection_map_keyword_k, merge_project_map_keyword_k,
                                                     delim_types_keyword_k, 0);


    vector<LogicalType> result_types{LogicalType::VARCHAR};
    vector<unique_ptr<Expression>> select_list;
    auto result_col0 = make_uniq<BoundReferenceExpression>("title", LogicalType::VARCHAR, 2);
    select_list.push_back(move(result_col0));
    auto projection = make_uniq<PhysicalProjection>(result_types, move(select_list), 0);
    projection->children.push_back(move(join_keyword_k));

    // aggregate
    string agg_name = "min";
    string agg_error = "";
    QueryErrorContext error_context(NULL, NULL);
    auto min_func = Catalog::GetEntry(context, CatalogType::SCALAR_FUNCTION_ENTRY, "", "",
                                      "min", OnEntryNotFound::RETURN_NULL, error_context);
    auto &min_func_set = min_func->Cast<AggregateFunctionCatalogEntry>();
    // bind the aggregate
    FunctionBinder function_binder(context);
    vector<LogicalType> types;
    types.push_back(LogicalType::VARCHAR);
    idx_t best_function_varchar = function_binder.BindFunction(agg_name, min_func_set.functions, types, agg_error);
    auto bound_function_min_varchar = min_func_set.functions.GetFunctionByOffset(best_function_varchar);

    auto second_children = make_uniq<BoundReferenceExpression>("title", LogicalType::VARCHAR, 0);
    vector<unique_ptr<Expression>> childrenlist2;
    childrenlist2.push_back(move(second_children));
    auto aggregate2 =
            function_binder.BindAggregateFunction(bound_function_min_varchar, std::move(childrenlist2), nullptr,
                                                  AggregateType::NON_DISTINCT);

    vector<unique_ptr<Expression>> aggregates;
    aggregates.push_back(move(aggregate2));

    vector<LogicalType> aggregate_types{LogicalType::VARCHAR};
    auto ungrouped_aggregate = make_uniq<PhysicalUngroupedAggregate>(aggregate_types, move(aggregates), 0);
    ungrouped_aggregate->children.push_back(move(projection));

    return ungrouped_aggregate;
}

unique_ptr<PhysicalOperator> ClientContext::GenerateJOB2aPlanNewDirect(duckdb::ClientContext &context) {
    vector<idx_t> left_projection_map, right_projection_map;

    string table_vertex_company_name_cn = "company_name";
    string table_vertex_title_t = "title";
    string table_vertex_keyword_k = "keyword";
    string table_vertex_movie_companies_ = "movie_companies";
    string table_vertex_movie_keyword_ = "movie_keyword";

    idx_t table_index_company_name_cn = 1;
    idx_t table_index_title_t = 2;
    idx_t table_index_keyword_k = 3;
    idx_t table_index_movie_companies_ = 4;
    idx_t table_index_movie_keyword_ = 5;
    auto table_or_view_company_name = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                        table_vertex_company_name_cn, OnEntryNotFound::RETURN_NULL);
    auto &table_company_name = table_or_view_company_name->Cast<TableCatalogEntry>();
    auto table_or_view_title = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_title_t,
                                                 OnEntryNotFound::RETURN_NULL);
    auto &table_title = table_or_view_title->Cast<TableCatalogEntry>();
    auto table_or_view_keyword = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_keyword_k,
                                                   OnEntryNotFound::RETURN_NULL);
    auto &table_keyword = table_or_view_keyword->Cast<TableCatalogEntry>();
    auto table_or_view_movie_companies = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                           table_vertex_movie_companies_, OnEntryNotFound::RETURN_NULL);
    auto &table_movie_companies = table_or_view_movie_companies->Cast<TableCatalogEntry>();
    auto table_or_view_movie_keyword = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                         table_vertex_movie_keyword_, OnEntryNotFound::RETURN_NULL);
    auto &table_movie_keyword = table_or_view_movie_keyword->Cast<TableCatalogEntry>();

    string p_company_code = "[de]"; // 933;
    Value p_country_code = Value(p_company_code);
    vector<idx_t> company_name_cn_ids{COLUMN_IDENTIFIER_ROW_ID, 2};
    vector<LogicalType> get_company_name_cn_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_company_name_cn = "cn";
    vector<LogicalType> table_types_company_name_cn;
    vector<unique_ptr<Expression>> filter_company_name_cn;
    unique_ptr<LogicalGet> get_op_company_name_cn = move(
            getLogicalGet(*this, table_company_name, alias_company_name_cn, table_index_company_name_cn,
                          table_types_company_name_cn));
    unique_ptr<TableFilterSet> table_filters_company_name_cn = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL,
                                                                                   p_country_code);
    table_filters_company_name_cn->filters[1] = move(constant_filter);
    unique_ptr<PhysicalTableScan> scan_company_name_cn = make_uniq<PhysicalTableScan>(get_company_name_cn_types,
                                                                                      get_op_company_name_cn->function,
                                                                                      get_op_company_name_cn->table_index,
                                                                                      move(get_op_company_name_cn->bind_data),
                                                                                      table_types_company_name_cn,
                                                                                      company_name_cn_ids,
                                                                                      move(filter_company_name_cn),
                                                                                      vector<column_t>(),
                                                                                      get_op_company_name_cn->names,
                                                                                      std::move(
                                                                                              table_filters_company_name_cn),
                                                                                      get_op_company_name_cn->estimated_cardinality,
                                                                                      get_op_company_name_cn->extra_info);

    string p_keyword_n = "character-name-in-title"; // 933;
    Value p_keyword = Value(p_keyword_n);
    vector<idx_t> keyword_k_ids{COLUMN_IDENTIFIER_ROW_ID, 1};
    vector<LogicalType> get_keyword_k_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_keyword_k = "k";
    vector<LogicalType> table_types_keyword_k;
    vector<unique_ptr<Expression>> filter_keyword_k;
    unique_ptr<LogicalGet> get_op_keyword_k = move(
            getLogicalGet(*this, table_keyword, alias_keyword_k, table_index_keyword_k, table_types_keyword_k));
    unique_ptr<TableFilterSet> table_filters_keyword_k = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_keyword = duckdb::make_uniq<ConstantFilter>(
            ExpressionType::COMPARE_EQUAL,
            p_keyword);
    table_filters_keyword_k->filters[1] = move(constant_filter_keyword);;
    unique_ptr<PhysicalTableScan> scan_keyword_k = make_uniq<PhysicalTableScan>(get_keyword_k_types,
                                                                                get_op_keyword_k->function,
                                                                                get_op_keyword_k->table_index,
                                                                                move(get_op_keyword_k->bind_data),
                                                                                table_types_keyword_k, keyword_k_ids,
                                                                                move(filter_keyword_k),
                                                                                vector<column_t>(),
                                                                                get_op_keyword_k->names,
                                                                                std::move(table_filters_keyword_k),
                                                                                get_op_keyword_k->estimated_cardinality,
                                                                                get_op_keyword_k->extra_info);

    vector<idx_t> title_t_ids{COLUMN_IDENTIFIER_ROW_ID, 1};
    vector<LogicalType> get_title_t_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_title_t = "t";
    vector<LogicalType> table_types_title_t;
    vector<unique_ptr<Expression>> filter_title_t;
    unique_ptr<LogicalGet> get_op_title_t = move(
            getLogicalGet(*this, table_title, alias_title_t, table_index_title_t, table_types_title_t));
    unique_ptr<TableFilterSet> table_filters_title_t = NULL;
    unique_ptr<PhysicalTableScan> scan_title_t = make_uniq<PhysicalTableScan>(get_title_t_types,
                                                                              get_op_title_t->function,
                                                                              get_op_title_t->table_index,
                                                                              move(get_op_title_t->bind_data),
                                                                              table_types_title_t, title_t_ids,
                                                                              move(filter_title_t), vector<column_t>(),
                                                                              get_op_title_t->names,
                                                                              std::move(table_filters_title_t),
                                                                              get_op_title_t->estimated_cardinality,
                                                                              get_op_title_t->extra_info);

    vector<JoinCondition> cond_keyword_k;
    JoinCondition join_condition_keyword_k;
    join_condition_keyword_k.left = make_uniq<BoundReferenceExpression>("title_rowid", LogicalType::BIGINT, 0);
    join_condition_keyword_k.right = make_uniq<BoundReferenceExpression>("keyword_rowid", LogicalType::BIGINT, 0);
    join_condition_keyword_k.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_keyword_k = make_uniq<RAIInfo>();
    rai_info_keyword_k->rai = table_movie_keyword.GetStorage().info->rais[0].get();
    rai_info_keyword_k->rai_type = RAIType::TARGET_EDGE;
    rai_info_keyword_k->forward = true;
    rai_info_keyword_k->vertex = &table_title;
    rai_info_keyword_k->vertex_id = table_index_title_t;
    rai_info_keyword_k->passing_tables[0] = table_index_title_t;
    rai_info_keyword_k->left_cardinalities[0] = table_title.GetStorage().info->cardinality;
    // rai_info_keyword_k->compact_list = &rai_info_keyword_k->rai->alist->compact__list;

    join_condition_keyword_k.rais.push_back(move(rai_info_keyword_k));
    cond_keyword_k.push_back(move(join_condition_keyword_k));

    LogicalComparisonJoin join_keyword_k_op(JoinType::INNER);
    vector<LogicalType> output_keyword_k_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::BIGINT};
    join_keyword_k_op.types = output_keyword_k_types;
    vector<idx_t> right_projection_map_keyword_k{0};
    vector<idx_t> merge_project_map_keyword_k;
    vector<LogicalType> delim_types_keyword_k;
    auto join_keyword_k = make_uniq<PhysicalMergeSIPJoin>(join_keyword_k_op, move(scan_title_t), move(scan_keyword_k),
                                                          move(cond_keyword_k),
                                                          JoinType::INNER, left_projection_map,
                                                          right_projection_map_keyword_k, merge_project_map_keyword_k,
                                                          delim_types_keyword_k, 0);

    vector<JoinCondition> cond_movie_companies_;
    JoinCondition join_condition_movie_companies_;
    join_condition_movie_companies_.left = make_uniq<BoundReferenceExpression>("company_name_rowid",
                                                                               LogicalType::BIGINT, 0);
    join_condition_movie_companies_.right = make_uniq<BoundReferenceExpression>("title_rowid", LogicalType::BIGINT, 0);
    join_condition_movie_companies_.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_movie_companies_ = make_uniq<RAIInfo>();
    rai_info_movie_companies_->rai = table_movie_companies.GetStorage().info->rais[0].get();
    rai_info_movie_companies_->rai_type = RAIType::SOURCE_EDGE;
    rai_info_movie_companies_->forward = false;
    rai_info_movie_companies_->vertex = &table_company_name;
    rai_info_movie_companies_->vertex_id = table_index_company_name_cn;
    rai_info_movie_companies_->passing_tables[0] = table_index_company_name_cn;
    rai_info_movie_companies_->left_cardinalities[0] = table_company_name.GetStorage().info->cardinality;
    // rai_info_movie_companies_->compact_list = &rai_info_movie_companies_->rai->alist->compact__list;

    join_condition_movie_companies_.rais.push_back(move(rai_info_movie_companies_));
    cond_movie_companies_.push_back(move(join_condition_movie_companies_));

    LogicalComparisonJoin join_movie_companies__op(JoinType::INNER);
    vector<LogicalType> output_movie_companies__types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::VARCHAR};
    join_movie_companies__op.types = output_movie_companies__types;
    vector<idx_t> right_projection_map_movie_companies_{1};
    vector<idx_t> merge_project_map_movie_companies_;
    vector<LogicalType> delim_types_movie_companies_;
    auto join_movie_companies_ = make_uniq<PhysicalMergeSIPJoin>(join_movie_companies__op, move(scan_company_name_cn),
                                                                 move(join_keyword_k),
                                                                 move(cond_movie_companies_), JoinType::INNER,
                                                                 left_projection_map,
                                                                 right_projection_map_movie_companies_,
                                                                 merge_project_map_movie_companies_,
                                                                 delim_types_movie_companies_, 0);

    vector<LogicalType> result_types{LogicalType::VARCHAR};
    vector<unique_ptr<Expression>> select_list;
    auto result_col0 = make_uniq<BoundReferenceExpression>("title", LogicalType::VARCHAR, 2);
    select_list.push_back(move(result_col0));
    auto projection = make_uniq<PhysicalProjection>(result_types, move(select_list), 0);
    projection->children.push_back(move(join_movie_companies_));

    // aggregate
    string agg_name = "min";
    string agg_error = "";
    QueryErrorContext error_context(NULL, NULL);
    auto min_func = Catalog::GetEntry(context, CatalogType::SCALAR_FUNCTION_ENTRY, "", "",
                                      "min", OnEntryNotFound::RETURN_NULL, error_context);
    auto &min_func_set = min_func->Cast<AggregateFunctionCatalogEntry>();
    // bind the aggregate
    FunctionBinder function_binder(context);
    vector<LogicalType> types;
    types.push_back(LogicalType::VARCHAR);
    idx_t best_function_varchar = function_binder.BindFunction(agg_name, min_func_set.functions, types, agg_error);
    auto bound_function_min_varchar = min_func_set.functions.GetFunctionByOffset(best_function_varchar);

    auto second_children = make_uniq<BoundReferenceExpression>("title", LogicalType::VARCHAR, 0);
    vector<unique_ptr<Expression>> childrenlist2;
    childrenlist2.push_back(move(second_children));
    auto aggregate2 =
            function_binder.BindAggregateFunction(bound_function_min_varchar, std::move(childrenlist2), nullptr,
                                                  AggregateType::NON_DISTINCT);

    vector<unique_ptr<Expression>> aggregates;
    aggregates.push_back(move(aggregate2));

    vector<LogicalType> aggregate_types{LogicalType::VARCHAR};
    auto ungrouped_aggregate = make_uniq<PhysicalUngroupedAggregate>(aggregate_types, move(aggregates), 0);
    ungrouped_aggregate->children.push_back(move(projection));

    return ungrouped_aggregate;
}


unique_ptr<PhysicalOperator> ClientContext::GenerateJOB3aPlanMerge(duckdb::ClientContext &context) {
    vector<idx_t> left_projection_map, right_projection_map;

    string table_vertex_keyword_k = "keyword";
    string table_vertex_title_t = "title";
    string table_vertex_info_type_i = "info_type";
    string table_vertex_movie_keyword_ = "movie_keyword";
    string table_vertex_movie_info_ = "movie_info";

    idx_t table_index_keyword_k = 1;
    idx_t table_index_title_t = 2;
    idx_t table_index_info_type_i = 3;
    idx_t table_index_movie_keyword_ = 4;
    idx_t table_index_movie_info_ = 5;
    auto table_or_view_keyword = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_keyword_k,
                                                   OnEntryNotFound::RETURN_NULL);
    auto &table_keyword = table_or_view_keyword->Cast<TableCatalogEntry>();
    auto table_or_view_title = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_title_t,
                                                 OnEntryNotFound::RETURN_NULL);
    auto &table_title = table_or_view_title->Cast<TableCatalogEntry>();
    auto table_or_view_info_type = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_info_type_i,
                                                     OnEntryNotFound::RETURN_NULL);
    auto &table_info_type = table_or_view_info_type->Cast<TableCatalogEntry>();
    auto table_or_view_movie_keyword = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                         table_vertex_movie_keyword_, OnEntryNotFound::RETURN_NULL);
    auto &table_movie_keyword = table_or_view_movie_keyword->Cast<TableCatalogEntry>();
    auto table_or_view_movie_info = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_movie_info_,
                                                      OnEntryNotFound::RETURN_NULL);
    auto &table_movie_info = table_or_view_movie_info->Cast<TableCatalogEntry>();

    vector<idx_t> keyword_k_ids{COLUMN_IDENTIFIER_ROW_ID, 1};
    vector<LogicalType> get_keyword_k_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_keyword_k = "k";
    vector<LogicalType> table_types_keyword_k;
    vector<unique_ptr<Expression>> filter_keyword_k;
    unique_ptr<LogicalGet> get_op_keyword_k = move(
            getLogicalGet(*this, table_keyword, alias_keyword_k, table_index_keyword_k, table_types_keyword_k));
    unique_ptr<TableFilterSet> table_filters_keyword_k = NULL;
    unique_ptr<PhysicalTableScan> scan_keyword_k = make_uniq<PhysicalTableScan>(get_keyword_k_types,
                                                                                get_op_keyword_k->function,
                                                                                get_op_keyword_k->table_index,
                                                                                move(get_op_keyword_k->bind_data),
                                                                                table_types_keyword_k, keyword_k_ids,
                                                                                move(filter_keyword_k),
                                                                                vector<column_t>(),
                                                                                get_op_keyword_k->names,
                                                                                std::move(table_filters_keyword_k),
                                                                                get_op_keyword_k->estimated_cardinality,
                                                                                get_op_keyword_k->extra_info);

    string p_keyword = "sequel";
    Value p_keyword_n = Value(p_keyword);
    vector<LogicalType> filter_mc_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    vector<unique_ptr<Expression>> select_list;
    auto like_expression_left = make_uniq<BoundReferenceExpression>("keyword", LogicalType::VARCHAR, 1);
    auto like_expression_value = make_uniq<BoundConstantExpression>(p_keyword_n);
    vector<unique_ptr<Expression>> like_arguments;
    like_arguments.push_back(move(like_expression_left));
    like_arguments.push_back(move(like_expression_value));

    QueryErrorContext error_context_unlike(NULL, NULL);
    ScalarFunction bound_function_contains = ContainsFun::GetFunction();
    unique_ptr<FunctionData> bind_data_contains = NULL;

    auto like_bound_function = make_uniq<BoundFunctionExpression>(LogicalType::BOOLEAN,
                                                                    bound_function_contains,
                                                                    move(like_arguments),
                                                                    move(bind_data_contains), false);

    select_list.push_back(move(like_bound_function));
    unique_ptr<PhysicalFilter> filter_mc_contains = make_uniq<PhysicalFilter>(filter_mc_types, move(select_list), 0);
    filter_mc_contains->children.push_back(move(scan_keyword_k));

    idx_t p_title_year = 2005; // 933;
    Value p_title = Value::BIGINT(p_title_year);
    vector<idx_t> title_t_ids{COLUMN_IDENTIFIER_ROW_ID, 1, 4};
    vector<LogicalType> get_title_t_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::BIGINT};
    string alias_title_t = "t";
    vector<LogicalType> table_types_title_t;
    vector<unique_ptr<Expression>> filter_title_t;
    unique_ptr<LogicalGet> get_op_title_t = move(
            getLogicalGet(*this, table_title, alias_title_t, table_index_title_t, table_types_title_t));
    unique_ptr<TableFilterSet> table_filters_title_t = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_GREATERTHAN, p_title);
    table_filters_title_t->filters[2] = move(constant_filter);
    unique_ptr<PhysicalTableScan> scan_title_t = make_uniq<PhysicalTableScan>(get_title_t_types,
                                                                              get_op_title_t->function,
                                                                              get_op_title_t->table_index,
                                                                              move(get_op_title_t->bind_data),
                                                                              table_types_title_t, title_t_ids,
                                                                              move(filter_title_t), vector<column_t>(),
                                                                              get_op_title_t->names,
                                                                              std::move(table_filters_title_t),
                                                                              get_op_title_t->estimated_cardinality,
                                                                              get_op_title_t->extra_info);


    vector<JoinCondition> cond_title_t;
    JoinCondition join_condition_title_t;
    join_condition_title_t.left = make_uniq<BoundReferenceExpression>("title_rowid", LogicalType::BIGINT, 0);
    join_condition_title_t.right = make_uniq<BoundReferenceExpression>("keyword_rowid", LogicalType::BIGINT, 0);
    join_condition_title_t.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_title_t = make_uniq<RAIInfo>();
    rai_info_title_t->rai = table_movie_keyword.GetStorage().info->rais[0].get();
    rai_info_title_t->rai_type = RAIType::TARGET_EDGE;
    rai_info_title_t->forward = true;
    rai_info_title_t->vertex = &table_title;
    rai_info_title_t->vertex_id = table_index_title_t;
    rai_info_title_t->passing_tables[0] = table_index_title_t;
    rai_info_title_t->left_cardinalities[0] = table_title.GetStorage().info->cardinality;
    // rai_info_title_t->compact_list = &rai_info_title_t->rai->alist->compact__list;

    join_condition_title_t.rais.push_back(move(rai_info_title_t));
    cond_title_t.push_back(move(join_condition_title_t));

    LogicalComparisonJoin join_title_t_op(JoinType::INNER);
    vector<LogicalType> output_title_t_types{LogicalType::BIGINT, LogicalType::VARCHAR,
                                             LogicalType::BIGINT, LogicalType::BIGINT};
    join_title_t_op.types = output_title_t_types;
    vector<idx_t> right_projection_map_title_t{0};
    vector<idx_t> merge_project_map_title_t;
    vector<LogicalType> delim_types_title_t;
    auto join_title_t = make_uniq<PhysicalMergeSIPJoin>(join_title_t_op, move(scan_title_t), move(filter_mc_contains), move(cond_title_t), JoinType::INNER,
                                                   left_projection_map, right_projection_map_title_t,
                                                   merge_project_map_title_t, delim_types_title_t, 0);


    vector<idx_t> info_type_i_ids{6, 3};
    vector<LogicalType> get_info_type_i_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_info_type_i = "i";
    vector<LogicalType> table_types_info_type_i;
    vector<unique_ptr<Expression>> filter_info_type_i;
    unique_ptr<LogicalGet> get_op_info_type_i = move(
            getLogicalGet(*this, table_movie_info, alias_info_type_i, table_index_movie_info_, table_types_info_type_i));
    unique_ptr<TableFilterSet> table_filters_info_type_i = NULL;
    unique_ptr<PhysicalTableScan> scan_info_type_i = make_uniq<PhysicalTableScan>(get_info_type_i_types,
                                                                                  get_op_info_type_i->function,
                                                                                  get_op_info_type_i->table_index,
                                                                                  move(get_op_info_type_i->bind_data),
                                                                                  table_types_info_type_i,
                                                                                  info_type_i_ids,
                                                                                  move(filter_info_type_i),
                                                                                  vector<column_t>(),
                                                                                  get_op_info_type_i->names,
                                                                                  std::move(table_filters_info_type_i),
                                                                                  get_op_info_type_i->estimated_cardinality,
                                                                                  get_op_info_type_i->extra_info);

    auto &allocator = Allocator::Get(context);
    vector<LogicalType> join_in_types {LogicalType::VARCHAR};
    auto collection =
            make_uniq<ColumnDataCollection>(context, join_in_types, ColumnDataAllocatorType::IN_MEMORY_ALLOCATOR);

    vector<LogicalType> chunk_in_types {LogicalType::VARCHAR};
    DataChunk chunk;
    chunk.SetCardinality(8);
    chunk.Initialize(allocator, chunk_in_types);
    chunk.SetValue(0, 0, Value("Sweden"));
    chunk.SetValue(0, 1, Value("Norway"));
    chunk.SetValue(0, 2, Value("Germany"));
    chunk.SetValue(0, 3, Value("Denmark"));
    chunk.SetValue(0, 4, Value("Swedish"));
    chunk.SetValue(0, 5, Value("Denish"));
    chunk.SetValue(0, 6, Value("Norwegian"));
    chunk.SetValue(0, 7, Value("German"));
    collection->Append(chunk);

    // create a chunk scan to output the result
    vector<LogicalType> ouput_in_types {LogicalType::VARCHAR};
    auto chunk_scan = make_uniq<PhysicalColumnDataScan>(ouput_in_types, PhysicalOperatorType::COLUMN_DATA_SCAN,
                                                        8, std::move(collection));

    vector<JoinCondition> cond_hash_join_;
    JoinCondition join_condition_hash_join_;
    join_condition_hash_join_.left = make_uniq<BoundReferenceExpression>("info", LogicalType::VARCHAR, 1);
    join_condition_hash_join_.right = make_uniq<BoundReferenceExpression>("", LogicalType::VARCHAR, 0);
    join_condition_hash_join_.comparison = ExpressionType::COMPARE_EQUAL;
    cond_hash_join_.push_back(move(join_condition_hash_join_));

    LogicalComparisonJoin join_hash_join_op(JoinType::MARK);
    vector<LogicalType> output_hash_join_types{LogicalType::BIGINT, LogicalType::VARCHAR,
                                                 LogicalType::BOOLEAN};
    join_hash_join_op.types = output_hash_join_types;
    vector<idx_t> right_projection_map_hash_join_;
    vector<LogicalType> delim_types_hash_join_;
    PerfectHashJoinStats joinstate;
    auto join_hash_join_ = make_uniq<PhysicalHashJoin>(join_hash_join_op, move(scan_info_type_i), move(chunk_scan), move(cond_hash_join_),
                                                       JoinType::MARK, left_projection_map,
                                                       right_projection_map_hash_join_,
                                                       delim_types_hash_join_, 0, joinstate);

    /*vector<LogicalType> result_types_test{LogicalType::VARCHAR};
    vector<unique_ptr<Expression>> select_list_project_test;
    auto result_col0_test = make_uniq<BoundReferenceExpression>("title", LogicalType::VARCHAR, 1);
    select_list_project_test.push_back(move(result_col0_test));
    auto projection_test = make_uniq<PhysicalProjection>(result_types_test, move(select_list_project_test), 0);
    projection_test->children.push_back(move(join_hash_join_));

    return projection_test;*/

    vector<LogicalType> filter_in_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::BOOLEAN};
    vector<unique_ptr<Expression>> select_list_in;
    auto in_exp = make_uniq<BoundReferenceExpression>("IN (...)", LogicalType::BOOLEAN, 2);
    select_list_in.push_back(move(in_exp));
    unique_ptr<PhysicalFilter> filter_in = make_uniq<PhysicalFilter>(filter_in_types, move(select_list_in), 0);
    filter_in->children.push_back(move(join_hash_join_));

    vector<JoinCondition> cond_movie_info_;
    JoinCondition join_condition_movie_info_;
    join_condition_movie_info_.left = make_uniq<BoundReferenceExpression>("movie_id_rowid", LogicalType::BIGINT, 0);
    join_condition_movie_info_.right = make_uniq<BoundReferenceExpression>("title_rowid", LogicalType::BIGINT, 0);
    join_condition_movie_info_.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_movie_info_ = make_uniq<RAIInfo>();
    rai_info_movie_info_->rai = table_movie_info.GetStorage().info->rais[0].get();
    rai_info_movie_info_->rai_type = RAIType::EDGE_TARGET;
    rai_info_movie_info_->forward = false;
    rai_info_movie_info_->vertex = &table_title;
    rai_info_movie_info_->vertex_id = table_index_title_t;
    rai_info_movie_info_->passing_tables[0] = table_index_movie_info_;
    rai_info_movie_info_->left_cardinalities[0] = table_movie_info.GetStorage().info->cardinality;
    rai_info_movie_info_->compact_list = &rai_info_movie_info_->rai->alist->compact_backward_list;

    join_condition_movie_info_.rais.push_back(move(rai_info_movie_info_));
    cond_movie_info_.push_back(move(join_condition_movie_info_));

    LogicalComparisonJoin join_movie_info__op(JoinType::INNER);
    vector<LogicalType> output_movie_info__types{LogicalType::BIGINT, LogicalType::VARCHAR,
                                                 LogicalType::BOOLEAN, LogicalType::VARCHAR};
    join_movie_info__op.types = output_movie_info__types;
    vector<idx_t> right_projection_map_movie_info_{1};
    vector<idx_t> merge_project_map_movie_info_;
    vector<LogicalType> delim_types_movie_info_;
    auto join_movie_info_ = make_uniq<PhysicalSIPJoin>(join_movie_info__op, move(filter_in), move(join_title_t), move(cond_movie_info_),
                                                            JoinType::INNER, left_projection_map,
                                                            right_projection_map_movie_info_,
                                                            delim_types_movie_info_, 0);


    vector<LogicalType> result_types{LogicalType::VARCHAR};
    vector<unique_ptr<Expression>> select_list_project;
    auto result_col0 = make_uniq<BoundReferenceExpression>("title", LogicalType::VARCHAR, 3);
    select_list_project.push_back(move(result_col0));
    auto projection = make_uniq<PhysicalProjection>(result_types, move(select_list_project), 0);
    projection->children.push_back(move(join_movie_info_));

    // aggregate
    string agg_name = "min";
    string agg_error = "";
    QueryErrorContext error_context(NULL, NULL);
    auto min_func = Catalog::GetEntry(context, CatalogType::SCALAR_FUNCTION_ENTRY, "", "",
                                      "min", OnEntryNotFound::RETURN_NULL, error_context);
    auto &min_func_set = min_func->Cast<AggregateFunctionCatalogEntry>();
    // bind the aggregate
    FunctionBinder function_binder(context);
    vector<LogicalType> types;
    types.push_back(LogicalType::VARCHAR);
    idx_t best_function_varchar = function_binder.BindFunction(agg_name, min_func_set.functions, types, agg_error);
    auto bound_function_min_varchar = min_func_set.functions.GetFunctionByOffset(best_function_varchar);

    auto second_children = make_uniq<BoundReferenceExpression>("title", LogicalType::VARCHAR, 0);
    vector<unique_ptr<Expression>> childrenlist2;
    childrenlist2.push_back(move(second_children));
    auto aggregate2 =
            function_binder.BindAggregateFunction(bound_function_min_varchar, std::move(childrenlist2), nullptr,
                                                  AggregateType::NON_DISTINCT);

    vector<unique_ptr<Expression>> aggregates;
    aggregates.push_back(move(aggregate2));

    vector<LogicalType> aggregate_types{LogicalType::VARCHAR};
    auto ungrouped_aggregate = make_uniq<PhysicalUngroupedAggregate>(aggregate_types, move(aggregates), 0);
    ungrouped_aggregate->children.push_back(move(projection));

    return ungrouped_aggregate;
}

unique_ptr<PhysicalOperator> ClientContext::GenerateJOB4aPlan(duckdb::ClientContext &context) {
    vector<idx_t> left_projection_map, right_projection_map;

    string table_vertex_keyword_k = "keyword";
    string table_vertex_title_t = "title";
    string table_vertex_info_type_it = "info_type";
    string table_vertex_movie_keyword_mk = "movie_keyword";
    string table_vertex_movie_info_idx_mi = "movie_info_idx";

    idx_t table_index_keyword_k = 1;
    idx_t table_index_title_t = 2;
    idx_t table_index_info_type_it = 3;
    idx_t table_index_movie_keyword_mk = 4;
    idx_t table_index_movie_info_idx_mi = 5;
    auto table_or_view_keyword = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_keyword_k,
                                                   OnEntryNotFound::RETURN_NULL);
    auto &table_keyword = table_or_view_keyword->Cast<TableCatalogEntry>();
    auto table_or_view_title = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_title_t,
                                                 OnEntryNotFound::RETURN_NULL);
    auto &table_title = table_or_view_title->Cast<TableCatalogEntry>();
    auto table_or_view_info_type = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_info_type_it,
                                                     OnEntryNotFound::RETURN_NULL);
    auto &table_info_type = table_or_view_info_type->Cast<TableCatalogEntry>();
    auto table_or_view_movie_keyword = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                         table_vertex_movie_keyword_mk, OnEntryNotFound::RETURN_NULL);
    auto &table_movie_keyword = table_or_view_movie_keyword->Cast<TableCatalogEntry>();
    auto table_or_view_movie_info_idx = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                          table_vertex_movie_info_idx_mi, OnEntryNotFound::RETURN_NULL);
    auto &table_movie_info_idx = table_or_view_movie_info_idx->Cast<TableCatalogEntry>();

    string p_info = "rating"; // 933;
    Value info = Value(p_info);
    vector<idx_t> info_type_it_ids{1, COLUMN_IDENTIFIER_ROW_ID};
    vector<LogicalType> get_info_type_it_types{LogicalType::VARCHAR, LogicalType::BIGINT};
    string alias_info_type_it = "it";
    vector<LogicalType> table_types_info_type_it;
    vector<unique_ptr<Expression>> filter_info_type_it;
    unique_ptr<LogicalGet> get_op_info_type_it = move(
            getLogicalGet(*this, table_info_type, alias_info_type_it, table_index_info_type_it,
                          table_types_info_type_it));
    unique_ptr<TableFilterSet> table_filters_info_type_it = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL, info);
    table_filters_info_type_it->filters[0] = move(constant_filter);
    unique_ptr<PhysicalTableScan> scan_info_type_it = make_uniq<PhysicalTableScan>(get_info_type_it_types,
                                                                                   get_op_info_type_it->function,
                                                                                   get_op_info_type_it->table_index,
                                                                                   move(get_op_info_type_it->bind_data),
                                                                                   table_types_info_type_it,
                                                                                   info_type_it_ids,
                                                                                   move(filter_info_type_it),
                                                                                   vector<column_t>(),
                                                                                   get_op_info_type_it->names,
                                                                                   std::move(
                                                                                           table_filters_info_type_it),
                                                                                   get_op_info_type_it->estimated_cardinality,
                                                                                   get_op_info_type_it->extra_info);

    string p_mi_info = "5.0"; // 933;
    Value mi_info = Value(p_mi_info);
    vector<idx_t> mi_ids{3, 5, 6};
    vector<LogicalType> get_mi_types{LogicalType::VARCHAR, LogicalType::BIGINT, LogicalType::BIGINT};
    string alias_mi = "mi";
    vector<LogicalType> table_types_mi;
    vector<unique_ptr<Expression>> filter_mi;
    unique_ptr<LogicalGet> get_op_mi = move(
            getLogicalGet(*this, table_movie_info_idx, alias_mi, table_index_movie_info_idx_mi,
                          table_types_mi));
    unique_ptr<TableFilterSet> table_filters_mi = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_mi = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_GREATERTHAN, mi_info);
    table_filters_mi->filters[0] = move(constant_filter_mi);
    unique_ptr<PhysicalTableScan> scan_movie_info_idx = make_uniq<PhysicalTableScan>(get_mi_types,
                                                                                   get_op_mi->function,
                                                                                   get_op_mi->table_index,
                                                                                   move(get_op_mi->bind_data),
                                                                                   table_types_mi,
                                                                                   mi_ids,
                                                                                   move(filter_mi),
                                                                                   vector<column_t>(),
                                                                                   get_op_mi->names,
                                                                                   std::move(table_filters_mi),
                                                                                   get_op_mi->estimated_cardinality,
                                                                                   get_op_mi->extra_info);


    vector<JoinCondition> cond_movie_info_idx_;
    JoinCondition join_condition_movie_info_idx_;
    join_condition_movie_info_idx_.left = make_uniq<BoundReferenceExpression>("info_type_id_rowid", LogicalType::BIGINT, 1);
    join_condition_movie_info_idx_.right = make_uniq<BoundReferenceExpression>("info_type_rowid", LogicalType::BIGINT, 1);
    join_condition_movie_info_idx_.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_movie_info_idx_ = make_uniq<RAIInfo>();
    rai_info_movie_info_idx_->rai = table_movie_info_idx.GetStorage().info->rais[0].get();
    rai_info_movie_info_idx_->rai_type = RAIType::EDGE_SOURCE;
    rai_info_movie_info_idx_->forward = true;
    rai_info_movie_info_idx_->vertex = &table_info_type;
    rai_info_movie_info_idx_->vertex_id = table_index_info_type_it;
    rai_info_movie_info_idx_->passing_tables[0] = table_index_movie_info_idx_mi;
    rai_info_movie_info_idx_->left_cardinalities[0] = table_movie_info_idx.GetStorage().info->cardinality;
    rai_info_movie_info_idx_->compact_list = &rai_info_movie_info_idx_->rai->alist->compact_forward_list;

    join_condition_movie_info_idx_.rais.push_back(move(rai_info_movie_info_idx_));
    cond_movie_info_idx_.push_back(move(join_condition_movie_info_idx_));

    LogicalComparisonJoin join_movie_info_idx__op(JoinType::INNER);
    vector<LogicalType> output_movie_info_idx__types{LogicalType::VARCHAR, LogicalType::BIGINT,
                                                     LogicalType::BIGINT, LogicalType::BIGINT};
    join_movie_info_idx__op.types = output_movie_info_idx__types;
    vector<idx_t> right_projection_map_movie_info_idx_{1};
    vector<idx_t> merge_project_map_movie_info_idx_;
    vector<LogicalType> delim_types_movie_info_idx_;
    auto join_movie_info_idx_ = make_uniq<PhysicalSIPJoin>(join_movie_info_idx__op, move(scan_movie_info_idx), move(scan_info_type_it),
                                                                move(cond_movie_info_idx_), JoinType::INNER,
                                                                left_projection_map,
                                                                right_projection_map_movie_info_idx_,
                                                                delim_types_movie_info_idx_, 0);


    idx_t p_production_year = 2005; // 933;
    Value production_year = Value::BIGINT(p_production_year);
    vector<idx_t> title_t_ids{4, COLUMN_IDENTIFIER_ROW_ID, 1};
    vector<LogicalType> get_title_t_types{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_title_t = "t";
    vector<LogicalType> table_types_title_t;
    vector<unique_ptr<Expression>> filter_title_t;
    unique_ptr<LogicalGet> get_op_title_t = move(
            getLogicalGet(*this, table_title, alias_title_t, table_index_title_t, table_types_title_t));
    unique_ptr<TableFilterSet> table_filters_title_t = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_title = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_GREATERTHAN, production_year);
    table_filters_title_t->filters[0] = move(constant_filter_title);
    unique_ptr<PhysicalTableScan> scan_title_t = make_uniq<PhysicalTableScan>(get_title_t_types,
                                                                              get_op_title_t->function,
                                                                              get_op_title_t->table_index,
                                                                              move(get_op_title_t->bind_data),
                                                                              table_types_title_t, title_t_ids,
                                                                              move(filter_title_t), vector<column_t>(),
                                                                              get_op_title_t->names,
                                                                              std::move(table_filters_title_t),
                                                                              get_op_title_t->estimated_cardinality,
                                                                              get_op_title_t->extra_info);


    vector<JoinCondition> cond_title_t;
    JoinCondition join_condition_title_t;
    join_condition_title_t.left = make_uniq<BoundReferenceExpression>("title_rowid", LogicalType::BIGINT, 1);
    join_condition_title_t.right = make_uniq<BoundReferenceExpression>("movie_id_rowid", LogicalType::BIGINT, 2);
    join_condition_title_t.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_title_t = make_uniq<RAIInfo>();
    rai_info_title_t->rai = table_movie_info_idx.GetStorage().info->rais[0].get();
    rai_info_title_t->rai_type = RAIType::TARGET_EDGE;
    rai_info_title_t->forward = true;
    rai_info_title_t->vertex = &table_title;
    rai_info_title_t->vertex_id = table_index_title_t;
    rai_info_title_t->passing_tables[0] = table_index_title_t;
    rai_info_title_t->left_cardinalities[0] = table_title.GetStorage().info->cardinality;
    // rai_info_title_t->compact_list = &rai_info_title_t->rai->alist->compact__list;

    join_condition_title_t.rais.push_back(move(rai_info_title_t));
    cond_title_t.push_back(move(join_condition_title_t));

    LogicalComparisonJoin join_title_t_op(JoinType::INNER);
    vector<LogicalType> output_title_t_types{LogicalType::BIGINT, LogicalType::BIGINT,
                                             LogicalType::VARCHAR, LogicalType::VARCHAR};
    join_title_t_op.types = output_title_t_types;
    vector<idx_t> right_projection_map_title_t{0};
    vector<idx_t> merge_project_map_title_t;
    vector<LogicalType> delim_types_title_t;
    auto join_title_t = make_uniq<PhysicalSIPJoin>(join_title_t_op, move(scan_title_t), move(join_movie_info_idx_), move(cond_title_t), JoinType::INNER,
                                                   left_projection_map, right_projection_map_title_t,
                                                   delim_types_title_t, 0);


    vector<idx_t> keyword_k_ids{1, COLUMN_IDENTIFIER_ROW_ID};
    vector<LogicalType> get_keyword_k_types{LogicalType::VARCHAR, LogicalType::BIGINT};
    string alias_keyword_k = "k";
    vector<LogicalType> table_types_keyword_k;
    vector<unique_ptr<Expression>> filter_keyword_k;
    unique_ptr<LogicalGet> get_op_keyword_k = move(
            getLogicalGet(*this, table_keyword, alias_keyword_k, table_index_keyword_k, table_types_keyword_k));
    unique_ptr<TableFilterSet> table_filters_keyword_k = NULL;
    unique_ptr<PhysicalTableScan> scan_keyword_k = make_uniq<PhysicalTableScan>(get_keyword_k_types,
                                                                                get_op_keyword_k->function,
                                                                                get_op_keyword_k->table_index,
                                                                                move(get_op_keyword_k->bind_data),
                                                                                table_types_keyword_k, keyword_k_ids,
                                                                                move(filter_keyword_k),
                                                                                vector<column_t>(),
                                                                                get_op_keyword_k->names,
                                                                                std::move(table_filters_keyword_k),
                                                                                get_op_keyword_k->estimated_cardinality,
                                                                                get_op_keyword_k->extra_info);


    string p_keyword = "sequel";
    Value p_keyword_n = Value(p_keyword);
    vector<LogicalType> filter_mc_types{LogicalType::VARCHAR, LogicalType::BIGINT};
    vector<unique_ptr<Expression>> select_list_keyword;
    auto like_expression_left = make_uniq<BoundReferenceExpression>("keyword", LogicalType::VARCHAR, 0);
    auto like_expression_value = make_uniq<BoundConstantExpression>(p_keyword_n);
    vector<unique_ptr<Expression>> like_arguments;
    like_arguments.push_back(move(like_expression_left));
    like_arguments.push_back(move(like_expression_value));

    QueryErrorContext error_context_unlike(NULL, NULL);
    ScalarFunction bound_function_contains = ContainsFun::GetFunction();
    unique_ptr<FunctionData> bind_data_contains = NULL;

    auto like_bound_function = make_uniq<BoundFunctionExpression>(LogicalType::BOOLEAN,
                                                                  bound_function_contains,
                                                                  move(like_arguments),
                                                                  move(bind_data_contains), false);

    select_list_keyword.push_back(move(like_bound_function));
    unique_ptr<PhysicalFilter> filter_mc_contains = make_uniq<PhysicalFilter>(filter_mc_types, move(select_list_keyword), 0);
    filter_mc_contains->children.push_back(move(scan_keyword_k));


    vector<JoinCondition> cond_keyword_k;
    JoinCondition join_condition_keyword_k;
    join_condition_keyword_k.left = make_uniq<BoundReferenceExpression>("keyword_rowid", LogicalType::BIGINT, 1);
    join_condition_keyword_k.right = make_uniq<BoundReferenceExpression>("title_rowid", LogicalType::BIGINT, 1);
    join_condition_keyword_k.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_keyword_k = make_uniq<RAIInfo>();
    rai_info_keyword_k->rai = table_movie_keyword.GetStorage().info->rais[0].get();
    rai_info_keyword_k->rai_type = RAIType::SOURCE_EDGE;
    rai_info_keyword_k->forward = false;
    rai_info_keyword_k->vertex = &table_keyword;
    rai_info_keyword_k->vertex_id = table_index_keyword_k;
    rai_info_keyword_k->passing_tables[0] = table_index_keyword_k;
    rai_info_keyword_k->left_cardinalities[0] = table_keyword.GetStorage().info->cardinality;
    // rai_info_keyword_k->compact_list = &rai_info_keyword_k->rai->alist->compact__list;

    join_condition_keyword_k.rais.push_back(move(rai_info_keyword_k));
    cond_keyword_k.push_back(move(join_condition_keyword_k));

    LogicalComparisonJoin join_keyword_k_op(JoinType::INNER);
    vector<LogicalType> output_keyword_k_types{LogicalType::VARCHAR, LogicalType::BIGINT,
                                               LogicalType::VARCHAR, LogicalType::VARCHAR};
    join_keyword_k_op.types = output_keyword_k_types;
    vector<idx_t> right_projection_map_keyword_k{2, 3};
    vector<idx_t> merge_project_map_keyword_k;
    vector<LogicalType> delim_types_keyword_k;
    auto join_keyword_k = make_uniq<PhysicalMergeSIPJoin>(join_keyword_k_op, move(filter_mc_contains), move(join_title_t), move(cond_keyword_k),
                                                     JoinType::INNER, left_projection_map,
                                                     right_projection_map_keyword_k,
                                                     merge_project_map_keyword_k,
                                                     delim_types_keyword_k, 0);


    vector<LogicalType> result_types{LogicalType::VARCHAR, LogicalType::VARCHAR};
    vector<unique_ptr<Expression>> select_list;
    auto result_col0 = make_uniq<BoundReferenceExpression>("info", LogicalType::VARCHAR, 3);
    auto result_col1 = make_uniq<BoundReferenceExpression>("title", LogicalType::VARCHAR, 2);
    select_list.push_back(move(result_col0));
    select_list.push_back(move(result_col1));
    auto projection = make_uniq<PhysicalProjection>(result_types, move(select_list), 0);
    projection->children.push_back(move(join_keyword_k));

    // aggregate
    string agg_name = "min";
    string agg_error = "";
    QueryErrorContext error_context(NULL, NULL);
    auto min_func = Catalog::GetEntry(context, CatalogType::SCALAR_FUNCTION_ENTRY, "", "",
                                      "min", OnEntryNotFound::RETURN_NULL, error_context);
    auto &min_func_set = min_func->Cast<AggregateFunctionCatalogEntry>();
    // bind the aggregate
    FunctionBinder function_binder(context);
    vector<LogicalType> types;
    types.push_back(LogicalType::VARCHAR);
    idx_t best_function_varchar = function_binder.BindFunction(agg_name, min_func_set.functions, types, agg_error);
    auto bound_function_min_varchar = min_func_set.functions.GetFunctionByOffset(best_function_varchar);

    auto first_children = make_uniq<BoundReferenceExpression>("info", LogicalType::VARCHAR, 0);
    vector<unique_ptr<Expression>> childrenlist1;
    childrenlist1.push_back(move(first_children));
    auto aggregate1 =
            function_binder.BindAggregateFunction(bound_function_min_varchar, std::move(childrenlist1), nullptr,
                                                  AggregateType::NON_DISTINCT);

    auto second_children = make_uniq<BoundReferenceExpression>("title", LogicalType::VARCHAR, 1);
    vector<unique_ptr<Expression>> childrenlist2;
    childrenlist2.push_back(move(second_children));
    auto aggregate2 =
            function_binder.BindAggregateFunction(bound_function_min_varchar, std::move(childrenlist2), nullptr,
                                                  AggregateType::NON_DISTINCT);

    vector<unique_ptr<Expression>> aggregates;
    aggregates.push_back(move(aggregate1));
    aggregates.push_back(move(aggregate2));

    vector<LogicalType> aggregate_types{LogicalType::VARCHAR, LogicalType::VARCHAR};
    auto ungrouped_aggregate = make_uniq<PhysicalUngroupedAggregate>(aggregate_types, move(aggregates), 0);
    ungrouped_aggregate->children.push_back(move(projection));

    return ungrouped_aggregate;
}

unique_ptr<PhysicalOperator> ClientContext::GenerateJOB5aPlan(duckdb::ClientContext &context) {
    vector<idx_t> left_projection_map, right_projection_map;

    string table_vertex_company_type_ct = "company_type";
    string table_vertex_title_t = "title";
    string table_vertex_info_type_it = "info_type";
    string table_vertex_movie_companies_ = "movie_companies";
    string table_vertex_movie_info_ = "movie_info";

    idx_t table_index_company_type_ct = 1;
    idx_t table_index_title_t = 2;
    idx_t table_index_info_type_it = 3;
    idx_t table_index_movie_companies_ = 4;
    idx_t table_index_movie_info_ = 5;
    auto table_or_view_company_type = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                        table_vertex_company_type_ct, OnEntryNotFound::RETURN_NULL);
    auto &table_company_type = table_or_view_company_type->Cast<TableCatalogEntry>();
    auto table_or_view_title = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_title_t,
                                                 OnEntryNotFound::RETURN_NULL);
    auto &table_title = table_or_view_title->Cast<TableCatalogEntry>();
    auto table_or_view_info_type = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_info_type_it,
                                                     OnEntryNotFound::RETURN_NULL);
    auto &table_info_type = table_or_view_info_type->Cast<TableCatalogEntry>();
    auto table_or_view_movie_companies = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                           table_vertex_movie_companies_, OnEntryNotFound::RETURN_NULL);
    auto &table_movie_companies = table_or_view_movie_companies->Cast<TableCatalogEntry>();
    auto table_or_view_movie_info = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_movie_info_,
                                                      OnEntryNotFound::RETURN_NULL);
    auto &table_movie_info = table_or_view_movie_info->Cast<TableCatalogEntry>();

    string p_company_type_kind = "production companies";
    Value p_kind = Value(p_company_type_kind);
    vector<idx_t> company_type_ct_ids{1, COLUMN_IDENTIFIER_ROW_ID};
    vector<LogicalType> get_company_type_ct_types{LogicalType::VARCHAR, LogicalType::BIGINT};
    string alias_company_type_ct = "ct";
    vector<LogicalType> table_types_company_type_ct;
    vector<unique_ptr<Expression>> filter_company_type_ct;
    unique_ptr<LogicalGet> get_op_company_type_ct = move(
            getLogicalGet(*this, table_company_type, alias_company_type_ct, table_index_company_type_ct,
                          table_types_company_type_ct));
    unique_ptr<TableFilterSet> table_filters_company_type_ct = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL, p_kind);
    table_filters_company_type_ct->filters[0] = move(constant_filter);
    unique_ptr<PhysicalTableScan> scan_company_type_ct = make_uniq<PhysicalTableScan>(get_company_type_ct_types,
                                                                                      get_op_company_type_ct->function,
                                                                                      get_op_company_type_ct->table_index,
                                                                                      move(get_op_company_type_ct->bind_data),
                                                                                      table_types_company_type_ct,
                                                                                      company_type_ct_ids,
                                                                                      move(filter_company_type_ct),
                                                                                      vector<column_t>(),
                                                                                      get_op_company_type_ct->names,
                                                                                      std::move(
                                                                                              table_filters_company_type_ct),
                                                                                      get_op_company_type_ct->estimated_cardinality,
                                                                                      get_op_company_type_ct->extra_info);


    vector<idx_t> movie_companies_ids{4, 6, 7};
    vector<LogicalType> get_movie_companies_types{LogicalType::VARCHAR, LogicalType::BIGINT, LogicalType::BIGINT};
    string alias_movie_companies = "ct";
    vector<LogicalType> table_types_movie_companies;
    vector<unique_ptr<Expression>> filter_movie_companies;
    unique_ptr<LogicalGet> get_op_movie_companies = move(
            getLogicalGet(*this, table_movie_companies, alias_movie_companies, table_index_movie_companies_,
                          table_types_movie_companies));
    unique_ptr<TableFilterSet> table_filters_movie_companies = NULL;
    unique_ptr<PhysicalTableScan> scan_movie_companies = make_uniq<PhysicalTableScan>(get_movie_companies_types,
                                                                                      get_op_movie_companies->function,
                                                                                      get_op_movie_companies->table_index,
                                                                                      move(get_op_movie_companies->bind_data),
                                                                                      table_types_movie_companies,
                                                                                      movie_companies_ids,
                                                                                      move(filter_movie_companies),
                                                                                      vector<column_t>(),
                                                                                      get_op_movie_companies->names,
                                                                                      std::move(
                                                                                              table_filters_movie_companies),
                                                                                      get_op_movie_companies->estimated_cardinality,
                                                                                      get_op_movie_companies->extra_info);


    string p_movie_company_note1 = "(theatrical)"; // 933;
    string p_movie_company_note2 = "(France)"; // 933;
    Value p_note1 = Value(p_movie_company_note1);
    Value p_note2 = Value(p_movie_company_note2);
    vector<LogicalType> filter_mc_types{LogicalType::VARCHAR, LogicalType::BIGINT, LogicalType::BIGINT};
    vector<unique_ptr<Expression>> select_list_movie_companies;
    auto like_expression_left = make_uniq<BoundReferenceExpression>("note", LogicalType::VARCHAR, 0);
    auto like_expression_value = make_uniq<BoundConstantExpression>(p_note1);
    vector<unique_ptr<Expression>> like_arguments1, like_arguments2;
    like_arguments1.push_back(move(like_expression_left));
    like_arguments1.push_back(move(like_expression_value));

    auto like_expression_left2 = make_uniq<BoundReferenceExpression>("note", LogicalType::VARCHAR, 0);
    auto like_expression_value2 = make_uniq<BoundConstantExpression>(p_note2);
    like_arguments2.push_back(move(like_expression_left2));
    like_arguments2.push_back(move(like_expression_value2));

    QueryErrorContext error_context_unlike(NULL, NULL);
    ScalarFunction bound_function_contains = ContainsFun::GetFunction();
    unique_ptr<FunctionData> bind_data_contains = NULL;

    auto like_bound_function = make_uniq<BoundFunctionExpression>(LogicalType::BOOLEAN,
                                                                  bound_function_contains,
                                                                  move(like_arguments1),
                                                                  move(bind_data_contains), false);

    unique_ptr<FunctionData> bind_data_contains2 = NULL;
    auto like_bound_function2 = make_uniq<BoundFunctionExpression>(LogicalType::BOOLEAN,
                                                                  bound_function_contains,
                                                                  move(like_arguments2),
                                                                  move(bind_data_contains2), false);


    select_list_movie_companies.push_back(move(like_bound_function));
    select_list_movie_companies.push_back(move(like_bound_function2));
    unique_ptr<PhysicalFilter> filter_mc_contains = make_uniq<PhysicalFilter>(filter_mc_types, move(select_list_movie_companies), 0);
    filter_mc_contains->children.push_back(move(scan_movie_companies));


    vector<JoinCondition> cond_movie_companies_;
    JoinCondition join_condition_movie_companies_;
    join_condition_movie_companies_.left = make_uniq<BoundReferenceExpression>("company_type_id_rowid", LogicalType::BIGINT, 2);
    join_condition_movie_companies_.right = make_uniq<BoundReferenceExpression>("company_type_rowid", LogicalType::BIGINT, 1);
    join_condition_movie_companies_.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_movie_companies_ = make_uniq<RAIInfo>();
    rai_info_movie_companies_->rai = table_movie_companies.GetStorage().info->rais[1].get();
    rai_info_movie_companies_->rai_type = RAIType::EDGE_SOURCE;
    rai_info_movie_companies_->forward = true;
    rai_info_movie_companies_->vertex = &table_company_type;
    rai_info_movie_companies_->vertex_id = table_index_company_type_ct;
    rai_info_movie_companies_->passing_tables[0] = table_index_movie_companies_;
    rai_info_movie_companies_->left_cardinalities[0] = table_movie_companies.GetStorage().info->cardinality;
    rai_info_movie_companies_->compact_list = &rai_info_movie_companies_->rai->alist->compact_forward_list;

    join_condition_movie_companies_.rais.push_back(move(rai_info_movie_companies_));
    cond_movie_companies_.push_back(move(join_condition_movie_companies_));

    LogicalComparisonJoin join_movie_companies__op(JoinType::INNER);
    vector<LogicalType> output_movie_companies__types{LogicalType::VARCHAR, LogicalType::BIGINT,
                                                      LogicalType::BIGINT, LogicalType::BIGINT};
    join_movie_companies__op.types = output_movie_companies__types;
    vector<idx_t> right_projection_map_movie_companies_{1};
    vector<idx_t> merge_project_map_movie_companies_;
    vector<LogicalType> delim_types_movie_companies_;
    auto join_movie_companies_ = make_uniq<PhysicalSIPJoin>(join_movie_companies__op, move(filter_mc_contains), move(scan_company_type_ct),
                                                                 move(cond_movie_companies_), JoinType::INNER,
                                                                 left_projection_map,
                                                                 right_projection_map_movie_companies_,
                                                                 delim_types_movie_companies_, 0);


    idx_t p_production_year = 2005; // 933;
    Value production_year = Value::BIGINT(p_production_year);
    vector<idx_t> title_t_ids{4, COLUMN_IDENTIFIER_ROW_ID, 1};
    vector<LogicalType> get_title_t_types{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_title_t = "t";
    vector<LogicalType> table_types_title_t;
    vector<unique_ptr<Expression>> filter_title_t;
    unique_ptr<LogicalGet> get_op_title_t = move(
            getLogicalGet(*this, table_title, alias_title_t, table_index_title_t, table_types_title_t));
    unique_ptr<TableFilterSet> table_filters_title_t = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_title = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_GREATERTHAN, production_year);
    table_filters_title_t->filters[0] = move(constant_filter_title);
    unique_ptr<PhysicalTableScan> scan_title_t = make_uniq<PhysicalTableScan>(get_title_t_types,
                                                                              get_op_title_t->function,
                                                                              get_op_title_t->table_index,
                                                                              move(get_op_title_t->bind_data),
                                                                              table_types_title_t, title_t_ids,
                                                                              move(filter_title_t), vector<column_t>(),
                                                                              get_op_title_t->names,
                                                                              std::move(table_filters_title_t),
                                                                              get_op_title_t->estimated_cardinality,
                                                                              get_op_title_t->extra_info);


    vector<JoinCondition> cond_title_t;
    JoinCondition join_condition_title_t;
    join_condition_title_t.left = make_uniq<BoundReferenceExpression>("title_rowid", LogicalType::BIGINT, 1);
    join_condition_title_t.right = make_uniq<BoundReferenceExpression>("movie_id_rowid", LogicalType::BIGINT, 1);
    join_condition_title_t.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_title_t = make_uniq<RAIInfo>();
    rai_info_title_t->rai = table_movie_companies.GetStorage().info->rais[1].get();
    rai_info_title_t->rai_type = RAIType::TARGET_EDGE;
    rai_info_title_t->forward = true;
    rai_info_title_t->vertex = &table_title;
    rai_info_title_t->vertex_id = table_index_title_t;
    rai_info_title_t->passing_tables[0] = table_index_title_t;
    rai_info_title_t->left_cardinalities[0] = table_title.GetStorage().info->cardinality;
    // rai_info_title_t->compact_list = &rai_info_title_t->rai->alist->compact__list;

    join_condition_title_t.rais.push_back(move(rai_info_title_t));
    cond_title_t.push_back(move(join_condition_title_t));

    LogicalComparisonJoin join_title_t_op(JoinType::INNER);
    vector<LogicalType> output_title_t_types{LogicalType::BIGINT, LogicalType::BIGINT,
                                             LogicalType::VARCHAR, LogicalType::BIGINT};
    join_title_t_op.types = output_title_t_types;
    vector<idx_t> right_projection_map_title_t{1};
    vector<idx_t> merge_project_map_title_t;
    vector<LogicalType> delim_types_title_t;
    auto join_title_t = make_uniq<PhysicalSIPJoin>(join_title_t_op, move(scan_title_t), move(join_movie_companies_), move(cond_title_t), JoinType::INNER,
                                                   left_projection_map, right_projection_map_title_t,
                                                   delim_types_title_t, 0);

    vector<idx_t> movie_info_ids{6, 5, 3};
    vector<LogicalType> get_movie_info_types{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_movie_info = "i";
    vector<LogicalType> table_types_movie_info;
    vector<unique_ptr<Expression>> filter_movie_info;
    unique_ptr<LogicalGet> get_op_movie_info = move(
            getLogicalGet(*this, table_movie_info, alias_movie_info, table_index_movie_info_, table_types_movie_info));
    unique_ptr<TableFilterSet> table_filters_movie_info = NULL;
    unique_ptr<PhysicalTableScan> scan_movie_info = make_uniq<PhysicalTableScan>(get_movie_info_types,
                                                                                  get_op_movie_info->function,
                                                                                  get_op_movie_info->table_index,
                                                                                  move(get_op_movie_info->bind_data),
                                                                                  table_types_movie_info,
                                                                                  movie_info_ids,
                                                                                  move(filter_movie_info),
                                                                                  vector<column_t>(),
                                                                                  get_op_movie_info->names,
                                                                                  std::move(table_filters_movie_info),
                                                                                  get_op_movie_info->estimated_cardinality,
                                                                                  get_op_movie_info->extra_info);

    auto &allocator = Allocator::Get(context);
    vector<LogicalType> join_in_types {LogicalType::VARCHAR};
    auto collection =
            make_uniq<ColumnDataCollection>(context, join_in_types, ColumnDataAllocatorType::IN_MEMORY_ALLOCATOR);

    vector<LogicalType> chunk_in_types {LogicalType::VARCHAR};
    DataChunk chunk;
    chunk.SetCardinality(8);
    chunk.Initialize(allocator, chunk_in_types);
    chunk.SetValue(0, 0, Value("Sweden"));
    chunk.SetValue(0, 1, Value("Norway"));
    chunk.SetValue(0, 2, Value("Germany"));
    chunk.SetValue(0, 3, Value("Denmark"));
    chunk.SetValue(0, 4, Value("Swedish"));
    chunk.SetValue(0, 5, Value("Denish"));
    chunk.SetValue(0, 6, Value("Norwegian"));
    chunk.SetValue(0, 7, Value("German"));
    collection->Append(chunk);

    // create a chunk scan to output the result
    vector<LogicalType> ouput_in_types {LogicalType::VARCHAR};
    auto chunk_scan = make_uniq<PhysicalColumnDataScan>(ouput_in_types, PhysicalOperatorType::COLUMN_DATA_SCAN,
                                                        8, std::move(collection));

    vector<JoinCondition> cond_hash_join_;
    JoinCondition join_condition_hash_join_;
    join_condition_hash_join_.left = make_uniq<BoundReferenceExpression>("info", LogicalType::VARCHAR, 2);
    join_condition_hash_join_.right = make_uniq<BoundReferenceExpression>("", LogicalType::VARCHAR, 0);
    join_condition_hash_join_.comparison = ExpressionType::COMPARE_EQUAL;
    cond_hash_join_.push_back(move(join_condition_hash_join_));

    LogicalComparisonJoin join_hash_join_op(JoinType::MARK);
    vector<LogicalType> output_hash_join_types{LogicalType::BIGINT, LogicalType::BIGINT,
                                               LogicalType::VARCHAR, LogicalType::BOOLEAN};
    join_hash_join_op.types = output_hash_join_types;
    vector<idx_t> right_projection_map_hash_join_;
    vector<LogicalType> delim_types_hash_join_;
    PerfectHashJoinStats joinstate;
    auto join_hash_join_ = make_uniq<PhysicalHashJoin>(join_hash_join_op, move(scan_movie_info), move(chunk_scan), move(cond_hash_join_),
                                                       JoinType::MARK, left_projection_map,
                                                       right_projection_map_hash_join_,
                                                       delim_types_hash_join_, 0, joinstate);

    vector<LogicalType> filter_in_types{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::BOOLEAN};
    vector<unique_ptr<Expression>> select_list_in;
    auto in_exp = make_uniq<BoundReferenceExpression>("IN (...)", LogicalType::BOOLEAN, 3);
    select_list_in.push_back(move(in_exp));
    unique_ptr<PhysicalFilter> filter_in = make_uniq<PhysicalFilter>(filter_in_types, move(select_list_in), 0);
    filter_in->children.push_back(move(join_hash_join_));

    vector<JoinCondition> cond_title_movie_info_;
    JoinCondition join_condition_title_movie_info_;
    join_condition_title_movie_info_.left = make_uniq<BoundReferenceExpression>("movie_id_rowid", LogicalType::BIGINT, 0);
    join_condition_title_movie_info_.right = make_uniq<BoundReferenceExpression>("title_rowid", LogicalType::BIGINT, 1);
    join_condition_title_movie_info_.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_title_movie_info_ = make_uniq<RAIInfo>();
    rai_info_title_movie_info_->rai = table_movie_info.GetStorage().info->rais[0].get();
    rai_info_title_movie_info_->rai_type = RAIType::EDGE_TARGET;
    rai_info_title_movie_info_->forward = false;
    rai_info_title_movie_info_->vertex = &table_title;
    rai_info_title_movie_info_->vertex_id = table_index_title_t;
    rai_info_title_movie_info_->passing_tables[0] = table_index_movie_info_;
    rai_info_title_movie_info_->left_cardinalities[0] = table_movie_info.GetStorage().info->cardinality;
    rai_info_title_movie_info_->compact_list = &rai_info_title_movie_info_->rai->alist->compact_backward_list;

    join_condition_title_movie_info_.rais.push_back(move(rai_info_title_movie_info_));
    cond_title_movie_info_.push_back(move(join_condition_title_movie_info_));

    LogicalComparisonJoin join_title_movie_info__op(JoinType::INNER);
    vector<LogicalType> output_title_movie_info__types{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::VARCHAR,
                                                       LogicalType::BOOLEAN, LogicalType::VARCHAR};
    join_title_movie_info__op.types = output_title_movie_info__types;
    vector<idx_t> right_projection_map_title_movie_info_{2};
    vector<idx_t> merge_project_map_title_movie_info_;
    vector<LogicalType> delim_types_title_movie_info_;
    auto join_title_movie_info_ = make_uniq<PhysicalSIPJoin>(join_title_movie_info__op, move(filter_in), move(join_title_t), move(cond_title_movie_info_),
                                                            JoinType::INNER, left_projection_map,
                                                            right_projection_map_title_movie_info_,
                                                            delim_types_title_movie_info_, 0);


    vector<idx_t> info_type_it_ids{COLUMN_IDENTIFIER_ROW_ID};
    vector<LogicalType> get_info_type_it_types{LogicalType::BIGINT};
    string alias_info_type_it = "it";
    vector<LogicalType> table_types_info_type_it;
    vector<unique_ptr<Expression>> filter_info_type_it;
    unique_ptr<LogicalGet> get_op_info_type_it = move(
            getLogicalGet(*this, table_info_type, alias_info_type_it, table_index_info_type_it,
                          table_types_info_type_it));
    unique_ptr<TableFilterSet> table_filters_info_type_it = NULL;
    unique_ptr<PhysicalTableScan> scan_info_type_it = make_uniq<PhysicalTableScan>(get_info_type_it_types,
                                                                                   get_op_info_type_it->function,
                                                                                   get_op_info_type_it->table_index,
                                                                                   move(get_op_info_type_it->bind_data),
                                                                                   table_types_info_type_it,
                                                                                   info_type_it_ids,
                                                                                   move(filter_info_type_it),
                                                                                   vector<column_t>(),
                                                                                   get_op_info_type_it->names,
                                                                                   std::move(
                                                                                           table_filters_info_type_it),
                                                                                   get_op_info_type_it->estimated_cardinality,
                                                                                   get_op_info_type_it->extra_info);


    vector<JoinCondition> cond_movie_info_;
    JoinCondition join_condition_movie_info_;
    join_condition_movie_info_.left = make_uniq<BoundReferenceExpression>("info_type_rowid", LogicalType::BIGINT, 0);
    join_condition_movie_info_.right = make_uniq<BoundReferenceExpression>("info_type_id_rowid", LogicalType::BIGINT, 1);
    join_condition_movie_info_.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_movie_info_ = make_uniq<RAIInfo>();
    rai_info_movie_info_->rai = table_movie_info.GetStorage().info->rais[0].get();
    rai_info_movie_info_->rai_type = RAIType::SOURCE_EDGE;
    rai_info_movie_info_->forward = false;
    rai_info_movie_info_->vertex = &table_info_type;
    rai_info_movie_info_->vertex_id = table_index_info_type_it;
    rai_info_movie_info_->passing_tables[0] = table_index_info_type_it;
    rai_info_movie_info_->left_cardinalities[0] = table_info_type.GetStorage().info->cardinality;
    // rai_info_movie_info_->compact_list = &rai_info_movie_info_->rai->alist->compact__list;

    join_condition_movie_info_.rais.push_back(move(rai_info_movie_info_));
    cond_movie_info_.push_back(move(join_condition_movie_info_));

    LogicalComparisonJoin join_movie_info__op(JoinType::INNER);
    vector<LogicalType> output_movie_info__types{LogicalType::BIGINT, LogicalType::VARCHAR};
    join_movie_info__op.types = output_movie_info__types;
    vector<idx_t> right_projection_map_movie_info_{4};
    vector<idx_t> merge_project_map_movie_info_;
    vector<LogicalType> delim_types_movie_info_;
    auto join_movie_info_ = make_uniq<PhysicalSIPJoin>(join_movie_info__op, move(scan_info_type_it), move(join_title_movie_info_), move(cond_movie_info_),
                                                            JoinType::INNER, left_projection_map,
                                                            right_projection_map_movie_info_,
                                                            delim_types_movie_info_, 0);

    vector<LogicalType> result_types{LogicalType::VARCHAR};
    vector<unique_ptr<Expression>> select_list;
    auto result_col0 = make_uniq<BoundReferenceExpression>("title", LogicalType::VARCHAR, 1);
    select_list.push_back(move(result_col0));
    auto projection = make_uniq<PhysicalProjection>(result_types, move(select_list), 0);
    projection->children.push_back(move(join_movie_info_));

    // aggregate
    string agg_name = "min";
    string agg_error = "";
    QueryErrorContext error_context(NULL, NULL);
    auto min_func = Catalog::GetEntry(context, CatalogType::SCALAR_FUNCTION_ENTRY, "", "",
                                      "min", OnEntryNotFound::RETURN_NULL, error_context);
    auto &min_func_set = min_func->Cast<AggregateFunctionCatalogEntry>();
    // bind the aggregate
    FunctionBinder function_binder(context);
    vector<LogicalType> types;
    types.push_back(LogicalType::VARCHAR);
    idx_t best_function_varchar = function_binder.BindFunction(agg_name, min_func_set.functions, types, agg_error);
    auto bound_function_min_varchar = min_func_set.functions.GetFunctionByOffset(best_function_varchar);

    auto second_children = make_uniq<BoundReferenceExpression>("title", LogicalType::VARCHAR, 0);
    vector<unique_ptr<Expression>> childrenlist2;
    childrenlist2.push_back(move(second_children));
    auto aggregate2 =
            function_binder.BindAggregateFunction(bound_function_min_varchar, std::move(childrenlist2), nullptr,
                                                  AggregateType::NON_DISTINCT);

    vector<unique_ptr<Expression>> aggregates;
    aggregates.push_back(move(aggregate2));

    vector<LogicalType> aggregate_types{LogicalType::VARCHAR};
    auto ungrouped_aggregate = make_uniq<PhysicalUngroupedAggregate>(aggregate_types, move(aggregates), 0);
    ungrouped_aggregate->children.push_back(move(projection));

    return ungrouped_aggregate;
}

unique_ptr<PhysicalOperator> ClientContext::GenerateJOB6aPlan(duckdb::ClientContext &context) {
    vector<idx_t> left_projection_map, right_projection_map;

    string table_vertex_keyword_k = "keyword";
    string table_vertex_title_t = "title";
    string table_vertex_name_n = "name";
    string table_vertex_movie_keyword_ = "movie_keyword";
    string table_vertex_cast_info_ = "cast_info";

    idx_t table_index_keyword_k = 1;
    idx_t table_index_title_t = 2;
    idx_t table_index_name_n = 3;
    idx_t table_index_movie_keyword_ = 4;
    idx_t table_index_cast_info_ = 5;
    auto table_or_view_keyword = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_keyword_k,
                                                   OnEntryNotFound::RETURN_NULL);
    auto &table_keyword = table_or_view_keyword->Cast<TableCatalogEntry>();
    auto table_or_view_title = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_title_t,
                                                 OnEntryNotFound::RETURN_NULL);
    auto &table_title = table_or_view_title->Cast<TableCatalogEntry>();
    auto table_or_view_name = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_name_n,
                                                OnEntryNotFound::RETURN_NULL);
    auto &table_name = table_or_view_name->Cast<TableCatalogEntry>();
    auto table_or_view_movie_keyword = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                         table_vertex_movie_keyword_, OnEntryNotFound::RETURN_NULL);
    auto &table_movie_keyword = table_or_view_movie_keyword->Cast<TableCatalogEntry>();
    auto table_or_view_cast_info = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_cast_info_,
                                                     OnEntryNotFound::RETURN_NULL);
    auto &table_cast_info = table_or_view_cast_info->Cast<TableCatalogEntry>();

    string p_keyword_k = "marvel-cinematic-universe";
    Value p_keyword = Value(p_keyword_k);
    vector<idx_t> keyword_k_ids{COLUMN_IDENTIFIER_ROW_ID, 1};
    vector<LogicalType> get_keyword_k_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_keyword_k = "k";
    vector<LogicalType> table_types_keyword_k;
    vector<unique_ptr<Expression>> filter_keyword_k;
    unique_ptr<LogicalGet> get_op_keyword_k = move(
            getLogicalGet(*this, table_keyword, alias_keyword_k, table_index_keyword_k, table_types_keyword_k));
    unique_ptr<TableFilterSet> table_filters_keyword_k = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL, p_keyword);
    table_filters_keyword_k->filters[1] = move(constant_filter);
    unique_ptr<PhysicalTableScan> scan_keyword_k = make_uniq<PhysicalTableScan>(get_keyword_k_types,
                                                                                get_op_keyword_k->function,
                                                                                get_op_keyword_k->table_index,
                                                                                move(get_op_keyword_k->bind_data),
                                                                                table_types_keyword_k, keyword_k_ids,
                                                                                move(filter_keyword_k),
                                                                                vector<column_t>(),
                                                                                get_op_keyword_k->names,
                                                                                std::move(table_filters_keyword_k),
                                                                                get_op_keyword_k->estimated_cardinality,
                                                                                get_op_keyword_k->extra_info);

    idx_t p_production_year = 2010; // 933;
    Value production_year = Value::BIGINT(p_production_year);
    vector<idx_t> title_t_ids{COLUMN_IDENTIFIER_ROW_ID, 4, 1};
    vector<LogicalType> get_title_t_types{LogicalType::BIGINT, LogicalType::BIGINT,
                                          LogicalType::VARCHAR};
    string alias_title_t = "t";
    vector<LogicalType> table_types_title_t;
    vector<unique_ptr<Expression>> filter_title_t;
    unique_ptr<LogicalGet> get_op_title_t = move(
            getLogicalGet(*this, table_title, alias_title_t, table_index_title_t, table_types_title_t));
    unique_ptr<TableFilterSet> table_filters_title_t = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_title = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_GREATERTHAN, production_year);
    table_filters_title_t->filters[1] = move(constant_filter_title);
    unique_ptr<PhysicalTableScan> scan_title_t = make_uniq<PhysicalTableScan>(get_title_t_types,
                                                                              get_op_title_t->function,
                                                                              get_op_title_t->table_index,
                                                                              move(get_op_title_t->bind_data),
                                                                              table_types_title_t, title_t_ids,
                                                                              move(filter_title_t), vector<column_t>(),
                                                                              get_op_title_t->names,
                                                                              std::move(table_filters_title_t),
                                                                              get_op_title_t->estimated_cardinality,
                                                                              get_op_title_t->extra_info);


    vector<JoinCondition> cond_title_t;
    JoinCondition join_condition_title_t;
    join_condition_title_t.left = make_uniq<BoundReferenceExpression>("title_rowid", LogicalType::BIGINT, 0);
    join_condition_title_t.right = make_uniq<BoundReferenceExpression>("keyword_rowid", LogicalType::BIGINT, 0);
    join_condition_title_t.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_title_t = make_uniq<RAIInfo>();
    rai_info_title_t->rai = table_movie_keyword.GetStorage().info->rais[0].get();
    rai_info_title_t->rai_type = RAIType::TARGET_EDGE;
    rai_info_title_t->forward = true;
    rai_info_title_t->vertex = &table_title;
    rai_info_title_t->vertex_id = table_index_title_t;
    rai_info_title_t->passing_tables[0] = table_index_title_t;
    rai_info_title_t->left_cardinalities[0] = table_title.GetStorage().info->cardinality;
    // rai_info_title_t->compact_list = &rai_info_title_t->rai->alist->compact__list;

    join_condition_title_t.rais.push_back(move(rai_info_title_t));
    cond_title_t.push_back(move(join_condition_title_t));

    LogicalComparisonJoin join_title_t_op(JoinType::INNER);
    vector<LogicalType> output_title_t_types{LogicalType::BIGINT, LogicalType::BIGINT,
                                             LogicalType::VARCHAR, LogicalType::VARCHAR};
    join_title_t_op.types = output_title_t_types;
    vector<idx_t> right_projection_map_title_t{1};
    vector<idx_t> merge_project_map_title_t;
    vector<LogicalType> delim_types_title_t;
    auto join_title_t = make_uniq<PhysicalMergeSIPJoin>(join_title_t_op, move(scan_title_t), move(scan_keyword_k), move(cond_title_t), JoinType::INNER,
                                                   left_projection_map, right_projection_map_title_t,
                                                   merge_project_map_title_t,
                                                   delim_types_title_t, 0);


    vector<idx_t> name_n_ids{COLUMN_IDENTIFIER_ROW_ID, 1};
    vector<LogicalType> get_name_n_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_name_n = "n";
    vector<LogicalType> table_types_name_n;
    vector<unique_ptr<Expression>> filter_name_n;
    unique_ptr<LogicalGet> get_op_name_n = move(
            getLogicalGet(*this, table_name, alias_name_n, table_index_name_n, table_types_name_n));
    unique_ptr<TableFilterSet> table_filters_name_n = NULL;
    unique_ptr<PhysicalTableScan> scan_name_n = make_uniq<PhysicalTableScan>(get_name_n_types, get_op_name_n->function,
                                                                             get_op_name_n->table_index,
                                                                             move(get_op_name_n->bind_data),
                                                                             table_types_name_n, name_n_ids,
                                                                             move(filter_name_n), vector<column_t>(),
                                                                             get_op_name_n->names,
                                                                             std::move(table_filters_name_n),
                                                                             get_op_name_n->estimated_cardinality,
                                                                             get_op_name_n->extra_info);

    string p_name_n = "%Downey%Robert%";
    Value p_name = Value(p_name_n);
    vector<LogicalType> filter_mc_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    vector<unique_ptr<Expression>> select_list_name;
    auto like_expression_left = make_uniq<BoundReferenceExpression>("name", LogicalType::VARCHAR, 1);
    auto like_expression_value = make_uniq<BoundConstantExpression>(p_name);
    vector<unique_ptr<Expression>> like_arguments;
    like_arguments.push_back(move(like_expression_left));
    like_arguments.push_back(move(like_expression_value));

    QueryErrorContext error_context_unlike(NULL, NULL);
    ScalarFunction bound_function_like = LikeFun::GetLikeFunction();
    unique_ptr<FunctionData> bind_data_like = NULL;

    auto like_bound_function = make_uniq<BoundFunctionExpression>(LogicalType::BOOLEAN,
                                                                  bound_function_like,
                                                                  move(like_arguments),
                                                                  move(bind_data_like), false);

    select_list_name.push_back(move(like_bound_function));
    unique_ptr<PhysicalFilter> filter_like = make_uniq<PhysicalFilter>(filter_mc_types, move(select_list_name), 0);
    filter_like->children.push_back(move(scan_name_n));

    vector<JoinCondition> cond_name_n;
    JoinCondition join_condition_name_n;
    join_condition_name_n.left = make_uniq<BoundReferenceExpression>("name_rowid", LogicalType::BIGINT, 0);
    join_condition_name_n.right = make_uniq<BoundReferenceExpression>("title_rowid", LogicalType::BIGINT, 0);
    join_condition_name_n.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_name_n = make_uniq<RAIInfo>();
    rai_info_name_n->rai = table_cast_info.GetStorage().info->rais[0].get();
    rai_info_name_n->rai_type = RAIType::TARGET_EDGE;
    rai_info_name_n->forward = true;
    rai_info_name_n->vertex = &table_name;
    rai_info_name_n->vertex_id = table_index_name_n;
    rai_info_name_n->passing_tables[0] = table_index_name_n;
    rai_info_name_n->left_cardinalities[0] = table_name.GetStorage().info->cardinality;
    // rai_info_name_n->compact_list = &rai_info_name_n->rai->alist->compact__list;

    join_condition_name_n.rais.push_back(move(rai_info_name_n));
    cond_name_n.push_back(move(join_condition_name_n));

    LogicalComparisonJoin join_name_n_op(JoinType::INNER);
    vector<LogicalType> output_name_n_types{LogicalType::BIGINT, LogicalType::VARCHAR,
                                            LogicalType::VARCHAR, LogicalType::VARCHAR};
    join_name_n_op.types = output_name_n_types;
    vector<idx_t> right_projection_map_name_n{2, 3};
    vector<idx_t> merge_project_map_name_n;
    vector<LogicalType> delim_types_name_n;
    auto join_name_n = make_uniq<PhysicalMergeSIPJoin>(join_name_n_op, move(filter_like), move(join_title_t), move(cond_name_n), JoinType::INNER,
                                                  left_projection_map, right_projection_map_name_n,
                                                  merge_project_map_name_n,
                                                  delim_types_name_n,
                                                  0);


    vector<LogicalType> result_types{LogicalType::VARCHAR, LogicalType::VARCHAR, LogicalType::VARCHAR};
    vector<unique_ptr<Expression>> select_list;
    auto result_col0 = make_uniq<BoundReferenceExpression>("keyword", LogicalType::VARCHAR, 3);
    auto result_col1 = make_uniq<BoundReferenceExpression>("name", LogicalType::VARCHAR, 1);
    auto result_col2 = make_uniq<BoundReferenceExpression>("title", LogicalType::VARCHAR, 2);
    select_list.push_back(move(result_col0));
    select_list.push_back(move(result_col1));
    select_list.push_back(move(result_col2));
    auto projection = make_uniq<PhysicalProjection>(result_types, move(select_list), 0);
    projection->children.push_back(move(join_name_n));

    // aggregate
    string agg_name = "min";
    string agg_error = "";
    QueryErrorContext error_context(NULL, NULL);
    auto min_func = Catalog::GetEntry(context, CatalogType::SCALAR_FUNCTION_ENTRY, "", "",
                                      "min", OnEntryNotFound::RETURN_NULL, error_context);
    auto &min_func_set = min_func->Cast<AggregateFunctionCatalogEntry>();
    // bind the aggregate
    FunctionBinder function_binder(context);
    vector<LogicalType> types;
    types.push_back(LogicalType::VARCHAR);
    idx_t best_function_varchar = function_binder.BindFunction(agg_name, min_func_set.functions, types, agg_error);
    auto bound_function_min_varchar = min_func_set.functions.GetFunctionByOffset(best_function_varchar);

    auto first_children = make_uniq<BoundReferenceExpression>("keyword", LogicalType::VARCHAR, 0);
    vector<unique_ptr<Expression>> childrenlist1;
    childrenlist1.push_back(move(first_children));
    auto aggregate1 =
            function_binder.BindAggregateFunction(bound_function_min_varchar, std::move(childrenlist1), nullptr,
                                                  AggregateType::NON_DISTINCT);

    auto second_children = make_uniq<BoundReferenceExpression>("name", LogicalType::VARCHAR, 1);
    vector<unique_ptr<Expression>> childrenlist2;
    childrenlist2.push_back(move(second_children));
    auto aggregate2 =
            function_binder.BindAggregateFunction(bound_function_min_varchar, std::move(childrenlist2), nullptr,
                                                  AggregateType::NON_DISTINCT);

    auto third_children = make_uniq<BoundReferenceExpression>("title", LogicalType::VARCHAR, 2);
    vector<unique_ptr<Expression>> childrenlist3;
    childrenlist3.push_back(move(third_children));
    auto aggregate3 =
            function_binder.BindAggregateFunction(bound_function_min_varchar, std::move(childrenlist3), nullptr,
                                                  AggregateType::NON_DISTINCT);

    vector<unique_ptr<Expression>> aggregates;
    aggregates.push_back(move(aggregate1));
    aggregates.push_back(move(aggregate2));
    aggregates.push_back(move(aggregate3));

    vector<LogicalType> aggregate_types{LogicalType::VARCHAR, LogicalType::VARCHAR, LogicalType::VARCHAR};
    auto ungrouped_aggregate = make_uniq<PhysicalUngroupedAggregate>(aggregate_types, move(aggregates), 0);
    ungrouped_aggregate->children.push_back(move(projection));

    return ungrouped_aggregate;
}

unique_ptr<PhysicalOperator> ClientContext::GenerateJOB7aPlan(duckdb::ClientContext &context) {
    vector<idx_t> left_projection_map, right_projection_map;

    string table_vertex_aka_name_an = "aka_name";
    string table_vertex_name_n = "name";
    string table_vertex_title_t = "title";
    string table_vertex_link_type_lt = "link_type";
    string table_vertex_info_type_it = "info_type";
    string table_vertex_cast_info_ = "cast_info";
    string table_vertex_movie_link_ = "movie_link";
    string table_vertex_person_info_ = "person_info";

    idx_t table_index_aka_name_an = 1;
    idx_t table_index_name_n = 2;
    idx_t table_index_title_t = 3;
    idx_t table_index_link_type_lt = 4;
    idx_t table_index_info_type_it = 5;
    idx_t table_index_cast_info_ = 7;
    idx_t table_index_movie_link_ = 8;
    idx_t table_index_person_info_ = 9;
    auto table_or_view_aka_name = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_aka_name_an,
                                                    OnEntryNotFound::RETURN_NULL);
    auto &table_aka_name = table_or_view_aka_name->Cast<TableCatalogEntry>();
    auto table_or_view_name = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_name_n,
                                                OnEntryNotFound::RETURN_NULL);
    auto &table_name = table_or_view_name->Cast<TableCatalogEntry>();
    auto table_or_view_title = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_title_t,
                                                 OnEntryNotFound::RETURN_NULL);
    auto &table_title = table_or_view_title->Cast<TableCatalogEntry>();
    auto table_or_view_link_type = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_link_type_lt,
                                                     OnEntryNotFound::RETURN_NULL);
    auto &table_link_type = table_or_view_link_type->Cast<TableCatalogEntry>();
    auto table_or_view_info_type = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_info_type_it,
                                                     OnEntryNotFound::RETURN_NULL);
    auto &table_info_type = table_or_view_info_type->Cast<TableCatalogEntry>();
    auto table_or_view_cast_info = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_cast_info_,
                                                     OnEntryNotFound::RETURN_NULL);
    auto &table_cast_info = table_or_view_cast_info->Cast<TableCatalogEntry>();
    auto table_or_view_movie_link = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_movie_link_,
                                                      OnEntryNotFound::RETURN_NULL);
    auto &table_movie_link = table_or_view_movie_link->Cast<TableCatalogEntry>();
    auto table_or_view_person_info = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                       table_vertex_person_info_, OnEntryNotFound::RETURN_NULL);
    auto &table_person_info = table_or_view_person_info->Cast<TableCatalogEntry>();

    string p_info_type_it = "mini biography";
    Value p_info_type = Value(p_info_type_it);
    vector<idx_t> info_type_it_ids{COLUMN_IDENTIFIER_ROW_ID, 1};
    vector<LogicalType> get_info_type_it_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_info_type_it = "it";
    vector<LogicalType> table_types_info_type_it;
    vector<unique_ptr<Expression>> filter_info_type_it;
    unique_ptr<LogicalGet> get_op_info_type_it = move(
            getLogicalGet(*this, table_info_type, alias_info_type_it, table_index_info_type_it,
                          table_types_info_type_it));
    unique_ptr<TableFilterSet> table_filters_info_type_it = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_it = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL, p_info_type);
    table_filters_info_type_it->filters[1] = move(constant_filter_it);
    unique_ptr<PhysicalTableScan> scan_info_type_it = make_uniq<PhysicalTableScan>(get_info_type_it_types,
                                                                                   get_op_info_type_it->function,
                                                                                   get_op_info_type_it->table_index,
                                                                                   move(get_op_info_type_it->bind_data),
                                                                                   table_types_info_type_it,
                                                                                   info_type_it_ids,
                                                                                   move(filter_info_type_it),
                                                                                   vector<column_t>(),
                                                                                   get_op_info_type_it->names,
                                                                                   std::move(
                                                                                           table_filters_info_type_it),
                                                                                   get_op_info_type_it->estimated_cardinality,
                                                                                   get_op_info_type_it->extra_info);



    string p_info_n = "Volker Boehm";
    Value p_info = Value(p_info_n);
    vector<idx_t> person_info_pi_ids{4, 5, 6};
    vector<LogicalType> get_person_info_pi_types{LogicalType::VARCHAR, LogicalType::BIGINT,
                                                 LogicalType::BIGINT};
    string alias_person_info_pi = "pi";
    vector<LogicalType> table_types_person_info_pi;
    vector<unique_ptr<Expression>> filter_person_info_pi;
    unique_ptr<LogicalGet> get_op_person_info_pi = move(
            getLogicalGet(*this, table_person_info, alias_person_info_pi, table_index_person_info_,
                          table_types_person_info_pi));
    unique_ptr<TableFilterSet> table_filters_person_info_pi = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_pi = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL, p_info);
    table_filters_person_info_pi->filters[0] = move(constant_filter_pi);
    unique_ptr<PhysicalTableScan> scan_person_info_pi = make_uniq<PhysicalTableScan>(get_person_info_pi_types,
                                                                                   get_op_person_info_pi->function,
                                                                                   get_op_person_info_pi->table_index,
                                                                                   move(get_op_person_info_pi->bind_data),
                                                                                   table_types_person_info_pi,
                                                                                   person_info_pi_ids,
                                                                                   move(filter_person_info_pi),
                                                                                   vector<column_t>(),
                                                                                   get_op_person_info_pi->names,
                                                                                   std::move(
                                                                                           table_filters_person_info_pi),
                                                                                   get_op_person_info_pi->estimated_cardinality,
                                                                                   get_op_person_info_pi->extra_info);


    vector<JoinCondition> cond_person_info_;
    JoinCondition join_condition_person_info_;
    join_condition_person_info_.left = make_uniq<BoundReferenceExpression>("info_type_id_rowid", LogicalType::BIGINT, 1);
    join_condition_person_info_.right = make_uniq<BoundReferenceExpression>("info_type_rowid", LogicalType::BIGINT, 0);
    join_condition_person_info_.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_person_info_ = make_uniq<RAIInfo>();
    rai_info_person_info_->rai = table_person_info.GetStorage().info->rais[0].get();
    rai_info_person_info_->rai_type = RAIType::EDGE_SOURCE;
    rai_info_person_info_->forward = true;
    rai_info_person_info_->vertex = &table_info_type;
    rai_info_person_info_->vertex_id = table_index_info_type_it;
    rai_info_person_info_->passing_tables[0] = table_index_person_info_;
    rai_info_person_info_->left_cardinalities[0] = table_person_info.GetStorage().info->cardinality;
    rai_info_person_info_->compact_list = &rai_info_person_info_->rai->alist->compact_forward_list;

    join_condition_person_info_.rais.push_back(move(rai_info_person_info_));
    cond_person_info_.push_back(move(join_condition_person_info_));

    LogicalComparisonJoin join_person_info__op(JoinType::INNER);
    vector<LogicalType> output_person_info__types{LogicalType::VARCHAR, LogicalType::BIGINT,
                                                  LogicalType::BIGINT, LogicalType::BIGINT};
    join_person_info__op.types = output_person_info__types;
    vector<idx_t> right_projection_map_person_info_{0};
    vector<idx_t> merge_project_map_person_info_;
    vector<LogicalType> delim_types_person_info_;
    auto join_person_info_ = make_uniq<PhysicalSIPJoin>(join_person_info__op, move(scan_person_info_pi), move(scan_info_type_it),
                                                             move(cond_person_info_), JoinType::INNER,
                                                             left_projection_map, right_projection_map_person_info_,
                                                             delim_types_person_info_,
                                                             0);

    string p_name_n1 = "A";
    string p_name_n2 = "F";
    Value p_name1 = Value(p_name_n1);
    Value p_name2 = Value(p_name_n2);
    vector<idx_t> name_n_ids{COLUMN_IDENTIFIER_ROW_ID, 1, 4, 5};
    vector<LogicalType> get_name_n_types{LogicalType::BIGINT, LogicalType::VARCHAR,
                                         LogicalType::VARCHAR, LogicalType::VARCHAR};
    string alias_name_n = "n";
    vector<LogicalType> table_types_name_n;
    vector<unique_ptr<Expression>> filter_name_n;
    unique_ptr<LogicalGet> get_op_name_n = move(
            getLogicalGet(*this, table_name, alias_name_n, table_index_name_n, table_types_name_n));
    unique_ptr<TableFilterSet> table_filters_name_n = make_uniq<TableFilterSet>();
    unique_ptr<ConjunctionAndFilter> and_filter_name = duckdb::make_uniq<ConjunctionAndFilter>();
    unique_ptr<ConstantFilter> constant_filter_name_start = duckdb::make_uniq<ConstantFilter>(
            ExpressionType::COMPARE_GREATERTHANOREQUALTO, p_name_n1);
    unique_ptr<ConstantFilter> constant_filter_name_end = duckdb::make_uniq<ConstantFilter>(
            ExpressionType::COMPARE_LESSTHANOREQUALTO, p_name_n2);
    and_filter_name->child_filters.push_back(move(constant_filter_name_start));
    and_filter_name->child_filters.push_back(move(constant_filter_name_end));
    table_filters_name_n->filters[3] = move(and_filter_name);
    unique_ptr<PhysicalTableScan> scan_name_n = make_uniq<PhysicalTableScan>(get_name_n_types, get_op_name_n->function,
                                                                             get_op_name_n->table_index,
                                                                             move(get_op_name_n->bind_data),
                                                                             table_types_name_n, name_n_ids,
                                                                             move(filter_name_n), vector<column_t>(),
                                                                             get_op_name_n->names,
                                                                             std::move(table_filters_name_n),
                                                                             get_op_name_n->estimated_cardinality,
                                                                             get_op_name_n->extra_info);


    vector<LogicalType> filter_name_types{LogicalType::BIGINT, LogicalType::VARCHAR,
                                          LogicalType::VARCHAR, LogicalType::VARCHAR};
    vector<unique_ptr<Expression>> select_list_name;
    auto male_gender_left = make_uniq<BoundReferenceExpression>("gender", LogicalType::VARCHAR, 2);
    auto male_gender_value = make_uniq<BoundConstantExpression>(Value("m"));
    auto male_gender_bound_function = make_uniq<BoundComparisonExpression>(ExpressionType::COMPARE_EQUAL,
                                                                             move(male_gender_left),
                                                                             move(male_gender_value));

    auto female_gender_left = make_uniq<BoundReferenceExpression>("gender", LogicalType::VARCHAR, 2);
    auto female_gender_value = make_uniq<BoundConstantExpression>(Value("f"));
    auto female_gender_bound_function = make_uniq<BoundComparisonExpression>(ExpressionType::COMPARE_EQUAL,
                                                                             move(female_gender_left),
                                                                             move(female_gender_value));

    auto female_expression_left = make_uniq<BoundReferenceExpression>("name", LogicalType::VARCHAR, 1);
    auto female_expression_value = make_uniq<BoundConstantExpression>(Value("B%"));
    vector<unique_ptr<Expression>> female_arguments;
    female_arguments.push_back(move(female_expression_left));
    female_arguments.push_back(move(female_expression_value));

    QueryErrorContext error_context_unlike(NULL, NULL);
    ScalarFunction bound_function_like = LikeFun::GetLikeFunction();
    unique_ptr<FunctionData> bind_data_like = NULL;

    auto female_bound_function = make_uniq<BoundFunctionExpression>(LogicalType::BOOLEAN,
                                                                    bound_function_like,
                                                                    move(female_arguments),
                                                                    move(bind_data_like), false);

    auto and_conjunction = make_uniq<BoundConjunctionExpression>(ExpressionType::CONJUNCTION_AND);
    and_conjunction->children.push_back(move(female_gender_bound_function));
    and_conjunction->children.push_back(move(female_bound_function));

    auto or_conjunction = make_uniq<BoundConjunctionExpression>(ExpressionType::CONJUNCTION_OR);
    or_conjunction->children.push_back(move(male_gender_bound_function));
    or_conjunction->children.push_back(move(and_conjunction));

    select_list_name.push_back(move(or_conjunction));
    unique_ptr<PhysicalFilter> filter_name = make_uniq<PhysicalFilter>(filter_name_types, move(select_list_name), 0);
    filter_name->children.push_back(move(scan_name_n));

    vector<JoinCondition> cond_name_n;
    JoinCondition join_condition_name_n;
    join_condition_name_n.left = make_uniq<BoundReferenceExpression>("name_rowid", LogicalType::BIGINT, 0);
    join_condition_name_n.right = make_uniq<BoundReferenceExpression>("person_id_rowid", LogicalType::BIGINT, 2);
    join_condition_name_n.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_name_n = make_uniq<RAIInfo>();
    rai_info_name_n->rai = table_person_info.GetStorage().info->rais[0].get();
    rai_info_name_n->rai_type = RAIType::TARGET_EDGE;
    rai_info_name_n->forward = true;
    rai_info_name_n->vertex = &table_name;
    rai_info_name_n->vertex_id = table_index_name_n;
    rai_info_name_n->passing_tables[0] = table_index_name_n;
    rai_info_name_n->left_cardinalities[0] = table_name.GetStorage().info->cardinality;
    // rai_info_name_n->compact_list = &rai_info_name_n->rai->alist->compact__list;

    join_condition_name_n.rais.push_back(move(rai_info_name_n));
    cond_name_n.push_back(move(join_condition_name_n));

    LogicalComparisonJoin join_name_n_op(JoinType::INNER);
    vector<LogicalType> output_name_n_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::VARCHAR,
                                            LogicalType::VARCHAR, LogicalType::BIGINT};
    join_name_n_op.types = output_name_n_types;
    vector<idx_t> right_projection_map_name_n{1};
    vector<idx_t> merge_project_map_name_n;
    vector<LogicalType> delim_types_name_n;
    auto join_name_n = make_uniq<PhysicalSIPJoin>(join_name_n_op, move(filter_name), move(join_person_info_), move(cond_name_n), JoinType::INNER,
                                                  left_projection_map, right_projection_map_name_n, delim_types_name_n,
                                                  0);


    vector<idx_t> aka_name_an_ids{8, 2};
    vector<LogicalType> get_aka_name_an_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_aka_name_an = "an";
    vector<LogicalType> table_types_aka_name_an;
    vector<unique_ptr<Expression>> filter_aka_name_an;
    unique_ptr<LogicalGet> get_op_aka_name_an = move(
            getLogicalGet(*this, table_aka_name, alias_aka_name_an, table_index_aka_name_an, table_types_aka_name_an));
    unique_ptr<TableFilterSet> table_filters_aka_name_an = NULL;
    unique_ptr<PhysicalTableScan> scan_aka_name_an = make_uniq<PhysicalTableScan>(get_aka_name_an_types,
                                                                                  get_op_aka_name_an->function,
                                                                                  get_op_aka_name_an->table_index,
                                                                                  move(get_op_aka_name_an->bind_data),
                                                                                  table_types_aka_name_an,
                                                                                  aka_name_an_ids,
                                                                                  move(filter_aka_name_an),
                                                                                  vector<column_t>(),
                                                                                  get_op_aka_name_an->names,
                                                                                  std::move(table_filters_aka_name_an),
                                                                                  get_op_aka_name_an->estimated_cardinality,
                                                                                  get_op_aka_name_an->extra_info);


    vector<LogicalType> filter_aka_name_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    vector<unique_ptr<Expression>> select_aka_name_list;
    auto aka_name_expression_left = make_uniq<BoundReferenceExpression>("name", LogicalType::VARCHAR, 1);
    auto aka_name_expression_value = make_uniq<BoundConstantExpression>(Value("a"));
    vector<unique_ptr<Expression>> aka_name_arguments;
    aka_name_arguments.push_back(move(aka_name_expression_left));
    aka_name_arguments.push_back(move(aka_name_expression_value));

    ScalarFunction bound_function_contains = ContainsFun::GetFunction();
    unique_ptr<FunctionData> bind_data_contains = NULL;

    auto aka_name_bound_function = make_uniq<BoundFunctionExpression>(LogicalType::BOOLEAN,
                                                                    bound_function_contains,
                                                                    move(aka_name_arguments),
                                                                    move(bind_data_contains), false);

    select_aka_name_list.push_back(move(aka_name_bound_function));
    unique_ptr<PhysicalFilter> filter_aka_name = make_uniq<PhysicalFilter>(filter_aka_name_types, move(select_aka_name_list), 0);
    filter_aka_name->children.push_back(move(scan_aka_name_an));

    vector<JoinCondition> cond_aka_name_an;
    JoinCondition join_condition_aka_name_an;
    join_condition_aka_name_an.left = make_uniq<BoundReferenceExpression>("person_id_rowid", LogicalType::BIGINT, 0);
    join_condition_aka_name_an.right = make_uniq<BoundReferenceExpression>("name_rowid", LogicalType::BIGINT, 0);
    join_condition_aka_name_an.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_aka_name_an = make_uniq<RAIInfo>();
    rai_info_aka_name_an->rai = table_aka_name.GetStorage().info->rais[0].get();
    rai_info_aka_name_an->rai_type = RAIType::EDGE_SOURCE;
    rai_info_aka_name_an->forward = true;
    rai_info_aka_name_an->vertex = &table_name;
    rai_info_aka_name_an->vertex_id = table_index_name_n;
    rai_info_aka_name_an->passing_tables[0] = table_index_aka_name_an;
    rai_info_aka_name_an->left_cardinalities[0] = table_aka_name.GetStorage().info->cardinality;
    rai_info_aka_name_an->compact_list = &rai_info_aka_name_an->rai->alist->compact_forward_list;

    join_condition_aka_name_an.rais.push_back(move(rai_info_aka_name_an));
    cond_aka_name_an.push_back(move(join_condition_aka_name_an));

    LogicalComparisonJoin join_aka_name_an_op(JoinType::INNER);
    vector<LogicalType> output_aka_name_an_types{LogicalType::BIGINT, LogicalType::VARCHAR,
                                                 LogicalType::BIGINT, LogicalType::VARCHAR};
    join_aka_name_an_op.types = output_aka_name_an_types;
    vector<idx_t> right_projection_map_aka_name_an{0, 1};
    vector<idx_t> merge_project_map_aka_name_an;
    vector<LogicalType> delim_types_aka_name_an;
    auto join_aka_name_an = make_uniq<PhysicalSIPJoin>(join_aka_name_an_op, move(filter_aka_name), move(join_name_n), move(cond_aka_name_an),
                                                       JoinType::INNER, left_projection_map,
                                                       right_projection_map_aka_name_an, delim_types_aka_name_an, 0);



    idx_t p_production_year1 = 1980;
    idx_t p_production_year2 = 1995;
    Value p_year1 = Value::BIGINT(p_production_year1);
    Value p_year2 = Value::BIGINT(p_production_year2);
    vector<idx_t> title_t_ids{COLUMN_IDENTIFIER_ROW_ID, 4, 1};
    vector<LogicalType> get_title_t_types{LogicalType::BIGINT, LogicalType::BIGINT,
                                          LogicalType::VARCHAR};
    string alias_title_t = "t";
    vector<LogicalType> table_types_title_t;
    vector<unique_ptr<Expression>> filter_title_t;
    unique_ptr<LogicalGet> get_op_title_t = move(
            getLogicalGet(*this, table_title, alias_title_t, table_index_title_t, table_types_title_t));
    unique_ptr<TableFilterSet> table_filters_title_t = make_uniq<TableFilterSet>();
    unique_ptr<ConjunctionAndFilter> and_filter_title = duckdb::make_uniq<ConjunctionAndFilter>();
    unique_ptr<ConstantFilter> constant_filter_title_start = duckdb::make_uniq<ConstantFilter>(
            ExpressionType::COMPARE_GREATERTHANOREQUALTO, p_year1);
    unique_ptr<ConstantFilter> constant_filter_title_end = duckdb::make_uniq<ConstantFilter>(
            ExpressionType::COMPARE_LESSTHANOREQUALTO, p_year2);
    and_filter_title->child_filters.push_back(move(constant_filter_title_start));
    and_filter_title->child_filters.push_back(move(constant_filter_title_end));
    table_filters_title_t->filters[1] = move(and_filter_title);
    unique_ptr<PhysicalTableScan> scan_title_t = make_uniq<PhysicalTableScan>(get_title_t_types,
                                                                              get_op_title_t->function,
                                                                              get_op_title_t->table_index,
                                                                              move(get_op_title_t->bind_data),
                                                                              table_types_title_t, title_t_ids,
                                                                              move(filter_title_t), vector<column_t>(),
                                                                              get_op_title_t->names,
                                                                              std::move(table_filters_title_t),
                                                                              get_op_title_t->estimated_cardinality,
                                                                              get_op_title_t->extra_info);


    vector<JoinCondition> cond_title_t;
    JoinCondition join_condition_title_t;
    join_condition_title_t.left = make_uniq<BoundReferenceExpression>("title_rowid", LogicalType::BIGINT, 0);
    join_condition_title_t.right = make_uniq<BoundReferenceExpression>("name_rowid", LogicalType::BIGINT, 2);
    join_condition_title_t.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_title_t = make_uniq<RAIInfo>();
    rai_info_title_t->rai = table_cast_info.GetStorage().info->rais[0].get();
    rai_info_title_t->rai_type = RAIType::SOURCE_EDGE;
    rai_info_title_t->forward = false;
    rai_info_title_t->vertex = &table_title;
    rai_info_title_t->vertex_id = table_index_title_t;
    rai_info_title_t->passing_tables[0] = table_index_title_t;
    rai_info_title_t->left_cardinalities[0] = table_title.GetStorage().info->cardinality;
    // rai_info_title_t->compact_list = &rai_info_title_t->rai->alist->compact__list;

    join_condition_title_t.rais.push_back(move(rai_info_title_t));
    cond_title_t.push_back(move(join_condition_title_t));

    LogicalComparisonJoin join_title_t_op(JoinType::INNER);
    vector<LogicalType> output_title_t_types{LogicalType::BIGINT, LogicalType::BIGINT,
                                             LogicalType::VARCHAR, LogicalType::VARCHAR};
    join_title_t_op.types = output_title_t_types;
    vector<idx_t> right_projection_map_title_t{3};
    vector<idx_t> merge_project_map_title_t;
    vector<LogicalType> delim_types_title_t;
    auto join_title_t = make_uniq<PhysicalMergeSIPJoin>(join_title_t_op, move(scan_title_t), move(join_aka_name_an), move(cond_title_t), JoinType::INNER,
                                                   left_projection_map, right_projection_map_title_t,
                                                   merge_project_map_title_t, delim_types_title_t, 0);


    string p_link_lt = "features";
    Value p_link = Value(p_link_lt);
    vector<idx_t> link_type_lt_ids{COLUMN_IDENTIFIER_ROW_ID, 1};
    vector<LogicalType> get_link_type_lt_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_link_type_lt = "lt";
    vector<LogicalType> table_types_link_type_lt;
    vector<unique_ptr<Expression>> filter_link_type_lt;
    unique_ptr<LogicalGet> get_op_link_type_lt = move(
            getLogicalGet(*this, table_link_type, alias_link_type_lt, table_index_link_type_lt,
                          table_types_link_type_lt));
    unique_ptr<TableFilterSet> table_filters_link_type_lt = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_lt = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL, p_link);
    table_filters_link_type_lt->filters[1] = move(constant_filter_lt);
    unique_ptr<PhysicalTableScan> scan_link_type_lt = make_uniq<PhysicalTableScan>(get_link_type_lt_types,
                                                                                   get_op_link_type_lt->function,
                                                                                   get_op_link_type_lt->table_index,
                                                                                   move(get_op_link_type_lt->bind_data),
                                                                                   table_types_link_type_lt,
                                                                                   link_type_lt_ids,
                                                                                   move(filter_link_type_lt),
                                                                                   vector<column_t>(),
                                                                                   get_op_link_type_lt->names,
                                                                                   std::move(
                                                                                           table_filters_link_type_lt),
                                                                                   get_op_link_type_lt->estimated_cardinality,
                                                                                   get_op_link_type_lt->extra_info);


    vector<JoinCondition> cond_movie_link_;
    JoinCondition join_condition_movie_link_;
    join_condition_movie_link_.left = make_uniq<BoundReferenceExpression>("link_type_rowid", LogicalType::BIGINT, 0);
    join_condition_movie_link_.right = make_uniq<BoundReferenceExpression>("title_rowid", LogicalType::BIGINT, 0);
    join_condition_movie_link_.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_movie_link_ = make_uniq<RAIInfo>();
    rai_info_movie_link_->rai = table_movie_link.GetStorage().info->rais[1].get();
    rai_info_movie_link_->rai_type = RAIType::SOURCE_EDGE;
    rai_info_movie_link_->forward = false;
    rai_info_movie_link_->vertex = &table_link_type;
    rai_info_movie_link_->vertex_id = table_index_link_type_lt;
    rai_info_movie_link_->passing_tables[0] = table_index_link_type_lt;
    rai_info_movie_link_->left_cardinalities[0] = table_link_type.GetStorage().info->cardinality;
    // rai_info_movie_link_->compact_list = &rai_info_movie_link_->rai->alist->compact__list;

    join_condition_movie_link_.rais.push_back(move(rai_info_movie_link_));
    cond_movie_link_.push_back(move(join_condition_movie_link_));

    LogicalComparisonJoin join_movie_link__op(JoinType::INNER);
    vector<LogicalType> output_movie_link__types{LogicalType::BIGINT, LogicalType::VARCHAR,
                                                 LogicalType::VARCHAR, LogicalType::VARCHAR};
    join_movie_link__op.types = output_movie_link__types;
    vector<idx_t> right_projection_map_movie_link_{3, 2};
    vector<idx_t> merge_project_map_movie_link_;
    vector<LogicalType> delim_types_movie_link_;
    auto join_movie_link_ = make_uniq<PhysicalMergeSIPJoin>(join_movie_link__op, move(scan_link_type_lt), move(join_title_t), move(cond_movie_link_),
                                                            JoinType::INNER, left_projection_map,
                                                            right_projection_map_movie_link_,
                                                            merge_project_map_movie_link_, delim_types_movie_link_, 0);


    vector<LogicalType> result_types{LogicalType::VARCHAR, LogicalType::VARCHAR};
    vector<unique_ptr<Expression>> select_list;
    auto result_col0 = make_uniq<BoundReferenceExpression>("name", LogicalType::VARCHAR, 2);
    auto result_col1 = make_uniq<BoundReferenceExpression>("title", LogicalType::VARCHAR, 3);
    select_list.push_back(move(result_col0));
    select_list.push_back(move(result_col1));
    auto projection = make_uniq<PhysicalProjection>(result_types, move(select_list), 0);
    projection->children.push_back(move(join_movie_link_));

    // aggregate
    string agg_name = "min";
    string agg_error = "";
    QueryErrorContext error_context(NULL, NULL);
    auto min_func = Catalog::GetEntry(context, CatalogType::SCALAR_FUNCTION_ENTRY, "", "",
                                      "min", OnEntryNotFound::RETURN_NULL, error_context);
    auto &min_func_set = min_func->Cast<AggregateFunctionCatalogEntry>();
    // bind the aggregate
    FunctionBinder function_binder(context);
    vector<LogicalType> types;
    types.push_back(LogicalType::VARCHAR);
    idx_t best_function_varchar = function_binder.BindFunction(agg_name, min_func_set.functions, types, agg_error);
    auto bound_function_min_varchar = min_func_set.functions.GetFunctionByOffset(best_function_varchar);

    auto first_children = make_uniq<BoundReferenceExpression>("name", LogicalType::VARCHAR, 0);
    vector<unique_ptr<Expression>> childrenlist1;
    childrenlist1.push_back(move(first_children));
    auto aggregate1 =
            function_binder.BindAggregateFunction(bound_function_min_varchar, std::move(childrenlist1), nullptr,
                                                  AggregateType::NON_DISTINCT);

    auto second_children = make_uniq<BoundReferenceExpression>("title", LogicalType::VARCHAR, 1);
    vector<unique_ptr<Expression>> childrenlist2;
    childrenlist2.push_back(move(second_children));
    auto aggregate2 =
            function_binder.BindAggregateFunction(bound_function_min_varchar, std::move(childrenlist2), nullptr,
                                                  AggregateType::NON_DISTINCT);

    vector<unique_ptr<Expression>> aggregates;
    aggregates.push_back(move(aggregate1));
    aggregates.push_back(move(aggregate2));

    vector<LogicalType> aggregate_types{LogicalType::VARCHAR, LogicalType::VARCHAR};
    auto ungrouped_aggregate = make_uniq<PhysicalUngroupedAggregate>(aggregate_types, move(aggregates), 0);
    ungrouped_aggregate->children.push_back(move(projection));

    return ungrouped_aggregate;
}

unique_ptr<PhysicalOperator> ClientContext::GenerateJOB8aPlan(duckdb::ClientContext &context) {
    vector<idx_t> left_projection_map, right_projection_map;

    string table_vertex_aka_name_an1 = "aka_name";
    string table_vertex_name_n1 = "name";
    string table_vertex_title_t = "title";
    string table_vertex_company_name_cn = "company_name";
    string table_vertex_role_type_rt = "role_type";
    string table_vertex_cast_info_ = "cast_info";
    string table_vertex_movie_companies_ = "movie_companies";

    idx_t table_index_aka_name_an1 = 1;
    idx_t table_index_name_n1 = 2;
    idx_t table_index_title_t = 3;
    idx_t table_index_company_name_cn = 4;
    idx_t table_index_role_type_rt = 5;
    idx_t table_index_cast_info_ = 9;
    idx_t table_index_movie_companies_ = 8;
    auto table_or_view_aka_name = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_aka_name_an1,
                                                    OnEntryNotFound::RETURN_NULL);
    auto &table_aka_name = table_or_view_aka_name->Cast<TableCatalogEntry>();
    auto table_or_view_name = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_name_n1,
                                                OnEntryNotFound::RETURN_NULL);
    auto &table_name = table_or_view_name->Cast<TableCatalogEntry>();
    auto table_or_view_title = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_title_t,
                                                 OnEntryNotFound::RETURN_NULL);
    auto &table_title = table_or_view_title->Cast<TableCatalogEntry>();
    auto table_or_view_company_name = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                        table_vertex_company_name_cn, OnEntryNotFound::RETURN_NULL);
    auto &table_company_name = table_or_view_company_name->Cast<TableCatalogEntry>();
    auto table_or_view_role_type = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_role_type_rt,
                                                     OnEntryNotFound::RETURN_NULL);
    auto &table_role_type = table_or_view_role_type->Cast<TableCatalogEntry>();
    auto table_or_view_cast_info = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_cast_info_,
                                                     OnEntryNotFound::RETURN_NULL);
    auto &table_cast_info = table_or_view_cast_info->Cast<TableCatalogEntry>();
    auto table_or_view_movie_companies = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                           table_vertex_movie_companies_, OnEntryNotFound::RETURN_NULL);
    auto &table_movie_companies = table_or_view_movie_companies->Cast<TableCatalogEntry>();

    string p_country_code_n = "[jp]";
    Value p_country_code = Value(p_country_code_n);
    vector<idx_t> company_name_cn_ids{COLUMN_IDENTIFIER_ROW_ID, 2};
    vector<LogicalType> get_company_name_cn_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_company_name_cn = "cn";
    vector<LogicalType> table_types_company_name_cn;
    vector<unique_ptr<Expression>> filter_company_name_cn;
    unique_ptr<LogicalGet> get_op_company_name_cn = move(
            getLogicalGet(*this, table_company_name, alias_company_name_cn, table_index_company_name_cn,
                          table_types_company_name_cn));
    unique_ptr<TableFilterSet> table_filters_company_name_cn = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_cn = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL,
                                                                                      p_country_code);
    table_filters_company_name_cn->filters[1] = move(constant_filter_cn);
    unique_ptr<PhysicalTableScan> scan_company_name_cn = make_uniq<PhysicalTableScan>(get_company_name_cn_types,
                                                                                      get_op_company_name_cn->function,
                                                                                      get_op_company_name_cn->table_index,
                                                                                      move(get_op_company_name_cn->bind_data),
                                                                                      table_types_company_name_cn,
                                                                                      company_name_cn_ids,
                                                                                      move(filter_company_name_cn),
                                                                                      vector<column_t>(),
                                                                                      get_op_company_name_cn->names,
                                                                                      std::move(
                                                                                              table_filters_company_name_cn),
                                                                                      get_op_company_name_cn->estimated_cardinality,
                                                                                      get_op_company_name_cn->extra_info);


    vector<idx_t> movie_companies_ids{4, 5, 6};
    vector<LogicalType> get_movie_companies_types{LogicalType::VARCHAR, LogicalType::BIGINT,
                                                  LogicalType::BIGINT};
    string alias_movie_companies = "mc";
    vector<LogicalType> table_types_movie_companies;
    vector<unique_ptr<Expression>> filter_movie_companies;
    unique_ptr<LogicalGet> get_op_movie_companies = move(
            getLogicalGet(*this, table_movie_companies, alias_movie_companies, table_index_movie_companies_,
                          table_types_movie_companies));
    unique_ptr<TableFilterSet> table_filters_movie_companies = NULL;
    unique_ptr<PhysicalTableScan> scan_movie_companies = make_uniq<PhysicalTableScan>(get_movie_companies_types,
                                                                                      get_op_movie_companies->function,
                                                                                      get_op_movie_companies->table_index,
                                                                                      move(get_op_movie_companies->bind_data),
                                                                                      table_types_movie_companies,
                                                                                      movie_companies_ids,
                                                                                      move(filter_movie_companies),
                                                                                      vector<column_t>(),
                                                                                      get_op_movie_companies->names,
                                                                                      std::move(
                                                                                              table_filters_movie_companies),
                                                                                      get_op_movie_companies->estimated_cardinality,
                                                                                      get_op_movie_companies->extra_info);


    vector<LogicalType> filter_mc_types{LogicalType::VARCHAR, LogicalType::BIGINT, LogicalType::BIGINT};
    vector<unique_ptr<Expression>> select_list_mc;
    auto mc_unlike_expression_left = make_uniq<BoundReferenceExpression>("note", LogicalType::VARCHAR, 0);
    auto mc_unlike_expression_value = make_uniq<BoundConstantExpression>(Value("(USA)"));
    vector<unique_ptr<Expression>> mc_unlike_arguments;
    mc_unlike_arguments.push_back(move(mc_unlike_expression_left));
    mc_unlike_arguments.push_back(move(mc_unlike_expression_value));

    QueryErrorContext error_context_unlike(NULL, NULL);
    ScalarFunction mc_bound_function_contains = ContainsFun::GetFunction();
    unique_ptr<FunctionData> mc_bind_data_contains = NULL;
    /*auto contains_func = Catalog::GetEntry(context, CatalogType::SCALAR_FUNCTION_ENTRY, "", "",
                                      "contains", OnEntryNotFound::RETURN_NULL, error_context_unlike);
    ScalarFunctionCatalogEntry& contains_func_set = contains_func->Cast<ScalarFunctionCatalogEntry>();
    // bind the aggregate
    string contain_name = "contains";
    string contain_error = "";
    FunctionBinder function_binder_contains(context);
    vector<LogicalType> types_contains;

    types_contains.push_back(LogicalType::BOOLEAN);
    idx_t best_function_contains_idx = function_binder_contains.BindFunction(contain_name, contains_func_set.functions, types_contains, contain_error);
    std::cout << best_function_contains_idx << " " << contains_func_set.functions.functions.size() << std::endl;
    ScalarFunction bound_function_contains = contains_func_set.functions.GetFunctionByOffset(best_function_contains_idx);*/

    auto mc_unlike_bound_function = make_uniq<BoundFunctionExpression>(LogicalType::BOOLEAN,
                                                                       mc_bound_function_contains,
                                                                       move(mc_unlike_arguments),
                                                                       move(mc_bind_data_contains), false);

    auto mc_not_unlike_bound_function = make_uniq<BoundOperatorExpression>(ExpressionType::OPERATOR_NOT,
                                                                           LogicalType::BOOLEAN);
    mc_not_unlike_bound_function->children.push_back(move(mc_unlike_bound_function));

    auto mc_like_expression_left_exp = make_uniq<BoundReferenceExpression>("note", LogicalType::VARCHAR, 0);
    auto mc_like_expression_left_value = make_uniq<BoundConstantExpression>(Value("(Japan)"));
    vector<unique_ptr<Expression>> mc_like_arguments_left;
    mc_like_arguments_left.push_back(move(mc_like_expression_left_exp));
    mc_like_arguments_left.push_back(move(mc_like_expression_left_value));
    auto mc_like_bound_function_left = make_uniq<BoundFunctionExpression>(LogicalType::BOOLEAN,
                                                                          mc_bound_function_contains,
                                                                          move(mc_like_arguments_left),
                                                                          move(mc_bind_data_contains), false);

    auto mc_and_conjunction = make_uniq<BoundConjunctionExpression>(ExpressionType::CONJUNCTION_AND);
    mc_and_conjunction->children.push_back(move(mc_not_unlike_bound_function));
    mc_and_conjunction->children.push_back(move(mc_like_bound_function_left));

    select_list_mc.push_back(move(mc_and_conjunction));
    unique_ptr<PhysicalFilter> filter_mc_contains = make_uniq<PhysicalFilter>(filter_mc_types, move(select_list_mc), 0);
    filter_mc_contains->children.push_back(move(scan_movie_companies));


    vector<JoinCondition> cond_movie_companies_;
    JoinCondition join_condition_movie_companies_;
    join_condition_movie_companies_.left = make_uniq<BoundReferenceExpression>("company_id_rowid", LogicalType::BIGINT,
                                                                               1);
    join_condition_movie_companies_.right = make_uniq<BoundReferenceExpression>("company_name_rowid",
                                                                                LogicalType::BIGINT, 0);
    join_condition_movie_companies_.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_movie_companies_ = make_uniq<RAIInfo>();
    rai_info_movie_companies_->rai = table_movie_companies.GetStorage().info->rais[0].get();
    rai_info_movie_companies_->rai_type = RAIType::EDGE_SOURCE;
    rai_info_movie_companies_->forward = true;
    rai_info_movie_companies_->vertex = &table_company_name;
    rai_info_movie_companies_->vertex_id = table_index_company_name_cn;
    rai_info_movie_companies_->passing_tables[0] = table_index_movie_companies_;
    rai_info_movie_companies_->left_cardinalities[0] = table_movie_companies.GetStorage().info->cardinality;
    rai_info_movie_companies_->compact_list = &rai_info_movie_companies_->rai->alist->compact_forward_list;

    join_condition_movie_companies_.rais.push_back(move(rai_info_movie_companies_));
    cond_movie_companies_.push_back(move(join_condition_movie_companies_));

    LogicalComparisonJoin join_movie_companies__op(JoinType::INNER);
    vector<LogicalType> output_movie_companies__types{LogicalType::VARCHAR, LogicalType::BIGINT, LogicalType::BIGINT,
                                                      LogicalType::BIGINT};
    join_movie_companies__op.types = output_movie_companies__types;
    vector<idx_t> right_projection_map_movie_companies_{0};
    vector<idx_t> merge_project_map_movie_companies_;
    vector<LogicalType> delim_types_movie_companies_;
    auto join_movie_companies_ = make_uniq<PhysicalSIPJoin>(join_movie_companies__op, move(filter_mc_contains),
                                                            move(scan_company_name_cn),
                                                            move(cond_movie_companies_), JoinType::INNER,
                                                            left_projection_map,
                                                            right_projection_map_movie_companies_,
                                                            delim_types_movie_companies_, 0);


    vector<idx_t> title_t_ids{COLUMN_IDENTIFIER_ROW_ID, 1};
    vector<LogicalType> get_title_t_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_title_t = "t";
    vector<LogicalType> table_types_title_t;
    vector<unique_ptr<Expression>> filter_title_t;
    unique_ptr<LogicalGet> get_op_title_t = move(
            getLogicalGet(*this, table_title, alias_title_t, table_index_title_t, table_types_title_t));
    unique_ptr<TableFilterSet> table_filters_title_t = NULL;
    unique_ptr<PhysicalTableScan> scan_title_t = make_uniq<PhysicalTableScan>(get_title_t_types,
                                                                              get_op_title_t->function,
                                                                              get_op_title_t->table_index,
                                                                              move(get_op_title_t->bind_data),
                                                                              table_types_title_t, title_t_ids,
                                                                              move(filter_title_t), vector<column_t>(),
                                                                              get_op_title_t->names,
                                                                              std::move(table_filters_title_t),
                                                                              get_op_title_t->estimated_cardinality,
                                                                              get_op_title_t->extra_info);

    vector<JoinCondition> cond_title_t;
    JoinCondition join_condition_title_t;
    join_condition_title_t.left = make_uniq<BoundReferenceExpression>("title_rowid", LogicalType::BIGINT, 0);
    join_condition_title_t.right = make_uniq<BoundReferenceExpression>("movie_id_rowid", LogicalType::BIGINT, 2);
    join_condition_title_t.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_title_t = make_uniq<RAIInfo>();
    rai_info_title_t->rai = table_movie_companies.GetStorage().info->rais[0].get();
    rai_info_title_t->rai_type = RAIType::TARGET_EDGE;
    rai_info_title_t->forward = true;
    rai_info_title_t->vertex = &table_title;
    rai_info_title_t->vertex_id = table_index_title_t;
    rai_info_title_t->passing_tables[0] = table_index_title_t;
    rai_info_title_t->left_cardinalities[0] = table_title.GetStorage().info->cardinality;
    // rai_info_title_t->compact_list = &rai_info_title_t->rai->alist->compact__list;

    join_condition_title_t.rais.push_back(move(rai_info_title_t));
    cond_title_t.push_back(move(join_condition_title_t));

    LogicalComparisonJoin join_title_t_op(JoinType::INNER);
    vector<LogicalType> output_title_t_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::BIGINT};
    join_title_t_op.types = output_title_t_types;
    vector<idx_t> right_projection_map_title_t{1};
    vector<idx_t> merge_project_map_title_t;
    vector<LogicalType> delim_types_title_t;
    auto join_title_t = make_uniq<PhysicalSIPJoin>(join_title_t_op, move(scan_title_t), move(join_movie_companies_), move(cond_title_t),
                                                   JoinType::INNER, left_projection_map,
                                                   right_projection_map_title_t,
                                                   delim_types_title_t, 0);


    string p_cast_note = "(voice: English version)";
    Value p_note = Value(p_cast_note);
    vector<idx_t> cast_info_ids{4, 7, 8, 9};
    vector<LogicalType> get_cast_info_types{LogicalType::VARCHAR, LogicalType::BIGINT,
                                            LogicalType::BIGINT, LogicalType::BIGINT};
    string alias_cast_info = "ci";
    vector<LogicalType> table_types_cast_info;
    vector<unique_ptr<Expression>> filter_cast_info;
    unique_ptr<LogicalGet> get_op_cast_info = move(
            getLogicalGet(*this, table_cast_info, alias_cast_info, table_index_cast_info_, table_types_cast_info));
    unique_ptr<TableFilterSet> table_filters_cast_info = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_ci = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL, p_note);
    table_filters_cast_info->filters[0] = move(constant_filter_ci);
    unique_ptr<PhysicalTableScan> scan_cast_info = make_uniq<PhysicalTableScan>(get_cast_info_types,
                                                                                get_op_cast_info->function,
                                                                                get_op_cast_info->table_index,
                                                                                move(get_op_cast_info->bind_data),
                                                                                table_types_cast_info, cast_info_ids,
                                                                                move(filter_cast_info),
                                                                                vector<column_t>(),
                                                                                get_op_cast_info->names,
                                                                                std::move(table_filters_cast_info),
                                                                                get_op_cast_info->estimated_cardinality,
                                                                                get_op_cast_info->extra_info);


    vector<JoinCondition> cond_cast_info_;
    JoinCondition join_condition_cast_info_;
    join_condition_cast_info_.left = make_uniq<BoundReferenceExpression>("movie_id_rowid", LogicalType::BIGINT, 1);
    join_condition_cast_info_.right = make_uniq<BoundReferenceExpression>("title_rowid", LogicalType::BIGINT, 0);
    join_condition_cast_info_.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_cast_info_ = make_uniq<RAIInfo>();
    rai_info_cast_info_->rai = table_cast_info.GetStorage().info->rais[0].get();
    rai_info_cast_info_->rai_type = RAIType::EDGE_SOURCE;
    rai_info_cast_info_->forward = true;
    rai_info_cast_info_->vertex = &table_title;
    rai_info_cast_info_->vertex_id = table_index_title_t;
    rai_info_cast_info_->passing_tables[0] = table_index_cast_info_;
    rai_info_cast_info_->left_cardinalities[0] = table_cast_info.GetStorage().info->cardinality;
    rai_info_cast_info_->compact_list = &rai_info_cast_info_->rai->alist->compact_forward_list;

    join_condition_cast_info_.rais.push_back(move(rai_info_cast_info_));
    cond_cast_info_.push_back(move(join_condition_cast_info_));

    LogicalComparisonJoin join_cast_info__op(JoinType::INNER);
    vector<LogicalType> output_cast_info__types{LogicalType::VARCHAR, LogicalType::BIGINT,
                                                LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::VARCHAR};
    join_cast_info__op.types = output_cast_info__types;
    vector<idx_t> right_projection_map_cast_info_{1};
    vector<idx_t> merge_project_map_cast_info_;
    vector<LogicalType> delim_types_cast_info_;
    auto join_cast_info_ = make_uniq<PhysicalSIPJoin>(join_cast_info__op, move(scan_cast_info), move(join_title_t), move(cond_cast_info_),
                                                           JoinType::INNER, left_projection_map,
                                                           right_projection_map_cast_info_,
                                                           delim_types_cast_info_, 0);

    string p_role_p = "actress";
    Value p_role = Value(p_role_p);
    vector<idx_t> role_type_rt_ids{COLUMN_IDENTIFIER_ROW_ID, 1};
    vector<LogicalType> get_role_type_rt_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_role_type_rt = "rt";
    vector<LogicalType> table_types_role_type_rt;
    vector<unique_ptr<Expression>> filter_role_type_rt;
    unique_ptr<LogicalGet> get_op_role_type_rt = move(
            getLogicalGet(*this, table_role_type, alias_role_type_rt, table_index_role_type_rt,
                          table_types_role_type_rt));
    unique_ptr<TableFilterSet> table_filters_role_type_rt = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_rt = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL, p_role);
    table_filters_role_type_rt->filters[1] = move(constant_filter_rt);
    unique_ptr<PhysicalTableScan> scan_role_type_rt = make_uniq<PhysicalTableScan>(get_role_type_rt_types,
                                                                                   get_op_role_type_rt->function,
                                                                                   get_op_role_type_rt->table_index,
                                                                                   move(get_op_role_type_rt->bind_data),
                                                                                   table_types_role_type_rt,
                                                                                   role_type_rt_ids,
                                                                                   move(filter_role_type_rt),
                                                                                   vector<column_t>(),
                                                                                   get_op_role_type_rt->names,
                                                                                   std::move(
                                                                                           table_filters_role_type_rt),
                                                                                   get_op_role_type_rt->estimated_cardinality,
                                                                                   get_op_role_type_rt->extra_info);


    vector<JoinCondition> cond_role_type_rt;
    JoinCondition join_condition_role_type_rt;
    join_condition_role_type_rt.left = make_uniq<BoundReferenceExpression>("role_type_rowid", LogicalType::BIGINT, 0);
    join_condition_role_type_rt.right = make_uniq<BoundReferenceExpression>("role_id_rowid", LogicalType::BIGINT, 3);
    join_condition_role_type_rt.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_role_type_rt = make_uniq<RAIInfo>();
    rai_info_role_type_rt->rai = table_cast_info.GetStorage().info->rais[1].get();
    rai_info_role_type_rt->rai_type = RAIType::SOURCE_EDGE;
    rai_info_role_type_rt->forward = false;
    rai_info_role_type_rt->vertex = &table_role_type;
    rai_info_role_type_rt->vertex_id = table_index_role_type_rt;
    rai_info_role_type_rt->passing_tables[0] = table_index_role_type_rt;
    rai_info_role_type_rt->left_cardinalities[0] = table_role_type.GetStorage().info->cardinality;
    // rai_info_role_type_rt->compact_list = &rai_info_role_type_rt->rai->alist->compact__list;

    join_condition_role_type_rt.rais.push_back(move(rai_info_role_type_rt));
    cond_role_type_rt.push_back(move(join_condition_role_type_rt));

    LogicalComparisonJoin join_role_type_rt_op(JoinType::INNER);
    vector<LogicalType> output_role_type_rt_types{LogicalType::BIGINT, LogicalType::VARCHAR,
                                                  LogicalType::BIGINT, LogicalType::VARCHAR};
    join_role_type_rt_op.types = output_role_type_rt_types;
    vector<idx_t> right_projection_map_role_type_rt{2, 4};
    vector<idx_t> merge_project_map_role_type_rt;
    vector<LogicalType> delim_types_role_type_rt;
    auto join_role_type_rt = make_uniq<PhysicalSIPJoin>(join_role_type_rt_op, move(scan_role_type_rt), move(join_cast_info_), move(cond_role_type_rt),
                                                        JoinType::INNER, left_projection_map,
                                                        right_projection_map_role_type_rt, delim_types_role_type_rt, 0);



    vector<idx_t> name_n1_ids{COLUMN_IDENTIFIER_ROW_ID, 1};
    vector<LogicalType> get_name_n1_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_name_n1 = "n1";
    vector<LogicalType> table_types_name_n1;
    vector<unique_ptr<Expression>> filter_name_n1;
    unique_ptr<LogicalGet> get_op_name_n1 = move(
            getLogicalGet(*this, table_name, alias_name_n1, table_index_name_n1, table_types_name_n1));
    unique_ptr<TableFilterSet> table_filters_name_n1 = NULL;
    unique_ptr<PhysicalTableScan> scan_name_n1 = make_uniq<PhysicalTableScan>(get_name_n1_types,
                                                                              get_op_name_n1->function,
                                                                              get_op_name_n1->table_index,
                                                                              move(get_op_name_n1->bind_data),
                                                                              table_types_name_n1, name_n1_ids,
                                                                              move(filter_name_n1), vector<column_t>(),
                                                                              get_op_name_n1->names,
                                                                              std::move(table_filters_name_n1),
                                                                              get_op_name_n1->estimated_cardinality,
                                                                              get_op_name_n1->extra_info);

    vector<LogicalType> filter_name_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    vector<unique_ptr<Expression>> select_list_name;
    auto name_unlike_expression_left = make_uniq<BoundReferenceExpression>("name", LogicalType::VARCHAR, 1);
    auto name_unlike_expression_value = make_uniq<BoundConstantExpression>(Value("Yu"));
    vector<unique_ptr<Expression>> name_unlike_arguments;
    name_unlike_arguments.push_back(move(name_unlike_expression_left));
    name_unlike_arguments.push_back(move(name_unlike_expression_value));

    ScalarFunction name_bound_function_contains = ContainsFun::GetFunction();
    unique_ptr<FunctionData> name_bind_data_contains = NULL;
    /*auto contains_func = Catalog::GetEntry(context, CatalogType::SCALAR_FUNCTION_ENTRY, "", "",
                                      "contains", OnEntryNotFound::RETURN_NULL, error_context_unlike);
    ScalarFunctionCatalogEntry& contains_func_set = contains_func->Cast<ScalarFunctionCatalogEntry>();
    // bind the aggregate
    string contain_name = "contains";
    string contain_error = "";
    FunctionBinder function_binder_contains(context);
    vector<LogicalType> types_contains;

    types_contains.push_back(LogicalType::BOOLEAN);
    idx_t best_function_contains_idx = function_binder_contains.BindFunction(contain_name, contains_func_set.functions, types_contains, contain_error);
    std::cout << best_function_contains_idx << " " << contains_func_set.functions.functions.size() << std::endl;
    ScalarFunction bound_function_contains = contains_func_set.functions.GetFunctionByOffset(best_function_contains_idx);*/

    auto name_unlike_bound_function = make_uniq<BoundFunctionExpression>(LogicalType::BOOLEAN,
                                                                       name_bound_function_contains,
                                                                       move(name_unlike_arguments),
                                                                       move(name_bind_data_contains), false);

    auto name_not_unlike_bound_function = make_uniq<BoundOperatorExpression>(ExpressionType::OPERATOR_NOT,
                                                                           LogicalType::BOOLEAN);
    name_not_unlike_bound_function->children.push_back(move(name_unlike_bound_function));

    auto name_like_expression_left_exp = make_uniq<BoundReferenceExpression>("name", LogicalType::VARCHAR, 1);
    auto name_like_expression_left_value = make_uniq<BoundConstantExpression>(Value("Yo"));
    vector<unique_ptr<Expression>> name_like_arguments_left;
    name_like_arguments_left.push_back(move(name_like_expression_left_exp));
    name_like_arguments_left.push_back(move(name_like_expression_left_value));
    auto name_like_bound_function_left = make_uniq<BoundFunctionExpression>(LogicalType::BOOLEAN,
                                                                          name_bound_function_contains,
                                                                          move(name_like_arguments_left),
                                                                          move(name_bind_data_contains), false);

    auto name_and_conjunction = make_uniq<BoundConjunctionExpression>(ExpressionType::CONJUNCTION_AND);
    name_and_conjunction->children.push_back(move(name_not_unlike_bound_function));
    name_and_conjunction->children.push_back(move(name_like_bound_function_left));

    select_list_name.push_back(move(name_and_conjunction));
    unique_ptr<PhysicalFilter> filter_name_contains = make_uniq<PhysicalFilter>(filter_name_types, move(select_list_name), 0);
    filter_name_contains->children.push_back(move(scan_name_n1));


    vector<JoinCondition> cond_name_n1;
    JoinCondition join_condition_name_n1;
    join_condition_name_n1.left = make_uniq<BoundReferenceExpression>("name_rowid", LogicalType::BIGINT, 0);
    join_condition_name_n1.right = make_uniq<BoundReferenceExpression>("person_id_rowid", LogicalType::BIGINT, 2);
    join_condition_name_n1.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_name_n1 = make_uniq<RAIInfo>();
    rai_info_name_n1->rai = table_cast_info.GetStorage().info->rais[0].get();
    rai_info_name_n1->rai_type = RAIType::TARGET_EDGE;
    rai_info_name_n1->forward = true;
    rai_info_name_n1->vertex = &table_name;
    rai_info_name_n1->vertex_id = table_index_name_n1;
    rai_info_name_n1->passing_tables[0] = table_index_name_n1;
    rai_info_name_n1->left_cardinalities[0] = table_name.GetStorage().info->cardinality;
    // rai_info_name_n1->compact_list = &rai_info_name_n1->rai->alist->compact__list;

    join_condition_name_n1.rais.push_back(move(rai_info_name_n1));
    cond_name_n1.push_back(move(join_condition_name_n1));

    LogicalComparisonJoin join_name_n1_op(JoinType::INNER);
    vector<LogicalType> output_name_n1_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::VARCHAR};
    join_name_n1_op.types = output_name_n1_types;
    vector<idx_t> right_projection_map_name_n1{3};
    vector<idx_t> merge_project_map_name_n1;
    vector<LogicalType> delim_types_name_n1;
    auto join_name_n1 = make_uniq<PhysicalSIPJoin>(join_name_n1_op, move(filter_name_contains), move(join_role_type_rt), move(cond_name_n1), JoinType::INNER,
                                                   left_projection_map, right_projection_map_name_n1,
                                                   delim_types_name_n1, 0);


    vector<idx_t> aka_name_an1_ids{8, 2};
    vector<LogicalType> get_aka_name_an1_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_aka_name_an1 = "an1";
    vector<LogicalType> table_types_aka_name_an1;
    vector<unique_ptr<Expression>> filter_aka_name_an1;
    unique_ptr<LogicalGet> get_op_aka_name_an1 = move(
            getLogicalGet(*this, table_aka_name, alias_aka_name_an1, table_index_aka_name_an1,
                          table_types_aka_name_an1));
    unique_ptr<TableFilterSet> table_filters_aka_name_an1 = NULL;
    unique_ptr<PhysicalTableScan> scan_aka_name_an1 = make_uniq<PhysicalTableScan>(get_aka_name_an1_types,
                                                                                   get_op_aka_name_an1->function,
                                                                                   get_op_aka_name_an1->table_index,
                                                                                   move(get_op_aka_name_an1->bind_data),
                                                                                   table_types_aka_name_an1,
                                                                                   aka_name_an1_ids,
                                                                                   move(filter_aka_name_an1),
                                                                                   vector<column_t>(),
                                                                                   get_op_aka_name_an1->names,
                                                                                   std::move(
                                                                                           table_filters_aka_name_an1),
                                                                                   get_op_aka_name_an1->estimated_cardinality,
                                                                                   get_op_aka_name_an1->extra_info);


    vector<JoinCondition> cond_aka_name_to_name_;
    JoinCondition join_condition_aka_name_to_name_;
    join_condition_aka_name_to_name_.left = make_uniq<BoundReferenceExpression>("person_id_rowid", LogicalType::BIGINT, 0);
    join_condition_aka_name_to_name_.right = make_uniq<BoundReferenceExpression>("name_rowid", LogicalType::BIGINT, 0);
    join_condition_aka_name_to_name_.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_aka_name_to_name_ = make_uniq<RAIInfo>();
    rai_info_aka_name_to_name_->rai = table_aka_name.GetStorage().info->rais[0].get();
    rai_info_aka_name_to_name_->rai_type = RAIType::EDGE_SOURCE;
    rai_info_aka_name_to_name_->forward = true;
    rai_info_aka_name_to_name_->vertex = &table_name;
    rai_info_aka_name_to_name_->vertex_id = table_index_name_n1;
    rai_info_aka_name_to_name_->passing_tables[0] = table_index_aka_name_an1;
    rai_info_aka_name_to_name_->left_cardinalities[0] = table_aka_name.GetStorage().info->cardinality;
    rai_info_aka_name_to_name_->compact_list = &rai_info_aka_name_to_name_->rai->alist->compact_forward_list;

    join_condition_aka_name_to_name_.rais.push_back(move(rai_info_aka_name_to_name_));
    cond_aka_name_to_name_.push_back(move(join_condition_aka_name_to_name_));

    LogicalComparisonJoin join_aka_name_to_name__op(JoinType::INNER);
    vector<LogicalType> output_aka_name_to_name__types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::VARCHAR};
    join_aka_name_to_name__op.types = output_aka_name_to_name__types;
    vector<idx_t> right_projection_map_aka_name_to_name_{2};
    vector<idx_t> merge_project_map_aka_name_to_name_;
    vector<LogicalType> delim_types_aka_name_to_name_;
    auto join_aka_name_to_name_ = make_uniq<PhysicalSIPJoin>(join_aka_name_to_name__op, move(scan_aka_name_an1), move(join_name_n1),
                                                                  move(cond_aka_name_to_name_), JoinType::INNER,
                                                                  left_projection_map,
                                                                  right_projection_map_aka_name_to_name_,
                                                                  delim_types_aka_name_to_name_, 0);


    vector<LogicalType> result_types{LogicalType::VARCHAR, LogicalType::VARCHAR};
    vector<unique_ptr<Expression>> select_list;
    auto result_col0 = make_uniq<BoundReferenceExpression>("name", LogicalType::VARCHAR, 1);
    auto result_col1 = make_uniq<BoundReferenceExpression>("title", LogicalType::VARCHAR, 2);
    select_list.push_back(move(result_col0));
    select_list.push_back(move(result_col1));
    auto projection = make_uniq<PhysicalProjection>(result_types, move(select_list), 0);
    projection->children.push_back(move(join_aka_name_to_name_));

    // aggregate
    string agg_name = "min";
    string agg_error = "";
    QueryErrorContext error_context(NULL, NULL);
    auto min_func = Catalog::GetEntry(context, CatalogType::SCALAR_FUNCTION_ENTRY, "", "",
                                      "min", OnEntryNotFound::RETURN_NULL, error_context);
    auto &min_func_set = min_func->Cast<AggregateFunctionCatalogEntry>();
    // bind the aggregate
    FunctionBinder function_binder(context);
    vector<LogicalType> types;
    types.push_back(LogicalType::VARCHAR);
    idx_t best_function_varchar = function_binder.BindFunction(agg_name, min_func_set.functions, types, agg_error);
    auto bound_function_min_varchar = min_func_set.functions.GetFunctionByOffset(best_function_varchar);

    auto first_children = make_uniq<BoundReferenceExpression>("name", LogicalType::VARCHAR, 0);
    vector<unique_ptr<Expression>> childrenlist1;
    childrenlist1.push_back(move(first_children));
    auto aggregate1 =
            function_binder.BindAggregateFunction(bound_function_min_varchar, std::move(childrenlist1), nullptr,
                                                  AggregateType::NON_DISTINCT);

    auto second_children = make_uniq<BoundReferenceExpression>("title", LogicalType::VARCHAR, 1);
    vector<unique_ptr<Expression>> childrenlist2;
    childrenlist2.push_back(move(second_children));
    auto aggregate2 =
            function_binder.BindAggregateFunction(bound_function_min_varchar, std::move(childrenlist2), nullptr,
                                                  AggregateType::NON_DISTINCT);

    vector<unique_ptr<Expression>> aggregates;
    aggregates.push_back(move(aggregate1));
    aggregates.push_back(move(aggregate2));

    vector<LogicalType> aggregate_types{LogicalType::VARCHAR, LogicalType::VARCHAR};
    auto ungrouped_aggregate = make_uniq<PhysicalUngroupedAggregate>(aggregate_types, move(aggregates), 0);
    ungrouped_aggregate->children.push_back(move(projection));

    return ungrouped_aggregate;
}

unique_ptr<PhysicalOperator> ClientContext::GenerateJOB9aPlan(duckdb::ClientContext &context) {
    vector<idx_t> left_projection_map, right_projection_map;

    string table_vertex_aka_name_an = "aka_name";
    string table_vertex_name_n = "name";
    string table_vertex_title_t = "title";
    string table_vertex_company_name_cn = "company_name";
    string table_vertex_char_name_chn = "char_name";
    string table_vertex_role_type_rt1 = "role_type";
    string table_vertex_aka_name_to_name_ = "aka_name_to_name";
    string table_vertex_cast_info_ = "cast_info";
    string table_vertex_movie_companies_ = "movie_companies";

    idx_t table_index_aka_name_an = 1;
    idx_t table_index_name_n = 2;
    idx_t table_index_title_t = 3;
    idx_t table_index_company_name_cn = 4;
    idx_t table_index_char_name_chn = 5;
    idx_t table_index_role_type_rt1 = 6;
    idx_t table_index_aka_name_to_name_ = 8;
    idx_t table_index_cast_info_ = 15;
    idx_t table_index_movie_companies_ = 10;

    auto table_or_view_aka_name = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_aka_name_an,
                                                    OnEntryNotFound::RETURN_NULL);
    auto &table_aka_name = table_or_view_aka_name->Cast<TableCatalogEntry>();
    auto table_or_view_name = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_name_n,
                                                OnEntryNotFound::RETURN_NULL);
    auto &table_name = table_or_view_name->Cast<TableCatalogEntry>();
    auto table_or_view_title = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_title_t,
                                                 OnEntryNotFound::RETURN_NULL);
    auto &table_title = table_or_view_title->Cast<TableCatalogEntry>();
    auto table_or_view_company_name = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                        table_vertex_company_name_cn, OnEntryNotFound::RETURN_NULL);
    auto &table_company_name = table_or_view_company_name->Cast<TableCatalogEntry>();
    auto table_or_view_char_name = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                     table_vertex_char_name_chn, OnEntryNotFound::RETURN_NULL);
    auto &table_char_name = table_or_view_char_name->Cast<TableCatalogEntry>();
    auto table_or_view_role_type = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                     table_vertex_role_type_rt1, OnEntryNotFound::RETURN_NULL);
    auto &table_role_type = table_or_view_role_type->Cast<TableCatalogEntry>();
    auto table_or_view_cast_info = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_cast_info_,
                                                     OnEntryNotFound::RETURN_NULL);
    auto &table_cast_info = table_or_view_cast_info->Cast<TableCatalogEntry>();
    auto table_or_view_movie_companies = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                           table_vertex_movie_companies_, OnEntryNotFound::RETURN_NULL);
    auto &table_movie_companies = table_or_view_movie_companies->Cast<TableCatalogEntry>();

    string p_role_n = "actress";
    Value p_role = Value(p_role_n);
    vector<idx_t> role_type_rt1_ids{COLUMN_IDENTIFIER_ROW_ID, 1};
    vector<LogicalType> get_role_type_rt1_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_role_type_rt1 = "rt1";
    vector<LogicalType> table_types_role_type_rt1;
    vector<unique_ptr<Expression>> filter_role_type_rt1;
    unique_ptr<LogicalGet> get_op_role_type_rt1 = move(
            getLogicalGet(*this, table_role_type, alias_role_type_rt1, table_index_role_type_rt1,
                          table_types_role_type_rt1));
    unique_ptr<TableFilterSet> table_filters_role_type_rt1 = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_role = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL,
                                                                                        p_role);
    table_filters_role_type_rt1->filters[1] = move(constant_filter_role);
    unique_ptr<PhysicalTableScan> scan_role_type_rt1 = make_uniq<PhysicalTableScan>(get_role_type_rt1_types,
                                                                                    get_op_role_type_rt1->function,
                                                                                    get_op_role_type_rt1->table_index,
                                                                                    move(get_op_role_type_rt1->bind_data),
                                                                                    table_types_role_type_rt1,
                                                                                    role_type_rt1_ids,
                                                                                    move(filter_role_type_rt1),
                                                                                    vector<column_t>(),
                                                                                    get_op_role_type_rt1->names,
                                                                                    std::move(
                                                                                            table_filters_role_type_rt1),
                                                                                    get_op_role_type_rt1->estimated_cardinality,
                                                                                    get_op_role_type_rt1->extra_info);


    vector<idx_t> cast_info_ids{4, 7, 8, 9, 10};
    vector<LogicalType> get_cast_info_types{LogicalType::VARCHAR, LogicalType::BIGINT, LogicalType::BIGINT,
                                            LogicalType::BIGINT, LogicalType::BIGINT};
    string alias_cast_info = "ci";
    vector<LogicalType> table_types_cast_info;
    vector<unique_ptr<Expression>> filter_cast_info;
    unique_ptr<LogicalGet> get_op_cast_info = move(
            getLogicalGet(*this, table_cast_info, alias_cast_info, table_index_cast_info_, table_types_cast_info));
    unique_ptr<TableFilterSet> table_filters_cast_info = NULL;
    unique_ptr<PhysicalTableScan> scan_cast_info = make_uniq<PhysicalTableScan>(get_cast_info_types,
                                                                                get_op_cast_info->function,
                                                                                get_op_cast_info->table_index,
                                                                                move(get_op_cast_info->bind_data),
                                                                                table_types_cast_info, cast_info_ids,
                                                                                move(filter_cast_info),
                                                                                vector<column_t>(),
                                                                                get_op_cast_info->names,
                                                                                std::move(table_filters_cast_info),
                                                                                get_op_cast_info->estimated_cardinality,
                                                                                get_op_cast_info->extra_info);

    auto &allocator = Allocator::Get(context);
    vector<LogicalType> join_in_types{LogicalType::VARCHAR};
    auto collection =
            make_uniq<ColumnDataCollection>(context, join_in_types, ColumnDataAllocatorType::IN_MEMORY_ALLOCATOR);

    vector<LogicalType> chunk_in_types{LogicalType::VARCHAR};
    DataChunk chunk;
    chunk.SetCardinality(4);
    chunk.Initialize(allocator, chunk_in_types);
    chunk.SetValue(0, 0, Value("(voice)"));
    chunk.SetValue(0, 1, Value("(voice: Japanese version)"));
    chunk.SetValue(0, 2, Value("(voice) (uncredited)"));
    chunk.SetValue(0, 3, Value("(voice: English version)"));
    collection->Append(chunk);

    // create a chunk scan to output the result
    vector<LogicalType> ouput_in_types{LogicalType::VARCHAR};
    auto chunk_scan = make_uniq<PhysicalColumnDataScan>(ouput_in_types, PhysicalOperatorType::COLUMN_DATA_SCAN,
                                                        4, std::move(collection));

    vector<JoinCondition> cond_hash_join_;
    JoinCondition join_condition_hash_join_;
    join_condition_hash_join_.left = make_uniq<BoundReferenceExpression>("note", LogicalType::VARCHAR, 0);
    join_condition_hash_join_.right = make_uniq<BoundReferenceExpression>("", LogicalType::VARCHAR, 0);
    join_condition_hash_join_.comparison = ExpressionType::COMPARE_EQUAL;
    cond_hash_join_.push_back(move(join_condition_hash_join_));

    LogicalComparisonJoin join_hash_join_op(JoinType::MARK);
    vector<LogicalType> output_hash_join_types{LogicalType::VARCHAR, LogicalType::BIGINT, LogicalType::BIGINT,
                                               LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::BOOLEAN};
    join_hash_join_op.types = output_hash_join_types;
    vector<idx_t> right_projection_map_hash_join_;
    vector<LogicalType> delim_types_hash_join_;
    PerfectHashJoinStats joinstate;
    auto join_hash_join_ = make_uniq<PhysicalHashJoin>(join_hash_join_op, move(scan_cast_info), move(chunk_scan),
                                                       move(cond_hash_join_),
                                                       JoinType::MARK, left_projection_map,
                                                       right_projection_map_hash_join_,
                                                       delim_types_hash_join_, 0, joinstate);


    vector<LogicalType> filter_in_types{LogicalType::VARCHAR, LogicalType::BIGINT, LogicalType::BIGINT,
                                        LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::BOOLEAN};
    vector<unique_ptr<Expression>> select_list_in;
    auto in_exp = make_uniq<BoundReferenceExpression>("IN (...)", LogicalType::BOOLEAN, 5);
    select_list_in.push_back(move(in_exp));
    unique_ptr<PhysicalFilter> filter_in = make_uniq<PhysicalFilter>(filter_in_types, move(select_list_in), 0);
    filter_in->children.push_back(move(join_hash_join_));


    vector<JoinCondition> cond_cast_info_;
    JoinCondition join_condition_cast_info_;
    join_condition_cast_info_.left = make_uniq<BoundReferenceExpression>("role_id_rowid", LogicalType::BIGINT, 3);
    join_condition_cast_info_.right = make_uniq<BoundReferenceExpression>("role_type_rowid", LogicalType::BIGINT, 0);
    join_condition_cast_info_.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_cast_info_ = make_uniq<RAIInfo>();
    rai_info_cast_info_->rai = table_cast_info.GetStorage().info->rais[1].get();
    rai_info_cast_info_->rai_type = RAIType::EDGE_SOURCE;
    rai_info_cast_info_->forward = true;
    rai_info_cast_info_->vertex = &table_role_type;
    rai_info_cast_info_->vertex_id = table_index_role_type_rt1;
    rai_info_cast_info_->passing_tables[0] = table_index_cast_info_;
    rai_info_cast_info_->left_cardinalities[0] = table_cast_info.GetStorage().info->cardinality;
    rai_info_cast_info_->compact_list = &rai_info_cast_info_->rai->alist->compact_forward_list;

    join_condition_cast_info_.rais.push_back(move(rai_info_cast_info_));
    cond_cast_info_.push_back(move(join_condition_cast_info_));

    LogicalComparisonJoin join_cast_info__op(JoinType::INNER);
    vector<LogicalType> output_cast_info__types{LogicalType::VARCHAR, LogicalType::BIGINT, LogicalType::BIGINT,
                                                LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::BOOLEAN,
                                                LogicalType::BIGINT};
    join_cast_info__op.types = output_cast_info__types;
    vector<idx_t> right_projection_map_cast_info_{0};
    vector<idx_t> merge_project_map_cast_info_;
    vector<LogicalType> delim_types_cast_info_;
    auto join_cast_info_ = make_uniq<PhysicalSIPJoin>(join_cast_info__op, move(filter_in), move(scan_role_type_rt1),
                                                      move(cond_cast_info_),
                                                      JoinType::INNER, left_projection_map,
                                                      right_projection_map_cast_info_,
                                                      delim_types_cast_info_, 0);


    idx_t p_production_year1 = 2005;
    idx_t p_production_year2 = 2015;
    Value p_year1 = Value::BIGINT(p_production_year1);
    Value p_year2 = Value::BIGINT(p_production_year2);
    vector<idx_t> title_t_ids{COLUMN_IDENTIFIER_ROW_ID, 1, 4};
    vector<LogicalType> get_title_t_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::BIGINT};
    string alias_title_t = "t";
    vector<LogicalType> table_types_title_t;
    vector<unique_ptr<Expression>> filter_title_t;
    unique_ptr<LogicalGet> get_op_title_t = move(
            getLogicalGet(*this, table_title, alias_title_t, table_index_title_t, table_types_title_t));
    unique_ptr<TableFilterSet> table_filters_title_t = make_uniq<TableFilterSet>();
    unique_ptr<ConjunctionAndFilter> and_filter_title = duckdb::make_uniq<ConjunctionAndFilter>();
    unique_ptr<ConstantFilter> constant_filter_title_start = duckdb::make_uniq<ConstantFilter>(
            ExpressionType::COMPARE_GREATERTHANOREQUALTO, p_year1);
    unique_ptr<ConstantFilter> constant_filter_title_end = duckdb::make_uniq<ConstantFilter>(
            ExpressionType::COMPARE_LESSTHANOREQUALTO, p_year2);
    and_filter_title->child_filters.push_back(move(constant_filter_title_start));
    and_filter_title->child_filters.push_back(move(constant_filter_title_end));
    table_filters_title_t->filters[2] = move(and_filter_title);
    unique_ptr<PhysicalTableScan> scan_title_t = make_uniq<PhysicalTableScan>(get_title_t_types,
                                                                              get_op_title_t->function,
                                                                              get_op_title_t->table_index,
                                                                              move(get_op_title_t->bind_data),
                                                                              table_types_title_t, title_t_ids,
                                                                              move(filter_title_t), vector<column_t>(),
                                                                              get_op_title_t->names,
                                                                              std::move(table_filters_title_t),
                                                                              get_op_title_t->estimated_cardinality,
                                                                              get_op_title_t->extra_info);


    vector<JoinCondition> cond_title_t;
    JoinCondition join_condition_title_t;
    join_condition_title_t.left = make_uniq<BoundReferenceExpression>("title_rowid", LogicalType::BIGINT, 0);
    join_condition_title_t.right = make_uniq<BoundReferenceExpression>("movie_id_rowid", LogicalType::BIGINT, 1);
    join_condition_title_t.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_title_t = make_uniq<RAIInfo>();
    rai_info_title_t->rai = table_cast_info.GetStorage().info->rais[2].get();
    rai_info_title_t->rai_type = RAIType::TARGET_EDGE;
    rai_info_title_t->forward = true;
    rai_info_title_t->vertex = &table_title;
    rai_info_title_t->vertex_id = table_index_title_t;
    rai_info_title_t->passing_tables[0] = table_index_title_t;
    rai_info_title_t->left_cardinalities[0] = table_title.GetStorage().info->cardinality;
    // rai_info_title_t->compact_list = &rai_info_title_t->rai->alist->compact__list;

    join_condition_title_t.rais.push_back(move(rai_info_title_t));
    cond_title_t.push_back(move(join_condition_title_t));

    LogicalComparisonJoin join_title_t_op(JoinType::INNER);
    vector<LogicalType> output_title_t_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::BIGINT,
                                             LogicalType::BIGINT, LogicalType::BIGINT};
    join_title_t_op.types = output_title_t_types;
    vector<idx_t> right_projection_map_title_t{2, 4};
    vector<idx_t> merge_project_map_title_t;
    vector<LogicalType> delim_types_title_t;
    auto join_title_t = make_uniq<PhysicalSIPJoin>(join_title_t_op, move(scan_title_t), move(join_cast_info_),
                                                   move(cond_title_t),
                                                   JoinType::INNER, left_projection_map,
                                                   right_projection_map_title_t,
                                                   delim_types_title_t, 0);


    vector<idx_t> movie_companies_ids{4, 5, 6};
    vector<LogicalType> get_movie_companies_types{LogicalType::VARCHAR, LogicalType::BIGINT,
                                                  LogicalType::BIGINT};
    string alias_movie_companies = "mc";
    vector<LogicalType> table_types_movie_companies;
    vector<unique_ptr<Expression>> filter_movie_companies;
    unique_ptr<LogicalGet> get_op_movie_companies = move(
            getLogicalGet(*this, table_movie_companies, alias_movie_companies, table_index_movie_companies_,
                          table_types_movie_companies));
    unique_ptr<TableFilterSet> table_filters_movie_companies = NULL;
    unique_ptr<PhysicalTableScan> scan_movie_companies = make_uniq<PhysicalTableScan>(get_movie_companies_types,
                                                                                      get_op_movie_companies->function,
                                                                                      get_op_movie_companies->table_index,
                                                                                      move(get_op_movie_companies->bind_data),
                                                                                      table_types_movie_companies,
                                                                                      movie_companies_ids,
                                                                                      move(filter_movie_companies),
                                                                                      vector<column_t>(),
                                                                                      get_op_movie_companies->names,
                                                                                      std::move(
                                                                                              table_filters_movie_companies),
                                                                                      get_op_movie_companies->estimated_cardinality,
                                                                                      get_op_movie_companies->extra_info);


    vector<LogicalType> filter_mc_types{LogicalType::VARCHAR, LogicalType::BIGINT, LogicalType::BIGINT};
    vector<unique_ptr<Expression>> select_list_mc;
    auto mc_like_expression_left1 = make_uniq<BoundReferenceExpression>("note", LogicalType::VARCHAR, 0);
    auto mc_like_expression_value1 = make_uniq<BoundConstantExpression>(Value("(USA)"));
    vector<unique_ptr<Expression>> mc_like_arguments;
    mc_like_arguments.push_back(move(mc_like_expression_left1));
    mc_like_arguments.push_back(move(mc_like_expression_value1));

    QueryErrorContext error_context_like(NULL, NULL);
    ScalarFunction mc_bound_function_contains = ContainsFun::GetFunction();
    unique_ptr<FunctionData> mc_bind_data_contains = NULL;

    auto mc_like_bound_function = make_uniq<BoundFunctionExpression>(LogicalType::BOOLEAN,
                                                                     mc_bound_function_contains,
                                                                     move(mc_like_arguments),
                                                                     move(mc_bind_data_contains), false);


    auto mc_like_expression_left_exp = make_uniq<BoundReferenceExpression>("note", LogicalType::VARCHAR, 0);
    auto mc_like_expression_left_value = make_uniq<BoundConstantExpression>(Value("(worldwide)"));
    vector<unique_ptr<Expression>> mc_like_arguments_left2;
    mc_like_arguments_left2.push_back(move(mc_like_expression_left_exp));
    mc_like_arguments_left2.push_back(move(mc_like_expression_left_value));
    auto mc_like_bound_function_left = make_uniq<BoundFunctionExpression>(LogicalType::BOOLEAN,
                                                                          mc_bound_function_contains,
                                                                          move(mc_like_arguments_left2),
                                                                          move(mc_bind_data_contains), false);

    auto mc_or_conjunction = make_uniq<BoundConjunctionExpression>(ExpressionType::CONJUNCTION_OR);
    mc_or_conjunction->children.push_back(move(mc_like_bound_function));
    mc_or_conjunction->children.push_back(move(mc_like_bound_function_left));

    auto mc_not_null_bound_function = make_uniq<BoundOperatorExpression>(ExpressionType::OPERATOR_IS_NOT_NULL, LogicalType::BOOLEAN);
    auto mc_not_null = make_uniq<BoundReferenceExpression>("note", LogicalType::VARCHAR, 0);
    mc_not_null_bound_function->children.push_back(move(mc_not_null));

    auto mc_and_conjunction = make_uniq<BoundConjunctionExpression>(ExpressionType::CONJUNCTION_AND);
    mc_and_conjunction->children.push_back(move(mc_or_conjunction));
    mc_and_conjunction->children.push_back(move(mc_not_null_bound_function));

    select_list_mc.push_back(move(mc_and_conjunction));
    unique_ptr<PhysicalFilter> filter_mc_contains = make_uniq<PhysicalFilter>(filter_mc_types, move(select_list_mc), 0);
    filter_mc_contains->children.push_back(move(scan_movie_companies));


    vector<JoinCondition> cond_movie_companies_;
    JoinCondition join_condition_movie_companies_;
    join_condition_movie_companies_.left = make_uniq<BoundReferenceExpression>("movie_id_rowid", LogicalType::BIGINT,
                                                                               2);
    join_condition_movie_companies_.right = make_uniq<BoundReferenceExpression>("title_rowid",
                                                                                LogicalType::BIGINT, 0);
    join_condition_movie_companies_.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_movie_companies_ = make_uniq<RAIInfo>();
    rai_info_movie_companies_->rai = table_movie_companies.GetStorage().info->rais[0].get();
    rai_info_movie_companies_->rai_type = RAIType::EDGE_TARGET;
    rai_info_movie_companies_->forward = false;
    rai_info_movie_companies_->vertex = &table_title;
    rai_info_movie_companies_->vertex_id = table_index_title_t;
    rai_info_movie_companies_->passing_tables[0] = table_index_movie_companies_;
    rai_info_movie_companies_->left_cardinalities[0] = table_movie_companies.GetStorage().info->cardinality;
    rai_info_movie_companies_->compact_list = &rai_info_movie_companies_->rai->alist->compact_backward_list;

    join_condition_movie_companies_.rais.push_back(move(rai_info_movie_companies_));
    cond_movie_companies_.push_back(move(join_condition_movie_companies_));

    LogicalComparisonJoin join_movie_companies__op(JoinType::INNER);
    vector<LogicalType> output_movie_companies__types{LogicalType::VARCHAR, LogicalType::BIGINT, LogicalType::BIGINT,
                                                      LogicalType::VARCHAR, LogicalType::BIGINT, LogicalType::BIGINT};
    join_movie_companies__op.types = output_movie_companies__types;
    vector<idx_t> right_projection_map_movie_companies_{1, 3, 4};
    vector<idx_t> merge_project_map_movie_companies_;
    vector<LogicalType> delim_types_movie_companies_;
    auto join_movie_companies_ = make_uniq<PhysicalSIPJoin>(join_movie_companies__op, move(filter_mc_contains),
                                                            move(join_title_t),
                                                            move(cond_movie_companies_), JoinType::INNER,
                                                            left_projection_map,
                                                            right_projection_map_movie_companies_,
                                                            delim_types_movie_companies_, 0);


    string p_country_code = "[us]";
    Value p_code = Value(p_country_code);
    vector<idx_t> company_name_cn_ids{COLUMN_IDENTIFIER_ROW_ID, 2};
    vector<LogicalType> get_company_name_cn_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_company_name_cn = "cn";
    vector<LogicalType> table_types_company_name_cn;
    vector<unique_ptr<Expression>> filter_company_name_cn;
    unique_ptr<LogicalGet> get_op_company_name_cn = move(
            getLogicalGet(*this, table_company_name, alias_company_name_cn, table_index_company_name_cn,
                          table_types_company_name_cn));
    unique_ptr<TableFilterSet> table_filters_company_name_cn = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_cn = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL,
                                                                                      p_code);
    table_filters_company_name_cn->filters[1] = move(constant_filter_cn);
    unique_ptr<PhysicalTableScan> scan_company_name_cn = make_uniq<PhysicalTableScan>(get_company_name_cn_types,
                                                                                      get_op_company_name_cn->function,
                                                                                      get_op_company_name_cn->table_index,
                                                                                      move(get_op_company_name_cn->bind_data),
                                                                                      table_types_company_name_cn,
                                                                                      company_name_cn_ids,
                                                                                      move(filter_company_name_cn),
                                                                                      vector<column_t>(),
                                                                                      get_op_company_name_cn->names,
                                                                                      std::move(
                                                                                              table_filters_company_name_cn),
                                                                                      get_op_company_name_cn->estimated_cardinality,
                                                                                      get_op_company_name_cn->extra_info);


    vector<JoinCondition> cond_company_name_cn;
    JoinCondition join_condition_company_name_cn;
    join_condition_company_name_cn.left = make_uniq<BoundReferenceExpression>("company_name_rowid", LogicalType::BIGINT,
                                                                              0);
    join_condition_company_name_cn.right = make_uniq<BoundReferenceExpression>("company_id_rowid", LogicalType::BIGINT,
                                                                               1);
    join_condition_company_name_cn.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_company_name_cn = make_uniq<RAIInfo>();
    rai_info_company_name_cn->rai = table_movie_companies.GetStorage().info->rais[0].get();
    rai_info_company_name_cn->rai_type = RAIType::SOURCE_EDGE;
    rai_info_company_name_cn->forward = false;
    rai_info_company_name_cn->vertex = &table_company_name;
    rai_info_company_name_cn->vertex_id = table_index_company_name_cn;
    rai_info_company_name_cn->passing_tables[0] = table_index_company_name_cn;
    rai_info_company_name_cn->left_cardinalities[0] = table_company_name.GetStorage().info->cardinality;
    // rai_info_company_name_cn->compact_list = &rai_info_company_name_cn->rai->alist->compact__list;

    join_condition_company_name_cn.rais.push_back(move(rai_info_company_name_cn));
    cond_company_name_cn.push_back(move(join_condition_company_name_cn));

    LogicalComparisonJoin join_company_name_cn_op(JoinType::INNER);
    vector<LogicalType> output_company_name_cn_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::VARCHAR,
                                                     LogicalType::BIGINT, LogicalType::BIGINT};
    join_company_name_cn_op.types = output_company_name_cn_types;
    vector<idx_t> right_projection_map_company_name_cn{3, 4, 5};
    vector<idx_t> merge_project_map_company_name_cn;
    vector<LogicalType> delim_types_company_name_cn;
    auto join_company_name_cn = make_uniq<PhysicalSIPJoin>(join_company_name_cn_op, move(scan_company_name_cn),
                                                           move(join_movie_companies_),
                                                           move(cond_company_name_cn), JoinType::INNER,
                                                           left_projection_map,
                                                           right_projection_map_company_name_cn,
                                                           delim_types_company_name_cn, 0);

    string p_gender_n = "f";
    Value p_gender = Value(p_gender_n);
    vector<idx_t> name_n_ids{COLUMN_IDENTIFIER_ROW_ID, 1, 4};
    vector<LogicalType> get_name_n_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::VARCHAR};
    string alias_name_n = "n";
    vector<LogicalType> table_types_name_n;
    vector<unique_ptr<Expression>> filter_name_n;
    unique_ptr<LogicalGet> get_op_name_n = move(
            getLogicalGet(*this, table_name, alias_name_n, table_index_name_n, table_types_name_n));
    unique_ptr<TableFilterSet> table_filters_name_n = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_n = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL,
                                                                                     p_gender);
    table_filters_name_n->filters[2] = move(constant_filter_n);
    unique_ptr<PhysicalTableScan> scan_name_n = make_uniq<PhysicalTableScan>(get_name_n_types, get_op_name_n->function,
                                                                             get_op_name_n->table_index,
                                                                             move(get_op_name_n->bind_data),
                                                                             table_types_name_n, name_n_ids,
                                                                             move(filter_name_n), vector<column_t>(),
                                                                             get_op_name_n->names,
                                                                             std::move(table_filters_name_n),
                                                                             get_op_name_n->estimated_cardinality,
                                                                             get_op_name_n->extra_info);


    vector<LogicalType> filter_name_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::VARCHAR};
    vector<unique_ptr<Expression>> select_list_name;
    auto name_like_expression_left1 = make_uniq<BoundReferenceExpression>("name", LogicalType::VARCHAR, 1);
    auto name_like_expression_value1 = make_uniq<BoundConstantExpression>(Value("Ang"));
    vector<unique_ptr<Expression>> name_like_arguments;
    name_like_arguments.push_back(move(name_like_expression_left1));
    name_like_arguments.push_back(move(name_like_expression_value1));

    ScalarFunction name_bound_function_contains = ContainsFun::GetFunction();
    unique_ptr<FunctionData> name_bind_data_contains = NULL;

    auto name_like_bound_function = make_uniq<BoundFunctionExpression>(LogicalType::BOOLEAN,
                                                                       name_bound_function_contains,
                                                                       move(name_like_arguments),
                                                                       move(name_bind_data_contains), false);

    select_list_name.push_back(move(name_like_bound_function));
    unique_ptr<PhysicalFilter> filter_name_contains = make_uniq<PhysicalFilter>(filter_name_types,
                                                                                move(select_list_name), 0);
    filter_name_contains->children.push_back(move(scan_name_n));

    vector<JoinCondition> cond_name_n;
    JoinCondition join_condition_name_n;
    join_condition_name_n.left = make_uniq<BoundReferenceExpression>("name_rowid", LogicalType::BIGINT, 0);
    join_condition_name_n.right = make_uniq<BoundReferenceExpression>("person_id_rowid", LogicalType::BIGINT, 3);
    join_condition_name_n.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_name_n = make_uniq<RAIInfo>();
    rai_info_name_n->rai = table_cast_info.GetStorage().info->rais[1].get();
    rai_info_name_n->rai_type = RAIType::TARGET_EDGE;
    rai_info_name_n->forward = true;
    rai_info_name_n->vertex = &table_name;
    rai_info_name_n->vertex_id = table_index_name_n;
    rai_info_name_n->passing_tables[0] = table_index_name_n;
    rai_info_name_n->left_cardinalities[0] = table_name.GetStorage().info->cardinality;
    // rai_info_name_n->compact_list = &rai_info_name_n->rai->alist->compact__list;

    join_condition_name_n.rais.push_back(move(rai_info_name_n));
    cond_name_n.push_back(move(join_condition_name_n));

    LogicalComparisonJoin join_name_n_op(JoinType::INNER);
    vector<LogicalType> output_name_n_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::VARCHAR,
                                            LogicalType::VARCHAR, LogicalType::BIGINT};
    join_name_n_op.types = output_name_n_types;
    vector<idx_t> right_projection_map_name_n{2, 4};
    vector<idx_t> merge_project_map_name_n;
    vector<LogicalType> delim_types_name_n;
    auto join_name_n = make_uniq<PhysicalSIPJoin>(join_name_n_op, move(filter_name_contains),
                                                  move(join_company_name_cn), move(cond_name_n), JoinType::INNER,
                                                  left_projection_map, right_projection_map_name_n, delim_types_name_n,
                                                  0);


    vector<idx_t> aka_name_an_ids{8, 2};
    vector<LogicalType> get_aka_name_an_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_aka_name_an = "an";
    vector<LogicalType> table_types_aka_name_an;
    vector<unique_ptr<Expression>> filter_aka_name_an;
    unique_ptr<LogicalGet> get_op_aka_name_an = move(
            getLogicalGet(*this, table_aka_name, alias_aka_name_an, table_index_aka_name_an, table_types_aka_name_an));
    unique_ptr<TableFilterSet> table_filters_aka_name_an = NULL;
    unique_ptr<PhysicalTableScan> scan_aka_name_an = make_uniq<PhysicalTableScan>(get_aka_name_an_types,
                                                                                  get_op_aka_name_an->function,
                                                                                  get_op_aka_name_an->table_index,
                                                                                  move(get_op_aka_name_an->bind_data),
                                                                                  table_types_aka_name_an,
                                                                                  aka_name_an_ids,
                                                                                  move(filter_aka_name_an),
                                                                                  vector<column_t>(),
                                                                                  get_op_aka_name_an->names,
                                                                                  std::move(table_filters_aka_name_an),
                                                                                  get_op_aka_name_an->estimated_cardinality,
                                                                                  get_op_aka_name_an->extra_info);


    vector<JoinCondition> cond_aka_name_to_name_;
    JoinCondition join_condition_aka_name_to_name_;
    join_condition_aka_name_to_name_.left = make_uniq<BoundReferenceExpression>("person_id_rowid", LogicalType::BIGINT,
                                                                                0);
    join_condition_aka_name_to_name_.right = make_uniq<BoundReferenceExpression>("name_rowid", LogicalType::BIGINT, 0);
    join_condition_aka_name_to_name_.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_aka_name_to_name_ = make_uniq<RAIInfo>();
    rai_info_aka_name_to_name_->rai = table_aka_name.GetStorage().info->rais[0].get();
    rai_info_aka_name_to_name_->rai_type = RAIType::EDGE_SOURCE;
    rai_info_aka_name_to_name_->forward = true;
    rai_info_aka_name_to_name_->vertex = &table_name;
    rai_info_aka_name_to_name_->vertex_id = table_index_name_n;
    rai_info_aka_name_to_name_->passing_tables[0] = table_index_aka_name_an;
    rai_info_aka_name_to_name_->left_cardinalities[0] = table_aka_name.GetStorage().info->cardinality;
    rai_info_aka_name_to_name_->compact_list = &rai_info_aka_name_to_name_->rai->alist->compact_forward_list;

    join_condition_aka_name_to_name_.rais.push_back(move(rai_info_aka_name_to_name_));
    cond_aka_name_to_name_.push_back(move(join_condition_aka_name_to_name_));

    LogicalComparisonJoin join_aka_name_to_name__op(JoinType::INNER);
    vector<LogicalType> output_aka_name_to_name__types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::VARCHAR,
                                                       LogicalType::BIGINT};
    join_aka_name_to_name__op.types = output_aka_name_to_name__types;
    vector<idx_t> right_projection_map_aka_name_to_name_{3, 4};
    vector<idx_t> merge_project_map_aka_name_to_name_;
    vector<LogicalType> delim_types_aka_name_to_name_;
    auto join_aka_name_to_name_ = make_uniq<PhysicalSIPJoin>(join_aka_name_to_name__op, move(scan_aka_name_an), move(join_name_n),
                                                                  move(cond_aka_name_to_name_), JoinType::INNER,
                                                                  left_projection_map,
                                                                  right_projection_map_aka_name_to_name_,
                                                                  delim_types_aka_name_to_name_, 0);



    vector<idx_t> char_name_chn_ids{COLUMN_IDENTIFIER_ROW_ID, 1};
    vector<LogicalType> get_char_name_chn_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_char_name_chn = "chn";
    vector<LogicalType> table_types_char_name_chn;
    vector<unique_ptr<Expression>> filter_char_name_chn;
    unique_ptr<LogicalGet> get_op_char_name_chn = move(
            getLogicalGet(*this, table_char_name, alias_char_name_chn, table_index_char_name_chn,
                          table_types_char_name_chn));
    unique_ptr<TableFilterSet> table_filters_char_name_chn = NULL;
    unique_ptr<PhysicalTableScan> scan_char_name_chn = make_uniq<PhysicalTableScan>(get_char_name_chn_types,
                                                                                    get_op_char_name_chn->function,
                                                                                    get_op_char_name_chn->table_index,
                                                                                    move(get_op_char_name_chn->bind_data),
                                                                                    table_types_char_name_chn,
                                                                                    char_name_chn_ids,
                                                                                    move(filter_char_name_chn),
                                                                                    vector<column_t>(),
                                                                                    get_op_char_name_chn->names,
                                                                                    std::move(
                                                                                            table_filters_char_name_chn),
                                                                                    get_op_char_name_chn->estimated_cardinality,
                                                                                    get_op_char_name_chn->extra_info);


    vector<JoinCondition> cond_char_name_chn;
    JoinCondition join_condition_char_name_chn;
    join_condition_char_name_chn.left = make_uniq<BoundReferenceExpression>("char_name_rowid", LogicalType::BIGINT, 0);
    join_condition_char_name_chn.right = make_uniq<BoundReferenceExpression>("person_role_id_rowid", LogicalType::BIGINT, 3);
    join_condition_char_name_chn.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_char_name_chn = make_uniq<RAIInfo>();
    rai_info_char_name_chn->rai = table_cast_info.GetStorage().info->rais[3].get();
    rai_info_char_name_chn->rai_type = RAIType::TARGET_EDGE;
    rai_info_char_name_chn->forward = true;
    rai_info_char_name_chn->vertex = &table_char_name;
    rai_info_char_name_chn->vertex_id = table_index_char_name_chn;
    rai_info_char_name_chn->passing_tables[0] = table_index_char_name_chn;
    rai_info_char_name_chn->left_cardinalities[0] = table_char_name.GetStorage().info->cardinality;
    // rai_info_char_name_chn->compact_list = &rai_info_char_name_chn->rai->alist->compact__list;

    join_condition_char_name_chn.rais.push_back(move(rai_info_char_name_chn));
    cond_char_name_chn.push_back(move(join_condition_char_name_chn));

    LogicalComparisonJoin join_multi_at_char_name_chn_op(JoinType::INNER);
    vector<LogicalType> output_multi_at_char_name_chn_types{LogicalType::BIGINT, LogicalType::VARCHAR,
                                                            LogicalType::VARCHAR, LogicalType::VARCHAR};
    join_multi_at_char_name_chn_op.types = output_multi_at_char_name_chn_types;
    vector<idx_t> right_projection_map_multi_at_char_name_chn{1, 2};
    vector<LogicalType> delim_types_multi_at_char_name_chn;
    auto join_multi_at_char_name_chn = make_uniq<PhysicalSIPJoin>(join_multi_at_char_name_chn_op, move(scan_char_name_chn),
                                                                          move(join_aka_name_to_name_), move(cond_char_name_chn), JoinType::INNER,
                                                                          left_projection_map,
                                                                          right_projection_map_multi_at_char_name_chn,
                                                                          delim_types_multi_at_char_name_chn, 0);


    vector<LogicalType> result_types{LogicalType::VARCHAR, LogicalType::VARCHAR, LogicalType::VARCHAR};
    vector<unique_ptr<Expression>> select_list;
    auto result_col0 = make_uniq<BoundReferenceExpression>("name", LogicalType::VARCHAR, 2);
    auto result_col1 = make_uniq<BoundReferenceExpression>("name", LogicalType::VARCHAR, 1);
    auto result_col2 = make_uniq<BoundReferenceExpression>("title", LogicalType::VARCHAR, 3);
    select_list.push_back(move(result_col0));
    select_list.push_back(move(result_col1));
    select_list.push_back(move(result_col2));
    auto projection = make_uniq<PhysicalProjection>(result_types, move(select_list), 0);
    projection->children.push_back(move(join_multi_at_char_name_chn));

    // aggregate
    string agg_name = "min";
    string agg_error = "";
    QueryErrorContext error_context(NULL, NULL);
    auto min_func = Catalog::GetEntry(context, CatalogType::SCALAR_FUNCTION_ENTRY, "", "",
                                      "min", OnEntryNotFound::RETURN_NULL, error_context);
    auto &min_func_set = min_func->Cast<AggregateFunctionCatalogEntry>();
    // bind the aggregate
    FunctionBinder function_binder(context);
    vector<LogicalType> types;
    types.push_back(LogicalType::VARCHAR);
    idx_t best_function_varchar = function_binder.BindFunction(agg_name, min_func_set.functions, types, agg_error);
    auto bound_function_min_varchar = min_func_set.functions.GetFunctionByOffset(best_function_varchar);

    auto first_children = make_uniq<BoundReferenceExpression>("name", LogicalType::VARCHAR, 0);
    vector<unique_ptr<Expression>> childrenlist1;
    childrenlist1.push_back(move(first_children));
    auto aggregate1 =
            function_binder.BindAggregateFunction(bound_function_min_varchar, std::move(childrenlist1), nullptr,
                                                  AggregateType::NON_DISTINCT);

    auto second_children = make_uniq<BoundReferenceExpression>("name", LogicalType::VARCHAR, 1);
    vector<unique_ptr<Expression>> childrenlist2;
    childrenlist2.push_back(move(second_children));
    auto aggregate2 =
            function_binder.BindAggregateFunction(bound_function_min_varchar, std::move(childrenlist2), nullptr,
                                                  AggregateType::NON_DISTINCT);

    auto third_children = make_uniq<BoundReferenceExpression>("title", LogicalType::VARCHAR, 2);
    vector<unique_ptr<Expression>> childrenlist3;
    childrenlist3.push_back(move(third_children));
    auto aggregate3 =
            function_binder.BindAggregateFunction(bound_function_min_varchar, std::move(childrenlist3), nullptr,
                                                  AggregateType::NON_DISTINCT);

    vector<unique_ptr<Expression>> aggregates;
    aggregates.push_back(move(aggregate1));
    aggregates.push_back(move(aggregate2));
    aggregates.push_back(move(aggregate3));

    vector<LogicalType> aggregate_types{LogicalType::VARCHAR, LogicalType::VARCHAR, LogicalType::VARCHAR};
    auto ungrouped_aggregate = make_uniq<PhysicalUngroupedAggregate>(aggregate_types, move(aggregates), 0);
    ungrouped_aggregate->children.push_back(move(projection));

    return ungrouped_aggregate;
}

unique_ptr<PhysicalOperator> ClientContext::GenerateJOB10aPlan(duckdb::ClientContext &context) {
    vector<idx_t> left_projection_map, right_projection_map;

    string table_vertex_company_type_ct = "company_type";
    string table_vertex_title_t = "title";
    string table_vertex_char_name_chn = "char_name";
    string table_vertex_company_name_cn = "company_name";
    string table_vertex_role_type_rt = "role_type";
    string table_vertex_movie_companies_ = "movie_companies";
    string table_vertex_cast_info_ = "cast_info";

    idx_t table_index_company_type_ct = 1;
    idx_t table_index_title_t = 2;
    idx_t table_index_char_name_chn = 3;
    idx_t table_index_company_name_cn = 4;
    idx_t table_index_role_type_rt = 5;
    idx_t table_index_movie_companies_ = 8;
    idx_t table_index_cast_info_ = 10;

    auto table_or_view_company_type = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                        table_vertex_company_type_ct, OnEntryNotFound::RETURN_NULL);
    auto &table_company_type = table_or_view_company_type->Cast<TableCatalogEntry>();
    auto table_or_view_title = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_title_t,
                                                 OnEntryNotFound::RETURN_NULL);
    auto &table_title = table_or_view_title->Cast<TableCatalogEntry>();
    auto table_or_view_char_name = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                     table_vertex_char_name_chn, OnEntryNotFound::RETURN_NULL);
    auto &table_char_name = table_or_view_char_name->Cast<TableCatalogEntry>();
    auto table_or_view_company_name = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                        table_vertex_company_name_cn, OnEntryNotFound::RETURN_NULL);
    auto &table_company_name = table_or_view_company_name->Cast<TableCatalogEntry>();
    auto table_or_view_role_type = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_role_type_rt,
                                                     OnEntryNotFound::RETURN_NULL);
    auto &table_role_type = table_or_view_role_type->Cast<TableCatalogEntry>();
    auto table_or_view_movie_companies = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                           table_vertex_movie_companies_, OnEntryNotFound::RETURN_NULL);
    auto &table_movie_companies = table_or_view_movie_companies->Cast<TableCatalogEntry>();
    auto table_or_view_cast_info = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_cast_info_,
                                                     OnEntryNotFound::RETURN_NULL);
    auto &table_cast_info = table_or_view_cast_info->Cast<TableCatalogEntry>();

    string p_role_n = "actor";
    Value p_role = Value(p_role_n);
    vector<idx_t> role_type_rt_ids{COLUMN_IDENTIFIER_ROW_ID, 1};
    vector<LogicalType> get_role_type_rt_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_role_type_rt = "rt";
    vector<LogicalType> table_types_role_type_rt;
    vector<unique_ptr<Expression>> filter_role_type_rt;
    unique_ptr<LogicalGet> get_op_role_type_rt = move(
            getLogicalGet(*this, table_role_type, alias_role_type_rt, table_index_role_type_rt,
                          table_types_role_type_rt));
    unique_ptr<TableFilterSet> table_filters_role_type_rt = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_rt = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL, p_role);
    table_filters_role_type_rt->filters[1] = move(constant_filter_rt);;
    unique_ptr<PhysicalTableScan> scan_role_type_rt = make_uniq<PhysicalTableScan>(get_role_type_rt_types,
                                                                                   get_op_role_type_rt->function,
                                                                                   get_op_role_type_rt->table_index,
                                                                                   move(get_op_role_type_rt->bind_data),
                                                                                   table_types_role_type_rt,
                                                                                   role_type_rt_ids,
                                                                                   move(filter_role_type_rt),
                                                                                   vector<column_t>(),
                                                                                   get_op_role_type_rt->names,
                                                                                   std::move(
                                                                                           table_filters_role_type_rt),
                                                                                   get_op_role_type_rt->estimated_cardinality,
                                                                                   get_op_role_type_rt->extra_info);



    vector<idx_t> cast_info_ids{4, 7, 9, 10};
    vector<LogicalType> get_cast_info_types{LogicalType::VARCHAR, LogicalType::BIGINT,
                                            LogicalType::BIGINT, LogicalType::BIGINT};
    string alias_cast_info = "ci";
    vector<LogicalType> table_types_cast_info;
    vector<unique_ptr<Expression>> filter_cast_info;
    unique_ptr<LogicalGet> get_op_cast_info = move(
            getLogicalGet(*this, table_cast_info, alias_cast_info, table_index_cast_info_, table_types_cast_info));
    unique_ptr<TableFilterSet> table_filters_cast_info = NULL;
    unique_ptr<PhysicalTableScan> scan_cast_info = make_uniq<PhysicalTableScan>(get_cast_info_types,
                                                                                get_op_cast_info->function,
                                                                                get_op_cast_info->table_index,
                                                                                move(get_op_cast_info->bind_data),
                                                                                table_types_cast_info, cast_info_ids,
                                                                                move(filter_cast_info),
                                                                                vector<column_t>(),
                                                                                get_op_cast_info->names,
                                                                                std::move(table_filters_cast_info),
                                                                                get_op_cast_info->estimated_cardinality,
                                                                                get_op_cast_info->extra_info);

    vector<LogicalType> filter_ci_types{LogicalType::VARCHAR, LogicalType::BIGINT,
                                        LogicalType::BIGINT, LogicalType::BIGINT};
    vector<unique_ptr<Expression>> select_list_ci;

    QueryErrorContext error_context_unlike(NULL, NULL);
    ScalarFunction bound_function_contains = ContainsFun::GetFunction();
    unique_ptr<FunctionData> bind_data_contains = NULL;

    auto like_bound_function = make_uniq<BoundConjunctionExpression>(ExpressionType::CONJUNCTION_AND);

    auto like_expression_left_exp = make_uniq<BoundReferenceExpression>("note", LogicalType::VARCHAR, 0);
    auto like_expression_left_value = make_uniq<BoundConstantExpression>(Value("(voice)"));
    vector<unique_ptr<Expression>> like_arguments_left;
    like_arguments_left.push_back(move(like_expression_left_exp));
    like_arguments_left.push_back(move(like_expression_left_value));
    auto like_bound_function_left = make_uniq<BoundFunctionExpression>(LogicalType::BOOLEAN,
                                                                       bound_function_contains,
                                                                       move(like_arguments_left),
                                                                       move(bind_data_contains), false);

    auto like_expression_right_exp = make_uniq<BoundReferenceExpression>("note", LogicalType::VARCHAR, 0);
    auto like_expression_right_value = make_uniq<BoundConstantExpression>(Value("(uncredited)"));
    vector<unique_ptr<Expression>> like_arguments_right;
    like_arguments_right.push_back(move(like_expression_right_exp));
    like_arguments_right.push_back(move(like_expression_right_value));
    auto like_bound_function_right = make_uniq<BoundFunctionExpression>(LogicalType::BOOLEAN,
                                                                        bound_function_contains,
                                                                        move(like_arguments_right),
                                                                        move(bind_data_contains), false);

    like_bound_function->children.push_back(move(like_bound_function_left));
    like_bound_function->children.push_back(move(like_bound_function_right));

    select_list_ci.push_back(move(like_bound_function));
    unique_ptr<PhysicalFilter> filter_ci_contains = make_uniq<PhysicalFilter>(filter_ci_types, move(select_list_ci), 0);
    filter_ci_contains->children.push_back(move(scan_cast_info));

    vector<JoinCondition> cond_cast_info_;
    JoinCondition join_condition_cast_info_;
    join_condition_cast_info_.left = make_uniq<BoundReferenceExpression>("role_id_rowid", LogicalType::BIGINT, 2);
    join_condition_cast_info_.right = make_uniq<BoundReferenceExpression>("role_type_rowid", LogicalType::BIGINT, 0);
    join_condition_cast_info_.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_cast_info_ = make_uniq<RAIInfo>();
    rai_info_cast_info_->rai = table_cast_info.GetStorage().info->rais[2].get();
    rai_info_cast_info_->rai_type = RAIType::EDGE_SOURCE;
    rai_info_cast_info_->forward = true;
    rai_info_cast_info_->vertex = &table_role_type;
    rai_info_cast_info_->vertex_id = table_index_role_type_rt;
    rai_info_cast_info_->passing_tables[0] = table_index_cast_info_;
    rai_info_cast_info_->left_cardinalities[0] = table_cast_info.GetStorage().info->cardinality;
    rai_info_cast_info_->compact_list = &rai_info_cast_info_->rai->alist->compact_forward_list;

    join_condition_cast_info_.rais.push_back(move(rai_info_cast_info_));
    cond_cast_info_.push_back(move(join_condition_cast_info_));

    LogicalComparisonJoin join_cast_info__op(JoinType::INNER);
    vector<LogicalType> output_cast_info__types{LogicalType::VARCHAR, LogicalType::BIGINT, LogicalType::BIGINT,
                                                LogicalType::BIGINT, LogicalType::BIGINT};
    join_cast_info__op.types = output_cast_info__types;
    vector<idx_t> right_projection_map_cast_info_{0};
    vector<idx_t> merge_project_map_cast_info_;
    vector<LogicalType> delim_types_cast_info_;
    auto join_cast_info_ = make_uniq<PhysicalSIPJoin>(join_cast_info__op, move(filter_ci_contains), move(scan_role_type_rt), move(cond_cast_info_),
                                                           JoinType::INNER, left_projection_map,
                                                           right_projection_map_cast_info_,
                                                           delim_types_cast_info_, 0);


    idx_t p_production_year = 2005;
    Value p_year = Value::BIGINT(p_production_year);
    vector<idx_t> title_t_ids{COLUMN_IDENTIFIER_ROW_ID, 1, 4};
    vector<LogicalType> get_title_t_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::BIGINT};
    string alias_title_t = "t";
    vector<LogicalType> table_types_title_t;
    vector<unique_ptr<Expression>> filter_title_t;
    unique_ptr<LogicalGet> get_op_title_t = move(
            getLogicalGet(*this, table_title, alias_title_t, table_index_title_t, table_types_title_t));
    unique_ptr<TableFilterSet> table_filters_title_t = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_title = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_GREATERTHAN, p_year);
    table_filters_title_t->filters[2] = move(constant_filter_title);
    unique_ptr<PhysicalTableScan> scan_title_t = make_uniq<PhysicalTableScan>(get_title_t_types,
                                                                              get_op_title_t->function,
                                                                              get_op_title_t->table_index,
                                                                              move(get_op_title_t->bind_data),
                                                                              table_types_title_t, title_t_ids,
                                                                              move(filter_title_t), vector<column_t>(),
                                                                              get_op_title_t->names,
                                                                              std::move(table_filters_title_t),
                                                                              get_op_title_t->estimated_cardinality,
                                                                              get_op_title_t->extra_info);


    vector<JoinCondition> cond_title_t;
    JoinCondition join_condition_title_t;
    join_condition_title_t.left = make_uniq<BoundReferenceExpression>("title_rowid", LogicalType::BIGINT, 0);
    join_condition_title_t.right = make_uniq<BoundReferenceExpression>("movie_id_rowid", LogicalType::BIGINT, 1);
    join_condition_title_t.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_title_t = make_uniq<RAIInfo>();
    rai_info_title_t->rai = table_cast_info.GetStorage().info->rais[2].get();
    rai_info_title_t->rai_type = RAIType::TARGET_EDGE;
    rai_info_title_t->forward = true;
    rai_info_title_t->vertex = &table_title;
    rai_info_title_t->vertex_id = table_index_title_t;
    rai_info_title_t->passing_tables[0] = table_index_title_t;
    rai_info_title_t->left_cardinalities[0] = table_title.GetStorage().info->cardinality;
    // rai_info_title_t->compact_list = &rai_info_title_t->rai->alist->compact__list;

    join_condition_title_t.rais.push_back(move(rai_info_title_t));
    cond_title_t.push_back(move(join_condition_title_t));

    LogicalComparisonJoin join_title_t_op(JoinType::INNER);
    vector<LogicalType> output_title_t_types{LogicalType::BIGINT, LogicalType::VARCHAR,
                                             LogicalType::BIGINT, LogicalType::BIGINT};
    join_title_t_op.types = output_title_t_types;
    vector<idx_t> right_projection_map_title_t{3};
    vector<idx_t> merge_project_map_title_t;
    vector<LogicalType> delim_types_title_t;
    auto join_title_t = make_uniq<PhysicalSIPJoin>(join_title_t_op, move(scan_title_t), move(join_cast_info_), move(cond_title_t), JoinType::INNER,
                                                   left_projection_map, right_projection_map_title_t,
                                                   delim_types_title_t, 0);


    string p_country_code = "[ru]";
    Value p_code = Value(p_country_code);
    vector<idx_t> company_name_cn_ids{COLUMN_IDENTIFIER_ROW_ID, 2};
    vector<LogicalType> get_company_name_cn_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_company_name_cn = "cn";
    vector<LogicalType> table_types_company_name_cn;
    vector<unique_ptr<Expression>> filter_company_name_cn;
    unique_ptr<LogicalGet> get_op_company_name_cn = move(
            getLogicalGet(*this, table_company_name, alias_company_name_cn, table_index_company_name_cn,
                          table_types_company_name_cn));
    unique_ptr<TableFilterSet> table_filters_company_name_cn = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_cn = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL, p_code);
    table_filters_company_name_cn->filters[1] = move(constant_filter_cn);
    unique_ptr<PhysicalTableScan> scan_company_name_cn = make_uniq<PhysicalTableScan>(get_company_name_cn_types,
                                                                                      get_op_company_name_cn->function,
                                                                                      get_op_company_name_cn->table_index,
                                                                                      move(get_op_company_name_cn->bind_data),
                                                                                      table_types_company_name_cn,
                                                                                      company_name_cn_ids,
                                                                                      move(filter_company_name_cn),
                                                                                      vector<column_t>(),
                                                                                      get_op_company_name_cn->names,
                                                                                      std::move(
                                                                                              table_filters_company_name_cn),
                                                                                      get_op_company_name_cn->estimated_cardinality,
                                                                                      get_op_company_name_cn->extra_info);


    vector<JoinCondition> cond_company_name_cn;
    JoinCondition join_condition_company_name_cn;
    join_condition_company_name_cn.left = make_uniq<BoundReferenceExpression>("company_name_rowid", LogicalType::BIGINT, 0);
    join_condition_company_name_cn.right = make_uniq<BoundReferenceExpression>("title_rowid", LogicalType::BIGINT, 0);
    join_condition_company_name_cn.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_company_name_cn = make_uniq<RAIInfo>();
    rai_info_company_name_cn->rai = table_movie_companies.GetStorage().info->rais[0].get();
    rai_info_company_name_cn->rai_type = RAIType::SOURCE_EDGE;
    rai_info_company_name_cn->forward = false;
    rai_info_company_name_cn->vertex = &table_company_name;
    rai_info_company_name_cn->vertex_id = table_index_company_name_cn;
    rai_info_company_name_cn->passing_tables[0] = table_index_company_name_cn;
    rai_info_company_name_cn->left_cardinalities[0] = table_company_name.GetStorage().info->cardinality;
    // rai_info_company_name_cn->compact_list = &rai_info_company_name_cn->rai->alist->compact__list;

    join_condition_company_name_cn.rais.push_back(move(rai_info_company_name_cn));
    cond_company_name_cn.push_back(move(join_condition_company_name_cn));

    LogicalComparisonJoin join_company_name_cn_op(JoinType::INNER);
    vector<LogicalType> output_company_name_cn_types{LogicalType::BIGINT, LogicalType::VARCHAR,
                                                     LogicalType::BIGINT, LogicalType::VARCHAR,
                                                     LogicalType::BIGINT};
    join_company_name_cn_op.types = output_company_name_cn_types;
    vector<idx_t> right_projection_map_company_name_cn{0, 1, 3};
    vector<idx_t> merge_project_map_company_name_cn;
    vector<LogicalType> delim_types_company_name_cn;
    auto join_company_name_cn = make_uniq<PhysicalMergeSIPJoin>(join_company_name_cn_op, move(scan_company_name_cn), move(join_title_t),
                                                           move(cond_company_name_cn), JoinType::INNER,
                                                           left_projection_map, right_projection_map_company_name_cn,
                                                           merge_project_map_company_name_cn,
                                                           delim_types_company_name_cn, 0);


    vector<idx_t> char_name_chn_ids{COLUMN_IDENTIFIER_ROW_ID, 1};
    vector<LogicalType> get_char_name_chn_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_char_name_chn = "chn";
    vector<LogicalType> table_types_char_name_chn;
    vector<unique_ptr<Expression>> filter_char_name_chn;
    unique_ptr<LogicalGet> get_op_char_name_chn = move(
            getLogicalGet(*this, table_char_name, alias_char_name_chn, table_index_char_name_chn,
                          table_types_char_name_chn));
    unique_ptr<TableFilterSet> table_filters_char_name_chn = NULL;
    unique_ptr<PhysicalTableScan> scan_char_name_chn = make_uniq<PhysicalTableScan>(get_char_name_chn_types,
                                                                                    get_op_char_name_chn->function,
                                                                                    get_op_char_name_chn->table_index,
                                                                                    move(get_op_char_name_chn->bind_data),
                                                                                    table_types_char_name_chn,
                                                                                    char_name_chn_ids,
                                                                                    move(filter_char_name_chn),
                                                                                    vector<column_t>(),
                                                                                    get_op_char_name_chn->names,
                                                                                    std::move(
                                                                                            table_filters_char_name_chn),
                                                                                    get_op_char_name_chn->estimated_cardinality,
                                                                                    get_op_char_name_chn->extra_info);


    vector<JoinCondition> cond_cast_info_chn;
    JoinCondition join_condition_cast_info_chn;
    join_condition_cast_info_chn.left = make_uniq<BoundReferenceExpression>("char_name_rowid", LogicalType::BIGINT, 0);
    join_condition_cast_info_chn.right = make_uniq<BoundReferenceExpression>("person_role_id_rowid", LogicalType::BIGINT, 4);
    join_condition_cast_info_chn.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_cast_info_chn = make_uniq<RAIInfo>();
    rai_info_cast_info_chn->rai = table_cast_info.GetStorage().info->rais[3].get();
    rai_info_cast_info_chn->rai_type = RAIType::TARGET_EDGE;
    rai_info_cast_info_chn->forward = true;
    rai_info_cast_info_chn->vertex = &table_char_name;
    rai_info_cast_info_chn->vertex_id = table_index_char_name_chn;
    rai_info_cast_info_chn->passing_tables[0] = table_index_char_name_chn;
    rai_info_cast_info_chn->left_cardinalities[0] = table_char_name.GetStorage().info->cardinality;
    // rai_info_cast_info_chn->compact_list = &rai_info_cast_info_chn->rai->alist->compact__list;

    join_condition_cast_info_chn.rais.push_back(move(rai_info_cast_info_chn));
    cond_cast_info_chn.push_back(move(join_condition_cast_info_chn));

    LogicalComparisonJoin join_cast_info_chn_op(JoinType::INNER);
    vector<LogicalType> output_cast_info_chn_types{LogicalType::BIGINT, LogicalType::VARCHAR,
                                                   LogicalType::BIGINT, LogicalType::VARCHAR};
    join_cast_info_chn_op.types = output_cast_info_chn_types;
    vector<idx_t> right_projection_map_cast_info_chn{2, 3};
    vector<idx_t> merge_project_map_cast_info_chn;
    vector<LogicalType> delim_types_cast_info_chn;
    auto join_cast_info_chn = make_uniq<PhysicalSIPJoin>(join_cast_info_chn_op, move(scan_char_name_chn), move(join_company_name_cn), move(cond_cast_info_chn),
                                                           JoinType::INNER, left_projection_map,
                                                           right_projection_map_cast_info_chn,
                                                           delim_types_cast_info_chn, 0);


    vector<idx_t> company_type_ct_ids{COLUMN_IDENTIFIER_ROW_ID};
    vector<LogicalType> get_company_type_ct_types{LogicalType::BIGINT};
    string alias_company_type_ct = "ct";
    vector<LogicalType> table_types_company_type_ct;
    vector<unique_ptr<Expression>> filter_company_type_ct;
    unique_ptr<LogicalGet> get_op_company_type_ct = move(
            getLogicalGet(*this, table_company_type, alias_company_type_ct, table_index_company_type_ct,
                          table_types_company_type_ct));
    unique_ptr<TableFilterSet> table_filters_company_type_ct = NULL;
    unique_ptr<PhysicalTableScan> scan_company_type_ct = make_uniq<PhysicalTableScan>(get_company_type_ct_types,
                                                                                      get_op_company_type_ct->function,
                                                                                      get_op_company_type_ct->table_index,
                                                                                      move(get_op_company_type_ct->bind_data),
                                                                                      table_types_company_type_ct,
                                                                                      company_type_ct_ids,
                                                                                      move(filter_company_type_ct),
                                                                                      vector<column_t>(),
                                                                                      get_op_company_type_ct->names,
                                                                                      std::move(
                                                                                              table_filters_company_type_ct),
                                                                                      get_op_company_type_ct->estimated_cardinality,
                                                                                      get_op_company_type_ct->extra_info);


    vector<JoinCondition> cond_movie_companies_;
    JoinCondition join_condition_movie_companies_;
    join_condition_movie_companies_.left = make_uniq<BoundReferenceExpression>("company_type_rowid", LogicalType::BIGINT, 0);
    join_condition_movie_companies_.right = make_uniq<BoundReferenceExpression>("title_rowid", LogicalType::BIGINT, 2);
    join_condition_movie_companies_.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_movie_companies_ = make_uniq<RAIInfo>();
    rai_info_movie_companies_->rai = table_movie_companies.GetStorage().info->rais[1].get();
    rai_info_movie_companies_->rai_type = RAIType::SOURCE_EDGE;
    rai_info_movie_companies_->forward = false;
    rai_info_movie_companies_->vertex = &table_company_type;
    rai_info_movie_companies_->vertex_id = table_index_company_type_ct;
    rai_info_movie_companies_->passing_tables[0] = table_index_company_type_ct;
    rai_info_movie_companies_->left_cardinalities[0] = table_company_type.GetStorage().info->cardinality;
    // rai_info_movie_companies_->compact_list = &rai_info_movie_companies_->rai->alist->compact__list;

    join_condition_movie_companies_.rais.push_back(move(rai_info_movie_companies_));
    cond_movie_companies_.push_back(move(join_condition_movie_companies_));

    LogicalComparisonJoin join_movie_companies__op(JoinType::INNER);
    vector<LogicalType> output_movie_companies__types{LogicalType::BIGINT, LogicalType::VARCHAR,
                                                      LogicalType::VARCHAR};
    join_movie_companies__op.types = output_movie_companies__types;
    vector<idx_t> right_projection_map_movie_companies_{1, 3};
    vector<idx_t> merge_project_map_movie_companies_;
    vector<LogicalType> delim_types_movie_companies_;
    auto join_movie_companies_ = make_uniq<PhysicalMergeSIPJoin>(join_movie_companies__op, move(scan_company_type_ct), move(join_cast_info_chn),
                                                                 move(cond_movie_companies_), JoinType::INNER,
                                                                 left_projection_map,
                                                                 right_projection_map_movie_companies_,
                                                                 merge_project_map_movie_companies_,
                                                                 delim_types_movie_companies_, 0);


    vector<LogicalType> result_types{LogicalType::VARCHAR, LogicalType::VARCHAR};
    vector<unique_ptr<Expression>> select_list;
    auto result_col0 = make_uniq<BoundReferenceExpression>("name", LogicalType::VARCHAR, 1);
    auto result_col1 = make_uniq<BoundReferenceExpression>("title", LogicalType::VARCHAR, 2);
    select_list.push_back(move(result_col0));
    select_list.push_back(move(result_col1));
    auto projection = make_uniq<PhysicalProjection>(result_types, move(select_list), 0);
    projection->children.push_back(move(join_movie_companies_));

    // aggregate
    string agg_name = "min";
    string agg_error = "";
    QueryErrorContext error_context(NULL, NULL);
    auto min_func = Catalog::GetEntry(context, CatalogType::SCALAR_FUNCTION_ENTRY, "", "",
                                      "min", OnEntryNotFound::RETURN_NULL, error_context);
    auto &min_func_set = min_func->Cast<AggregateFunctionCatalogEntry>();
    // bind the aggregate
    FunctionBinder function_binder(context);
    vector<LogicalType> types;
    types.push_back(LogicalType::VARCHAR);
    idx_t best_function_varchar = function_binder.BindFunction(agg_name, min_func_set.functions, types, agg_error);
    auto bound_function_min_varchar = min_func_set.functions.GetFunctionByOffset(best_function_varchar);

    auto first_children = make_uniq<BoundReferenceExpression>("name", LogicalType::VARCHAR, 0);
    vector<unique_ptr<Expression>> childrenlist1;
    childrenlist1.push_back(move(first_children));
    auto aggregate1 =
            function_binder.BindAggregateFunction(bound_function_min_varchar, std::move(childrenlist1), nullptr,
                                                  AggregateType::NON_DISTINCT);

    auto second_children = make_uniq<BoundReferenceExpression>("title", LogicalType::VARCHAR, 1);
    vector<unique_ptr<Expression>> childrenlist2;
    childrenlist2.push_back(move(second_children));
    auto aggregate2 =
            function_binder.BindAggregateFunction(bound_function_min_varchar, std::move(childrenlist2), nullptr,
                                                  AggregateType::NON_DISTINCT);

    vector<unique_ptr<Expression>> aggregates;
    aggregates.push_back(move(aggregate1));
    aggregates.push_back(move(aggregate2));

    vector<LogicalType> aggregate_types{LogicalType::VARCHAR, LogicalType::VARCHAR};
    auto ungrouped_aggregate = make_uniq<PhysicalUngroupedAggregate>(aggregate_types, move(aggregates), 0);
    ungrouped_aggregate->children.push_back(move(projection));

    return ungrouped_aggregate;
}

unique_ptr<PhysicalOperator> ClientContext::GenerateJOB11aPlan(duckdb::ClientContext &context) {
    vector<idx_t> left_projection_map, right_projection_map;

    string table_vertex_keyword_k = "keyword";
    string table_vertex_title_t = "title";
    string table_vertex_link_type_lt = "link_type";
    string table_vertex_company_type_ct = "company_type";
    string table_vertex_company_name_cn = "company_name";
    string table_vertex_movie_keyword_ = "movie_keyword";
    string table_vertex_movie_link_ = "movie_link";
    string table_vertex_movie_companies_ = "movie_companies";

    idx_t table_index_keyword_k = 1;
    idx_t table_index_title_t = 2;
    idx_t table_index_link_type_lt = 3;
    idx_t table_index_company_type_ct = 4;
    idx_t table_index_company_name_cn = 5;
    idx_t table_index_movie_keyword_ = 6;
    idx_t table_index_movie_link_ = 7;
    idx_t table_index_movie_companies_ = 9;

    auto table_or_view_keyword = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_keyword_k,
                                                   OnEntryNotFound::RETURN_NULL);
    auto &table_keyword = table_or_view_keyword->Cast<TableCatalogEntry>();
    auto table_or_view_title = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_title_t,
                                                 OnEntryNotFound::RETURN_NULL);
    auto &table_title = table_or_view_title->Cast<TableCatalogEntry>();
    auto table_or_view_link_type = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_link_type_lt,
                                                     OnEntryNotFound::RETURN_NULL);
    auto &table_link_type = table_or_view_link_type->Cast<TableCatalogEntry>();
    auto table_or_view_company_type = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                        table_vertex_company_type_ct, OnEntryNotFound::RETURN_NULL);
    auto &table_company_type = table_or_view_company_type->Cast<TableCatalogEntry>();
    auto table_or_view_company_name = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                        table_vertex_company_name_cn, OnEntryNotFound::RETURN_NULL);
    auto &table_company_name = table_or_view_company_name->Cast<TableCatalogEntry>();
    auto table_or_view_movie_keyword = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                         table_vertex_movie_keyword_, OnEntryNotFound::RETURN_NULL);
    auto &table_movie_keyword = table_or_view_movie_keyword->Cast<TableCatalogEntry>();
    auto table_or_view_movie_link = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_movie_link_,
                                                      OnEntryNotFound::RETURN_NULL);
    auto &table_movie_link = table_or_view_movie_link->Cast<TableCatalogEntry>();
    auto table_or_view_movie_companies = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                           table_vertex_movie_companies_, OnEntryNotFound::RETURN_NULL);
    auto &table_movie_companies = table_or_view_movie_companies->Cast<TableCatalogEntry>();

    vector<idx_t> link_type_lt_ids{COLUMN_IDENTIFIER_ROW_ID, 1};
    vector<LogicalType> get_link_type_lt_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_link_type_lt = "lt";
    vector<LogicalType> table_types_link_type_lt;
    vector<unique_ptr<Expression>> filter_link_type_lt;
    unique_ptr<LogicalGet> get_op_link_type_lt = move(
            getLogicalGet(*this, table_link_type, alias_link_type_lt, table_index_link_type_lt,
                          table_types_link_type_lt));
    unique_ptr<TableFilterSet> table_filters_link_type_lt = NULL;
    unique_ptr<PhysicalTableScan> scan_link_type_lt = make_uniq<PhysicalTableScan>(get_link_type_lt_types,
                                                                                   get_op_link_type_lt->function,
                                                                                   get_op_link_type_lt->table_index,
                                                                                   move(get_op_link_type_lt->bind_data),
                                                                                   table_types_link_type_lt,
                                                                                   link_type_lt_ids,
                                                                                   move(filter_link_type_lt),
                                                                                   vector<column_t>(),
                                                                                   get_op_link_type_lt->names,
                                                                                   std::move(
                                                                                           table_filters_link_type_lt),
                                                                                   get_op_link_type_lt->estimated_cardinality,
                                                                                   get_op_link_type_lt->extra_info);

    vector<LogicalType> filter_link_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    vector<unique_ptr<Expression>> select_list_link;
    auto link_like_expression_left = make_uniq<BoundReferenceExpression>("link", LogicalType::VARCHAR, 1);
    auto link_like_expression_value = make_uniq<BoundConstantExpression>(Value("follow"));
    vector<unique_ptr<Expression>> link_like_arguments;
    link_like_arguments.push_back(move(link_like_expression_left));
    link_like_arguments.push_back(move(link_like_expression_value));

    QueryErrorContext error_context_like(NULL, NULL);
    ScalarFunction link_bound_function_contains = ContainsFun::GetFunction();
    unique_ptr<FunctionData> link_bind_data_contains = NULL;

    auto link_like_bound_function = make_uniq<BoundFunctionExpression>(LogicalType::BOOLEAN,
                                                                       link_bound_function_contains,
                                                                       move(link_like_arguments),
                                                                       move(link_bind_data_contains), false);


    select_list_link.push_back(move(link_like_bound_function));
    unique_ptr<PhysicalFilter> filter_link_contains = make_uniq<PhysicalFilter>(filter_link_types, move(select_list_link), 0);
    filter_link_contains->children.push_back(move(scan_link_type_lt));

    idx_t p_production_year1 = 1950;
    idx_t p_production_year2 = 2000;
    Value p_year1 = Value::BIGINT(p_production_year1);
    Value p_year2 = Value::BIGINT(p_production_year2);
    vector<idx_t> title_t_ids{COLUMN_IDENTIFIER_ROW_ID, 1, 4};
    vector<LogicalType> get_title_t_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::BIGINT};
    string alias_title_t = "t";
    vector<LogicalType> table_types_title_t;
    vector<unique_ptr<Expression>> filter_title_t;
    unique_ptr<LogicalGet> get_op_title_t = move(
            getLogicalGet(*this, table_title, alias_title_t, table_index_title_t, table_types_title_t));
    unique_ptr<TableFilterSet> table_filters_title_t = make_uniq<TableFilterSet>();
    unique_ptr<ConjunctionAndFilter> and_filter_title = duckdb::make_uniq<ConjunctionAndFilter>();
    unique_ptr<ConstantFilter> constant_filter_title_start = duckdb::make_uniq<ConstantFilter>(
            ExpressionType::COMPARE_GREATERTHANOREQUALTO, p_year1);
    unique_ptr<ConstantFilter> constant_filter_title_end = duckdb::make_uniq<ConstantFilter>(
            ExpressionType::COMPARE_LESSTHANOREQUALTO, p_year2);
    and_filter_title->child_filters.push_back(move(constant_filter_title_start));
    and_filter_title->child_filters.push_back(move(constant_filter_title_end));
    table_filters_title_t->filters[2] = move(and_filter_title);
    unique_ptr<PhysicalTableScan> scan_title_t = make_uniq<PhysicalTableScan>(get_title_t_types,
                                                                              get_op_title_t->function,
                                                                              get_op_title_t->table_index,
                                                                              move(get_op_title_t->bind_data),
                                                                              table_types_title_t, title_t_ids,
                                                                              move(filter_title_t), vector<column_t>(),
                                                                              get_op_title_t->names,
                                                                              std::move(table_filters_title_t),
                                                                              get_op_title_t->estimated_cardinality,
                                                                              get_op_title_t->extra_info);


    vector<JoinCondition> cond_title_t;
    JoinCondition join_condition_title_t;
    join_condition_title_t.left = make_uniq<BoundReferenceExpression>("title_rowid", LogicalType::BIGINT, 0);
    join_condition_title_t.right = make_uniq<BoundReferenceExpression>("link_type_rowid", LogicalType::BIGINT, 0);
    join_condition_title_t.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_title_t = make_uniq<RAIInfo>();
    rai_info_title_t->rai = table_movie_link.GetStorage().info->rais[0].get();
    rai_info_title_t->rai_type = RAIType::TARGET_EDGE;
    rai_info_title_t->forward = true;
    rai_info_title_t->vertex = &table_title;
    rai_info_title_t->vertex_id = table_index_title_t;
    rai_info_title_t->passing_tables[0] = table_index_title_t;
    rai_info_title_t->left_cardinalities[0] = table_title.GetStorage().info->cardinality;
    // rai_info_title_t->compact_list = &rai_info_title_t->rai->alist->compact__list;

    join_condition_title_t.rais.push_back(move(rai_info_title_t));
    cond_title_t.push_back(move(join_condition_title_t));

    LogicalComparisonJoin join_title_t_op(JoinType::INNER);
    vector<LogicalType> output_title_t_types{LogicalType::BIGINT, LogicalType::VARCHAR,
                                             LogicalType::BIGINT, LogicalType::VARCHAR};
    join_title_t_op.types = output_title_t_types;
    vector<idx_t> right_projection_map_title_t{1};
    vector<idx_t> merge_project_map_title_t;
    vector<LogicalType> delim_types_title_t;
    auto join_title_t = make_uniq<PhysicalMergeSIPJoin>(join_title_t_op, move(scan_title_t), move(filter_link_contains), move(cond_title_t), JoinType::INNER,
                                                   left_projection_map, right_projection_map_title_t,
                                                   merge_project_map_title_t, delim_types_title_t, 0);


    vector<idx_t> mc_ids{4, 5, 6, 7};
    vector<LogicalType> get_mc_types{LogicalType::VARCHAR, LogicalType::BIGINT,
                                     LogicalType::BIGINT, LogicalType::BIGINT};
    string alias_mc = "mc";
    vector<LogicalType> table_types_mc;
    vector<unique_ptr<Expression>> filter_mc;
    unique_ptr<LogicalGet> get_op_mc = move(
            getLogicalGet(*this, table_movie_companies, alias_mc, table_index_movie_companies_,
                          table_types_mc));
    unique_ptr<TableFilterSet> table_filters_mc = NULL;
    unique_ptr<PhysicalTableScan> scan_mc = make_uniq<PhysicalTableScan>(get_mc_types,
                                                                                   get_op_mc->function,
                                                                                   get_op_mc->table_index,
                                                                                   move(get_op_mc->bind_data),
                                                                                   table_types_mc,
                                                                                   mc_ids,
                                                                                   move(filter_mc),
                                                                                   vector<column_t>(),
                                                                                   get_op_mc->names,
                                                                                   std::move(
                                                                                           table_filters_mc),
                                                                                   get_op_mc->estimated_cardinality,
                                                                                   get_op_mc->extra_info);


    vector<JoinCondition> cond_movie_companies_;
    JoinCondition join_condition_movie_companies_;
    join_condition_movie_companies_.left = make_uniq<BoundReferenceExpression>("movie_id_rowid", LogicalType::BIGINT, 2);
    join_condition_movie_companies_.right = make_uniq<BoundReferenceExpression>("title_rowid", LogicalType::BIGINT, 0);
    join_condition_movie_companies_.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_movie_companies_ = make_uniq<RAIInfo>();
    rai_info_movie_companies_->rai = table_movie_companies.GetStorage().info->rais[0].get();
    rai_info_movie_companies_->rai_type = RAIType::EDGE_TARGET;
    rai_info_movie_companies_->forward = false;
    rai_info_movie_companies_->vertex = &table_title;
    rai_info_movie_companies_->vertex_id = table_index_title_t;
    rai_info_movie_companies_->passing_tables[0] = table_index_movie_companies_;
    rai_info_movie_companies_->left_cardinalities[0] = table_movie_companies.GetStorage().info->cardinality;
    rai_info_movie_companies_->compact_list = &rai_info_movie_companies_->rai->alist->compact_backward_list;

    join_condition_movie_companies_.rais.push_back(move(rai_info_movie_companies_));
    cond_movie_companies_.push_back(move(join_condition_movie_companies_));

    LogicalComparisonJoin join_movie_companies__op(JoinType::INNER);
    vector<LogicalType> output_movie_companies__types{LogicalType::VARCHAR, LogicalType::BIGINT, LogicalType::BIGINT,
                                                      LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::VARCHAR};
    join_movie_companies__op.types = output_movie_companies__types;
    vector<idx_t> right_projection_map_movie_companies_{1, 3};
    vector<idx_t> merge_project_map_movie_companies_;
    vector<LogicalType> delim_types_movie_companies_;
    auto join_movie_companies_ = make_uniq<PhysicalSIPJoin>(join_movie_companies__op, move(scan_mc), move(join_title_t),
                                                                 move(cond_movie_companies_), JoinType::INNER,
                                                                 left_projection_map,
                                                                 right_projection_map_movie_companies_,
                                                                 delim_types_movie_companies_, 0);

    vector<LogicalType> filter_note_types{LogicalType::VARCHAR, LogicalType::BIGINT, LogicalType::BIGINT,
                                          LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::VARCHAR};
    vector<unique_ptr<Expression>> select_list_note;

    auto note_null_bound_function = make_uniq<BoundOperatorExpression>(ExpressionType::OPERATOR_IS_NULL, LogicalType::BOOLEAN);
    auto note_null = make_uniq<BoundReferenceExpression>("note", LogicalType::VARCHAR, 0);
    note_null_bound_function->children.push_back(move(note_null));

    select_list_note.push_back(move(note_null_bound_function));
    unique_ptr<PhysicalFilter> filter_note_contains = make_uniq<PhysicalFilter>(filter_note_types, move(select_list_note), 0);
    filter_note_contains->children.push_back(move(join_movie_companies_));


    string p_kind_n = "production companies";
    Value p_kind = Value(p_kind_n);
    vector<idx_t> company_type_ct_ids{COLUMN_IDENTIFIER_ROW_ID, 1};
    vector<LogicalType> get_company_type_ct_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_company_type_ct = "ct";
    vector<LogicalType> table_types_company_type_ct;
    vector<unique_ptr<Expression>> filter_company_type_ct;
    unique_ptr<LogicalGet> get_op_company_type_ct = move(
            getLogicalGet(*this, table_company_type, alias_company_type_ct, table_index_company_type_ct,
                          table_types_company_type_ct));
    unique_ptr<TableFilterSet> table_filters_company_type_ct = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_kind = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL, p_kind);
    table_filters_company_type_ct->filters[1] = move(constant_filter_kind);
    unique_ptr<PhysicalTableScan> scan_company_type_ct = make_uniq<PhysicalTableScan>(get_company_type_ct_types,
                                                                                      get_op_company_type_ct->function,
                                                                                      get_op_company_type_ct->table_index,
                                                                                      move(get_op_company_type_ct->bind_data),
                                                                                      table_types_company_type_ct,
                                                                                      company_type_ct_ids,
                                                                                      move(filter_company_type_ct),
                                                                                      vector<column_t>(),
                                                                                      get_op_company_type_ct->names,
                                                                                      std::move(
                                                                                              table_filters_company_type_ct),
                                                                                      get_op_company_type_ct->estimated_cardinality,
                                                                                      get_op_company_type_ct->extra_info);


    vector<JoinCondition> cond_company_type_ct;
    JoinCondition join_condition_company_type_ct;
    join_condition_company_type_ct.left = make_uniq<BoundReferenceExpression>("company_type_rowid", LogicalType::BIGINT, 0);
    join_condition_company_type_ct.right = make_uniq<BoundReferenceExpression>("company_type_id_rowid", LogicalType::BIGINT, 3);
    join_condition_company_type_ct.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_company_type_ct = make_uniq<RAIInfo>();
    rai_info_company_type_ct->rai = table_movie_companies.GetStorage().info->rais[1].get();
    rai_info_company_type_ct->rai_type = RAIType::SOURCE_EDGE;
    rai_info_company_type_ct->forward = false;
    rai_info_company_type_ct->vertex = &table_company_type;
    rai_info_company_type_ct->vertex_id = table_index_company_type_ct;
    rai_info_company_type_ct->passing_tables[0] = table_index_company_type_ct;
    rai_info_company_type_ct->left_cardinalities[0] = table_company_type.GetStorage().info->cardinality;
    // rai_info_company_type_ct->compact_list = &rai_info_company_type_ct->rai->alist->compact__list;

    join_condition_company_type_ct.rais.push_back(move(rai_info_company_type_ct));
    cond_company_type_ct.push_back(move(join_condition_company_type_ct));

    LogicalComparisonJoin join_company_type_ct_op(JoinType::INNER);
    vector<LogicalType> output_company_type_ct_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::BIGINT,
                                                     LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::VARCHAR};
    join_company_type_ct_op.types = output_company_type_ct_types;
    vector<idx_t> right_projection_map_company_type_ct{1, 2, 4, 5};
    vector<idx_t> merge_project_map_company_type_ct;
    vector<LogicalType> delim_types_company_type_ct;
    auto join_company_type_ct = make_uniq<PhysicalSIPJoin>(join_company_type_ct_op, move(scan_company_type_ct), move(filter_note_contains),
                                                           move(cond_company_type_ct), JoinType::INNER,
                                                           left_projection_map, right_projection_map_company_type_ct,
                                                           delim_types_company_type_ct, 0);


    string p_country_code_n = "[pl]";
    Value p_code = Value(p_country_code_n);
    vector<idx_t> company_name_cn_ids{COLUMN_IDENTIFIER_ROW_ID, 2, 1};
    vector<LogicalType> get_company_name_cn_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::VARCHAR};
    string alias_company_name_cn = "cn";
    vector<LogicalType> table_types_company_name_cn;
    vector<unique_ptr<Expression>> filter_company_name_cn;
    unique_ptr<LogicalGet> get_op_company_name_cn = move(
            getLogicalGet(*this, table_company_name, alias_company_name_cn, table_index_company_name_cn,
                          table_types_company_name_cn));
    unique_ptr<TableFilterSet> table_filters_company_name_cn = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_cn = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_NOTEQUAL, p_code);
    table_filters_company_name_cn->filters[1] = move(constant_filter_cn);
    unique_ptr<PhysicalTableScan> scan_company_name_cn = make_uniq<PhysicalTableScan>(get_company_name_cn_types,
                                                                                      get_op_company_name_cn->function,
                                                                                      get_op_company_name_cn->table_index,
                                                                                      move(get_op_company_name_cn->bind_data),
                                                                                      table_types_company_name_cn,
                                                                                      company_name_cn_ids,
                                                                                      move(filter_company_name_cn),
                                                                                      vector<column_t>(),
                                                                                      get_op_company_name_cn->names,
                                                                                      std::move(
                                                                                              table_filters_company_name_cn),
                                                                                      get_op_company_name_cn->estimated_cardinality,
                                                                                      get_op_company_name_cn->extra_info);

    vector<LogicalType> filter_name_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::VARCHAR};
    vector<unique_ptr<Expression>> select_list_name;
    auto name_left = make_uniq<BoundReferenceExpression>("name", LogicalType::VARCHAR, 2);
    auto name_value = make_uniq<BoundConstantExpression>(Value("Film"));
    vector<unique_ptr<Expression>> name_left_arguments;
    name_left_arguments.push_back(move(name_left));
    name_left_arguments.push_back(move(name_value));

    unique_ptr<FunctionData> name_left_bind_data_contains = NULL;
    auto name_left_bound_function = make_uniq<BoundFunctionExpression>(LogicalType::BOOLEAN,
                                                                    link_bound_function_contains,
                                                                    move(name_left_arguments),
                                                                    move(name_left_bind_data_contains), false);


    auto name_right = make_uniq<BoundReferenceExpression>("name", LogicalType::VARCHAR, 2);
    auto name_value_right = make_uniq<BoundConstantExpression>(Value("Warner"));
    vector<unique_ptr<Expression>> name_right_arguments;
    name_right_arguments.push_back(move(name_right));
    name_right_arguments.push_back(move(name_value_right));

    unique_ptr<FunctionData> name_right_bind_data_contains = NULL;
    auto name_right_bound_function = make_uniq<BoundFunctionExpression>(LogicalType::BOOLEAN,
                                                                    link_bound_function_contains,
                                                                    move(name_right_arguments),
                                                                    move(name_right_bind_data_contains), false);

    auto or_conjunction = make_uniq<BoundConjunctionExpression>(ExpressionType::CONJUNCTION_OR);
    or_conjunction->children.push_back(move(name_left_bound_function));
    or_conjunction->children.push_back(move(name_right_bound_function));

    select_list_name.push_back(move(or_conjunction));
    unique_ptr<PhysicalFilter> filter_name = make_uniq<PhysicalFilter>(filter_name_types, move(select_list_name), 0);
    filter_name->children.push_back(move(scan_company_name_cn));


    vector<JoinCondition> cond_company_name_cn;
    JoinCondition join_condition_company_name_cn;
    join_condition_company_name_cn.left = make_uniq<BoundReferenceExpression>("company_name_rowid", LogicalType::BIGINT, 0);
    join_condition_company_name_cn.right = make_uniq<BoundReferenceExpression>("company_id_rowid", LogicalType::BIGINT, 2);
    join_condition_company_name_cn.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_company_name_cn = make_uniq<RAIInfo>();
    rai_info_company_name_cn->rai = table_movie_companies.GetStorage().info->rais[0].get();
    rai_info_company_name_cn->rai_type = RAIType::SOURCE_EDGE;
    rai_info_company_name_cn->forward = false;
    rai_info_company_name_cn->vertex = &table_company_name;
    rai_info_company_name_cn->vertex_id = table_index_company_name_cn;
    rai_info_company_name_cn->passing_tables[0] = table_index_company_name_cn;
    rai_info_company_name_cn->left_cardinalities[0] = table_company_name.GetStorage().info->cardinality;
    // rai_info_company_name_cn->compact_list = &rai_info_company_name_cn->rai->alist->compact__list;

    join_condition_company_name_cn.rais.push_back(move(rai_info_company_name_cn));
    cond_company_name_cn.push_back(move(join_condition_company_name_cn));

    LogicalComparisonJoin join_company_name_cn_op(JoinType::INNER);
    vector<LogicalType> output_company_name_cn_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::VARCHAR,
                                                     LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::VARCHAR};
    join_company_name_cn_op.types = output_company_name_cn_types;
    vector<idx_t> right_projection_map_company_name_cn{3, 4, 5};
    vector<idx_t> merge_project_map_company_name_cn;
    vector<LogicalType> delim_types_company_name_cn;
    auto join_company_name_cn = make_uniq<PhysicalSIPJoin>(join_company_name_cn_op, move(filter_name), move(join_company_type_ct),
                                                           move(cond_company_name_cn), JoinType::INNER,
                                                           left_projection_map, right_projection_map_company_name_cn,
                                                           delim_types_company_name_cn, 0);



    string p_keyword_n = "sequel";
    Value p_keyword = Value(p_keyword_n);
    vector<idx_t> keyword_k_ids{COLUMN_IDENTIFIER_ROW_ID, 1};
    vector<LogicalType> get_keyword_k_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_keyword_k = "k";
    vector<LogicalType> table_types_keyword_k;
    vector<unique_ptr<Expression>> filter_keyword_k;
    unique_ptr<LogicalGet> get_op_keyword_k = move(
            getLogicalGet(*this, table_keyword, alias_keyword_k, table_index_keyword_k, table_types_keyword_k));
    unique_ptr<TableFilterSet> table_filters_keyword_k = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_k = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL, p_keyword);
    table_filters_keyword_k->filters[1] = move(constant_filter_k);
    unique_ptr<PhysicalTableScan> scan_keyword_k = make_uniq<PhysicalTableScan>(get_keyword_k_types,
                                                                                get_op_keyword_k->function,
                                                                                get_op_keyword_k->table_index,
                                                                                move(get_op_keyword_k->bind_data),
                                                                                table_types_keyword_k, keyword_k_ids,
                                                                                move(filter_keyword_k),
                                                                                vector<column_t>(),
                                                                                get_op_keyword_k->names,
                                                                                std::move(table_filters_keyword_k),
                                                                                get_op_keyword_k->estimated_cardinality,
                                                                                get_op_keyword_k->extra_info);


    vector<JoinCondition> cond_keyword_k;
    JoinCondition join_condition_keyword_k;
    join_condition_keyword_k.left = make_uniq<BoundReferenceExpression>("keyword_rowid", LogicalType::BIGINT, 0);
    join_condition_keyword_k.right = make_uniq<BoundReferenceExpression>("movie_id_rowid", LogicalType::BIGINT, 3);
    join_condition_keyword_k.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_keyword_k = make_uniq<RAIInfo>();
    rai_info_keyword_k->rai = table_movie_keyword.GetStorage().info->rais[0].get();
    rai_info_keyword_k->rai_type = RAIType::SOURCE_EDGE;
    rai_info_keyword_k->forward = false;
    rai_info_keyword_k->vertex = &table_keyword;
    rai_info_keyword_k->vertex_id = table_index_keyword_k;
    rai_info_keyword_k->passing_tables[0] = table_index_keyword_k;
    rai_info_keyword_k->left_cardinalities[0] = table_keyword.GetStorage().info->cardinality;
    // rai_info_keyword_k->compact_list = &rai_info_keyword_k->rai->alist->compact__list;

    join_condition_keyword_k.rais.push_back(move(rai_info_keyword_k));
    cond_keyword_k.push_back(move(join_condition_keyword_k));

    LogicalComparisonJoin join_keyword_k_op(JoinType::INNER);
    vector<LogicalType> output_keyword_k_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::VARCHAR,
                                               LogicalType::VARCHAR, LogicalType::VARCHAR};
    join_keyword_k_op.types = output_keyword_k_types;
    vector<idx_t> right_projection_map_keyword_k{2, 4, 5};
    vector<idx_t> merge_project_map_keyword_k;
    vector<LogicalType> delim_types_keyword_k;
    auto join_keyword_k = make_uniq<PhysicalMergeSIPJoin>(join_keyword_k_op, move(scan_keyword_k), move(join_company_name_cn), move(cond_keyword_k),
                                                     JoinType::INNER, left_projection_map,
                                                     right_projection_map_keyword_k,
                                                     merge_project_map_keyword_k,
                                                     delim_types_keyword_k, 0);


    vector<LogicalType> result_types{LogicalType::VARCHAR, LogicalType::VARCHAR, LogicalType::VARCHAR};
    vector<unique_ptr<Expression>> select_list;
    auto result_col0 = make_uniq<BoundReferenceExpression>("name", LogicalType::VARCHAR, 2);
    auto result_col1 = make_uniq<BoundReferenceExpression>("link", LogicalType::VARCHAR, 4);
    auto result_col2 = make_uniq<BoundReferenceExpression>("title", LogicalType::VARCHAR, 3);
    select_list.push_back(move(result_col0));
    select_list.push_back(move(result_col1));
    select_list.push_back(move(result_col2));
    auto projection = make_uniq<PhysicalProjection>(result_types, move(select_list), 0);
    projection->children.push_back(move(join_keyword_k));

    // aggregate
    string agg_name = "min";
    string agg_error = "";
    QueryErrorContext error_context(NULL, NULL);
    auto min_func = Catalog::GetEntry(context, CatalogType::SCALAR_FUNCTION_ENTRY, "", "",
                                      "min", OnEntryNotFound::RETURN_NULL, error_context);
    auto& min_func_set = min_func->Cast<AggregateFunctionCatalogEntry>();
    // bind the aggregate
    FunctionBinder function_binder(context);
    vector<LogicalType> types;
    types.push_back(LogicalType::VARCHAR);
    idx_t best_function_varchar = function_binder.BindFunction(agg_name, min_func_set.functions, types, agg_error);
    auto bound_function_min_varchar = min_func_set.functions.GetFunctionByOffset(best_function_varchar);

    auto first_children = make_uniq<BoundReferenceExpression>("name", LogicalType::VARCHAR, 0);
    vector<unique_ptr<Expression>> childrenlist1;
    childrenlist1.push_back(move(first_children));
    auto aggregate1 =
            function_binder.BindAggregateFunction(bound_function_min_varchar, std::move(childrenlist1), nullptr, AggregateType::NON_DISTINCT);

    auto second_children = make_uniq<BoundReferenceExpression>("link", LogicalType::VARCHAR, 1);
    vector<unique_ptr<Expression>> childrenlist2;
    childrenlist2.push_back(move(second_children));
    auto aggregate2 =
            function_binder.BindAggregateFunction(bound_function_min_varchar, std::move(childrenlist2), nullptr, AggregateType::NON_DISTINCT);

    auto third_children = make_uniq<BoundReferenceExpression>("title", LogicalType::VARCHAR, 2);
    vector<unique_ptr<Expression>> childrenlist3;
    childrenlist3.push_back(move(third_children));
    auto aggregate3 =
            function_binder.BindAggregateFunction(bound_function_min_varchar, std::move(childrenlist3), nullptr, AggregateType::NON_DISTINCT);

    vector<unique_ptr<Expression>> aggregates;
    aggregates.push_back(move(aggregate1));
    aggregates.push_back(move(aggregate2));
    aggregates.push_back(move(aggregate3));

    vector<LogicalType> aggregate_types{LogicalType::VARCHAR, LogicalType::VARCHAR, LogicalType::VARCHAR};
    auto ungrouped_aggregate = make_uniq<PhysicalUngroupedAggregate>(aggregate_types, move(aggregates), 0);
    ungrouped_aggregate->children.push_back(move(projection));

    return ungrouped_aggregate;
}

unique_ptr<PhysicalOperator> ClientContext::GenerateJOB12aPlan(duckdb::ClientContext &context) {
    vector<idx_t> left_projection_map, right_projection_map;

    string table_vertex_info_type_it1 = "info_type";
    string table_vertex_title_t = "title";
    string table_vertex_company_type_ct = "company_type";
    string table_vertex_info_type_it2 = "info_type";
    string table_vertex_company_name_cn = "company_name";
    string table_vertex_movie_info_ = "movie_info";
    string table_vertex_movie_companies_ = "movie_companies";
    string table_vertex_movie_info_idx_ = "movie_info_idx";

    idx_t table_index_info_type_it1 = 1;
    idx_t table_index_title_t = 2;
    idx_t table_index_company_type_ct = 3;
    idx_t table_index_info_type_it2 = 4;
    idx_t table_index_company_name_cn = 5;
    idx_t table_index_movie_info_ = 6;
    idx_t table_index_movie_companies_ = 9;
    idx_t table_index_movie_info_idx_ = 8;

    auto table_or_view_info_type = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                     table_vertex_info_type_it1, OnEntryNotFound::RETURN_NULL);
    auto &table_info_type = table_or_view_info_type->Cast<TableCatalogEntry>();
    auto table_or_view_title = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_title_t,
                                                 OnEntryNotFound::RETURN_NULL);
    auto &table_title = table_or_view_title->Cast<TableCatalogEntry>();
    auto table_or_view_company_type = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                        table_vertex_company_type_ct, OnEntryNotFound::RETURN_NULL);
    auto &table_company_type = table_or_view_company_type->Cast<TableCatalogEntry>();
    auto table_or_view_company_name = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                        table_vertex_company_name_cn, OnEntryNotFound::RETURN_NULL);
    auto &table_company_name = table_or_view_company_name->Cast<TableCatalogEntry>();
    auto table_or_view_movie_info = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_movie_info_,
                                                      OnEntryNotFound::RETURN_NULL);
    auto &table_movie_info = table_or_view_movie_info->Cast<TableCatalogEntry>();
    auto table_or_view_movie_companies = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                           table_vertex_movie_companies_, OnEntryNotFound::RETURN_NULL);
    auto &table_movie_companies = table_or_view_movie_companies->Cast<TableCatalogEntry>();
    auto table_or_view_movie_info_idx = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                          table_vertex_movie_info_idx_, OnEntryNotFound::RETURN_NULL);
    auto &table_movie_info_idx = table_or_view_movie_info_idx->Cast<TableCatalogEntry>();

    string p_info_n2 = "rating";
    Value p_info2 = Value(p_info_n2);
    vector<idx_t> info_type_it2_ids{COLUMN_IDENTIFIER_ROW_ID, 1};
    vector<LogicalType> get_info_type_it2_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_info_type_it2 = "it2";
    vector<LogicalType> table_types_info_type_it2;
    vector<unique_ptr<Expression>> filter_info_type_it2;
    unique_ptr<LogicalGet> get_op_info_type_it2 = move(
            getLogicalGet(*this, table_info_type, alias_info_type_it2, table_index_info_type_it2,
                          table_types_info_type_it2));
    unique_ptr<TableFilterSet> table_filters_info_type_it2 = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_it2 = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL, p_info2);
    table_filters_info_type_it2->filters[1] = move(constant_filter_it2);
    unique_ptr<PhysicalTableScan> scan_info_type_it2 = make_uniq<PhysicalTableScan>(get_info_type_it2_types,
                                                                                    get_op_info_type_it2->function,
                                                                                    get_op_info_type_it2->table_index,
                                                                                    move(get_op_info_type_it2->bind_data),
                                                                                    table_types_info_type_it2,
                                                                                    info_type_it2_ids,
                                                                                    move(filter_info_type_it2),
                                                                                    vector<column_t>(),
                                                                                    get_op_info_type_it2->names,
                                                                                    std::move(
                                                                                            table_filters_info_type_it2),
                                                                                    get_op_info_type_it2->estimated_cardinality,
                                                                                    get_op_info_type_it2->extra_info);

    string p_idx_info = "8.0";
    Value p_idx = Value(p_idx_info);
    vector<idx_t> movie_info_idx_ids{6, 5, 3};
    vector<LogicalType> get_movie_info_idx_types{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_movie_info_idx = "mi_idx";
    vector<LogicalType> table_types_movie_info_idx;
    vector<unique_ptr<Expression>> filter_movie_info_idx;
    unique_ptr<LogicalGet> get_op_movie_info_idx = move(
            getLogicalGet(*this, table_movie_info_idx, alias_movie_info_idx, table_index_movie_info_idx_,
                          table_types_movie_info_idx));
    unique_ptr<TableFilterSet> table_filters_movie_info_idx = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_mi_idx = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_GREATERTHAN, p_idx);
    table_filters_movie_info_idx->filters[2] = move(constant_filter_mi_idx);
    unique_ptr<PhysicalTableScan> scan_movie_info_idx = make_uniq<PhysicalTableScan>(get_movie_info_idx_types,
                                                                                    get_op_movie_info_idx->function,
                                                                                    get_op_movie_info_idx->table_index,
                                                                                    move(get_op_movie_info_idx->bind_data),
                                                                                    table_types_movie_info_idx,
                                                                                    movie_info_idx_ids,
                                                                                    move(filter_movie_info_idx),
                                                                                    vector<column_t>(),
                                                                                    get_op_movie_info_idx->names,
                                                                                    std::move(
                                                                                            table_filters_movie_info_idx),
                                                                                    get_op_movie_info_idx->estimated_cardinality,
                                                                                    get_op_movie_info_idx->extra_info);

    vector<JoinCondition> cond_movie_info_idx_;
    JoinCondition join_condition_movie_info_idx_;
    join_condition_movie_info_idx_.left = make_uniq<BoundReferenceExpression>("info_type_id_rowid", LogicalType::BIGINT, 1);
    join_condition_movie_info_idx_.right = make_uniq<BoundReferenceExpression>("info_type_rowid", LogicalType::BIGINT, 0);
    join_condition_movie_info_idx_.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_movie_info_idx_ = make_uniq<RAIInfo>();
    rai_info_movie_info_idx_->rai = table_movie_info_idx.GetStorage().info->rais[0].get();
    rai_info_movie_info_idx_->rai_type = RAIType::EDGE_SOURCE;
    rai_info_movie_info_idx_->forward = true;
    rai_info_movie_info_idx_->vertex = &table_info_type;
    rai_info_movie_info_idx_->vertex_id = table_index_info_type_it2;
    rai_info_movie_info_idx_->passing_tables[0] = table_index_movie_info_idx_;
    rai_info_movie_info_idx_->left_cardinalities[0] = table_movie_info_idx.GetStorage().info->cardinality;
    rai_info_movie_info_idx_->compact_list = &rai_info_movie_info_idx_->rai->alist->compact_forward_list;

    join_condition_movie_info_idx_.rais.push_back(move(rai_info_movie_info_idx_));
    cond_movie_info_idx_.push_back(move(join_condition_movie_info_idx_));

    LogicalComparisonJoin join_movie_info_idx__op(JoinType::INNER);
    vector<LogicalType> output_movie_info_idx__types{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::VARCHAR,
                                                     LogicalType::BIGINT};
    join_movie_info_idx__op.types = output_movie_info_idx__types;
    vector<idx_t> right_projection_map_movie_info_idx_{0};
    vector<LogicalType> delim_types_movie_info_idx_;
    auto join_movie_info_idx_ = make_uniq<PhysicalSIPJoin>(join_movie_info_idx__op, move(scan_movie_info_idx), move(scan_info_type_it2),
                                                                move(cond_movie_info_idx_), JoinType::INNER,
                                                                left_projection_map, right_projection_map_movie_info_idx_,
                                                                delim_types_movie_info_idx_, 0);


    idx_t year1 = 2005;
    idx_t year2 = 2008;
    Value p_year1 = Value::BIGINT(year1);
    Value p_year2 = Value::BIGINT(year2);
    vector<idx_t> title_t_ids{COLUMN_IDENTIFIER_ROW_ID, 1, 4};
    vector<LogicalType> get_title_t_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::BIGINT};
    string alias_title_t = "t";
    vector<LogicalType> table_types_title_t;
    vector<unique_ptr<Expression>> filter_title_t;
    unique_ptr<LogicalGet> get_op_title_t = move(
            getLogicalGet(*this, table_title, alias_title_t, table_index_title_t, table_types_title_t));
    unique_ptr<TableFilterSet> table_filters_title_t = make_uniq<TableFilterSet>();
    unique_ptr<ConjunctionAndFilter> and_filter_year = duckdb::make_uniq<ConjunctionAndFilter>();
    unique_ptr<ConstantFilter> constant_filter_year_start = duckdb::make_uniq<ConstantFilter>(
            ExpressionType::COMPARE_GREATERTHANOREQUALTO, p_year1);
    unique_ptr<ConstantFilter> constant_filter_year_end = duckdb::make_uniq<ConstantFilter>(
            ExpressionType::COMPARE_LESSTHANOREQUALTO, p_year2);
    and_filter_year->child_filters.push_back(move(constant_filter_year_start));
    and_filter_year->child_filters.push_back(move(constant_filter_year_end));
    table_filters_title_t->filters[2] = move(and_filter_year);
    unique_ptr<PhysicalTableScan> scan_title_t = make_uniq<PhysicalTableScan>(get_title_t_types,
                                                                              get_op_title_t->function,
                                                                              get_op_title_t->table_index,
                                                                              move(get_op_title_t->bind_data),
                                                                              table_types_title_t, title_t_ids,
                                                                              move(filter_title_t), vector<column_t>(),
                                                                              get_op_title_t->names,
                                                                              std::move(table_filters_title_t),
                                                                              get_op_title_t->estimated_cardinality,
                                                                              get_op_title_t->extra_info);


    vector<JoinCondition> cond_title_t;
    JoinCondition join_condition_title_t;
    join_condition_title_t.left = make_uniq<BoundReferenceExpression>("title_rowid", LogicalType::BIGINT, 0);
    join_condition_title_t.right = make_uniq<BoundReferenceExpression>("movie_id_rowid", LogicalType::BIGINT, 0);
    join_condition_title_t.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_title_t = make_uniq<RAIInfo>();
    rai_info_title_t->rai = table_movie_info_idx.GetStorage().info->rais[0].get();
    rai_info_title_t->rai_type = RAIType::TARGET_EDGE;
    rai_info_title_t->forward = true;
    rai_info_title_t->vertex = &table_title;
    rai_info_title_t->vertex_id = table_index_title_t;
    rai_info_title_t->passing_tables[0] = table_index_title_t;
    rai_info_title_t->left_cardinalities[0] = table_title.GetStorage().info->cardinality;
    // rai_info_title_t->compact_list = &rai_info_title_t->rai->alist->compact__list;

    join_condition_title_t.rais.push_back(move(rai_info_title_t));
    cond_title_t.push_back(move(join_condition_title_t));

    LogicalComparisonJoin join_title_t_op(JoinType::INNER);
    vector<LogicalType> output_title_t_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::BIGINT,
                                             LogicalType::VARCHAR};
    join_title_t_op.types = output_title_t_types;
    vector<idx_t> right_projection_map_title_t{2};
    vector<idx_t> merge_project_map_title_t;
    vector<LogicalType> delim_types_title_t;
    auto join_title_t = make_uniq<PhysicalSIPJoin>(join_title_t_op, move(scan_title_t), move(join_movie_info_idx_), move(cond_title_t), JoinType::INNER,
                                                   left_projection_map, right_projection_map_title_t,
                                                   delim_types_title_t, 0);


    vector<idx_t> movie_info_ids{6, 5, 3};
    vector<LogicalType> get_movie_info_types{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_movie_info = "mi";
    vector<LogicalType> table_types_movie_info;
    vector<unique_ptr<Expression>> filter_movie_info;
    unique_ptr<LogicalGet> get_op_movie_info = move(
            getLogicalGet(*this, table_movie_info, alias_movie_info, table_index_movie_info_,
                          table_types_movie_info));
    unique_ptr<TableFilterSet> table_filters_movie_info = NULL;
    unique_ptr<PhysicalTableScan> scan_movie_info = make_uniq<PhysicalTableScan>(get_movie_info_types,
                                                                                     get_op_movie_info->function,
                                                                                     get_op_movie_info->table_index,
                                                                                     move(get_op_movie_info->bind_data),
                                                                                     table_types_movie_info,
                                                                                     movie_info_ids,
                                                                                     move(filter_movie_info),
                                                                                     vector<column_t>(),
                                                                                     get_op_movie_info->names,
                                                                                     std::move(
                                                                                             table_filters_movie_info),
                                                                                     get_op_movie_info->estimated_cardinality,
                                                                                     get_op_movie_info->extra_info);

    auto &allocator = Allocator::Get(context);
    vector<LogicalType> join_in_types {LogicalType::VARCHAR};
    auto collection =
            make_uniq<ColumnDataCollection>(context, join_in_types, ColumnDataAllocatorType::IN_MEMORY_ALLOCATOR);

    vector<LogicalType> chunk_in_types {LogicalType::VARCHAR};
    DataChunk chunk;
    chunk.SetCardinality(2);
    chunk.Initialize(allocator, chunk_in_types);
    chunk.SetValue(0, 0, Value("Drama"));
    chunk.SetValue(0, 1, Value("Horror"));
    collection->Append(chunk);

    // create a chunk scan to output the result
    vector<LogicalType> ouput_in_types {LogicalType::VARCHAR};
    auto chunk_scan = make_uniq<PhysicalColumnDataScan>(ouput_in_types, PhysicalOperatorType::COLUMN_DATA_SCAN,
                                                        2, std::move(collection));

    vector<JoinCondition> cond_hash_join_;
    JoinCondition join_condition_hash_join_;
    join_condition_hash_join_.left = make_uniq<BoundReferenceExpression>("info", LogicalType::VARCHAR, 2);
    join_condition_hash_join_.right = make_uniq<BoundReferenceExpression>("", LogicalType::VARCHAR, 0);
    join_condition_hash_join_.comparison = ExpressionType::COMPARE_EQUAL;
    cond_hash_join_.push_back(move(join_condition_hash_join_));

    LogicalComparisonJoin join_hash_join_op(JoinType::MARK);
    vector<LogicalType> output_hash_join_types{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::VARCHAR,
                                               LogicalType::BOOLEAN};
    join_hash_join_op.types = output_hash_join_types;
    vector<idx_t> right_projection_map_hash_join_;
    vector<LogicalType> delim_types_hash_join_;
    PerfectHashJoinStats joinstate;
    auto join_hash_join_ = make_uniq<PhysicalHashJoin>(join_hash_join_op, move(scan_movie_info), move(chunk_scan), move(cond_hash_join_),
                                                       JoinType::MARK, left_projection_map,
                                                       right_projection_map_hash_join_,
                                                       delim_types_hash_join_, 0, joinstate);

    vector<LogicalType> filter_in_types{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::VARCHAR,
                                        LogicalType::BOOLEAN};
    vector<unique_ptr<Expression>> select_list_in;
    auto in_exp = make_uniq<BoundReferenceExpression>("IN (...)", LogicalType::BOOLEAN, 3);
    select_list_in.push_back(move(in_exp));
    unique_ptr<PhysicalFilter> filter_in = make_uniq<PhysicalFilter>(filter_in_types, move(select_list_in), 0);
    filter_in->children.push_back(move(join_hash_join_));

    vector<JoinCondition> cond_movie_info_;
    JoinCondition join_condition_movie_info_;
    join_condition_movie_info_.left = make_uniq<BoundReferenceExpression>("movie_id_rowid", LogicalType::BIGINT, 0);
    join_condition_movie_info_.right = make_uniq<BoundReferenceExpression>("title_rowid", LogicalType::BIGINT, 0);
    join_condition_movie_info_.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_movie_info_ = make_uniq<RAIInfo>();
    rai_info_movie_info_->rai = table_movie_info.GetStorage().info->rais[0].get();
    rai_info_movie_info_->rai_type = RAIType::EDGE_TARGET;
    rai_info_movie_info_->forward = false;
    rai_info_movie_info_->vertex = &table_title;
    rai_info_movie_info_->vertex_id = table_index_title_t;
    rai_info_movie_info_->passing_tables[0] = table_index_movie_info_;
    rai_info_movie_info_->left_cardinalities[0] = table_movie_info.GetStorage().info->cardinality;
    rai_info_movie_info_->compact_list = &rai_info_movie_info_->rai->alist->compact_backward_list;

    join_condition_movie_info_.rais.push_back(move(rai_info_movie_info_));
    cond_movie_info_.push_back(move(join_condition_movie_info_));

    LogicalComparisonJoin join_movie_info__op(JoinType::INNER);
    vector<LogicalType> output_movie_info__types{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::VARCHAR,
                                                 LogicalType::BOOLEAN, LogicalType::VARCHAR, LogicalType::VARCHAR};
    join_movie_info__op.types = output_movie_info__types;
    vector<idx_t> right_projection_map_movie_info_{1, 3};
    vector<idx_t> merge_project_map_movie_info_;
    vector<LogicalType> delim_types_movie_info_;
    auto join_movie_info_ = make_uniq<PhysicalSIPJoin>(join_movie_info__op, move(filter_in), move(join_title_t), move(cond_movie_info_),
                                                       JoinType::INNER, left_projection_map,
                                                       right_projection_map_movie_info_,
                                                       delim_types_movie_info_, 0);


    string p_info_n1 = "genres";
    Value p_info1 = Value(p_info_n1);
    vector<idx_t> info_type_it1_ids{COLUMN_IDENTIFIER_ROW_ID, 1};
    vector<LogicalType> get_info_type_it1_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_info_type_it1 = "it1";
    vector<LogicalType> table_types_info_type_it1;
    vector<unique_ptr<Expression>> filter_info_type_it1;
    unique_ptr<LogicalGet> get_op_info_type_it1 = move(
            getLogicalGet(*this, table_info_type, alias_info_type_it1, table_index_info_type_it1,
                          table_types_info_type_it1));
    unique_ptr<TableFilterSet> table_filters_info_type_it1 = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_it1 = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL, p_info1);
    table_filters_info_type_it1->filters[1] = move(constant_filter_it1);
    unique_ptr<PhysicalTableScan> scan_info_type_it1 = make_uniq<PhysicalTableScan>(get_info_type_it1_types,
                                                                                    get_op_info_type_it1->function,
                                                                                    get_op_info_type_it1->table_index,
                                                                                    move(get_op_info_type_it1->bind_data),
                                                                                    table_types_info_type_it1,
                                                                                    info_type_it1_ids,
                                                                                    move(filter_info_type_it1),
                                                                                    vector<column_t>(),
                                                                                    get_op_info_type_it1->names,
                                                                                    std::move(
                                                                                            table_filters_info_type_it1),
                                                                                    get_op_info_type_it1->estimated_cardinality,
                                                                                    get_op_info_type_it1->extra_info);


    vector<JoinCondition> cond_info_type_it1;
    JoinCondition join_condition_info_type_it1;
    join_condition_info_type_it1.left = make_uniq<BoundReferenceExpression>("info_type_rowid", LogicalType::BIGINT, 0);
    join_condition_info_type_it1.right = make_uniq<BoundReferenceExpression>("info_type_id_rowid", LogicalType::BIGINT, 1);
    join_condition_info_type_it1.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_info_type_it1 = make_uniq<RAIInfo>();
    rai_info_info_type_it1->rai = table_movie_info.GetStorage().info->rais[0].get();
    rai_info_info_type_it1->rai_type = RAIType::SOURCE_EDGE;
    rai_info_info_type_it1->forward = false;
    rai_info_info_type_it1->vertex = &table_info_type;
    rai_info_info_type_it1->vertex_id = table_index_info_type_it1;
    rai_info_info_type_it1->passing_tables[0] = table_index_info_type_it1;
    rai_info_info_type_it1->left_cardinalities[0] = table_info_type.GetStorage().info->cardinality;
    // rai_info_info_type_it1->compact_list = &rai_info_info_type_it1->rai->alist->compact__list;

    join_condition_info_type_it1.rais.push_back(move(rai_info_info_type_it1));
    cond_info_type_it1.push_back(move(join_condition_info_type_it1));

    LogicalComparisonJoin join_info_type_it1_op(JoinType::INNER);
    vector<LogicalType> output_info_type_it1_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::BIGINT,
                                                   LogicalType::VARCHAR, LogicalType::VARCHAR};
    join_info_type_it1_op.types = output_info_type_it1_types;
    vector<idx_t> right_projection_map_info_type_it1{0, 4, 5};
    vector<idx_t> merge_project_map_info_type_it1;
    vector<LogicalType> delim_types_info_type_it1;
    auto join_info_type_it1 = make_uniq<PhysicalSIPJoin>(join_info_type_it1_op, move(scan_info_type_it1), move(join_movie_info_),
                                                         move(cond_info_type_it1), JoinType::INNER, left_projection_map,
                                                         right_projection_map_info_type_it1, delim_types_info_type_it1,
                                                         0);

    vector<idx_t> movie_companies_ids{5, 6, 7};
    vector<LogicalType> get_movie_companies_types{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::BIGINT};
    string alias_movie_companies = "ct";
    vector<LogicalType> table_types_movie_companies;
    vector<unique_ptr<Expression>> filter_movie_companies;
    unique_ptr<LogicalGet> get_op_movie_companies = move(
            getLogicalGet(*this, table_movie_companies, alias_movie_companies, table_index_movie_companies_,
                          table_types_movie_companies));
    unique_ptr<TableFilterSet> table_filters_movie_companies = NULL;
    unique_ptr<PhysicalTableScan> scan_movie_companies = make_uniq<PhysicalTableScan>(get_movie_companies_types,
                                                                                      get_op_movie_companies->function,
                                                                                      get_op_movie_companies->table_index,
                                                                                      move(get_op_movie_companies->bind_data),
                                                                                      table_types_movie_companies,
                                                                                      movie_companies_ids,
                                                                                      move(filter_movie_companies),
                                                                                      vector<column_t>(),
                                                                                      get_op_movie_companies->names,
                                                                                      std::move(
                                                                                              table_filters_movie_companies),
                                                                                      get_op_movie_companies->estimated_cardinality,
                                                                                      get_op_movie_companies->extra_info);

    vector<JoinCondition> cond_movie_companies_;
    JoinCondition join_condition_movie_companies_;
    join_condition_movie_companies_.left = make_uniq<BoundReferenceExpression>("movie_id_rowid", LogicalType::BIGINT, 1);
    join_condition_movie_companies_.right = make_uniq<BoundReferenceExpression>("movie_id_rowid", LogicalType::BIGINT, 2);
    join_condition_movie_companies_.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_movie_companies_ = make_uniq<RAIInfo>();
    rai_info_movie_companies_->rai = table_movie_companies.GetStorage().info->rais[0].get();
    rai_info_movie_companies_->rai_type = RAIType::EDGE_TARGET;
    rai_info_movie_companies_->forward = false;
    rai_info_movie_companies_->vertex = &table_title;
    rai_info_movie_companies_->vertex_id = table_index_title_t;
    rai_info_movie_companies_->passing_tables[0] = table_index_movie_companies_;
    rai_info_movie_companies_->left_cardinalities[0] = table_movie_companies.GetStorage().info->cardinality;
    rai_info_movie_companies_->compact_list = &rai_info_movie_companies_->rai->alist->compact_backward_list;

    join_condition_movie_companies_.rais.push_back(move(rai_info_movie_companies_));
    cond_movie_companies_.push_back(move(join_condition_movie_companies_));

    LogicalComparisonJoin join_movie_companies__op(JoinType::INNER);
    vector<LogicalType> output_movie_companies__types{LogicalType::BIGINT, LogicalType::BIGINT,
                                                      LogicalType::BIGINT, LogicalType::VARCHAR,
                                                      LogicalType::VARCHAR};
    join_movie_companies__op.types = output_movie_companies__types;
    vector<idx_t> right_projection_map_movie_companies_{3, 4};
    vector<idx_t> merge_project_map_movie_companies_;
    vector<LogicalType> delim_types_movie_companies_;
    auto join_movie_companies_ = make_uniq<PhysicalSIPJoin>(join_movie_companies__op, move(scan_movie_companies), move(join_info_type_it1),
                                                                 move(cond_movie_companies_), JoinType::INNER, left_projection_map,
                                                                 right_projection_map_movie_companies_, delim_types_movie_companies_, 0);

    string p_country_code = "[us]";
    Value p_code = Value(p_country_code);
    vector<idx_t> company_name_cn_ids{COLUMN_IDENTIFIER_ROW_ID, 2, 1};
    vector<LogicalType> get_company_name_cn_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::VARCHAR};
    string alias_company_name_cn = "cn";
    vector<LogicalType> table_types_company_name_cn;
    vector<unique_ptr<Expression>> filter_company_name_cn;
    unique_ptr<LogicalGet> get_op_company_name_cn = move(
            getLogicalGet(*this, table_company_name, alias_company_name_cn, table_index_company_name_cn,
                          table_types_company_name_cn));
    unique_ptr<TableFilterSet> table_filters_company_name_cn = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_cn = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL, p_code);
    table_filters_company_name_cn->filters[1] = move(constant_filter_cn);
    unique_ptr<PhysicalTableScan> scan_company_name_cn = make_uniq<PhysicalTableScan>(get_company_name_cn_types,
                                                                                      get_op_company_name_cn->function,
                                                                                      get_op_company_name_cn->table_index,
                                                                                      move(get_op_company_name_cn->bind_data),
                                                                                      table_types_company_name_cn,
                                                                                      company_name_cn_ids,
                                                                                      move(filter_company_name_cn),
                                                                                      vector<column_t>(),
                                                                                      get_op_company_name_cn->names,
                                                                                      std::move(
                                                                                              table_filters_company_name_cn),
                                                                                      get_op_company_name_cn->estimated_cardinality,
                                                                                      get_op_company_name_cn->extra_info);


    vector<JoinCondition> cond_company_name_cn;
    JoinCondition join_condition_company_name_cn;
    join_condition_company_name_cn.left = make_uniq<BoundReferenceExpression>("company_name_rowid", LogicalType::BIGINT, 0);
    join_condition_company_name_cn.right = make_uniq<BoundReferenceExpression>("company_id_rowid", LogicalType::BIGINT, 0);
    join_condition_company_name_cn.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_company_name_cn = make_uniq<RAIInfo>();
    rai_info_company_name_cn->rai = table_movie_companies.GetStorage().info->rais[0].get();
    rai_info_company_name_cn->rai_type = RAIType::SOURCE_EDGE;
    rai_info_company_name_cn->forward = false;
    rai_info_company_name_cn->vertex = &table_company_name;
    rai_info_company_name_cn->vertex_id = table_index_company_name_cn;
    rai_info_company_name_cn->passing_tables[0] = table_index_company_name_cn;
    rai_info_company_name_cn->left_cardinalities[0] = table_company_name.GetStorage().info->cardinality;
    // rai_info_company_name_cn->compact_list = &rai_info_company_name_cn->rai->alist->compact__list;

    join_condition_company_name_cn.rais.push_back(move(rai_info_company_name_cn));
    cond_company_name_cn.push_back(move(join_condition_company_name_cn));

    LogicalComparisonJoin join_company_name_cn_op(JoinType::INNER);
    vector<LogicalType> output_company_name_cn_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::VARCHAR,
                                                     LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::VARCHAR};
    join_company_name_cn_op.types = output_company_name_cn_types;
    vector<idx_t> right_projection_map_company_name_cn{2, 3, 4};
    vector<idx_t> merge_project_map_company_name_cn;
    vector<LogicalType> delim_types_company_name_cn;
    auto join_company_name_cn = make_uniq<PhysicalSIPJoin>(join_company_name_cn_op, move(scan_company_name_cn), move(join_movie_companies_),
                                                           move(cond_company_name_cn), JoinType::INNER,
                                                           left_projection_map, right_projection_map_company_name_cn,
                                                           delim_types_company_name_cn, 0);


    string p_kind_n = "production companies";
    Value p_kind = Value(p_kind_n);
    vector<idx_t> company_type_ct_ids{COLUMN_IDENTIFIER_ROW_ID, 1};
    vector<LogicalType> get_company_type_ct_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_company_type_ct = "ct";
    vector<LogicalType> table_types_company_type_ct;
    vector<unique_ptr<Expression>> filter_company_type_ct;
    unique_ptr<LogicalGet> get_op_company_type_ct = move(
            getLogicalGet(*this, table_company_type, alias_company_type_ct, table_index_company_type_ct,
                          table_types_company_type_ct));
    unique_ptr<TableFilterSet> table_filters_company_type_ct = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_ct = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL, p_kind);
    table_filters_company_type_ct->filters[1] = move(constant_filter_ct);
    unique_ptr<PhysicalTableScan> scan_company_type_ct = make_uniq<PhysicalTableScan>(get_company_type_ct_types,
                                                                                      get_op_company_type_ct->function,
                                                                                      get_op_company_type_ct->table_index,
                                                                                      move(get_op_company_type_ct->bind_data),
                                                                                      table_types_company_type_ct,
                                                                                      company_type_ct_ids,
                                                                                      move(filter_company_type_ct),
                                                                                      vector<column_t>(),
                                                                                      get_op_company_type_ct->names,
                                                                                      std::move(
                                                                                              table_filters_company_type_ct),
                                                                                      get_op_company_type_ct->estimated_cardinality,
                                                                                      get_op_company_type_ct->extra_info);


    vector<JoinCondition> cond_company_type_ct;
    JoinCondition join_condition_company_type_ct;
    join_condition_company_type_ct.left = make_uniq<BoundReferenceExpression>("company_type_rowid", LogicalType::BIGINT, 0);
    join_condition_company_type_ct.right = make_uniq<BoundReferenceExpression>("company_type_id_rowid", LogicalType::BIGINT, 3);
    join_condition_company_type_ct.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_company_type_ct = make_uniq<RAIInfo>();
    rai_info_company_type_ct->rai = table_movie_companies.GetStorage().info->rais[1].get();
    rai_info_company_type_ct->rai_type = RAIType::SOURCE_EDGE;
    rai_info_company_type_ct->forward = false;
    rai_info_company_type_ct->vertex = &table_company_type;
    rai_info_company_type_ct->vertex_id = table_index_company_type_ct;
    rai_info_company_type_ct->passing_tables[0] = table_index_company_type_ct;
    rai_info_company_type_ct->left_cardinalities[0] = table_company_type.GetStorage().info->cardinality;
    // rai_info_company_type_ct->compact_list = &rai_info_company_type_ct->rai->alist->compact__list;

    join_condition_company_type_ct.rais.push_back(move(rai_info_company_type_ct));
    cond_company_type_ct.push_back(move(join_condition_company_type_ct));

    LogicalComparisonJoin join_company_type_ct_op(JoinType::INNER);
    vector<LogicalType> output_company_type_ct_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::VARCHAR,
                                                     LogicalType::VARCHAR, LogicalType::VARCHAR};
    join_company_type_ct_op.types = output_company_type_ct_types;
    vector<idx_t> right_projection_map_company_type_ct{2, 4, 5};
    vector<idx_t> merge_project_map_company_type_ct;
    vector<LogicalType> delim_types_company_type_ct;
    auto join_company_type_ct = make_uniq<PhysicalSIPJoin>(join_company_type_ct_op, move(scan_company_type_ct), move(join_company_name_cn),
                                                           move(cond_company_type_ct), JoinType::INNER,
                                                           left_projection_map, right_projection_map_company_type_ct,
                                                           delim_types_company_type_ct, 0);


    vector<LogicalType> result_types{LogicalType::VARCHAR, LogicalType::VARCHAR, LogicalType::VARCHAR};
    vector<unique_ptr<Expression>> select_list;
    auto result_col0 = make_uniq<BoundReferenceExpression>("name", LogicalType::VARCHAR, 2);
    auto result_col1 = make_uniq<BoundReferenceExpression>("info", LogicalType::VARCHAR, 4);
    auto result_col2 = make_uniq<BoundReferenceExpression>("title", LogicalType::VARCHAR, 3);
    select_list.push_back(move(result_col0));
    select_list.push_back(move(result_col1));
    select_list.push_back(move(result_col2));
    auto projection = make_uniq<PhysicalProjection>(result_types, move(select_list), 0);
    projection->children.push_back(move(join_company_type_ct));

    // aggregate
    string agg_name = "min";
    string agg_error = "";
    QueryErrorContext error_context(NULL, NULL);
    auto min_func = Catalog::GetEntry(context, CatalogType::SCALAR_FUNCTION_ENTRY, "", "",
                                      "min", OnEntryNotFound::RETURN_NULL, error_context);
    auto& min_func_set = min_func->Cast<AggregateFunctionCatalogEntry>();
    // bind the aggregate
    FunctionBinder function_binder(context);
    vector<LogicalType> types;
    types.push_back(LogicalType::VARCHAR);
    idx_t best_function_varchar = function_binder.BindFunction(agg_name, min_func_set.functions, types, agg_error);
    auto bound_function_min_varchar = min_func_set.functions.GetFunctionByOffset(best_function_varchar);

    auto first_children = make_uniq<BoundReferenceExpression>("name", LogicalType::VARCHAR, 0);
    vector<unique_ptr<Expression>> childrenlist1;
    childrenlist1.push_back(move(first_children));
    auto aggregate1 =
            function_binder.BindAggregateFunction(bound_function_min_varchar, std::move(childrenlist1), nullptr, AggregateType::NON_DISTINCT);

    auto second_children = make_uniq<BoundReferenceExpression>("info", LogicalType::VARCHAR, 1);
    vector<unique_ptr<Expression>> childrenlist2;
    childrenlist2.push_back(move(second_children));
    auto aggregate2 =
            function_binder.BindAggregateFunction(bound_function_min_varchar, std::move(childrenlist2), nullptr, AggregateType::NON_DISTINCT);

    auto third_children = make_uniq<BoundReferenceExpression>("title", LogicalType::VARCHAR, 2);
    vector<unique_ptr<Expression>> childrenlist3;
    childrenlist3.push_back(move(third_children));
    auto aggregate3 =
            function_binder.BindAggregateFunction(bound_function_min_varchar, std::move(childrenlist3), nullptr, AggregateType::NON_DISTINCT);

    vector<unique_ptr<Expression>> aggregates;
    aggregates.push_back(move(aggregate1));
    aggregates.push_back(move(aggregate2));
    aggregates.push_back(move(aggregate3));

    vector<LogicalType> aggregate_types{LogicalType::VARCHAR, LogicalType::VARCHAR, LogicalType::VARCHAR};
    auto ungrouped_aggregate = make_uniq<PhysicalUngroupedAggregate>(aggregate_types, move(aggregates), 0);
    ungrouped_aggregate->children.push_back(move(projection));

    return ungrouped_aggregate;
}

unique_ptr<PhysicalOperator> ClientContext::GenerateJOB13aPlan(duckdb::ClientContext &context) {
    vector<idx_t> left_projection_map, right_projection_map;

    string table_vertex_info_type_it = "info_type";
    string table_vertex_title_t = "title";
    string table_vertex_info_type_it2 = "info_type";
    string table_vertex_kind_type_kt = "kind_type";
    string table_vertex_company_name_cn = "company_name";
    string table_vertex_company_type_ct = "company_type";
    string table_vertex_movie_info_idx_ = "movie_info_idx";
    string table_vertex_movie_info_ = "movie_info";
    string table_vertex_movie_kind_ = "movie_kind";
    string table_vertex_movie_companies_ = "movie_companies";

    idx_t table_index_info_type_it = 1;
    idx_t table_index_title_t = 2;
    idx_t table_index_info_type_it2 = 3;
    idx_t table_index_kind_type_kt = 4;
    idx_t table_index_company_name_cn = 5;
    idx_t table_index_company_type_ct = 6;
    idx_t table_index_movie_info_idx_ = 7;
    idx_t table_index_movie_info_ = 8;
    idx_t table_index_movie_kind_ = 9;
    idx_t table_index_movie_companies_ = 11;

    auto table_or_view_info_type = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_info_type_it,
                                                     OnEntryNotFound::RETURN_NULL);
    auto &table_info_type = table_or_view_info_type->Cast<TableCatalogEntry>();
    auto table_or_view_title = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_title_t,
                                                 OnEntryNotFound::RETURN_NULL);
    auto &table_title = table_or_view_title->Cast<TableCatalogEntry>();
    auto table_or_view_kind_type = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_kind_type_kt,
                                                     OnEntryNotFound::RETURN_NULL);
    auto &table_kind_type = table_or_view_kind_type->Cast<TableCatalogEntry>();
    auto table_or_view_company_name = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                        table_vertex_company_name_cn, OnEntryNotFound::RETURN_NULL);
    auto &table_company_name = table_or_view_company_name->Cast<TableCatalogEntry>();
    auto table_or_view_company_type = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                        table_vertex_company_type_ct, OnEntryNotFound::RETURN_NULL);
    auto &table_company_type = table_or_view_company_type->Cast<TableCatalogEntry>();
    auto table_or_view_movie_info_idx = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                          table_vertex_movie_info_idx_, OnEntryNotFound::RETURN_NULL);
    auto &table_movie_info_idx = table_or_view_movie_info_idx->Cast<TableCatalogEntry>();
    auto table_or_view_movie_info = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_movie_info_,
                                                      OnEntryNotFound::RETURN_NULL);
    auto &table_movie_info = table_or_view_movie_info->Cast<TableCatalogEntry>();
    auto table_or_view_movie_companies = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                           table_vertex_movie_companies_, OnEntryNotFound::RETURN_NULL);
    auto &table_movie_companies = table_or_view_movie_companies->Cast<TableCatalogEntry>();

    string p_info_n = "rating";
    Value p_info = Value(p_info_n);
    vector<idx_t> info_type_it_ids{COLUMN_IDENTIFIER_ROW_ID, 1};
    vector<LogicalType> get_info_type_it_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_info_type_it = "it";
    vector<LogicalType> table_types_info_type_it;
    vector<unique_ptr<Expression>> filter_info_type_it;
    unique_ptr<LogicalGet> get_op_info_type_it = move(
            getLogicalGet(*this, table_info_type, alias_info_type_it, table_index_info_type_it,
                          table_types_info_type_it));
    unique_ptr<TableFilterSet> table_filters_info_type_it = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_it = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL, p_info);
    table_filters_info_type_it->filters[1] = move(constant_filter_it);
    unique_ptr<PhysicalTableScan> scan_info_type_it = make_uniq<PhysicalTableScan>(get_info_type_it_types,
                                                                                   get_op_info_type_it->function,
                                                                                   get_op_info_type_it->table_index,
                                                                                   move(get_op_info_type_it->bind_data),
                                                                                   table_types_info_type_it,
                                                                                   info_type_it_ids,
                                                                                   move(filter_info_type_it),
                                                                                   vector<column_t>(),
                                                                                   get_op_info_type_it->names,
                                                                                   std::move(
                                                                                           table_filters_info_type_it),
                                                                                   get_op_info_type_it->estimated_cardinality,
                                                                                   get_op_info_type_it->extra_info);


    vector<idx_t> movie_info_idx_ids{6, 5, 3};
    vector<LogicalType> get_movie_info_idx_types{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_movie_info_idx = "mi_idx";
    vector<LogicalType> table_types_movie_info_idx;
    vector<unique_ptr<Expression>> filter_movie_info_idx;
    unique_ptr<LogicalGet> get_op_movie_info_idx = move(
            getLogicalGet(*this, table_movie_info_idx, alias_movie_info_idx, table_index_movie_info_idx_,
                          table_types_movie_info_idx));
    unique_ptr<TableFilterSet> table_filters_movie_info_idx = NULL;
    unique_ptr<PhysicalTableScan> scan_movie_info_idx = make_uniq<PhysicalTableScan>(get_movie_info_idx_types,
                                                                                     get_op_movie_info_idx->function,
                                                                                     get_op_movie_info_idx->table_index,
                                                                                     move(get_op_movie_info_idx->bind_data),
                                                                                     table_types_movie_info_idx,
                                                                                     movie_info_idx_ids,
                                                                                     move(filter_movie_info_idx),
                                                                                     vector<column_t>(),
                                                                                     get_op_movie_info_idx->names,
                                                                                     std::move(
                                                                                             table_filters_movie_info_idx),
                                                                                     get_op_movie_info_idx->estimated_cardinality,
                                                                                     get_op_movie_info_idx->extra_info);

    vector<JoinCondition> cond_movie_info_idx_;
    JoinCondition join_condition_movie_info_idx_;
    join_condition_movie_info_idx_.left = make_uniq<BoundReferenceExpression>("info_type_id_rowid", LogicalType::BIGINT, 1);
    join_condition_movie_info_idx_.right = make_uniq<BoundReferenceExpression>("info_type_rowid", LogicalType::BIGINT, 0);
    join_condition_movie_info_idx_.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_movie_info_idx_ = make_uniq<RAIInfo>();
    rai_info_movie_info_idx_->rai = table_movie_info_idx.GetStorage().info->rais[0].get();
    rai_info_movie_info_idx_->rai_type = RAIType::EDGE_SOURCE;
    rai_info_movie_info_idx_->forward = true;
    rai_info_movie_info_idx_->vertex = &table_info_type;
    rai_info_movie_info_idx_->vertex_id = table_index_info_type_it2;
    rai_info_movie_info_idx_->passing_tables[0] = table_index_movie_info_idx_;
    rai_info_movie_info_idx_->left_cardinalities[0] = table_movie_info_idx.GetStorage().info->cardinality;
    rai_info_movie_info_idx_->compact_list = &rai_info_movie_info_idx_->rai->alist->compact_forward_list;

    join_condition_movie_info_idx_.rais.push_back(move(rai_info_movie_info_idx_));
    cond_movie_info_idx_.push_back(move(join_condition_movie_info_idx_));

    LogicalComparisonJoin join_movie_info_idx__op(JoinType::INNER);
    vector<LogicalType> output_movie_info_idx__types{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::VARCHAR,
                                                     LogicalType::BIGINT};
    join_movie_info_idx__op.types = output_movie_info_idx__types;
    vector<idx_t> right_projection_map_movie_info_idx_{0};
    vector<LogicalType> delim_types_movie_info_idx_;
    auto join_movie_info_idx_ = make_uniq<PhysicalSIPJoin>(join_movie_info_idx__op, move(scan_movie_info_idx), move(scan_info_type_it),
                                                           move(cond_movie_info_idx_), JoinType::INNER,
                                                           left_projection_map, right_projection_map_movie_info_idx_,
                                                           delim_types_movie_info_idx_, 0);


    vector<idx_t> title_t_ids{COLUMN_IDENTIFIER_ROW_ID, 1, 12};
    vector<LogicalType> get_title_t_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::BIGINT};
    string alias_title_t = "t";
    vector<LogicalType> table_types_title_t;
    vector<unique_ptr<Expression>> filter_title_t;
    unique_ptr<LogicalGet> get_op_title_t = move(
            getLogicalGet(*this, table_title, alias_title_t, table_index_title_t, table_types_title_t));
    unique_ptr<TableFilterSet> table_filters_title_t = NULL;
    unique_ptr<PhysicalTableScan> scan_title_t = make_uniq<PhysicalTableScan>(get_title_t_types,
                                                                              get_op_title_t->function,
                                                                              get_op_title_t->table_index,
                                                                              move(get_op_title_t->bind_data),
                                                                              table_types_title_t, title_t_ids,
                                                                              move(filter_title_t), vector<column_t>(),
                                                                              get_op_title_t->names,
                                                                              std::move(table_filters_title_t),
                                                                              get_op_title_t->estimated_cardinality,
                                                                              get_op_title_t->extra_info);


    vector<JoinCondition> cond_title;
    JoinCondition join_condition_title;
    join_condition_title.left = make_uniq<BoundReferenceExpression>("title_rowid", LogicalType::BIGINT, 0);
    join_condition_title.right = make_uniq<BoundReferenceExpression>("movie_id_rowid", LogicalType::BIGINT, 0);
    join_condition_title.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_title = make_uniq<RAIInfo>();
    rai_info_title->rai = table_movie_info_idx.GetStorage().info->rais[0].get();
    rai_info_title->rai_type = RAIType::TARGET_EDGE;
    rai_info_title->forward = true;
    rai_info_title->vertex = &table_title;
    rai_info_title->vertex_id = table_index_title_t;
    rai_info_title->passing_tables[0] = table_index_title_t;
    rai_info_title->left_cardinalities[0] = table_title.GetStorage().info->cardinality;
    // rai_info_title->compact_list = &rai_info_title->rai->alist->compact__list;

    join_condition_title.rais.push_back(move(rai_info_title));
    cond_title.push_back(move(join_condition_title));

    LogicalComparisonJoin join_title_op(JoinType::INNER);
    vector<LogicalType> output_title_types{LogicalType::BIGINT, LogicalType::VARCHAR,
                                           LogicalType::BIGINT, LogicalType::VARCHAR};
    join_title_op.types = output_title_types;
    vector<idx_t> right_projection_map_title{2};
    vector<idx_t> merge_project_map_title;
    vector<LogicalType> delim_types_title;
    auto join_title = make_uniq<PhysicalSIPJoin>(join_title_op, move(scan_title_t), move(join_movie_info_idx_),
                                                                move(cond_title), JoinType::INNER,
                                                                left_projection_map,
                                                                right_projection_map_title,
                                                                delim_types_title, 0);

    vector<idx_t> movie_companies_ids{5, 6, 7};
    vector<LogicalType> get_movie_companies_types{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::BIGINT};
    string alias_movie_companies = "ct";
    vector<LogicalType> table_types_movie_companies;
    vector<unique_ptr<Expression>> filter_movie_companies;
    unique_ptr<LogicalGet> get_op_movie_companies = move(
            getLogicalGet(*this, table_movie_companies, alias_movie_companies, table_index_movie_companies_,
                          table_types_movie_companies));
    unique_ptr<TableFilterSet> table_filters_movie_companies = NULL;
    unique_ptr<PhysicalTableScan> scan_movie_companies = make_uniq<PhysicalTableScan>(get_movie_companies_types,
                                                                                      get_op_movie_companies->function,
                                                                                      get_op_movie_companies->table_index,
                                                                                      move(get_op_movie_companies->bind_data),
                                                                                      table_types_movie_companies,
                                                                                      movie_companies_ids,
                                                                                      move(filter_movie_companies),
                                                                                      vector<column_t>(),
                                                                                      get_op_movie_companies->names,
                                                                                      std::move(
                                                                                              table_filters_movie_companies),
                                                                                      get_op_movie_companies->estimated_cardinality,
                                                                                      get_op_movie_companies->extra_info);

    vector<JoinCondition> cond_movie_companies_;
    JoinCondition join_condition_movie_companies_;
    join_condition_movie_companies_.left = make_uniq<BoundReferenceExpression>("movie_id_rowid", LogicalType::BIGINT, 1);
    join_condition_movie_companies_.right = make_uniq<BoundReferenceExpression>("title_rowid", LogicalType::BIGINT, 0);
    join_condition_movie_companies_.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_movie_companies_ = make_uniq<RAIInfo>();
    rai_info_movie_companies_->rai = table_movie_companies.GetStorage().info->rais[0].get();
    rai_info_movie_companies_->rai_type = RAIType::EDGE_TARGET;
    rai_info_movie_companies_->forward = false;
    rai_info_movie_companies_->vertex = &table_title;
    rai_info_movie_companies_->vertex_id = table_index_title_t;
    rai_info_movie_companies_->passing_tables[0] = table_index_movie_companies_;
    rai_info_movie_companies_->left_cardinalities[0] = table_movie_companies.GetStorage().info->cardinality;
    rai_info_movie_companies_->compact_list = &rai_info_movie_companies_->rai->alist->compact_backward_list;

    join_condition_movie_companies_.rais.push_back(move(rai_info_movie_companies_));
    cond_movie_companies_.push_back(move(join_condition_movie_companies_));

    LogicalComparisonJoin join_movie_companies__op(JoinType::INNER);
    vector<LogicalType> output_movie_companies__types{LogicalType::BIGINT, LogicalType::BIGINT,
                                                      LogicalType::BIGINT, LogicalType::VARCHAR,
                                                      LogicalType::BIGINT, LogicalType::VARCHAR};
    join_movie_companies__op.types = output_movie_companies__types;
    vector<idx_t> right_projection_map_movie_companies_{1, 2, 3};
    vector<idx_t> merge_project_map_movie_companies_;
    vector<LogicalType> delim_types_movie_companies_;
    auto join_movie_companies_ = make_uniq<PhysicalSIPJoin>(join_movie_companies__op, move(scan_movie_companies), move(join_title),
                                                            move(cond_movie_companies_), JoinType::INNER, left_projection_map,
                                                            right_projection_map_movie_companies_, delim_types_movie_companies_, 0);

    string p_country_code = "[de]";
    Value p_code = Value(p_country_code);
    vector<idx_t> company_name_cn_ids{COLUMN_IDENTIFIER_ROW_ID, 2};
    vector<LogicalType> get_company_name_cn_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_company_name_cn = "cn";
    vector<LogicalType> table_types_company_name_cn;
    vector<unique_ptr<Expression>> filter_company_name_cn;
    unique_ptr<LogicalGet> get_op_company_name_cn = move(
            getLogicalGet(*this, table_company_name, alias_company_name_cn, table_index_company_name_cn,
                          table_types_company_name_cn));
    unique_ptr<TableFilterSet> table_filters_company_name_cn = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_cn = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL, p_code);
    table_filters_company_name_cn->filters[1] = move(constant_filter_cn);
    unique_ptr<PhysicalTableScan> scan_company_name_cn = make_uniq<PhysicalTableScan>(get_company_name_cn_types,
                                                                                      get_op_company_name_cn->function,
                                                                                      get_op_company_name_cn->table_index,
                                                                                      move(get_op_company_name_cn->bind_data),
                                                                                      table_types_company_name_cn,
                                                                                      company_name_cn_ids,
                                                                                      move(filter_company_name_cn),
                                                                                      vector<column_t>(),
                                                                                      get_op_company_name_cn->names,
                                                                                      std::move(
                                                                                              table_filters_company_name_cn),
                                                                                      get_op_company_name_cn->estimated_cardinality,
                                                                                      get_op_company_name_cn->extra_info);


    vector<JoinCondition> cond_company_name_cn;
    JoinCondition join_condition_company_name_cn;
    join_condition_company_name_cn.left = make_uniq<BoundReferenceExpression>("company_name_rowid", LogicalType::BIGINT, 0);
    join_condition_company_name_cn.right = make_uniq<BoundReferenceExpression>("company_id_rowid", LogicalType::BIGINT, 0);
    join_condition_company_name_cn.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_company_name_cn = make_uniq<RAIInfo>();
    rai_info_company_name_cn->rai = table_movie_companies.GetStorage().info->rais[0].get();
    rai_info_company_name_cn->rai_type = RAIType::SOURCE_EDGE;
    rai_info_company_name_cn->forward = false;
    rai_info_company_name_cn->vertex = &table_company_name;
    rai_info_company_name_cn->vertex_id = table_index_company_name_cn;
    rai_info_company_name_cn->passing_tables[0] = table_index_company_name_cn;
    rai_info_company_name_cn->left_cardinalities[0] = table_company_name.GetStorage().info->cardinality;
    // rai_info_company_name_cn->compact_list = &rai_info_company_name_cn->rai->alist->compact__list;

    join_condition_company_name_cn.rais.push_back(move(rai_info_company_name_cn));
    cond_company_name_cn.push_back(move(join_condition_company_name_cn));

    LogicalComparisonJoin join_company_name_cn_op(JoinType::INNER);
    vector<LogicalType> output_company_name_cn_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::BIGINT,
                                                     LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::BIGINT, LogicalType::VARCHAR};
    join_company_name_cn_op.types = output_company_name_cn_types;
    vector<idx_t> right_projection_map_company_name_cn{1, 2, 3, 4, 5};
    vector<idx_t> merge_project_map_company_name_cn;
    vector<LogicalType> delim_types_company_name_cn;
    auto join_company_name_cn = make_uniq<PhysicalSIPJoin>(join_company_name_cn_op, move(scan_company_name_cn), move(join_movie_companies_),
                                                           move(cond_company_name_cn), JoinType::INNER,
                                                           left_projection_map, right_projection_map_company_name_cn,
                                                           delim_types_company_name_cn, 0);


    string p_kind_n = "movie";
    Value p_kind = Value(p_kind_n);
    vector<idx_t> kind_type_kt_ids{COLUMN_IDENTIFIER_ROW_ID, 1};
    vector<LogicalType> get_kind_type_kt_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_kind_type_kt = "kt";
    vector<LogicalType> table_types_kind_type_kt;
    vector<unique_ptr<Expression>> filter_kind_type_kt;
    unique_ptr<LogicalGet> get_op_kind_type_kt = move(
            getLogicalGet(*this, table_kind_type, alias_kind_type_kt, table_index_kind_type_kt,
                          table_types_kind_type_kt));
    unique_ptr<TableFilterSet> table_filters_kind_type_kt = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_kt = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL, p_kind);
    table_filters_kind_type_kt->filters[1] = move(constant_filter_kt);
    unique_ptr<PhysicalTableScan> scan_kind_type_kt = make_uniq<PhysicalTableScan>(get_kind_type_kt_types,
                                                                                   get_op_kind_type_kt->function,
                                                                                   get_op_kind_type_kt->table_index,
                                                                                   move(get_op_kind_type_kt->bind_data),
                                                                                   table_types_kind_type_kt,
                                                                                   kind_type_kt_ids,
                                                                                   move(filter_kind_type_kt),
                                                                                   vector<column_t>(),
                                                                                   get_op_kind_type_kt->names,
                                                                                   std::move(
                                                                                           table_filters_kind_type_kt),
                                                                                   get_op_kind_type_kt->estimated_cardinality,
                                                                                   get_op_kind_type_kt->extra_info);


    vector<JoinCondition> cond_kind_type_kt;
    JoinCondition join_condition_kind_type_kt;
    join_condition_kind_type_kt.left = make_uniq<BoundReferenceExpression>("kind_type_rowid", LogicalType::BIGINT, 0);
    join_condition_kind_type_kt.right = make_uniq<BoundReferenceExpression>("kind_id_rowid", LogicalType::BIGINT, 5);
    join_condition_kind_type_kt.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_kind_type_kt = make_uniq<RAIInfo>();
    rai_info_kind_type_kt->rai = table_title.GetStorage().info->rais[0].get();
    rai_info_kind_type_kt->rai_type = RAIType::TARGET_EDGE;
    rai_info_kind_type_kt->forward = true;
    rai_info_kind_type_kt->vertex = &table_kind_type;
    rai_info_kind_type_kt->vertex_id = table_index_kind_type_kt;
    rai_info_kind_type_kt->passing_tables[0] = table_index_kind_type_kt;
    rai_info_kind_type_kt->left_cardinalities[0] = table_kind_type.GetStorage().info->cardinality;
    // rai_info_kind_type_kt->compact_list = &rai_info_kind_type_kt->rai->alist->compact__list;

    join_condition_kind_type_kt.rais.push_back(move(rai_info_kind_type_kt));
    cond_kind_type_kt.push_back(move(join_condition_kind_type_kt));

    LogicalComparisonJoin join_kind_type_kt_op(JoinType::INNER);
    vector<LogicalType> output_kind_type_kt_types{LogicalType::BIGINT, LogicalType::VARCHAR,
                                                  LogicalType::BIGINT, LogicalType::BIGINT,
                                                  LogicalType::VARCHAR, LogicalType::VARCHAR};
    join_kind_type_kt_op.types = output_kind_type_kt_types;
    vector<idx_t> right_projection_map_kind_type_kt{2, 3, 4, 6};
    vector<idx_t> merge_project_map_kind_type_kt;
    vector<LogicalType> delim_types_kind_type_kt;
    auto join_kind_type_kt = make_uniq<PhysicalSIPJoin>(join_kind_type_kt_op, move(scan_kind_type_kt), move(join_company_name_cn), move(cond_kind_type_kt),
                                                        JoinType::INNER, left_projection_map,
                                                        right_projection_map_kind_type_kt, delim_types_kind_type_kt, 0);

    string p_ct_kind_n = "production companies";
    Value p_ct_kind = Value(p_ct_kind_n);
    vector<idx_t> company_type_ct_ids{COLUMN_IDENTIFIER_ROW_ID, 1};
    vector<LogicalType> get_company_type_ct_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_company_type_ct = "ct";
    vector<LogicalType> table_types_company_type_ct;
    vector<unique_ptr<Expression>> filter_company_type_ct;
    unique_ptr<LogicalGet> get_op_company_type_ct = move(
            getLogicalGet(*this, table_company_type, alias_company_type_ct, table_index_company_type_ct,
                          table_types_company_type_ct));
    unique_ptr<TableFilterSet> table_filters_company_type_ct = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_ct = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL, p_ct_kind);
    table_filters_company_type_ct->filters[1] = move(constant_filter_ct);
    unique_ptr<PhysicalTableScan> scan_company_type_ct = make_uniq<PhysicalTableScan>(get_company_type_ct_types,
                                                                                      get_op_company_type_ct->function,
                                                                                      get_op_company_type_ct->table_index,
                                                                                      move(get_op_company_type_ct->bind_data),
                                                                                      table_types_company_type_ct,
                                                                                      company_type_ct_ids,
                                                                                      move(filter_company_type_ct),
                                                                                      vector<column_t>(),
                                                                                      get_op_company_type_ct->names,
                                                                                      std::move(
                                                                                              table_filters_company_type_ct),
                                                                                      get_op_company_type_ct->estimated_cardinality,
                                                                                      get_op_company_type_ct->extra_info);


    vector<JoinCondition> cond_company_type_ct;
    JoinCondition join_condition_company_type_ct;
    join_condition_company_type_ct.left = make_uniq<BoundReferenceExpression>("company_type_rowid", LogicalType::BIGINT, 0);
    join_condition_company_type_ct.right = make_uniq<BoundReferenceExpression>("company_type_id_rowid", LogicalType::BIGINT, 3);
    join_condition_company_type_ct.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_company_type_ct = make_uniq<RAIInfo>();
    rai_info_company_type_ct->rai = table_movie_companies.GetStorage().info->rais[1].get();
    rai_info_company_type_ct->rai_type = RAIType::SOURCE_EDGE;
    rai_info_company_type_ct->forward = false;
    rai_info_company_type_ct->vertex = &table_company_type;
    rai_info_company_type_ct->vertex_id = table_index_company_type_ct;
    rai_info_company_type_ct->passing_tables[0] = table_index_company_type_ct;
    rai_info_company_type_ct->left_cardinalities[0] = table_company_type.GetStorage().info->cardinality;
    // rai_info_company_type_ct->compact_list = &rai_info_company_type_ct->rai->alist->compact__list;

    join_condition_company_type_ct.rais.push_back(move(rai_info_company_type_ct));
    cond_company_type_ct.push_back(move(join_condition_company_type_ct));

    LogicalComparisonJoin join_company_type_ct_op(JoinType::INNER);
    vector<LogicalType> output_company_type_ct_types{LogicalType::BIGINT, LogicalType::VARCHAR,
                                                     LogicalType::BIGINT, LogicalType::VARCHAR,
                                                     LogicalType::VARCHAR};
    join_company_type_ct_op.types = output_company_type_ct_types;
    vector<idx_t> right_projection_map_company_type_ct{2, 4, 5};
    vector<idx_t> merge_project_map_company_type_ct;
    vector<LogicalType> delim_types_company_type_ct;
    auto join_company_type_ct = make_uniq<PhysicalSIPJoin>(join_company_type_ct_op, move(scan_company_type_ct), move(join_kind_type_kt),
                                                           move(cond_company_type_ct), JoinType::INNER,
                                                           left_projection_map, right_projection_map_company_type_ct,
                                                           delim_types_company_type_ct, 0);


    vector<idx_t> movie_info_ids{6, 5, 3};
    vector<LogicalType> get_movie_info_types{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_movie_info = "mi";
    vector<LogicalType> table_types_movie_info;
    vector<unique_ptr<Expression>> filter_movie_info;
    unique_ptr<LogicalGet> get_op_movie_info = move(
            getLogicalGet(*this, table_movie_info, alias_movie_info, table_index_movie_info_,
                          table_types_movie_info));
    unique_ptr<TableFilterSet> table_filters_movie_info = NULL;
    unique_ptr<PhysicalTableScan> scan_movie_info = make_uniq<PhysicalTableScan>(get_movie_info_types,
                                                                                 get_op_movie_info->function,
                                                                                 get_op_movie_info->table_index,
                                                                                 move(get_op_movie_info->bind_data),
                                                                                 table_types_movie_info,
                                                                                 movie_info_ids,
                                                                                 move(filter_movie_info),
                                                                                 vector<column_t>(),
                                                                                 get_op_movie_info->names,
                                                                                 std::move(
                                                                                         table_filters_movie_info),
                                                                                 get_op_movie_info->estimated_cardinality,
                                                                                 get_op_movie_info->extra_info);


    vector<JoinCondition> cond_movie_info_;
    JoinCondition join_condition_movie_info_;
    join_condition_movie_info_.left = make_uniq<BoundReferenceExpression>("movie_id_rowid", LogicalType::BIGINT, 0);
    join_condition_movie_info_.right = make_uniq<BoundReferenceExpression>("movie_id_rowid", LogicalType::BIGINT, 2);
    join_condition_movie_info_.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_movie_info_ = make_uniq<RAIInfo>();
    rai_info_movie_info_->rai = table_movie_info.GetStorage().info->rais[0].get();
    rai_info_movie_info_->rai_type = RAIType::EDGE_TARGET;
    rai_info_movie_info_->forward = false;
    rai_info_movie_info_->vertex = &table_title;
    rai_info_movie_info_->vertex_id = table_index_title_t;
    rai_info_movie_info_->passing_tables[0] = table_index_movie_info_;
    rai_info_movie_info_->left_cardinalities[0] = table_movie_info.GetStorage().info->cardinality;
    rai_info_movie_info_->compact_list = &rai_info_movie_info_->rai->alist->compact_backward_list;

    join_condition_movie_info_.rais.push_back(move(rai_info_movie_info_));
    cond_movie_info_.push_back(move(join_condition_movie_info_));

    LogicalComparisonJoin join_movie_info__op(JoinType::INNER);
    vector<LogicalType> output_movie_info__types{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::VARCHAR,
                                                 LogicalType::VARCHAR, LogicalType::VARCHAR};
    join_movie_info__op.types = output_movie_info__types;
    vector<idx_t> right_projection_map_movie_info_{3, 4};
    vector<idx_t> merge_project_map_movie_info_;
    vector<LogicalType> delim_types_movie_info_;
    auto join_movie_info_ = make_uniq<PhysicalSIPJoin>(join_movie_info__op, move(scan_movie_info), move(join_company_type_ct), move(cond_movie_info_),
                                                       JoinType::INNER, left_projection_map,
                                                       right_projection_map_movie_info_,
                                                       delim_types_movie_info_, 0);


    string p_info_n2 = "release dates";
    Value p_info2 = Value(p_info_n2);
    vector<idx_t> info_type_it2_ids{COLUMN_IDENTIFIER_ROW_ID, 1};
    vector<LogicalType> get_info_type_it2_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_info_type_it2 = "it2";
    vector<LogicalType> table_types_info_type_it2;
    vector<unique_ptr<Expression>> filter_info_type_it2;
    unique_ptr<LogicalGet> get_op_info_type_it2 = move(
            getLogicalGet(*this, table_info_type, alias_info_type_it2, table_index_info_type_it2,
                          table_types_info_type_it2));
    unique_ptr<TableFilterSet> table_filters_info_type_it2 = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_it2 = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL, p_info2);
    table_filters_info_type_it2->filters[1] = move(constant_filter_it2);
    unique_ptr<PhysicalTableScan> scan_info_type_it2 = make_uniq<PhysicalTableScan>(get_info_type_it2_types,
                                                                                    get_op_info_type_it2->function,
                                                                                    get_op_info_type_it2->table_index,
                                                                                    move(get_op_info_type_it2->bind_data),
                                                                                    table_types_info_type_it2,
                                                                                    info_type_it2_ids,
                                                                                    move(filter_info_type_it2),
                                                                                    vector<column_t>(),
                                                                                    get_op_info_type_it2->names,
                                                                                    std::move(
                                                                                            table_filters_info_type_it2),
                                                                                    get_op_info_type_it2->estimated_cardinality,
                                                                                    get_op_info_type_it2->extra_info);


    vector<JoinCondition> cond_info_type_it2;
    JoinCondition join_condition_info_type_it2;
    join_condition_info_type_it2.left = make_uniq<BoundReferenceExpression>("info_type_rowid", LogicalType::BIGINT, 0);
    join_condition_info_type_it2.right = make_uniq<BoundReferenceExpression>("info_type_id_rowid", LogicalType::BIGINT, 1);
    join_condition_info_type_it2.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_info_type_it2 = make_uniq<RAIInfo>();
    rai_info_info_type_it2->rai = table_movie_info.GetStorage().info->rais[0].get();
    rai_info_info_type_it2->rai_type = RAIType::SOURCE_EDGE;
    rai_info_info_type_it2->forward = false;
    rai_info_info_type_it2->vertex = &table_info_type;
    rai_info_info_type_it2->vertex_id = table_index_info_type_it2;
    rai_info_info_type_it2->passing_tables[0] = table_index_info_type_it2;
    rai_info_info_type_it2->left_cardinalities[0] = table_info_type.GetStorage().info->cardinality;
    // rai_info_info_type_it2->compact_list = &rai_info_info_type_it2->rai->alist->compact__list;

    join_condition_info_type_it2.rais.push_back(move(rai_info_info_type_it2));
    cond_info_type_it2.push_back(move(join_condition_info_type_it2));

    LogicalComparisonJoin join_info_type_it2_op(JoinType::INNER);
    vector<LogicalType> output_info_type_it2_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::VARCHAR,
                                                   LogicalType::VARCHAR, LogicalType::VARCHAR};
    join_info_type_it2_op.types = output_info_type_it2_types;
    vector<idx_t> right_projection_map_info_type_it2{2, 3, 4};
    vector<idx_t> merge_project_map_info_type_it2;
    vector<LogicalType> delim_types_info_type_it2;
    auto join_info_type_it2 = make_uniq<PhysicalSIPJoin>(join_info_type_it2_op, move(scan_info_type_it2), move(join_movie_info_),
                                                         move(cond_info_type_it2), JoinType::INNER, left_projection_map,
                                                         right_projection_map_info_type_it2, delim_types_info_type_it2,
                                                         0);


    vector<LogicalType> result_types{LogicalType::VARCHAR, LogicalType::VARCHAR, LogicalType::VARCHAR};
    vector<unique_ptr<Expression>> select_list;
    auto result_col0 = make_uniq<BoundReferenceExpression>("info", LogicalType::VARCHAR, 2);
    auto result_col1 = make_uniq<BoundReferenceExpression>("info", LogicalType::VARCHAR, 4);
    auto result_col2 = make_uniq<BoundReferenceExpression>("title", LogicalType::VARCHAR, 3);
    select_list.push_back(move(result_col0));
    select_list.push_back(move(result_col1));
    select_list.push_back(move(result_col2));
    auto projection = make_uniq<PhysicalProjection>(result_types, move(select_list), 0);
    projection->children.push_back(move(join_info_type_it2));

    // aggregate
    string agg_name = "min";
    string agg_error = "";
    QueryErrorContext error_context(NULL, NULL);
    auto min_func = Catalog::GetEntry(context, CatalogType::SCALAR_FUNCTION_ENTRY, "", "",
                                      "min", OnEntryNotFound::RETURN_NULL, error_context);
    auto& min_func_set = min_func->Cast<AggregateFunctionCatalogEntry>();
    // bind the aggregate
    FunctionBinder function_binder(context);
    vector<LogicalType> types;
    types.push_back(LogicalType::VARCHAR);
    idx_t best_function_varchar = function_binder.BindFunction(agg_name, min_func_set.functions, types, agg_error);
    auto bound_function_min_varchar = min_func_set.functions.GetFunctionByOffset(best_function_varchar);

    auto first_children = make_uniq<BoundReferenceExpression>("name", LogicalType::VARCHAR, 0);
    vector<unique_ptr<Expression>> childrenlist1;
    childrenlist1.push_back(move(first_children));
    auto aggregate1 =
            function_binder.BindAggregateFunction(bound_function_min_varchar, std::move(childrenlist1), nullptr, AggregateType::NON_DISTINCT);

    auto second_children = make_uniq<BoundReferenceExpression>("info", LogicalType::VARCHAR, 1);
    vector<unique_ptr<Expression>> childrenlist2;
    childrenlist2.push_back(move(second_children));
    auto aggregate2 =
            function_binder.BindAggregateFunction(bound_function_min_varchar, std::move(childrenlist2), nullptr, AggregateType::NON_DISTINCT);

    auto third_children = make_uniq<BoundReferenceExpression>("title", LogicalType::VARCHAR, 2);
    vector<unique_ptr<Expression>> childrenlist3;
    childrenlist3.push_back(move(third_children));
    auto aggregate3 =
            function_binder.BindAggregateFunction(bound_function_min_varchar, std::move(childrenlist3), nullptr, AggregateType::NON_DISTINCT);

    vector<unique_ptr<Expression>> aggregates;
    aggregates.push_back(move(aggregate1));
    aggregates.push_back(move(aggregate2));
    aggregates.push_back(move(aggregate3));

    vector<LogicalType> aggregate_types{LogicalType::VARCHAR, LogicalType::VARCHAR, LogicalType::VARCHAR};
    auto ungrouped_aggregate = make_uniq<PhysicalUngroupedAggregate>(aggregate_types, move(aggregates), 0);
    ungrouped_aggregate->children.push_back(move(projection));

    return ungrouped_aggregate;
}

unique_ptr<PhysicalOperator> ClientContext::GenerateJOB14aPlan(duckdb::ClientContext &context) {
    vector<idx_t> left_projection_map, right_projection_map;

    string table_vertex_info_type_it2 = "info_type";
    string table_vertex_title_t = "title";
    string table_vertex_info_type_it1 = "info_type";
    string table_vertex_kind_type_kt = "kind_type";
    string table_vertex_keyword_k = "keyword";
    string table_vertex_movie_info_idx_ = "movie_info_idx";
    string table_vertex_movie_info_ = "movie_info";
    string table_vertex_movie_kind_ = "movie_kind";
    string table_vertex_movie_keyword_ = "movie_keyword";

    idx_t table_index_info_type_it2 = 1;
    idx_t table_index_title_t = 2;
    idx_t table_index_info_type_it1 = 3;
    idx_t table_index_kind_type_kt = 4;
    idx_t table_index_keyword_k = 5;
    idx_t table_index_movie_info_idx_ = 6;
    idx_t table_index_movie_info_ = 7;
    idx_t table_index_movie_kind_ = 8;
    idx_t table_index_movie_keyword_ = 9;
    auto table_or_view_info_type = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                     table_vertex_info_type_it2, OnEntryNotFound::RETURN_NULL);
    auto &table_info_type = table_or_view_info_type->Cast<TableCatalogEntry>();
    auto table_or_view_title = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_title_t,
                                                 OnEntryNotFound::RETURN_NULL);
    auto &table_title = table_or_view_title->Cast<TableCatalogEntry>();
    auto table_or_view_kind_type = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_kind_type_kt,
                                                     OnEntryNotFound::RETURN_NULL);
    auto &table_kind_type = table_or_view_kind_type->Cast<TableCatalogEntry>();
    auto table_or_view_keyword = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_keyword_k,
                                                   OnEntryNotFound::RETURN_NULL);
    auto &table_keyword = table_or_view_keyword->Cast<TableCatalogEntry>();
    auto table_or_view_movie_info_idx = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                          table_vertex_movie_info_idx_, OnEntryNotFound::RETURN_NULL);
    auto &table_movie_info_idx = table_or_view_movie_info_idx->Cast<TableCatalogEntry>();
    auto table_or_view_movie_info = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_movie_info_,
                                                      OnEntryNotFound::RETURN_NULL);
    auto &table_movie_info = table_or_view_movie_info->Cast<TableCatalogEntry>();
    auto table_or_view_movie_keyword = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                         table_vertex_movie_keyword_, OnEntryNotFound::RETURN_NULL);
    auto &table_movie_keyword = table_or_view_movie_keyword->Cast<TableCatalogEntry>();


    string p_info_n2 = "rating";
    Value p_person = Value(p_info_n2);
    vector<idx_t> info_type_it2_ids{COLUMN_IDENTIFIER_ROW_ID, 1};
    vector<LogicalType> get_info_type_it2_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_info_type_it2 = "it2";
    vector<LogicalType> table_types_info_type_it2;
    vector<unique_ptr<Expression>> filter_info_type_it2;
    unique_ptr<LogicalGet> get_op_info_type_it2 = move(
            getLogicalGet(*this, table_info_type, alias_info_type_it2, table_index_info_type_it2,
                          table_types_info_type_it2));
    unique_ptr<TableFilterSet> table_filters_info_type_it2 = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_it2 = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL, p_info_n2);
    table_filters_info_type_it2->filters[1] = move(constant_filter_it2);
    unique_ptr<PhysicalTableScan> scan_info_type_it2 = make_uniq<PhysicalTableScan>(get_info_type_it2_types,
                                                                                    get_op_info_type_it2->function,
                                                                                    get_op_info_type_it2->table_index,
                                                                                    move(get_op_info_type_it2->bind_data),
                                                                                    table_types_info_type_it2,
                                                                                    info_type_it2_ids,
                                                                                    move(filter_info_type_it2),
                                                                                    vector<column_t>(),
                                                                                    get_op_info_type_it2->names,
                                                                                    std::move(
                                                                                            table_filters_info_type_it2),
                                                                                    get_op_info_type_it2->estimated_cardinality,
                                                                                    get_op_info_type_it2->extra_info);

    string p_idx_info_n = "8.5";
    Value p_idx_info = Value(p_idx_info_n);
    vector<idx_t> movie_info_idx_ids{6, 5, 3};
    vector<LogicalType> get_movie_info_idx_types{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_movie_info_idx = "mi_idx";
    vector<LogicalType> table_types_movie_info_idx;
    vector<unique_ptr<Expression>> filter_movie_info_idx;
    unique_ptr<LogicalGet> get_op_movie_info_idx = move(
            getLogicalGet(*this, table_movie_info_idx, alias_movie_info_idx, table_index_movie_info_idx_,
                          table_types_movie_info_idx));
    unique_ptr<TableFilterSet> table_filters_movie_info_idx = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_idx = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_LESSTHAN, p_idx_info);
    table_filters_movie_info_idx->filters[2] = move(constant_filter_idx);
    unique_ptr<PhysicalTableScan> scan_movie_info_idx = make_uniq<PhysicalTableScan>(get_movie_info_idx_types,
                                                                                     get_op_movie_info_idx->function,
                                                                                     get_op_movie_info_idx->table_index,
                                                                                     move(get_op_movie_info_idx->bind_data),
                                                                                     table_types_movie_info_idx,
                                                                                     movie_info_idx_ids,
                                                                                     move(filter_movie_info_idx),
                                                                                     vector<column_t>(),
                                                                                     get_op_movie_info_idx->names,
                                                                                     std::move(
                                                                                             table_filters_movie_info_idx),
                                                                                     get_op_movie_info_idx->estimated_cardinality,
                                                                                     get_op_movie_info_idx->extra_info);


    vector<JoinCondition> cond_movie_info_idx_;
    JoinCondition join_condition_movie_info_idx_;
    join_condition_movie_info_idx_.left = make_uniq<BoundReferenceExpression>("info_type_id_rowid", LogicalType::BIGINT, 1);
    join_condition_movie_info_idx_.right = make_uniq<BoundReferenceExpression>("info_type_rowid", LogicalType::BIGINT, 0);
    join_condition_movie_info_idx_.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_movie_info_idx_ = make_uniq<RAIInfo>();
    rai_info_movie_info_idx_->rai = table_movie_info_idx.GetStorage().info->rais[0].get();
    rai_info_movie_info_idx_->rai_type = RAIType::EDGE_SOURCE;
    rai_info_movie_info_idx_->forward = true;
    rai_info_movie_info_idx_->vertex = &table_info_type;
    rai_info_movie_info_idx_->vertex_id = table_index_info_type_it2;
    rai_info_movie_info_idx_->passing_tables[0] = table_index_movie_info_idx_;
    rai_info_movie_info_idx_->left_cardinalities[0] = table_movie_info_idx.GetStorage().info->cardinality;
    rai_info_movie_info_idx_->compact_list = &rai_info_movie_info_idx_->rai->alist->compact_forward_list;

    join_condition_movie_info_idx_.rais.push_back(move(rai_info_movie_info_idx_));
    cond_movie_info_idx_.push_back(move(join_condition_movie_info_idx_));

    LogicalComparisonJoin join_movie_info_idx__op(JoinType::INNER);
    vector<LogicalType> output_movie_info_idx__types{LogicalType::BIGINT, LogicalType::BIGINT,
                                                     LogicalType::VARCHAR, LogicalType::BIGINT};
    join_movie_info_idx__op.types = output_movie_info_idx__types;
    vector<idx_t> right_projection_map_movie_info_idx_{0};
    vector<idx_t> merge_project_map_movie_info_idx_;
    vector<LogicalType> delim_types_movie_info_idx_;
    auto join_movie_info_idx_ = make_uniq<PhysicalSIPJoin>(join_movie_info_idx__op, move(scan_movie_info_idx), move(scan_info_type_it2),
                                                                move(cond_movie_info_idx_), JoinType::INNER,
                                                                left_projection_map,
                                                                right_projection_map_movie_info_idx_,
                                                                delim_types_movie_info_idx_, 0);

    idx_t p_year_n = 2010;
    Value p_year = Value::BIGINT(p_year_n);
    vector<idx_t> title_t_ids{COLUMN_IDENTIFIER_ROW_ID, 1, 4, 12};
    vector<LogicalType> get_title_t_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::BIGINT,
                                          LogicalType::BIGINT};
    string alias_title_t = "t";
    vector<LogicalType> table_types_title_t;
    vector<unique_ptr<Expression>> filter_title_t;
    unique_ptr<LogicalGet> get_op_title_t = move(
            getLogicalGet(*this, table_title, alias_title_t, table_index_title_t, table_types_title_t));
    unique_ptr<TableFilterSet> table_filters_title_t = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_t = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_GREATERTHAN, p_year);
    table_filters_title_t->filters[2] = move(constant_filter_t);
    unique_ptr<PhysicalTableScan> scan_title_t = make_uniq<PhysicalTableScan>(get_title_t_types,
                                                                              get_op_title_t->function,
                                                                              get_op_title_t->table_index,
                                                                              move(get_op_title_t->bind_data),
                                                                              table_types_title_t, title_t_ids,
                                                                              move(filter_title_t), vector<column_t>(),
                                                                              get_op_title_t->names,
                                                                              std::move(table_filters_title_t),
                                                                              get_op_title_t->estimated_cardinality,
                                                                              get_op_title_t->extra_info);


    vector<JoinCondition> cond_title_t;
    JoinCondition join_condition_title_t;
    join_condition_title_t.left = make_uniq<BoundReferenceExpression>("title_rowid", LogicalType::BIGINT, 0);
    join_condition_title_t.right = make_uniq<BoundReferenceExpression>("movie_id_rowid", LogicalType::BIGINT, 0);
    join_condition_title_t.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_title_t = make_uniq<RAIInfo>();
    rai_info_title_t->rai = table_movie_info_idx.GetStorage().info->rais[0].get();
    rai_info_title_t->rai_type = RAIType::TARGET_EDGE;
    rai_info_title_t->forward = true;
    rai_info_title_t->vertex = &table_title;
    rai_info_title_t->vertex_id = table_index_title_t;
    rai_info_title_t->passing_tables[0] = table_index_title_t;
    rai_info_title_t->left_cardinalities[0] = table_title.GetStorage().info->cardinality;
    // rai_info_title_t->compact_list = &rai_info_title_t->rai->alist->compact__list;

    join_condition_title_t.rais.push_back(move(rai_info_title_t));
    cond_title_t.push_back(move(join_condition_title_t));

    LogicalComparisonJoin join_title_t_op(JoinType::INNER);
    vector<LogicalType> output_title_t_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::BIGINT,
                                             LogicalType::BIGINT, LogicalType::VARCHAR};
    join_title_t_op.types = output_title_t_types;
    vector<idx_t> right_projection_map_title_t{2};
    vector<idx_t> merge_project_map_title_t;
    vector<LogicalType> delim_types_title_t;
    auto join_title_t = make_uniq<PhysicalSIPJoin>(join_title_t_op, move(scan_title_t), move(join_movie_info_idx_), move(cond_title_t), JoinType::INNER,
                                                   left_projection_map, right_projection_map_title_t,
                                                   delim_types_title_t, 0);

    vector<idx_t> movie_info_ids{6, 5, 3};
    vector<LogicalType> get_movie_info_types{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_movie_info = "mi";
    vector<LogicalType> table_types_movie_info;
    vector<unique_ptr<Expression>> filter_movie_info;
    unique_ptr<LogicalGet> get_op_movie_info = move(
            getLogicalGet(*this, table_movie_info, alias_movie_info, table_index_movie_info_,
                          table_types_movie_info));
    unique_ptr<TableFilterSet> table_filters_movie_info = NULL;
    unique_ptr<PhysicalTableScan> scan_movie_info = make_uniq<PhysicalTableScan>(get_movie_info_types,
                                                                                 get_op_movie_info->function,
                                                                                 get_op_movie_info->table_index,
                                                                                 move(get_op_movie_info->bind_data),
                                                                                 table_types_movie_info,
                                                                                 movie_info_ids,
                                                                                 move(filter_movie_info),
                                                                                 vector<column_t>(),
                                                                                 get_op_movie_info->names,
                                                                                 std::move(
                                                                                         table_filters_movie_info),
                                                                                 get_op_movie_info->estimated_cardinality,
                                                                                 get_op_movie_info->extra_info);

    auto &allocator = Allocator::Get(context);
    vector<LogicalType> join_in_types {LogicalType::VARCHAR};
    auto collection =
            make_uniq<ColumnDataCollection>(context, join_in_types, ColumnDataAllocatorType::IN_MEMORY_ALLOCATOR);

    vector<LogicalType> chunk_in_types {LogicalType::VARCHAR};
    DataChunk chunk;
    chunk.SetCardinality(10);
    chunk.Initialize(allocator, chunk_in_types);
    chunk.SetValue(0, 0, Value("Sweden"));
    chunk.SetValue(0, 1, Value("Norway"));
    chunk.SetValue(0, 2, Value("Germany"));
    chunk.SetValue(0, 3, Value("Denmark"));
    chunk.SetValue(0, 4, Value("Swedish"));
    chunk.SetValue(0, 5, Value("Denish"));
    chunk.SetValue(0, 6, Value("Norwegian"));
    chunk.SetValue(0, 7, Value("German"));
    chunk.SetValue(0, 8, Value("USA"));
    chunk.SetValue(0, 9, Value("American"));
    collection->Append(chunk);

    // create a chunk scan to output the result
    vector<LogicalType> ouput_in_types {LogicalType::VARCHAR};
    auto chunk_scan = make_uniq<PhysicalColumnDataScan>(ouput_in_types, PhysicalOperatorType::COLUMN_DATA_SCAN,
                                                        10, std::move(collection));

    vector<JoinCondition> cond_hash_join_;
    JoinCondition join_condition_hash_join_;
    join_condition_hash_join_.left = make_uniq<BoundReferenceExpression>("info", LogicalType::VARCHAR, 2);
    join_condition_hash_join_.right = make_uniq<BoundReferenceExpression>("", LogicalType::VARCHAR, 0);
    join_condition_hash_join_.comparison = ExpressionType::COMPARE_EQUAL;
    cond_hash_join_.push_back(move(join_condition_hash_join_));

    LogicalComparisonJoin join_hash_join_op(JoinType::MARK);
    vector<LogicalType> output_hash_join_types{LogicalType::BIGINT, LogicalType::BIGINT,
                                               LogicalType::VARCHAR, LogicalType::BOOLEAN};
    join_hash_join_op.types = output_hash_join_types;
    vector<idx_t> right_projection_map_hash_join_;
    vector<LogicalType> delim_types_hash_join_;
    PerfectHashJoinStats joinstate;
    auto join_hash_join_ = make_uniq<PhysicalHashJoin>(join_hash_join_op, move(scan_movie_info), move(chunk_scan), move(cond_hash_join_),
                                                       JoinType::MARK, left_projection_map,
                                                       right_projection_map_hash_join_,
                                                       delim_types_hash_join_, 0, joinstate);

    vector<LogicalType> filter_in_types{LogicalType::BIGINT, LogicalType::BIGINT,
                                        LogicalType::VARCHAR, LogicalType::BOOLEAN};
    vector<unique_ptr<Expression>> select_list_in;
    auto in_exp = make_uniq<BoundReferenceExpression>("IN (...)", LogicalType::BOOLEAN, 3);
    select_list_in.push_back(move(in_exp));
    unique_ptr<PhysicalFilter> filter_in = make_uniq<PhysicalFilter>(filter_in_types, move(select_list_in), 0);
    filter_in->children.push_back(move(join_hash_join_));

    vector<JoinCondition> cond_movie_info_;
    JoinCondition join_condition_movie_info_;
    join_condition_movie_info_.left = make_uniq<BoundReferenceExpression>("movie_id_rowid", LogicalType::BIGINT, 0);
    join_condition_movie_info_.right = make_uniq<BoundReferenceExpression>("title_rowid", LogicalType::BIGINT, 0);
    join_condition_movie_info_.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_movie_info_ = make_uniq<RAIInfo>();
    rai_info_movie_info_->rai = table_movie_info.GetStorage().info->rais[0].get();
    rai_info_movie_info_->rai_type = RAIType::EDGE_TARGET;
    rai_info_movie_info_->forward = false;
    rai_info_movie_info_->vertex = &table_title;
    rai_info_movie_info_->vertex_id = table_index_title_t;
    rai_info_movie_info_->passing_tables[0] = table_index_movie_info_;
    rai_info_movie_info_->left_cardinalities[0] = table_movie_info.GetStorage().info->cardinality;
    rai_info_movie_info_->compact_list = &rai_info_movie_info_->rai->alist->compact_backward_list;

    join_condition_movie_info_.rais.push_back(move(rai_info_movie_info_));
    cond_movie_info_.push_back(move(join_condition_movie_info_));

    LogicalComparisonJoin join_movie_info__op(JoinType::INNER);
    vector<LogicalType> output_movie_info__types{LogicalType::BIGINT, LogicalType::BIGINT,
                                                 LogicalType::VARCHAR, LogicalType::BOOLEAN,
                                                 LogicalType::VARCHAR,
                                                 LogicalType::BIGINT, LogicalType::VARCHAR};
    join_movie_info__op.types = output_movie_info__types;
    vector<idx_t> right_projection_map_movie_info_{1, 3, 4};
    vector<idx_t> merge_project_map_movie_info_;
    vector<LogicalType> delim_types_movie_info_;
    auto join_movie_info_ = make_uniq<PhysicalSIPJoin>(join_movie_info__op, move(filter_in), move(join_title_t), move(cond_movie_info_),
                                                            JoinType::INNER, left_projection_map,
                                                            right_projection_map_movie_info_,
                                                            delim_types_movie_info_, 0);

    string p_info_n1 = "countries";
    Value p_info1 = Value(p_info_n1);
    vector<idx_t> info_type_it1_ids{COLUMN_IDENTIFIER_ROW_ID, 1};
    vector<LogicalType> get_info_type_it1_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_info_type_it1 = "it1";
    vector<LogicalType> table_types_info_type_it1;
    vector<unique_ptr<Expression>> filter_info_type_it1;
    unique_ptr<LogicalGet> get_op_info_type_it1 = move(
            getLogicalGet(*this, table_info_type, alias_info_type_it1, table_index_info_type_it1,
                          table_types_info_type_it1));
    unique_ptr<TableFilterSet> table_filters_info_type_it1 = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_it1 = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL, p_info1);
    table_filters_info_type_it1->filters[1] = move(constant_filter_it1);
    unique_ptr<PhysicalTableScan> scan_info_type_it1 = make_uniq<PhysicalTableScan>(get_info_type_it1_types,
                                                                                    get_op_info_type_it1->function,
                                                                                    get_op_info_type_it1->table_index,
                                                                                    move(get_op_info_type_it1->bind_data),
                                                                                    table_types_info_type_it1,
                                                                                    info_type_it1_ids,
                                                                                    move(filter_info_type_it1),
                                                                                    vector<column_t>(),
                                                                                    get_op_info_type_it1->names,
                                                                                    std::move(
                                                                                            table_filters_info_type_it1),
                                                                                    get_op_info_type_it1->estimated_cardinality,
                                                                                    get_op_info_type_it1->extra_info);


    vector<JoinCondition> cond_info_type_it1;
    JoinCondition join_condition_info_type_it1;
    join_condition_info_type_it1.left = make_uniq<BoundReferenceExpression>("info_type_rowid", LogicalType::BIGINT, 0);
    join_condition_info_type_it1.right = make_uniq<BoundReferenceExpression>("info_type_id_rowid", LogicalType::BIGINT, 1);
    join_condition_info_type_it1.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_info_type_it1 = make_uniq<RAIInfo>();
    rai_info_info_type_it1->rai = table_movie_info.GetStorage().info->rais[0].get();
    rai_info_info_type_it1->rai_type = RAIType::SOURCE_EDGE;
    rai_info_info_type_it1->forward = false;
    rai_info_info_type_it1->vertex = &table_info_type;
    rai_info_info_type_it1->vertex_id = table_index_info_type_it1;
    rai_info_info_type_it1->passing_tables[0] = table_index_info_type_it1;
    rai_info_info_type_it1->left_cardinalities[0] = table_info_type.GetStorage().info->cardinality;
    // rai_info_info_type_it1->compact_list = &rai_info_info_type_it1->rai->alist->compact__list;

    join_condition_info_type_it1.rais.push_back(move(rai_info_info_type_it1));
    cond_info_type_it1.push_back(move(join_condition_info_type_it1));

    LogicalComparisonJoin join_info_type_it1_op(JoinType::INNER);
    vector<LogicalType> output_info_type_it1_types{LogicalType::BIGINT, LogicalType::VARCHAR,
                                                   LogicalType::BIGINT, LogicalType::VARCHAR,
                                                   LogicalType::BIGINT, LogicalType::VARCHAR};
    join_info_type_it1_op.types = output_info_type_it1_types;
    vector<idx_t> right_projection_map_info_type_it1{0, 4, 5, 6};
    vector<idx_t> merge_project_map_info_type_it1;
    vector<LogicalType> delim_types_info_type_it1;
    auto join_info_type_it1 = make_uniq<PhysicalSIPJoin>(join_info_type_it1_op, move(scan_info_type_it1), move(join_movie_info_),
                                                         move(cond_info_type_it1), JoinType::INNER, left_projection_map,
                                                         right_projection_map_info_type_it1, delim_types_info_type_it1,
                                                         0);


    string p_kind_n = "movie";
    Value p_kind = Value(p_kind_n);
    vector<idx_t> kind_type_kt_ids{COLUMN_IDENTIFIER_ROW_ID, 1};
    vector<LogicalType> get_kind_type_kt_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_kind_type_kt = "kt";
    vector<LogicalType> table_types_kind_type_kt;
    vector<unique_ptr<Expression>> filter_kind_type_kt;
    unique_ptr<LogicalGet> get_op_kind_type_kt = move(
            getLogicalGet(*this, table_kind_type, alias_kind_type_kt, table_index_kind_type_kt,
                          table_types_kind_type_kt));
    unique_ptr<TableFilterSet> table_filters_kind_type_kt = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_kt = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL, p_kind);
    table_filters_kind_type_kt->filters[1] = move(constant_filter_kt);
    unique_ptr<PhysicalTableScan> scan_kind_type_kt = make_uniq<PhysicalTableScan>(get_kind_type_kt_types,
                                                                                   get_op_kind_type_kt->function,
                                                                                   get_op_kind_type_kt->table_index,
                                                                                   move(get_op_kind_type_kt->bind_data),
                                                                                   table_types_kind_type_kt,
                                                                                   kind_type_kt_ids,
                                                                                   move(filter_kind_type_kt),
                                                                                   vector<column_t>(),
                                                                                   get_op_kind_type_kt->names,
                                                                                   std::move(
                                                                                           table_filters_kind_type_kt),
                                                                                   get_op_kind_type_kt->estimated_cardinality,
                                                                                   get_op_kind_type_kt->extra_info);


    vector<JoinCondition> cond_kind_type_kt;
    JoinCondition join_condition_kind_type_kt;
    join_condition_kind_type_kt.left = make_uniq<BoundReferenceExpression>("kind_type_rowid", LogicalType::BIGINT, 0);
    join_condition_kind_type_kt.right = make_uniq<BoundReferenceExpression>("kind_id_rowid", LogicalType::BIGINT, 4);
    join_condition_kind_type_kt.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_kind_type_kt = make_uniq<RAIInfo>();
    rai_info_kind_type_kt->rai = table_title.GetStorage().info->rais[0].get();
    rai_info_kind_type_kt->rai_type = RAIType::TARGET_EDGE;
    rai_info_kind_type_kt->forward = true;
    rai_info_kind_type_kt->vertex = &table_kind_type;
    rai_info_kind_type_kt->vertex_id = table_index_kind_type_kt;
    rai_info_kind_type_kt->passing_tables[0] = table_index_kind_type_kt;
    rai_info_kind_type_kt->left_cardinalities[0] = table_kind_type.GetStorage().info->cardinality;
    // rai_info_kind_type_kt->compact_list = &rai_info_kind_type_kt->rai->alist->compact__list;

    join_condition_kind_type_kt.rais.push_back(move(rai_info_kind_type_kt));
    cond_kind_type_kt.push_back(move(join_condition_kind_type_kt));

    LogicalComparisonJoin join_kind_type_kt_op(JoinType::INNER);
    vector<LogicalType> output_kind_type_kt_types{LogicalType::BIGINT, LogicalType::VARCHAR,
                                                  LogicalType::BIGINT, LogicalType::VARCHAR,
                                                  LogicalType::VARCHAR};
    join_kind_type_kt_op.types = output_kind_type_kt_types;
    vector<idx_t> right_projection_map_kind_type_kt{2, 3, 5};
    vector<idx_t> merge_project_map_kind_type_kt;
    vector<LogicalType> delim_types_kind_type_kt;
    auto join_kind_type_kt = make_uniq<PhysicalSIPJoin>(join_kind_type_kt_op, move(scan_kind_type_kt), move(join_info_type_it1), move(cond_kind_type_kt),
                                                        JoinType::INNER, left_projection_map,
                                                        right_projection_map_kind_type_kt, delim_types_kind_type_kt, 0);

    vector<idx_t> keyword_k_ids{COLUMN_IDENTIFIER_ROW_ID, 1};
    vector<LogicalType> get_keyword_k_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_keyword_k = "k";
    vector<LogicalType> table_types_keyword_k;
    vector<unique_ptr<Expression>> filter_keyword_k;
    unique_ptr<LogicalGet> get_op_keyword_k = move(
            getLogicalGet(*this, table_keyword, alias_keyword_k, table_index_keyword_k, table_types_keyword_k));
    unique_ptr<TableFilterSet> table_filters_keyword_k = NULL;
    unique_ptr<PhysicalTableScan> scan_keyword_k = make_uniq<PhysicalTableScan>(get_keyword_k_types,
                                                                                get_op_keyword_k->function,
                                                                                get_op_keyword_k->table_index,
                                                                                move(get_op_keyword_k->bind_data),
                                                                                table_types_keyword_k, keyword_k_ids,
                                                                                move(filter_keyword_k),
                                                                                vector<column_t>(),
                                                                                get_op_keyword_k->names,
                                                                                std::move(table_filters_keyword_k),
                                                                                get_op_keyword_k->estimated_cardinality,
                                                                                get_op_keyword_k->extra_info);

    auto &allocator_keyword = Allocator::Get(context);
    vector<LogicalType> join_in_types_keyword {LogicalType::VARCHAR};
    auto collection_keyword =
            make_uniq<ColumnDataCollection>(context, join_in_types_keyword, ColumnDataAllocatorType::IN_MEMORY_ALLOCATOR);

    vector<LogicalType> chunk_in_types_keyword {LogicalType::VARCHAR};
    DataChunk chunk_keyword;
    chunk_keyword.SetCardinality(4);
    chunk_keyword.Initialize(allocator_keyword, chunk_in_types_keyword);
    chunk_keyword.SetValue(0, 0, Value("murder"));
    chunk_keyword.SetValue(0, 1, Value("murder-in-title"));
    chunk_keyword.SetValue(0, 2, Value("blood"));
    chunk_keyword.SetValue(0, 3, Value("violence"));
    collection_keyword->Append(chunk_keyword);

    // create a chunk scan to output the result
    vector<LogicalType> ouput_in_types_keyword {LogicalType::VARCHAR};
    auto chunk_scan_keyword = make_uniq<PhysicalColumnDataScan>(ouput_in_types_keyword, PhysicalOperatorType::COLUMN_DATA_SCAN,
                                                        4, std::move(collection_keyword));

    vector<JoinCondition> cond_hash_join__keyword;
    JoinCondition join_condition_hash_join__keyword;
    join_condition_hash_join__keyword.left = make_uniq<BoundReferenceExpression>("keyword", LogicalType::VARCHAR, 1);
    join_condition_hash_join__keyword.right = make_uniq<BoundReferenceExpression>("", LogicalType::VARCHAR, 0);
    join_condition_hash_join__keyword.comparison = ExpressionType::COMPARE_EQUAL;
    cond_hash_join__keyword.push_back(move(join_condition_hash_join__keyword));

    LogicalComparisonJoin join_hash_join_op_keyword(JoinType::MARK);
    vector<LogicalType> output_hash_join_types_keyword{LogicalType::BIGINT, LogicalType::VARCHAR,
                                               LogicalType::BOOLEAN};
    join_hash_join_op_keyword.types = output_hash_join_types_keyword;
    vector<idx_t> right_projection_map_hash_join__keyword;
    vector<LogicalType> delim_types_hash_join__keyword;
    PerfectHashJoinStats joinstate_keyword;
    auto join_hash_join__keyword = make_uniq<PhysicalHashJoin>(join_hash_join_op_keyword, move(scan_keyword_k), move(chunk_scan_keyword), move(cond_hash_join__keyword),
                                                       JoinType::MARK, left_projection_map,
                                                       right_projection_map_hash_join__keyword,
                                                       delim_types_hash_join__keyword, 0, joinstate_keyword);

    vector<LogicalType> filter_in_types_keyword{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::BOOLEAN};
    vector<unique_ptr<Expression>> select_list_in_keyword;
    auto in_exp_keyword = make_uniq<BoundReferenceExpression>("IN (...)", LogicalType::BOOLEAN, 2);
    select_list_in_keyword.push_back(move(in_exp_keyword));
    unique_ptr<PhysicalFilter> filter_in_keyword = make_uniq<PhysicalFilter>(filter_in_types_keyword, move(select_list_in_keyword), 0);
    filter_in_keyword->children.push_back(move(join_hash_join__keyword));

    vector<JoinCondition> cond_keyword_k;
    JoinCondition join_condition_keyword_k;
    join_condition_keyword_k.left = make_uniq<BoundReferenceExpression>("keyword_rowid", LogicalType::BIGINT, 0);
    join_condition_keyword_k.right = make_uniq<BoundReferenceExpression>("movie_id_rowid", LogicalType::BIGINT, 2);
    join_condition_keyword_k.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_keyword_k = make_uniq<RAIInfo>();
    rai_info_keyword_k->rai = table_movie_keyword.GetStorage().info->rais[0].get();
    rai_info_keyword_k->rai_type = RAIType::SOURCE_EDGE;
    rai_info_keyword_k->forward = false;
    rai_info_keyword_k->vertex = &table_keyword;
    rai_info_keyword_k->vertex_id = table_index_keyword_k;
    rai_info_keyword_k->passing_tables[0] = table_index_keyword_k;
    rai_info_keyword_k->left_cardinalities[0] = table_keyword.GetStorage().info->cardinality;
    // rai_info_keyword_k->compact_list = &rai_info_keyword_k->rai->alist->compact__list;

    join_condition_keyword_k.rais.push_back(move(rai_info_keyword_k));
    cond_keyword_k.push_back(move(join_condition_keyword_k));

    LogicalComparisonJoin join_keyword_k_op(JoinType::INNER);
    vector<LogicalType> output_keyword_k_types{LogicalType::BIGINT, LogicalType::VARCHAR,
                                               LogicalType::BOOLEAN, LogicalType::VARCHAR,
                                               LogicalType::VARCHAR};
    join_keyword_k_op.types = output_keyword_k_types;
    vector<idx_t> right_projection_map_keyword_k{3, 4};
    vector<idx_t> merge_project_map_keyword_k;
    vector<LogicalType> delim_types_keyword_k;
    auto join_keyword_k = make_uniq<PhysicalMergeSIPJoin>(join_keyword_k_op, move(filter_in_keyword), move(join_kind_type_kt), move(cond_keyword_k),
                                                     JoinType::INNER, left_projection_map,
                                                     right_projection_map_keyword_k,
                                                     merge_project_map_keyword_k,
                                                     delim_types_keyword_k, 0);


    vector<LogicalType> result_types{LogicalType::VARCHAR, LogicalType::VARCHAR};
    vector<unique_ptr<Expression>> select_list;
    auto result_col0 = make_uniq<BoundReferenceExpression>("info", LogicalType::VARCHAR, 4);
    auto result_col1 = make_uniq<BoundReferenceExpression>("title", LogicalType::VARCHAR, 3);
    select_list.push_back(move(result_col0));
    select_list.push_back(move(result_col1));
    auto projection = make_uniq<PhysicalProjection>(result_types, move(select_list), 0);
    projection->children.push_back(move(join_keyword_k));

    // aggregate
    string agg_name = "min";
    string agg_error = "";
    QueryErrorContext error_context(NULL, NULL);
    auto min_func = Catalog::GetEntry(context, CatalogType::SCALAR_FUNCTION_ENTRY, "", "",
                                      "min", OnEntryNotFound::RETURN_NULL, error_context);
    auto& min_func_set = min_func->Cast<AggregateFunctionCatalogEntry>();
    // bind the aggregate
    FunctionBinder function_binder(context);
    vector<LogicalType> types;
    types.push_back(LogicalType::VARCHAR);
    idx_t best_function_varchar = function_binder.BindFunction(agg_name, min_func_set.functions, types, agg_error);
    auto bound_function_min_varchar = min_func_set.functions.GetFunctionByOffset(best_function_varchar);

    auto first_children = make_uniq<BoundReferenceExpression>("info", LogicalType::VARCHAR, 0);
    vector<unique_ptr<Expression>> childrenlist1;
    childrenlist1.push_back(move(first_children));
    auto aggregate1 =
            function_binder.BindAggregateFunction(bound_function_min_varchar, std::move(childrenlist1), nullptr, AggregateType::NON_DISTINCT);

    auto second_children = make_uniq<BoundReferenceExpression>("title", LogicalType::VARCHAR, 1);
    vector<unique_ptr<Expression>> childrenlist2;
    childrenlist2.push_back(move(second_children));
    auto aggregate2 =
            function_binder.BindAggregateFunction(bound_function_min_varchar, std::move(childrenlist2), nullptr, AggregateType::NON_DISTINCT);

    vector<unique_ptr<Expression>> aggregates;
    aggregates.push_back(move(aggregate1));
    aggregates.push_back(move(aggregate2));

    vector<LogicalType> aggregate_types{LogicalType::VARCHAR, LogicalType::VARCHAR};
    auto ungrouped_aggregate = make_uniq<PhysicalUngroupedAggregate>(aggregate_types, move(aggregates), 0);
    ungrouped_aggregate->children.push_back(move(projection));

    return ungrouped_aggregate;
}

unique_ptr<PhysicalOperator> ClientContext::GenerateJOB15aPlan(duckdb::ClientContext &context) {
    vector<idx_t> left_projection_map, right_projection_map;

    string table_vertex_aka_title_at = "aka_title";
    string table_vertex_title_t = "title";
    string table_vertex_info_type_it1 = "info_type";
    string table_vertex_keyword_k = "keyword";
    string table_vertex_company_type_ct = "company_type";
    string table_vertex_company_name_cn = "company_name";
    string table_vertex_aka_title_to_movie_ = "aka_title_to_movie";
    string table_vertex_movie_info_ = "movie_info";
    string table_vertex_movie_keyword_ = "movie_keyword";
    string table_vertex_movie_companies_ = "movie_companies";

    idx_t table_index_aka_title_at = 1;
    idx_t table_index_title_t = 2;
    idx_t table_index_info_type_it1 = 3;
    idx_t table_index_keyword_k = 4;
    idx_t table_index_company_type_ct = 5;
    idx_t table_index_company_name_cn = 6;
    idx_t table_index_aka_title_to_movie_ = 7;
    idx_t table_index_movie_info_ = 8;
    idx_t table_index_movie_keyword_ = 9;
    idx_t table_index_movie_companies_ = 11;

    auto table_or_view_aka_title = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_aka_title_at,
                                                     OnEntryNotFound::RETURN_NULL);
    auto &table_aka_title = table_or_view_aka_title->Cast<TableCatalogEntry>();
    auto table_or_view_title = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_title_t,
                                                 OnEntryNotFound::RETURN_NULL);
    auto &table_title = table_or_view_title->Cast<TableCatalogEntry>();
    auto table_or_view_info_type = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                     table_vertex_info_type_it1, OnEntryNotFound::RETURN_NULL);
    auto &table_info_type = table_or_view_info_type->Cast<TableCatalogEntry>();
    auto table_or_view_keyword = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_keyword_k,
                                                   OnEntryNotFound::RETURN_NULL);
    auto &table_keyword = table_or_view_keyword->Cast<TableCatalogEntry>();
    auto table_or_view_company_type = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                        table_vertex_company_type_ct, OnEntryNotFound::RETURN_NULL);
    auto &table_company_type = table_or_view_company_type->Cast<TableCatalogEntry>();
    auto table_or_view_company_name = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                        table_vertex_company_name_cn, OnEntryNotFound::RETURN_NULL);
    auto &table_company_name = table_or_view_company_name->Cast<TableCatalogEntry>();
    auto table_or_view_movie_info = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_movie_info_,
                                                      OnEntryNotFound::RETURN_NULL);
    auto &table_movie_info = table_or_view_movie_info->Cast<TableCatalogEntry>();
    auto table_or_view_movie_keyword = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                         table_vertex_movie_keyword_, OnEntryNotFound::RETURN_NULL);
    auto &table_movie_keyword = table_or_view_movie_keyword->Cast<TableCatalogEntry>();
    auto table_or_view_movie_companies = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                           table_vertex_movie_companies_, OnEntryNotFound::RETURN_NULL);
    auto &table_movie_companies = table_or_view_movie_companies->Cast<TableCatalogEntry>();

    vector<idx_t> company_type_ct_ids{COLUMN_IDENTIFIER_ROW_ID};
    vector<LogicalType> get_company_type_ct_types{LogicalType::BIGINT};
    string alias_company_type_ct = "ct";
    vector<LogicalType> table_types_company_type_ct;
    vector<unique_ptr<Expression>> filter_company_type_ct;
    unique_ptr<LogicalGet> get_op_company_type_ct = move(
            getLogicalGet(*this, table_company_type, alias_company_type_ct, table_index_company_type_ct,
                          table_types_company_type_ct));
    unique_ptr<TableFilterSet> table_filters_company_type_ct = NULL;
    unique_ptr<PhysicalTableScan> scan_company_type_ct = make_uniq<PhysicalTableScan>(get_company_type_ct_types,
                                                                                      get_op_company_type_ct->function,
                                                                                      get_op_company_type_ct->table_index,
                                                                                      move(get_op_company_type_ct->bind_data),
                                                                                      table_types_company_type_ct,
                                                                                      company_type_ct_ids,
                                                                                      move(filter_company_type_ct),
                                                                                      vector<column_t>(),
                                                                                      get_op_company_type_ct->names,
                                                                                      std::move(
                                                                                              table_filters_company_type_ct),
                                                                                      get_op_company_type_ct->estimated_cardinality,
                                                                                      get_op_company_type_ct->extra_info);

    vector<idx_t> movie_companies_ids{4, 5, 6, 7};
    vector<LogicalType> get_movie_companies_types{LogicalType::VARCHAR, LogicalType::BIGINT,
                                                  LogicalType::BIGINT, LogicalType::BIGINT};
    string alias_movie_companies = "ct";
    vector<LogicalType> table_types_movie_companies;
    vector<unique_ptr<Expression>> filter_movie_companies;
    unique_ptr<LogicalGet> get_op_movie_companies = move(
            getLogicalGet(*this, table_movie_companies, alias_movie_companies, table_index_movie_companies_,
                          table_types_movie_companies));
    unique_ptr<TableFilterSet> table_filters_movie_companies = NULL;
    unique_ptr<PhysicalTableScan> scan_movie_companies = make_uniq<PhysicalTableScan>(get_movie_companies_types,
                                                                                      get_op_movie_companies->function,
                                                                                      get_op_movie_companies->table_index,
                                                                                      move(get_op_movie_companies->bind_data),
                                                                                      table_types_movie_companies,
                                                                                      movie_companies_ids,
                                                                                      move(filter_movie_companies),
                                                                                      vector<column_t>(),
                                                                                      get_op_movie_companies->names,
                                                                                      std::move(
                                                                                              table_filters_movie_companies),
                                                                                      get_op_movie_companies->estimated_cardinality,
                                                                                      get_op_movie_companies->extra_info);

    string p_movie_company_note1 = "%(200%)%"; // 933;
    string p_movie_company_note2 = "(worldwide)"; // 933;
    Value p_note1 = Value(p_movie_company_note1);
    Value p_note2 = Value(p_movie_company_note2);
    vector<LogicalType> filter_mc_types{LogicalType::VARCHAR, LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::BIGINT};
    vector<unique_ptr<Expression>> select_list_movie_companies;
    auto like_expression_left = make_uniq<BoundReferenceExpression>("note", LogicalType::VARCHAR, 0);
    auto like_expression_value = make_uniq<BoundConstantExpression>(p_note1);
    vector<unique_ptr<Expression>> like_arguments1, like_arguments2;
    like_arguments1.push_back(move(like_expression_left));
    like_arguments1.push_back(move(like_expression_value));

    auto like_expression_left2 = make_uniq<BoundReferenceExpression>("note", LogicalType::VARCHAR, 0);
    auto like_expression_value2 = make_uniq<BoundConstantExpression>(p_note2);
    like_arguments2.push_back(move(like_expression_left2));
    like_arguments2.push_back(move(like_expression_value2));

    QueryErrorContext error_context_unlike(NULL, NULL);
    ScalarFunction bound_function_contains = ContainsFun::GetFunction();
    unique_ptr<FunctionData> bind_data_contains = NULL;

    ScalarFunction bound_function_like = LikeFun::GetLikeFunction();
    unique_ptr<FunctionData> bind_data_like = NULL;

    auto like_bound_function = make_uniq<BoundFunctionExpression>(LogicalType::BOOLEAN,
                                                                  bound_function_like,
                                                                  move(like_arguments1),
                                                                  move(bind_data_like), false);

    auto like_bound_function2 = make_uniq<BoundFunctionExpression>(LogicalType::BOOLEAN,
                                                                   bound_function_contains,
                                                                   move(like_arguments2),
                                                                   move(bind_data_contains), false);


    select_list_movie_companies.push_back(move(like_bound_function));
    select_list_movie_companies.push_back(move(like_bound_function2));
    unique_ptr<PhysicalFilter> filter_mc_contains = make_uniq<PhysicalFilter>(filter_mc_types, move(select_list_movie_companies), 0);
    filter_mc_contains->children.push_back(move(scan_movie_companies));


    vector<JoinCondition> cond_movie_companies_;
    JoinCondition join_condition_movie_companies_;
    join_condition_movie_companies_.left = make_uniq<BoundReferenceExpression>("company_type_id_rowid", LogicalType::BIGINT, 3);
    join_condition_movie_companies_.right = make_uniq<BoundReferenceExpression>("company_type_rowid", LogicalType::BIGINT, 0);
    join_condition_movie_companies_.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_movie_companies_ = make_uniq<RAIInfo>();
    rai_info_movie_companies_->rai = table_movie_companies.GetStorage().info->rais[1].get();
    rai_info_movie_companies_->rai_type = RAIType::EDGE_SOURCE;
    rai_info_movie_companies_->forward = true;
    rai_info_movie_companies_->vertex = &table_company_type;
    rai_info_movie_companies_->vertex_id = table_index_company_type_ct;
    rai_info_movie_companies_->passing_tables[0] = table_index_movie_companies_;
    rai_info_movie_companies_->left_cardinalities[0] = table_movie_companies.GetStorage().info->cardinality;
    rai_info_movie_companies_->compact_list = &rai_info_movie_companies_->rai->alist->compact_forward_list;

    join_condition_movie_companies_.rais.push_back(move(rai_info_movie_companies_));
    cond_movie_companies_.push_back(move(join_condition_movie_companies_));

    LogicalComparisonJoin join_movie_companies__op(JoinType::INNER);
    vector<LogicalType> output_movie_companies__types{LogicalType::VARCHAR, LogicalType::BIGINT, LogicalType::BIGINT,
                                                      LogicalType::BIGINT, LogicalType::BIGINT};
    join_movie_companies__op.types = output_movie_companies__types;
    vector<idx_t> right_projection_map_movie_companies_{0};
    vector<idx_t> merge_project_map_movie_companies_;
    vector<LogicalType> delim_types_movie_companies_;
    auto join_movie_companies_ = make_uniq<PhysicalSIPJoin>(join_movie_companies__op, move(filter_mc_contains), move(scan_company_type_ct),
                                                                 move(cond_movie_companies_), JoinType::INNER,
                                                                 left_projection_map,
                                                                 right_projection_map_movie_companies_,
                                                                 delim_types_movie_companies_, 0);


    idx_t p_year_n = 2000;
    Value p_year = Value::BIGINT(p_year_n);
    vector<idx_t> title_t_ids{COLUMN_IDENTIFIER_ROW_ID, 1, 4};
    vector<LogicalType> get_title_t_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::BIGINT};
    string alias_title_t = "t";
    vector<LogicalType> table_types_title_t;
    vector<unique_ptr<Expression>> filter_title_t;
    unique_ptr<LogicalGet> get_op_title_t = move(
            getLogicalGet(*this, table_title, alias_title_t, table_index_title_t, table_types_title_t));
    unique_ptr<TableFilterSet> table_filters_title_t = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_t = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_GREATERTHAN, p_year);
    table_filters_title_t->filters[2] = move(constant_filter_t);
    unique_ptr<PhysicalTableScan> scan_title_t = make_uniq<PhysicalTableScan>(get_title_t_types,
                                                                              get_op_title_t->function,
                                                                              get_op_title_t->table_index,
                                                                              move(get_op_title_t->bind_data),
                                                                              table_types_title_t, title_t_ids,
                                                                              move(filter_title_t), vector<column_t>(),
                                                                              get_op_title_t->names,
                                                                              std::move(table_filters_title_t),
                                                                              get_op_title_t->estimated_cardinality,
                                                                              get_op_title_t->extra_info);


    vector<JoinCondition> cond_title_t;
    JoinCondition join_condition_title_t;
    join_condition_title_t.left = make_uniq<BoundReferenceExpression>("title_rowid", LogicalType::BIGINT, 0);
    join_condition_title_t.right = make_uniq<BoundReferenceExpression>("movie_id_rowid", LogicalType::BIGINT, 2);
    join_condition_title_t.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_title_t = make_uniq<RAIInfo>();
    rai_info_title_t->rai = table_movie_companies.GetStorage().info->rais[0].get();
    rai_info_title_t->rai_type = RAIType::TARGET_EDGE;
    rai_info_title_t->forward = true;
    rai_info_title_t->vertex = &table_title;
    rai_info_title_t->vertex_id = table_index_title_t;
    rai_info_title_t->passing_tables[0] = table_index_title_t;
    rai_info_title_t->left_cardinalities[0] = table_title.GetStorage().info->cardinality;
    // rai_info_title_t->compact_list = &rai_info_title_t->rai->alist->compact__list;

    join_condition_title_t.rais.push_back(move(rai_info_title_t));
    cond_title_t.push_back(move(join_condition_title_t));

    LogicalComparisonJoin join_title_t_op(JoinType::INNER);
    vector<LogicalType> output_title_t_types{LogicalType::BIGINT, LogicalType::VARCHAR,
                                             LogicalType::BIGINT, LogicalType::BIGINT};
    join_title_t_op.types = output_title_t_types;
    vector<idx_t> right_projection_map_title_t{1};
    vector<idx_t> merge_project_map_title_t;
    vector<LogicalType> delim_types_title_t;
    auto join_title_t = make_uniq<PhysicalSIPJoin>(join_title_t_op, move(scan_title_t), move(join_movie_companies_), move(cond_title_t), JoinType::INNER,
                                                   left_projection_map, right_projection_map_title_t,
                                                   delim_types_title_t, 0);


    string p_country_code_n = "[us]";
    Value p_code = Value(p_country_code_n);
    vector<idx_t> company_name_cn_ids{COLUMN_IDENTIFIER_ROW_ID, 2};
    vector<LogicalType> get_company_name_cn_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_company_name_cn = "cn";
    vector<LogicalType> table_types_company_name_cn;
    vector<unique_ptr<Expression>> filter_company_name_cn;
    unique_ptr<LogicalGet> get_op_company_name_cn = move(
            getLogicalGet(*this, table_company_name, alias_company_name_cn, table_index_company_name_cn,
                          table_types_company_name_cn));
    unique_ptr<TableFilterSet> table_filters_company_name_cn = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_cn = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL, p_code);
    table_filters_company_name_cn->filters[1] = move(constant_filter_cn);
    unique_ptr<PhysicalTableScan> scan_company_name_cn = make_uniq<PhysicalTableScan>(get_company_name_cn_types,
                                                                                      get_op_company_name_cn->function,
                                                                                      get_op_company_name_cn->table_index,
                                                                                      move(get_op_company_name_cn->bind_data),
                                                                                      table_types_company_name_cn,
                                                                                      company_name_cn_ids,
                                                                                      move(filter_company_name_cn),
                                                                                      vector<column_t>(),
                                                                                      get_op_company_name_cn->names,
                                                                                      std::move(
                                                                                              table_filters_company_name_cn),
                                                                                      get_op_company_name_cn->estimated_cardinality,
                                                                                      get_op_company_name_cn->extra_info);


    vector<JoinCondition> cond_company_name_cn;
    JoinCondition join_condition_company_name_cn;
    join_condition_company_name_cn.left = make_uniq<BoundReferenceExpression>("company_name_rowid", LogicalType::BIGINT, 0);
    join_condition_company_name_cn.right = make_uniq<BoundReferenceExpression>("company_id_rowid", LogicalType::BIGINT, 3);
    join_condition_company_name_cn.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_company_name_cn = make_uniq<RAIInfo>();
    rai_info_company_name_cn->rai = table_movie_companies.GetStorage().info->rais[0].get();
    rai_info_company_name_cn->rai_type = RAIType::SOURCE_EDGE;
    rai_info_company_name_cn->forward = false;
    rai_info_company_name_cn->vertex = &table_company_name;
    rai_info_company_name_cn->vertex_id = table_index_company_name_cn;
    rai_info_company_name_cn->passing_tables[0] = table_index_company_name_cn;
    rai_info_company_name_cn->left_cardinalities[0] = table_company_name.GetStorage().info->cardinality;
    // rai_info_company_name_cn->compact_list = &rai_info_company_name_cn->rai->alist->compact__list;

    join_condition_company_name_cn.rais.push_back(move(rai_info_company_name_cn));
    cond_company_name_cn.push_back(move(join_condition_company_name_cn));

    LogicalComparisonJoin join_company_name_cn_op(JoinType::INNER);
    vector<LogicalType> output_company_name_cn_types{LogicalType::BIGINT, LogicalType::VARCHAR,
                                                     LogicalType::BIGINT, LogicalType::VARCHAR};
    join_company_name_cn_op.types = output_company_name_cn_types;
    vector<idx_t> right_projection_map_company_name_cn{0, 1};
    vector<idx_t> merge_project_map_company_name_cn;
    vector<LogicalType> delim_types_company_name_cn;
    auto join_company_name_cn = make_uniq<PhysicalSIPJoin>(join_company_name_cn_op, move(scan_company_name_cn), move(join_title_t),
                                                           move(cond_company_name_cn), JoinType::INNER,
                                                           left_projection_map, right_projection_map_company_name_cn,
                                                           delim_types_company_name_cn, 0);


    vector<idx_t> movie_info_ids{6, 5, 3, 4};
    vector<LogicalType> get_movie_info_types{LogicalType::BIGINT, LogicalType::BIGINT,
                                             LogicalType::VARCHAR, LogicalType::VARCHAR};
    string alias_movie_info = "i";
    vector<LogicalType> table_types_movie_info;
    vector<unique_ptr<Expression>> filter_movie_info;
    unique_ptr<LogicalGet> get_op_movie_info = move(
            getLogicalGet(*this, table_movie_info, alias_movie_info, table_index_movie_info_, table_types_movie_info));
    unique_ptr<TableFilterSet> table_filters_movie_info = NULL;
    unique_ptr<PhysicalTableScan> scan_movie_info = make_uniq<PhysicalTableScan>(get_movie_info_types,
                                                                                 get_op_movie_info->function,
                                                                                 get_op_movie_info->table_index,
                                                                                 move(get_op_movie_info->bind_data),
                                                                                 table_types_movie_info,
                                                                                 movie_info_ids,
                                                                                 move(filter_movie_info),
                                                                                 vector<column_t>(),
                                                                                 get_op_movie_info->names,
                                                                                 std::move(table_filters_movie_info),
                                                                                 get_op_movie_info->estimated_cardinality,
                                                                                 get_op_movie_info->extra_info);

    string p_movie_info_note = "internet";
    string p_movie_info_info = "USA:% 200%";
    Value p_info_note = Value(p_movie_info_note);
    Value p_info_info = Value(p_movie_info_info);
    vector<LogicalType> filter_mi_types{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::VARCHAR};
    vector<unique_ptr<Expression>> select_list_movie_info;
    auto like_expression_left_mi = make_uniq<BoundReferenceExpression>("note", LogicalType::VARCHAR, 3);
    auto like_expression_value_mi = make_uniq<BoundConstantExpression>(p_info_note);
    vector<unique_ptr<Expression>> like_arguments1_mi, like_arguments2_mi;
    like_arguments1_mi.push_back(move(like_expression_left_mi));
    like_arguments1_mi.push_back(move(like_expression_value_mi));

    auto like_expression_left2_mi = make_uniq<BoundReferenceExpression>("info", LogicalType::VARCHAR, 2);
    auto like_expression_value2_mi = make_uniq<BoundConstantExpression>(p_info_info);
    like_arguments2_mi.push_back(move(like_expression_left2_mi));
    like_arguments2_mi.push_back(move(like_expression_value2_mi));

    unique_ptr<FunctionData> bind_data_contains_mi = NULL;
    auto like_bound_function_mi = make_uniq<BoundFunctionExpression>(LogicalType::BOOLEAN,
                                                                  bound_function_contains,
                                                                  move(like_arguments1_mi),
                                                                  move(bind_data_contains_mi), false);

    unique_ptr<FunctionData> bind_data_like_mi = NULL;
    auto like_bound_function2_mi = make_uniq<BoundFunctionExpression>(LogicalType::BOOLEAN,
                                                                   bound_function_like,
                                                                   move(like_arguments2_mi),
                                                                   move(bind_data_like_mi), false);


    select_list_movie_info.push_back(move(like_bound_function_mi));
    select_list_movie_info.push_back(move(like_bound_function2_mi));
    unique_ptr<PhysicalFilter> filter_mi_contains = make_uniq<PhysicalFilter>(filter_mi_types, move(select_list_movie_info), 0);
    filter_mi_contains->children.push_back(move(scan_movie_info));


    vector<JoinCondition> cond_movie_info_;
    JoinCondition join_condition_movie_info_;
    join_condition_movie_info_.left = make_uniq<BoundReferenceExpression>("movie_id_rowid", LogicalType::BIGINT, 0);
    join_condition_movie_info_.right = make_uniq<BoundReferenceExpression>("title_rowid", LogicalType::BIGINT, 2);
    join_condition_movie_info_.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_movie_info_ = make_uniq<RAIInfo>();
    rai_info_movie_info_->rai = table_movie_info.GetStorage().info->rais[0].get();
    rai_info_movie_info_->rai_type = RAIType::EDGE_TARGET;
    rai_info_movie_info_->forward = false;
    rai_info_movie_info_->vertex = &table_title;
    rai_info_movie_info_->vertex_id = table_index_title_t;
    rai_info_movie_info_->passing_tables[0] = table_index_movie_info_;
    rai_info_movie_info_->left_cardinalities[0] = table_movie_info.GetStorage().info->cardinality;
    rai_info_movie_info_->compact_list = &rai_info_movie_info_->rai->alist->compact_backward_list;

    join_condition_movie_info_.rais.push_back(move(rai_info_movie_info_));
    cond_movie_info_.push_back(move(join_condition_movie_info_));

    LogicalComparisonJoin join_movie_info__op(JoinType::INNER);
    vector<LogicalType> output_movie_info__types{LogicalType::BIGINT, LogicalType::BIGINT,
                                                 LogicalType::VARCHAR, LogicalType::VARCHAR,
                                                 LogicalType::VARCHAR};
    join_movie_info__op.types = output_movie_info__types;
    vector<idx_t> right_projection_map_movie_info_{3};
    vector<idx_t> merge_project_map_movie_info_;
    vector<LogicalType> delim_types_movie_info_;
    auto join_movie_info_ = make_uniq<PhysicalSIPJoin>(join_movie_info__op, move(filter_mi_contains), move(join_company_name_cn), move(cond_movie_info_),
                                                            JoinType::INNER, left_projection_map,
                                                            right_projection_map_movie_info_,
                                                            delim_types_movie_info_, 0);

    string p_info_n = "release dates";
    Value p_info = Value(p_info_n);
    vector<idx_t> info_type_it1_ids{COLUMN_IDENTIFIER_ROW_ID, 1};
    vector<LogicalType> get_info_type_it1_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_info_type_it1 = "it1";
    vector<LogicalType> table_types_info_type_it1;
    vector<unique_ptr<Expression>> filter_info_type_it1;
    unique_ptr<LogicalGet> get_op_info_type_it1 = move(
            getLogicalGet(*this, table_info_type, alias_info_type_it1, table_index_info_type_it1,
                          table_types_info_type_it1));
    unique_ptr<TableFilterSet> table_filters_info_type_it1 = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_it1 = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL, p_info);
    table_filters_info_type_it1->filters[1] = move(constant_filter_it1);
    unique_ptr<PhysicalTableScan> scan_info_type_it1 = make_uniq<PhysicalTableScan>(get_info_type_it1_types,
                                                                                    get_op_info_type_it1->function,
                                                                                    get_op_info_type_it1->table_index,
                                                                                    move(get_op_info_type_it1->bind_data),
                                                                                    table_types_info_type_it1,
                                                                                    info_type_it1_ids,
                                                                                    move(filter_info_type_it1),
                                                                                    vector<column_t>(),
                                                                                    get_op_info_type_it1->names,
                                                                                    std::move(
                                                                                            table_filters_info_type_it1),
                                                                                    get_op_info_type_it1->estimated_cardinality,
                                                                                    get_op_info_type_it1->extra_info);


    vector<JoinCondition> cond_info_type_it1;
    JoinCondition join_condition_info_type_it1;
    join_condition_info_type_it1.left = make_uniq<BoundReferenceExpression>("info_type_rowid", LogicalType::BIGINT, 0);
    join_condition_info_type_it1.right = make_uniq<BoundReferenceExpression>("info_type_id_rowid", LogicalType::BIGINT, 1);
    join_condition_info_type_it1.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_info_type_it1 = make_uniq<RAIInfo>();
    rai_info_info_type_it1->rai = table_movie_info.GetStorage().info->rais[0].get();
    rai_info_info_type_it1->rai_type = RAIType::SOURCE_EDGE;
    rai_info_info_type_it1->forward = false;
    rai_info_info_type_it1->vertex = &table_info_type;
    rai_info_info_type_it1->vertex_id = table_index_info_type_it1;
    rai_info_info_type_it1->passing_tables[0] = table_index_info_type_it1;
    rai_info_info_type_it1->left_cardinalities[0] = table_info_type.GetStorage().info->cardinality;
    // rai_info_info_type_it1->compact_list = &rai_info_info_type_it1->rai->alist->compact__list;

    join_condition_info_type_it1.rais.push_back(move(rai_info_info_type_it1));
    cond_info_type_it1.push_back(move(join_condition_info_type_it1));

    LogicalComparisonJoin join_info_type_it1_op(JoinType::INNER);
    vector<LogicalType> output_info_type_it1_types{LogicalType::BIGINT, LogicalType::VARCHAR,
                                                   LogicalType::BIGINT, LogicalType::VARCHAR,
                                                   LogicalType::VARCHAR};
    join_info_type_it1_op.types = output_info_type_it1_types;
    vector<idx_t> right_projection_map_info_type_it1{0, 2, 4};
    vector<idx_t> merge_project_map_info_type_it1;
    vector<LogicalType> delim_types_info_type_it1;
    auto join_info_type_it1 = make_uniq<PhysicalSIPJoin>(join_info_type_it1_op, move(scan_info_type_it1), move(join_movie_info_),
                                                         move(cond_info_type_it1), JoinType::INNER, left_projection_map,
                                                         right_projection_map_info_type_it1, delim_types_info_type_it1,
                                                         0);

    vector<idx_t> aka_title_at_ids{12};
    vector<LogicalType> get_aka_title_at_types{LogicalType::BIGINT};
    string alias_aka_title_at = "at";
    vector<LogicalType> table_types_aka_title_at;
    vector<unique_ptr<Expression>> filter_aka_title_at;
    unique_ptr<LogicalGet> get_op_aka_title_at = move(
            getLogicalGet(*this, table_aka_title, alias_aka_title_at, table_index_aka_title_at,
                          table_types_aka_title_at));
    unique_ptr<TableFilterSet> table_filters_aka_title_at = NULL;
    unique_ptr<PhysicalTableScan> scan_aka_title_at = make_uniq<PhysicalTableScan>(get_aka_title_at_types,
                                                                                   get_op_aka_title_at->function,
                                                                                   get_op_aka_title_at->table_index,
                                                                                   move(get_op_aka_title_at->bind_data),
                                                                                   table_types_aka_title_at,
                                                                                   aka_title_at_ids,
                                                                                   move(filter_aka_title_at),
                                                                                   vector<column_t>(),
                                                                                   get_op_aka_title_at->names,
                                                                                   std::move(
                                                                                           table_filters_aka_title_at),
                                                                                   get_op_aka_title_at->estimated_cardinality,
                                                                                   get_op_aka_title_at->extra_info);

    vector<JoinCondition> cond_aka_title_to_movie_;
    JoinCondition join_condition_aka_title_to_movie_;
    join_condition_aka_title_to_movie_.left = make_uniq<BoundReferenceExpression>("movie_id_rowid", LogicalType::BIGINT, 0);
    join_condition_aka_title_to_movie_.right = make_uniq<BoundReferenceExpression>("movie_id_rowid", LogicalType::BIGINT, 2);
    join_condition_aka_title_to_movie_.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_aka_title_to_movie_ = make_uniq<RAIInfo>();
    rai_info_aka_title_to_movie_->rai = table_aka_title.GetStorage().info->rais[0].get();
    rai_info_aka_title_to_movie_->rai_type = RAIType::EDGE_SOURCE;
    rai_info_aka_title_to_movie_->forward = true;
    rai_info_aka_title_to_movie_->vertex = &table_title;
    rai_info_aka_title_to_movie_->vertex_id = table_index_title_t;
    rai_info_aka_title_to_movie_->passing_tables[0] = table_index_aka_title_at;
    rai_info_aka_title_to_movie_->left_cardinalities[0] = table_aka_title.GetStorage().info->cardinality;
    rai_info_aka_title_to_movie_->compact_list = &rai_info_aka_title_to_movie_->rai->alist->compact_forward_list;

    join_condition_aka_title_to_movie_.rais.push_back(move(rai_info_aka_title_to_movie_));
    cond_aka_title_to_movie_.push_back(move(join_condition_aka_title_to_movie_));

    LogicalComparisonJoin join_aka_title_to_movie__op(JoinType::INNER);
    vector<LogicalType> output_aka_title_to_movie__types{LogicalType::BIGINT, LogicalType::BIGINT,
                                                         LogicalType::VARCHAR, LogicalType::VARCHAR};
    join_aka_title_to_movie__op.types = output_aka_title_to_movie__types;
    vector<idx_t> right_projection_map_aka_title_to_movie_{2, 3, 4};
    vector<idx_t> merge_project_map_aka_title_to_movie_;
    vector<LogicalType> delim_types_aka_title_to_movie_;
    auto join_aka_title_to_movie_ = make_uniq<PhysicalSIPJoin>(join_aka_title_to_movie__op, move(scan_aka_title_at), move(join_info_type_it1),
                                                                    move(cond_aka_title_to_movie_), JoinType::INNER,
                                                                    left_projection_map,
                                                                    right_projection_map_aka_title_to_movie_,
                                                                    delim_types_aka_title_to_movie_, 0);

    vector<idx_t> keyword_k_ids{COLUMN_IDENTIFIER_ROW_ID};
    vector<LogicalType> get_keyword_k_types{LogicalType::BIGINT};
    string alias_keyword_k = "k";
    vector<LogicalType> table_types_keyword_k;
    vector<unique_ptr<Expression>> filter_keyword_k;
    unique_ptr<LogicalGet> get_op_keyword_k = move(
            getLogicalGet(*this, table_keyword, alias_keyword_k, table_index_keyword_k, table_types_keyword_k));
    unique_ptr<TableFilterSet> table_filters_keyword_k = NULL;
    unique_ptr<PhysicalTableScan> scan_keyword_k = make_uniq<PhysicalTableScan>(get_keyword_k_types,
                                                                                get_op_keyword_k->function,
                                                                                get_op_keyword_k->table_index,
                                                                                move(get_op_keyword_k->bind_data),
                                                                                table_types_keyword_k, keyword_k_ids,
                                                                                move(filter_keyword_k),
                                                                                vector<column_t>(),
                                                                                get_op_keyword_k->names,
                                                                                std::move(table_filters_keyword_k),
                                                                                get_op_keyword_k->estimated_cardinality,
                                                                                get_op_keyword_k->extra_info);


    vector<JoinCondition> cond_movie_keyword_;
    JoinCondition join_condition_movie_keyword_;
    join_condition_movie_keyword_.left = make_uniq<BoundReferenceExpression>("keyword_rowid", LogicalType::BIGINT, 0);
    join_condition_movie_keyword_.right = make_uniq<BoundReferenceExpression>("movie_id_rowid", LogicalType::BIGINT, 1);
    join_condition_movie_keyword_.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_movie_keyword_ = make_uniq<RAIInfo>();
    rai_info_movie_keyword_->rai = table_movie_keyword.GetStorage().info->rais[0].get();
    rai_info_movie_keyword_->rai_type = RAIType::SOURCE_EDGE;
    rai_info_movie_keyword_->forward = false;
    rai_info_movie_keyword_->vertex = &table_keyword;
    rai_info_movie_keyword_->vertex_id = table_index_keyword_k;
    rai_info_movie_keyword_->passing_tables[0] = table_index_keyword_k;
    rai_info_movie_keyword_->left_cardinalities[0] = table_keyword.GetStorage().info->cardinality;
    // rai_info_movie_keyword_->compact_list = &rai_info_movie_keyword_->rai->alist->compact__list;

    join_condition_movie_keyword_.rais.push_back(move(rai_info_movie_keyword_));
    cond_movie_keyword_.push_back(move(join_condition_movie_keyword_));

    LogicalComparisonJoin join_movie_keyword__op(JoinType::INNER);
    vector<LogicalType> output_movie_keyword__types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::VARCHAR};
    join_movie_keyword__op.types = output_movie_keyword__types;
    vector<idx_t> right_projection_map_movie_keyword_{2, 3};
    vector<idx_t> merge_project_map_movie_keyword_;
    vector<LogicalType> delim_types_movie_keyword_;
    auto join_movie_keyword_ = make_uniq<PhysicalMergeSIPJoin>(join_movie_keyword__op, move(scan_keyword_k), move(join_aka_title_to_movie_),
                                                               move(cond_movie_keyword_), JoinType::INNER,
                                                               left_projection_map, right_projection_map_movie_keyword_,
                                                               merge_project_map_movie_keyword_,
                                                               delim_types_movie_keyword_, 0);


    vector<LogicalType> result_types{LogicalType::VARCHAR, LogicalType::VARCHAR};
    vector<unique_ptr<Expression>> select_list;
    auto result_col0 = make_uniq<BoundReferenceExpression>("info", LogicalType::VARCHAR, 1);
    auto result_col1 = make_uniq<BoundReferenceExpression>("title", LogicalType::VARCHAR, 2);
    select_list.push_back(move(result_col0));
    select_list.push_back(move(result_col1));
    auto projection = make_uniq<PhysicalProjection>(result_types, move(select_list), 0);
    projection->children.push_back(move(join_movie_keyword_));

    // aggregate
    string agg_name = "min";
    string agg_error = "";
    QueryErrorContext error_context(NULL, NULL);
    auto min_func = Catalog::GetEntry(context, CatalogType::SCALAR_FUNCTION_ENTRY, "", "",
                                      "min", OnEntryNotFound::RETURN_NULL, error_context);
    auto& min_func_set = min_func->Cast<AggregateFunctionCatalogEntry>();
    // bind the aggregate
    FunctionBinder function_binder(context);
    vector<LogicalType> types;
    types.push_back(LogicalType::VARCHAR);
    idx_t best_function_varchar = function_binder.BindFunction(agg_name, min_func_set.functions, types, agg_error);
    auto bound_function_min_varchar = min_func_set.functions.GetFunctionByOffset(best_function_varchar);

    auto first_children = make_uniq<BoundReferenceExpression>("info", LogicalType::VARCHAR, 0);
    vector<unique_ptr<Expression>> childrenlist1;
    childrenlist1.push_back(move(first_children));
    auto aggregate1 =
            function_binder.BindAggregateFunction(bound_function_min_varchar, std::move(childrenlist1), nullptr, AggregateType::NON_DISTINCT);

    auto second_children = make_uniq<BoundReferenceExpression>("title", LogicalType::VARCHAR, 1);
    vector<unique_ptr<Expression>> childrenlist2;
    childrenlist2.push_back(move(second_children));
    auto aggregate2 =
            function_binder.BindAggregateFunction(bound_function_min_varchar, std::move(childrenlist2), nullptr, AggregateType::NON_DISTINCT);

    vector<unique_ptr<Expression>> aggregates;
    aggregates.push_back(move(aggregate1));
    aggregates.push_back(move(aggregate2));

    vector<LogicalType> aggregate_types{LogicalType::VARCHAR, LogicalType::VARCHAR};
    auto ungrouped_aggregate = make_uniq<PhysicalUngroupedAggregate>(aggregate_types, move(aggregates), 0);
    ungrouped_aggregate->children.push_back(move(projection));

    return ungrouped_aggregate;
}

unique_ptr<PhysicalOperator> ClientContext::GenerateJOB16aPlan(duckdb::ClientContext &context) {
    vector<idx_t> left_projection_map, right_projection_map;

    string table_vertex_aka_name_an = "aka_name";
    string table_vertex_name_n = "name";
    string table_vertex_title_t = "title";
    string table_vertex_keyword_k = "keyword";
    string table_vertex_company_name_cn = "company_name";
    string table_vertex_aka_name_to_name_ = "aka_name_to_name";
    string table_vertex_cast_info_ = "cast_info";
    string table_vertex_movie_keyword_ = "movie_keyword";
    string table_vertex_movie_companies_ = "movie_companies";

    idx_t table_index_aka_name_an = 1;
    idx_t table_index_name_n = 2;
    idx_t table_index_title_t = 3;
    idx_t table_index_keyword_k = 4;
    idx_t table_index_company_name_cn = 5;
    idx_t table_index_aka_name_to_name_ = 6;
    idx_t table_index_cast_info_ = 7;
    idx_t table_index_movie_keyword_ = 8;
    idx_t table_index_movie_companies_ = 9;
    auto table_or_view_aka_name = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_aka_name_an,
                                                    OnEntryNotFound::RETURN_NULL);
    auto &table_aka_name = table_or_view_aka_name->Cast<TableCatalogEntry>();
    auto table_or_view_name = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_name_n,
                                                OnEntryNotFound::RETURN_NULL);
    auto &table_name = table_or_view_name->Cast<TableCatalogEntry>();
    auto table_or_view_title = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_title_t,
                                                 OnEntryNotFound::RETURN_NULL);
    auto &table_title = table_or_view_title->Cast<TableCatalogEntry>();
    auto table_or_view_keyword = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_keyword_k,
                                                   OnEntryNotFound::RETURN_NULL);
    auto &table_keyword = table_or_view_keyword->Cast<TableCatalogEntry>();
    auto table_or_view_company_name = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                        table_vertex_company_name_cn, OnEntryNotFound::RETURN_NULL);
    auto &table_company_name = table_or_view_company_name->Cast<TableCatalogEntry>();
    auto table_or_view_cast_info = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_cast_info_,
                                                     OnEntryNotFound::RETURN_NULL);
    auto &table_cast_info = table_or_view_cast_info->Cast<TableCatalogEntry>();
    auto table_or_view_movie_keyword = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                         table_vertex_movie_keyword_, OnEntryNotFound::RETURN_NULL);
    auto &table_movie_keyword = table_or_view_movie_keyword->Cast<TableCatalogEntry>();
    auto table_or_view_movie_companies = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                           table_vertex_movie_companies_, OnEntryNotFound::RETURN_NULL);
    auto &table_movie_companies = table_or_view_movie_companies->Cast<TableCatalogEntry>();

    string p_country_code = "[us]";
    Value p_code = Value(p_country_code);
    vector<idx_t> company_name_cn_ids{COLUMN_IDENTIFIER_ROW_ID, 2};
    vector<LogicalType> get_company_name_cn_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_company_name_cn = "cn";
    vector<LogicalType> table_types_company_name_cn;
    vector<unique_ptr<Expression>> filter_company_name_cn;
    unique_ptr<LogicalGet> get_op_company_name_cn = move(
            getLogicalGet(*this, table_company_name, alias_company_name_cn, table_index_company_name_cn,
                          table_types_company_name_cn));
    unique_ptr<TableFilterSet> table_filters_company_name_cn = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_cn = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL, p_code);
    table_filters_company_name_cn->filters[1] = move(constant_filter_cn);
    unique_ptr<PhysicalTableScan> scan_company_name_cn = make_uniq<PhysicalTableScan>(get_company_name_cn_types,
                                                                                      get_op_company_name_cn->function,
                                                                                      get_op_company_name_cn->table_index,
                                                                                      move(get_op_company_name_cn->bind_data),
                                                                                      table_types_company_name_cn,
                                                                                      company_name_cn_ids,
                                                                                      move(filter_company_name_cn),
                                                                                      vector<column_t>(),
                                                                                      get_op_company_name_cn->names,
                                                                                      std::move(
                                                                                              table_filters_company_name_cn),
                                                                                      get_op_company_name_cn->estimated_cardinality,
                                                                                      get_op_company_name_cn->extra_info);


    idx_t p_nr_left_n = 50;
    idx_t p_nr_right_n = 100;
    Value p_nr_left = Value::BIGINT(p_nr_left_n);
    Value p_nr_right = Value::BIGINT(p_nr_right_n);
    vector<idx_t> title_t_ids{COLUMN_IDENTIFIER_ROW_ID, 1, 9};
    vector<LogicalType> get_title_t_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::BIGINT};
    string alias_title_t = "t";
    vector<LogicalType> table_types_title_t;
    vector<unique_ptr<Expression>> filter_title_t;
    unique_ptr<LogicalGet> get_op_title_t = move(
            getLogicalGet(*this, table_title, alias_title_t, table_index_title_t, table_types_title_t));
    unique_ptr<TableFilterSet> table_filters_title_t = make_uniq<TableFilterSet>();
    unique_ptr<ConjunctionAndFilter> and_filter_t = duckdb::make_uniq<ConjunctionAndFilter>();
    unique_ptr<ConstantFilter> constant_filter_t_start = duckdb::make_uniq<ConstantFilter>(
            ExpressionType::COMPARE_GREATERTHANOREQUALTO, p_nr_left);
    unique_ptr<ConstantFilter> constant_filter_t_end = duckdb::make_uniq<ConstantFilter>(
            ExpressionType::COMPARE_LESSTHAN, p_nr_right);
    and_filter_t->child_filters.push_back(move(constant_filter_t_start));
    and_filter_t->child_filters.push_back(move(constant_filter_t_end));
    table_filters_title_t->filters[2] = move(and_filter_t);
    unique_ptr<PhysicalTableScan> scan_title_t = make_uniq<PhysicalTableScan>(get_title_t_types,
                                                                              get_op_title_t->function,
                                                                              get_op_title_t->table_index,
                                                                              move(get_op_title_t->bind_data),
                                                                              table_types_title_t, title_t_ids,
                                                                              move(filter_title_t), vector<column_t>(),
                                                                              get_op_title_t->names,
                                                                              std::move(table_filters_title_t),
                                                                              get_op_title_t->estimated_cardinality,
                                                                              get_op_title_t->extra_info);


    vector<JoinCondition> cond_title_t;
    JoinCondition join_condition_title_t;
    join_condition_title_t.left = make_uniq<BoundReferenceExpression>("title_rowid", LogicalType::BIGINT, 0);
    join_condition_title_t.right = make_uniq<BoundReferenceExpression>("company_name_rowid", LogicalType::BIGINT, 0);
    join_condition_title_t.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_title_t = make_uniq<RAIInfo>();
    rai_info_title_t->rai = table_movie_companies.GetStorage().info->rais[0].get();
    rai_info_title_t->rai_type = RAIType::TARGET_EDGE;
    rai_info_title_t->forward = true;
    rai_info_title_t->vertex = &table_title;
    rai_info_title_t->vertex_id = table_index_title_t;
    rai_info_title_t->passing_tables[0] = table_index_title_t;
    rai_info_title_t->left_cardinalities[0] = table_title.GetStorage().info->cardinality;
    // rai_info_title_t->compact_list = &rai_info_title_t->rai->alist->compact__list;

    join_condition_title_t.rais.push_back(move(rai_info_title_t));
    cond_title_t.push_back(move(join_condition_title_t));

    LogicalComparisonJoin join_title_t_op(JoinType::INNER);
    vector<LogicalType> output_title_t_types{LogicalType::BIGINT, LogicalType::VARCHAR,
                                             LogicalType::BIGINT, LogicalType::BIGINT};
    join_title_t_op.types = output_title_t_types;
    vector<idx_t> right_projection_map_title_t{0};
    vector<idx_t> merge_project_map_title_t;
    vector<LogicalType> delim_types_title_t;
    auto join_title_t = make_uniq<PhysicalMergeSIPJoin>(join_title_t_op, move(scan_title_t), move(scan_company_name_cn), move(cond_title_t), JoinType::INNER,
                                                   left_projection_map, right_projection_map_title_t,
                                                   merge_project_map_title_t, delim_types_title_t, 0);


    string p_keyword_n = "character-name-in-title";
    Value p_keyword = Value(p_keyword_n);
    vector<idx_t> keyword_k_ids{COLUMN_IDENTIFIER_ROW_ID, 1};
    vector<LogicalType> get_keyword_k_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_keyword_k = "k";
    vector<LogicalType> table_types_keyword_k;
    vector<unique_ptr<Expression>> filter_keyword_k;
    unique_ptr<LogicalGet> get_op_keyword_k = move(
            getLogicalGet(*this, table_keyword, alias_keyword_k, table_index_keyword_k, table_types_keyword_k));
    unique_ptr<TableFilterSet> table_filters_keyword_k = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_k = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL, p_keyword);
    table_filters_keyword_k->filters[1] = move(constant_filter_k);
    unique_ptr<PhysicalTableScan> scan_keyword_k = make_uniq<PhysicalTableScan>(get_keyword_k_types,
                                                                                get_op_keyword_k->function,
                                                                                get_op_keyword_k->table_index,
                                                                                move(get_op_keyword_k->bind_data),
                                                                                table_types_keyword_k, keyword_k_ids,
                                                                                move(filter_keyword_k),
                                                                                vector<column_t>(),
                                                                                get_op_keyword_k->names,
                                                                                std::move(table_filters_keyword_k),
                                                                                get_op_keyword_k->estimated_cardinality,
                                                                                get_op_keyword_k->extra_info);


    vector<JoinCondition> cond_keyword_k;
    JoinCondition join_condition_keyword_k;
    join_condition_keyword_k.left = make_uniq<BoundReferenceExpression>("keyword_rowid", LogicalType::BIGINT, 0);
    join_condition_keyword_k.right = make_uniq<BoundReferenceExpression>("title_rowid", LogicalType::BIGINT, 0);
    join_condition_keyword_k.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_keyword_k = make_uniq<RAIInfo>();
    rai_info_keyword_k->rai = table_movie_keyword.GetStorage().info->rais[0].get();
    rai_info_keyword_k->rai_type = RAIType::SOURCE_EDGE;
    rai_info_keyword_k->forward = false;
    rai_info_keyword_k->vertex = &table_keyword;
    rai_info_keyword_k->vertex_id = table_index_keyword_k;
    rai_info_keyword_k->passing_tables[0] = table_index_keyword_k;
    rai_info_keyword_k->left_cardinalities[0] = table_keyword.GetStorage().info->cardinality;
    // rai_info_keyword_k->compact_list = &rai_info_keyword_k->rai->alist->compact__list;

    join_condition_keyword_k.rais.push_back(move(rai_info_keyword_k));
    cond_keyword_k.push_back(move(join_condition_keyword_k));

    LogicalComparisonJoin join_keyword_k_op(JoinType::INNER);
    vector<LogicalType> output_keyword_k_types{LogicalType::BIGINT, LogicalType::VARCHAR,
                                               LogicalType::BIGINT, LogicalType::VARCHAR};
    join_keyword_k_op.types = output_keyword_k_types;
    vector<idx_t> right_projection_map_keyword_k{0, 1};
    vector<idx_t> merge_project_map_keyword_k;
    vector<LogicalType> delim_types_keyword_k;
    auto join_keyword_k = make_uniq<PhysicalMergeSIPJoin>(join_keyword_k_op, move(scan_keyword_k), move(join_title_t), move(cond_keyword_k),
                                                     JoinType::INNER, left_projection_map,
                                                     right_projection_map_keyword_k,
                                                     merge_project_map_keyword_k,
                                                     delim_types_keyword_k, 0);


    vector<idx_t> name_n_ids{COLUMN_IDENTIFIER_ROW_ID};
    vector<LogicalType> get_name_n_types{LogicalType::BIGINT};
    string alias_name_n = "n";
    vector<LogicalType> table_types_name_n;
    vector<unique_ptr<Expression>> filter_name_n;
    unique_ptr<LogicalGet> get_op_name_n = move(
            getLogicalGet(*this, table_name, alias_name_n, table_index_name_n, table_types_name_n));
    unique_ptr<TableFilterSet> table_filters_name_n = NULL;
    unique_ptr<PhysicalTableScan> scan_name_n = make_uniq<PhysicalTableScan>(get_name_n_types, get_op_name_n->function,
                                                                             get_op_name_n->table_index,
                                                                             move(get_op_name_n->bind_data),
                                                                             table_types_name_n, name_n_ids,
                                                                             move(filter_name_n), vector<column_t>(),
                                                                             get_op_name_n->names,
                                                                             std::move(table_filters_name_n),
                                                                             get_op_name_n->estimated_cardinality,
                                                                             get_op_name_n->extra_info);


    vector<JoinCondition> cond_cast_info_;
    JoinCondition join_condition_cast_info_;
    join_condition_cast_info_.left = make_uniq<BoundReferenceExpression>("name_rowod", LogicalType::BIGINT, 0);
    join_condition_cast_info_.right = make_uniq<BoundReferenceExpression>("title_rowid", LogicalType::BIGINT, 2);
    join_condition_cast_info_.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_cast_info_ = make_uniq<RAIInfo>();
    rai_info_cast_info_->rai = table_cast_info.GetStorage().info->rais[0].get();
    rai_info_cast_info_->rai_type = RAIType::TARGET_EDGE;
    rai_info_cast_info_->forward = true;
    rai_info_cast_info_->vertex = &table_name;
    rai_info_cast_info_->vertex_id = table_index_name_n;
    rai_info_cast_info_->passing_tables[0] = table_index_name_n;
    rai_info_cast_info_->left_cardinalities[0] = table_name.GetStorage().info->cardinality;
    // rai_info_cast_info_->compact_list = &rai_info_cast_info_->rai->alist->compact__list;

    join_condition_cast_info_.rais.push_back(move(rai_info_cast_info_));
    cond_cast_info_.push_back(move(join_condition_cast_info_));

    LogicalComparisonJoin join_cast_info__op(JoinType::INNER);
    vector<LogicalType> output_cast_info__types{LogicalType::BIGINT, LogicalType::VARCHAR};
    join_cast_info__op.types = output_cast_info__types;
    vector<idx_t> right_projection_map_cast_info_{3};
    vector<idx_t> merge_project_map_cast_info_;
    vector<LogicalType> delim_types_cast_info_;
    auto join_cast_info_ = make_uniq<PhysicalMergeSIPJoin>(join_cast_info__op, move(scan_name_n), move(join_keyword_k), move(cond_cast_info_),
                                                           JoinType::INNER, left_projection_map,
                                                           right_projection_map_cast_info_,
                                                           merge_project_map_cast_info_, delim_types_cast_info_, 0);


    vector<idx_t> aka_name_an_ids{8, 2};
    vector<LogicalType> get_aka_name_an_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_aka_name_an = "an";
    vector<LogicalType> table_types_aka_name_an;
    vector<unique_ptr<Expression>> filter_aka_name_an;
    unique_ptr<LogicalGet> get_op_aka_name_an = move(
            getLogicalGet(*this, table_aka_name, alias_aka_name_an, table_index_aka_name_an, table_types_aka_name_an));
    unique_ptr<TableFilterSet> table_filters_aka_name_an = NULL;
    unique_ptr<PhysicalTableScan> scan_aka_name_an = make_uniq<PhysicalTableScan>(get_aka_name_an_types,
                                                                                  get_op_aka_name_an->function,
                                                                                  get_op_aka_name_an->table_index,
                                                                                  move(get_op_aka_name_an->bind_data),
                                                                                  table_types_aka_name_an,
                                                                                  aka_name_an_ids,
                                                                                  move(filter_aka_name_an),
                                                                                  vector<column_t>(),
                                                                                  get_op_aka_name_an->names,
                                                                                  std::move(table_filters_aka_name_an),
                                                                                  get_op_aka_name_an->estimated_cardinality,
                                                                                  get_op_aka_name_an->extra_info);


    vector<JoinCondition> cond_aka_name_to_name_;
    JoinCondition join_condition_aka_name_to_name_;
    join_condition_aka_name_to_name_.left = make_uniq<BoundReferenceExpression>("person_id_rowid", LogicalType::BIGINT, 0);
    join_condition_aka_name_to_name_.right = make_uniq<BoundReferenceExpression>("name_rowid", LogicalType::BIGINT, 0);
    join_condition_aka_name_to_name_.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_aka_name_to_name_ = make_uniq<RAIInfo>();
    rai_info_aka_name_to_name_->rai = table_aka_name.GetStorage().info->rais[0].get();
    rai_info_aka_name_to_name_->rai_type = RAIType::EDGE_SOURCE;
    rai_info_aka_name_to_name_->forward = true;
    rai_info_aka_name_to_name_->vertex = &table_name;
    rai_info_aka_name_to_name_->vertex_id = table_index_name_n;
    rai_info_aka_name_to_name_->passing_tables[0] = table_index_aka_name_an;
    rai_info_aka_name_to_name_->left_cardinalities[0] = table_aka_name.GetStorage().info->cardinality;
    rai_info_aka_name_to_name_->compact_list = &rai_info_aka_name_to_name_->rai->alist->compact_forward_list;

    join_condition_aka_name_to_name_.rais.push_back(move(rai_info_aka_name_to_name_));
    cond_aka_name_to_name_.push_back(move(join_condition_aka_name_to_name_));

    LogicalComparisonJoin join_aka_name_to_name__op(JoinType::INNER);
    vector<LogicalType> output_aka_name_to_name__types{LogicalType::BIGINT, LogicalType::VARCHAR,
                                                       LogicalType::VARCHAR};
    join_aka_name_to_name__op.types = output_aka_name_to_name__types;
    vector<idx_t> right_projection_map_aka_name_to_name_{1};
    vector<idx_t> merge_project_map_aka_name_to_name_;
    vector<LogicalType> delim_types_aka_name_to_name_;
    auto join_aka_name_to_name_ = make_uniq<PhysicalSIPJoin>(join_aka_name_to_name__op, move(scan_aka_name_an), move(join_cast_info_),
                                                                  move(cond_aka_name_to_name_), JoinType::INNER,
                                                                  left_projection_map,
                                                                  right_projection_map_aka_name_to_name_,
                                                                  delim_types_aka_name_to_name_, 0);


    vector<LogicalType> result_types{LogicalType::VARCHAR, LogicalType::VARCHAR};
    vector<unique_ptr<Expression>> select_list;
    auto result_col0 = make_uniq<BoundReferenceExpression>("name", LogicalType::VARCHAR, 1);
    auto result_col1 = make_uniq<BoundReferenceExpression>("title", LogicalType::VARCHAR, 2);
    select_list.push_back(move(result_col0));
    select_list.push_back(move(result_col1));
    auto projection = make_uniq<PhysicalProjection>(result_types, move(select_list), 0);
    projection->children.push_back(move(join_aka_name_to_name_));

    // aggregate
    string agg_name = "min";
    string agg_error = "";
    QueryErrorContext error_context(NULL, NULL);
    auto min_func = Catalog::GetEntry(context, CatalogType::SCALAR_FUNCTION_ENTRY, "", "",
                                      "min", OnEntryNotFound::RETURN_NULL, error_context);
    auto& min_func_set = min_func->Cast<AggregateFunctionCatalogEntry>();
    // bind the aggregate
    FunctionBinder function_binder(context);
    vector<LogicalType> types;
    types.push_back(LogicalType::VARCHAR);
    idx_t best_function_varchar = function_binder.BindFunction(agg_name, min_func_set.functions, types, agg_error);
    auto bound_function_min_varchar = min_func_set.functions.GetFunctionByOffset(best_function_varchar);

    auto first_children = make_uniq<BoundReferenceExpression>("name", LogicalType::VARCHAR, 0);
    vector<unique_ptr<Expression>> childrenlist1;
    childrenlist1.push_back(move(first_children));
    auto aggregate1 =
            function_binder.BindAggregateFunction(bound_function_min_varchar, std::move(childrenlist1), nullptr, AggregateType::NON_DISTINCT);

    auto second_children = make_uniq<BoundReferenceExpression>("title", LogicalType::VARCHAR, 1);
    vector<unique_ptr<Expression>> childrenlist2;
    childrenlist2.push_back(move(second_children));
    auto aggregate2 =
            function_binder.BindAggregateFunction(bound_function_min_varchar, std::move(childrenlist2), nullptr, AggregateType::NON_DISTINCT);

    vector<unique_ptr<Expression>> aggregates;
    aggregates.push_back(move(aggregate1));
    aggregates.push_back(move(aggregate2));

    vector<LogicalType> aggregate_types{LogicalType::VARCHAR, LogicalType::VARCHAR};
    auto ungrouped_aggregate = make_uniq<PhysicalUngroupedAggregate>(aggregate_types, move(aggregates), 0);
    ungrouped_aggregate->children.push_back(move(projection));

    return ungrouped_aggregate;
}

unique_ptr<PhysicalOperator> ClientContext::GenerateJOB17aPlan(duckdb::ClientContext &context) {
    vector<idx_t> left_projection_map, right_projection_map;

    string table_vertex_name_n = "name";
    string table_vertex_title_t = "title";
    string table_vertex_keyword_k = "keyword";
    string table_vertex_company_name_cn = "company_name";
    string table_vertex_cast_info_ = "cast_info";
    string table_vertex_movie_keyword_ = "movie_keyword";
    string table_vertex_movie_companies_ = "movie_companies";

    idx_t table_index_name_n = 1;
    idx_t table_index_title_t = 2;
    idx_t table_index_keyword_k = 3;
    idx_t table_index_company_name_cn = 4;
    idx_t table_index_cast_info_ = 5;
    idx_t table_index_movie_keyword_ = 6;
    idx_t table_index_movie_companies_ = 7;
    auto table_or_view_name = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_name_n,
                                                OnEntryNotFound::RETURN_NULL);
    auto &table_name = table_or_view_name->Cast<TableCatalogEntry>();
    auto table_or_view_title = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_title_t,
                                                 OnEntryNotFound::RETURN_NULL);
    auto &table_title = table_or_view_title->Cast<TableCatalogEntry>();
    auto table_or_view_keyword = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_keyword_k,
                                                   OnEntryNotFound::RETURN_NULL);
    auto &table_keyword = table_or_view_keyword->Cast<TableCatalogEntry>();
    auto table_or_view_company_name = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                        table_vertex_company_name_cn, OnEntryNotFound::RETURN_NULL);
    auto &table_company_name = table_or_view_company_name->Cast<TableCatalogEntry>();
    auto table_or_view_cast_info = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_cast_info_,
                                                     OnEntryNotFound::RETURN_NULL);
    auto &table_cast_info = table_or_view_cast_info->Cast<TableCatalogEntry>();
    auto table_or_view_movie_keyword = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                         table_vertex_movie_keyword_, OnEntryNotFound::RETURN_NULL);
    auto &table_movie_keyword = table_or_view_movie_keyword->Cast<TableCatalogEntry>();
    auto table_or_view_movie_companies = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                           table_vertex_movie_companies_, OnEntryNotFound::RETURN_NULL);
    auto &table_movie_companies = table_or_view_movie_companies->Cast<TableCatalogEntry>();

    string p_country_code_n = "[us]";
    Value p_code = Value(p_country_code_n);
    vector<idx_t> company_name_cn_ids{COLUMN_IDENTIFIER_ROW_ID, 2};
    vector<LogicalType> get_company_name_cn_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_company_name_cn = "cn";
    vector<LogicalType> table_types_company_name_cn;
    vector<unique_ptr<Expression>> filter_company_name_cn;
    unique_ptr<LogicalGet> get_op_company_name_cn = move(
            getLogicalGet(*this, table_company_name, alias_company_name_cn, table_index_company_name_cn,
                          table_types_company_name_cn));
    unique_ptr<TableFilterSet> table_filters_company_name_cn = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_cn = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL, p_code);
    table_filters_company_name_cn->filters[1] = move(constant_filter_cn);
    unique_ptr<PhysicalTableScan> scan_company_name_cn = make_uniq<PhysicalTableScan>(get_company_name_cn_types,
                                                                                      get_op_company_name_cn->function,
                                                                                      get_op_company_name_cn->table_index,
                                                                                      move(get_op_company_name_cn->bind_data),
                                                                                      table_types_company_name_cn,
                                                                                      company_name_cn_ids,
                                                                                      move(filter_company_name_cn),
                                                                                      vector<column_t>(),
                                                                                      get_op_company_name_cn->names,
                                                                                      std::move(
                                                                                              table_filters_company_name_cn),
                                                                                      get_op_company_name_cn->estimated_cardinality,
                                                                                      get_op_company_name_cn->extra_info);


    vector<idx_t> title_t_ids{COLUMN_IDENTIFIER_ROW_ID};
    vector<LogicalType> get_title_t_types{LogicalType::BIGINT};
    string alias_title_t = "t";
    vector<LogicalType> table_types_title_t;
    vector<unique_ptr<Expression>> filter_title_t;
    unique_ptr<LogicalGet> get_op_title_t = move(
            getLogicalGet(*this, table_title, alias_title_t, table_index_title_t, table_types_title_t));
    unique_ptr<TableFilterSet> table_filters_title_t = NULL;
    unique_ptr<PhysicalTableScan> scan_title_t = make_uniq<PhysicalTableScan>(get_title_t_types,
                                                                              get_op_title_t->function,
                                                                              get_op_title_t->table_index,
                                                                              move(get_op_title_t->bind_data),
                                                                              table_types_title_t, title_t_ids,
                                                                              move(filter_title_t), vector<column_t>(),
                                                                              get_op_title_t->names,
                                                                              std::move(table_filters_title_t),
                                                                              get_op_title_t->estimated_cardinality,
                                                                              get_op_title_t->extra_info);


    vector<JoinCondition> cond_movie_companies_;
    JoinCondition join_condition_movie_companies_;
    join_condition_movie_companies_.left = make_uniq<BoundReferenceExpression>("title_rowid", LogicalType::BIGINT, 0);
    join_condition_movie_companies_.right = make_uniq<BoundReferenceExpression>("company_name_rowid", LogicalType::BIGINT, 0);
    join_condition_movie_companies_.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_movie_companies_ = make_uniq<RAIInfo>();
    rai_info_movie_companies_->rai = table_movie_companies.GetStorage().info->rais[0].get();
    rai_info_movie_companies_->rai_type = RAIType::TARGET_EDGE;
    rai_info_movie_companies_->forward = true;
    rai_info_movie_companies_->vertex = &table_title;
    rai_info_movie_companies_->vertex_id = table_index_title_t;
    rai_info_movie_companies_->passing_tables[0] = table_index_title_t;
    rai_info_movie_companies_->left_cardinalities[0] = table_title.GetStorage().info->cardinality;
    // rai_info_movie_companies_->compact_list = &rai_info_movie_companies_->rai->alist->compact__list;

    join_condition_movie_companies_.rais.push_back(move(rai_info_movie_companies_));
    cond_movie_companies_.push_back(move(join_condition_movie_companies_));

    LogicalComparisonJoin join_movie_companies__op(JoinType::INNER);
    vector<LogicalType> output_movie_companies__types{LogicalType::BIGINT, LogicalType::BIGINT};
    join_movie_companies__op.types = output_movie_companies__types;
    vector<idx_t> right_projection_map_movie_companies_{0};
    vector<idx_t> merge_project_map_movie_companies_;
    vector<LogicalType> delim_types_movie_companies_;
    auto join_movie_companies_ = make_uniq<PhysicalMergeSIPJoin>(join_movie_companies__op, move(scan_title_t), move(scan_company_name_cn),
                                                                 move(cond_movie_companies_), JoinType::INNER,
                                                                 left_projection_map,
                                                                 right_projection_map_movie_companies_,
                                                                 merge_project_map_movie_companies_,
                                                                 delim_types_movie_companies_, 0);

    string p_keyword_n = "character-name-in-title";
    Value p_keyword = Value(p_keyword_n);
    vector<idx_t> keyword_k_ids{COLUMN_IDENTIFIER_ROW_ID, 1};
    vector<LogicalType> get_keyword_k_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_keyword_k = "k";
    vector<LogicalType> table_types_keyword_k;
    vector<unique_ptr<Expression>> filter_keyword_k;
    unique_ptr<LogicalGet> get_op_keyword_k = move(
            getLogicalGet(*this, table_keyword, alias_keyword_k, table_index_keyword_k, table_types_keyword_k));
    unique_ptr<TableFilterSet> table_filters_keyword_k = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_k = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL, p_keyword);
    table_filters_keyword_k->filters[1] = move(constant_filter_k);
    unique_ptr<PhysicalTableScan> scan_keyword_k = make_uniq<PhysicalTableScan>(get_keyword_k_types,
                                                                                get_op_keyword_k->function,
                                                                                get_op_keyword_k->table_index,
                                                                                move(get_op_keyword_k->bind_data),
                                                                                table_types_keyword_k, keyword_k_ids,
                                                                                move(filter_keyword_k),
                                                                                vector<column_t>(),
                                                                                get_op_keyword_k->names,
                                                                                std::move(table_filters_keyword_k),
                                                                                get_op_keyword_k->estimated_cardinality,
                                                                                get_op_keyword_k->extra_info);


    vector<JoinCondition> cond_keyword_k;
    JoinCondition join_condition_keyword_k;
    join_condition_keyword_k.left = make_uniq<BoundReferenceExpression>("keyword_rowid", LogicalType::BIGINT, 0);
    join_condition_keyword_k.right = make_uniq<BoundReferenceExpression>("title_rowid", LogicalType::BIGINT, 0);
    join_condition_keyword_k.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_keyword_k = make_uniq<RAIInfo>();
    rai_info_keyword_k->rai = table_movie_keyword.GetStorage().info->rais[0].get();
    rai_info_keyword_k->rai_type = RAIType::SOURCE_EDGE;
    rai_info_keyword_k->forward = false;
    rai_info_keyword_k->vertex = &table_keyword;
    rai_info_keyword_k->vertex_id = table_index_keyword_k;
    rai_info_keyword_k->passing_tables[0] = table_index_keyword_k;
    rai_info_keyword_k->left_cardinalities[0] = table_keyword.GetStorage().info->cardinality;
    // rai_info_keyword_k->compact_list = &rai_info_keyword_k->rai->alist->compact__list;

    join_condition_keyword_k.rais.push_back(move(rai_info_keyword_k));
    cond_keyword_k.push_back(move(join_condition_keyword_k));

    LogicalComparisonJoin join_keyword_k_op(JoinType::INNER);
    vector<LogicalType> output_keyword_k_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::BIGINT};
    join_keyword_k_op.types = output_keyword_k_types;
    vector<idx_t> right_projection_map_keyword_k{0};
    vector<idx_t> merge_project_map_keyword_k;
    vector<LogicalType> delim_types_keyword_k;
    auto join_keyword_k = make_uniq<PhysicalMergeSIPJoin>(join_keyword_k_op, move(scan_keyword_k), move(join_movie_companies_), move(cond_keyword_k),
                                                     JoinType::INNER, left_projection_map,
                                                     right_projection_map_keyword_k,
                                                     merge_project_map_keyword_k,
                                                     delim_types_keyword_k, 0);

    vector<idx_t> name_n_ids{COLUMN_IDENTIFIER_ROW_ID, 1};
    vector<LogicalType> get_name_n_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_name_n = "n";
    vector<LogicalType> table_types_name_n;
    vector<unique_ptr<Expression>> filter_name_n;
    unique_ptr<LogicalGet> get_op_name_n = move(
            getLogicalGet(*this, table_name, alias_name_n, table_index_name_n, table_types_name_n));
    unique_ptr<TableFilterSet> table_filters_name_n = NULL;
    unique_ptr<PhysicalTableScan> scan_name_n = make_uniq<PhysicalTableScan>(get_name_n_types, get_op_name_n->function,
                                                                             get_op_name_n->table_index,
                                                                             move(get_op_name_n->bind_data),
                                                                             table_types_name_n, name_n_ids,
                                                                             move(filter_name_n), vector<column_t>(),
                                                                             get_op_name_n->names,
                                                                             std::move(table_filters_name_n),
                                                                             get_op_name_n->estimated_cardinality,
                                                                             get_op_name_n->extra_info);


    string p_name_n = "B%";
    Value p_name = Value(p_name_n);
    vector<LogicalType> filter_name_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    vector<unique_ptr<Expression>> select_list_name;
    auto like_expression_left = make_uniq<BoundReferenceExpression>("name", LogicalType::VARCHAR, 1);
    auto like_expression_value = make_uniq<BoundConstantExpression>(p_name);
    vector<unique_ptr<Expression>> like_arguments;
    like_arguments.push_back(move(like_expression_left));
    like_arguments.push_back(move(like_expression_value));

    QueryErrorContext error_context_unlike(NULL, NULL);
    ScalarFunction bound_function_like = LikeFun::GetLikeFunction();
    unique_ptr<FunctionData> bind_data_like = NULL;

    auto like_bound_function = make_uniq<BoundFunctionExpression>(LogicalType::BOOLEAN,
                                                                  bound_function_like,
                                                                  move(like_arguments),
                                                                  move(bind_data_like), false);

    select_list_name.push_back(move(like_bound_function));
    unique_ptr<PhysicalFilter> filter_like = make_uniq<PhysicalFilter>(filter_name_types, move(select_list_name), 0);
    filter_like->children.push_back(move(scan_name_n));

    vector<JoinCondition> cond_name_n;
    JoinCondition join_condition_name_n;
    join_condition_name_n.left = make_uniq<BoundReferenceExpression>("name_rowid", LogicalType::BIGINT, 0);
    join_condition_name_n.right = make_uniq<BoundReferenceExpression>("title_rowid", LogicalType::BIGINT, 2);
    join_condition_name_n.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_name_n = make_uniq<RAIInfo>();
    rai_info_name_n->rai = table_cast_info.GetStorage().info->rais[0].get();
    rai_info_name_n->rai_type = RAIType::TARGET_EDGE;
    rai_info_name_n->forward = true;
    rai_info_name_n->vertex = &table_name;
    rai_info_name_n->vertex_id = table_index_name_n;
    rai_info_name_n->passing_tables[0] = table_index_name_n;
    rai_info_name_n->left_cardinalities[0] = table_name.GetStorage().info->cardinality;
    // rai_info_name_n->compact_list = &rai_info_name_n->rai->alist->compact__list;

    join_condition_name_n.rais.push_back(move(rai_info_name_n));
    cond_name_n.push_back(move(join_condition_name_n));

    LogicalComparisonJoin join_name_n_op(JoinType::INNER);
    vector<LogicalType> output_name_n_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::BIGINT};
    join_name_n_op.types = output_name_n_types;
    vector<idx_t> right_projection_map_name_n{0};
    vector<idx_t> merge_project_map_name_n;
    vector<LogicalType> delim_types_name_n;
    auto join_name_n = make_uniq<PhysicalMergeSIPJoin>(join_name_n_op, move(filter_like), move(join_keyword_k), move(cond_name_n), JoinType::INNER,
                                                  left_projection_map, right_projection_map_name_n,
                                                  merge_project_map_name_n,
                                                  delim_types_name_n,
                                                  0);


    vector<LogicalType> result_types{LogicalType::VARCHAR, LogicalType::VARCHAR};
    vector<unique_ptr<Expression>> select_list;
    auto result_col0 = make_uniq<BoundReferenceExpression>("name", LogicalType::VARCHAR, 1);
    auto result_col1 = make_uniq<BoundReferenceExpression>("ma,e", LogicalType::VARCHAR, 1);
    select_list.push_back(move(result_col0));
    select_list.push_back(move(result_col1));
    auto projection = make_uniq<PhysicalProjection>(result_types, move(select_list), 0);
    projection->children.push_back(move(join_name_n));

    // aggregate
    string agg_name = "min";
    string agg_error = "";
    QueryErrorContext error_context(NULL, NULL);
    auto min_func = Catalog::GetEntry(context, CatalogType::SCALAR_FUNCTION_ENTRY, "", "",
                                      "min", OnEntryNotFound::RETURN_NULL, error_context);
    auto& min_func_set = min_func->Cast<AggregateFunctionCatalogEntry>();
    // bind the aggregate
    FunctionBinder function_binder(context);
    vector<LogicalType> types;
    types.push_back(LogicalType::VARCHAR);
    idx_t best_function_varchar = function_binder.BindFunction(agg_name, min_func_set.functions, types, agg_error);
    auto bound_function_min_varchar = min_func_set.functions.GetFunctionByOffset(best_function_varchar);

    auto first_children = make_uniq<BoundReferenceExpression>("name", LogicalType::VARCHAR, 0);
    vector<unique_ptr<Expression>> childrenlist1;
    childrenlist1.push_back(move(first_children));
    auto aggregate1 =
            function_binder.BindAggregateFunction(bound_function_min_varchar, std::move(childrenlist1), nullptr, AggregateType::NON_DISTINCT);

    auto second_children = make_uniq<BoundReferenceExpression>("title", LogicalType::VARCHAR, 1);
    vector<unique_ptr<Expression>> childrenlist2;
    childrenlist2.push_back(move(second_children));
    auto aggregate2 =
            function_binder.BindAggregateFunction(bound_function_min_varchar, std::move(childrenlist2), nullptr, AggregateType::NON_DISTINCT);

    vector<unique_ptr<Expression>> aggregates;
    aggregates.push_back(move(aggregate1));
    aggregates.push_back(move(aggregate2));

    vector<LogicalType> aggregate_types{LogicalType::VARCHAR, LogicalType::VARCHAR};
    auto ungrouped_aggregate = make_uniq<PhysicalUngroupedAggregate>(aggregate_types, move(aggregates), 0);
    ungrouped_aggregate->children.push_back(move(projection));

    return ungrouped_aggregate;
}

unique_ptr<PhysicalOperator> ClientContext::GenerateJOB18aPlan(duckdb::ClientContext &context) {
    vector<idx_t> left_projection_map, right_projection_map;

    string table_vertex_name_n = "name";
    string table_vertex_title_t = "title";
    string table_vertex_info_type_it1 = "info_type";
    string table_vertex_info_type_it2 = "info_type";
    string table_vertex_cast_info_ = "cast_info";
    string table_vertex_movie_info_ = "movie_info";
    string table_vertex_movie_info_idx_ = "movie_info_idx";

    idx_t table_index_name_n = 1;
    idx_t table_index_title_t = 2;
    idx_t table_index_info_type_it1 = 3;
    idx_t table_index_info_type_it2 = 4;
    idx_t table_index_cast_info_ = 5;
    idx_t table_index_movie_info_ = 6;
    idx_t table_index_movie_info_idx_ = 7;
    auto table_or_view_name = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_name_n,
                                                OnEntryNotFound::RETURN_NULL);
    auto &table_name = table_or_view_name->Cast<TableCatalogEntry>();
    auto table_or_view_title = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_title_t,
                                                 OnEntryNotFound::RETURN_NULL);
    auto &table_title = table_or_view_title->Cast<TableCatalogEntry>();
    auto table_or_view_info_type = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                     table_vertex_info_type_it1, OnEntryNotFound::RETURN_NULL);
    auto &table_info_type = table_or_view_info_type->Cast<TableCatalogEntry>();
    auto table_or_view_cast_info = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_cast_info_,
                                                     OnEntryNotFound::RETURN_NULL);
    auto &table_cast_info = table_or_view_cast_info->Cast<TableCatalogEntry>();
    auto table_or_view_movie_info = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_movie_info_,
                                                      OnEntryNotFound::RETURN_NULL);
    auto &table_movie_info = table_or_view_movie_info->Cast<TableCatalogEntry>();
    auto table_or_view_movie_info_idx = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                          table_vertex_movie_info_idx_, OnEntryNotFound::RETURN_NULL);
    auto &table_movie_info_idx = table_or_view_movie_info_idx->Cast<TableCatalogEntry>();

    string p_info2_n = "votes";
    Value p_info2 = Value(p_info2_n);
    vector<idx_t> info_type_it2_ids{COLUMN_IDENTIFIER_ROW_ID, 1};
    vector<LogicalType> get_info_type_it2_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_info_type_it2 = "it2";
    vector<LogicalType> table_types_info_type_it2;
    vector<unique_ptr<Expression>> filter_info_type_it2;
    unique_ptr<LogicalGet> get_op_info_type_it2 = move(
            getLogicalGet(*this, table_info_type, alias_info_type_it2, table_index_info_type_it2,
                          table_types_info_type_it2));
    unique_ptr<TableFilterSet> table_filters_info_type_it2 = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_it2 = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL, p_info2);
    table_filters_info_type_it2->filters[1] = move(constant_filter_it2);
    unique_ptr<PhysicalTableScan> scan_info_type_it2 = make_uniq<PhysicalTableScan>(get_info_type_it2_types,
                                                                                    get_op_info_type_it2->function,
                                                                                    get_op_info_type_it2->table_index,
                                                                                    move(get_op_info_type_it2->bind_data),
                                                                                    table_types_info_type_it2,
                                                                                    info_type_it2_ids,
                                                                                    move(filter_info_type_it2),
                                                                                    vector<column_t>(),
                                                                                    get_op_info_type_it2->names,
                                                                                    std::move(
                                                                                            table_filters_info_type_it2),
                                                                                    get_op_info_type_it2->estimated_cardinality,
                                                                                    get_op_info_type_it2->extra_info);

    vector<idx_t> movie_info_idx_ids{6, 5, 3};
    vector<LogicalType> get_movie_info_idx_type{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_movie_info_idx = "mi";
    vector<LogicalType> table_types_movie_info_idx;
    vector<unique_ptr<Expression>> filter_movie_info_idx;
    unique_ptr<LogicalGet> get_op_movie_info_idx = move(
            getLogicalGet(*this, table_movie_info_idx, alias_movie_info_idx, table_index_movie_info_idx_, table_types_movie_info_idx));
    unique_ptr<TableFilterSet> table_filters_movie_info_idx = NULL;
    unique_ptr<PhysicalTableScan> scan_movie_info_idx = make_uniq<PhysicalTableScan>(get_movie_info_idx_type,
                                                                                     get_op_movie_info_idx->function,
                                                                                     get_op_movie_info_idx->table_index,
                                                                                     move(get_op_movie_info_idx->bind_data),
                                                                                     table_types_movie_info_idx, movie_info_idx_ids,
                                                                                     move(filter_movie_info_idx),
                                                                                     vector<column_t>(),
                                                                                     get_op_movie_info_idx->names,
                                                                                     std::move(table_filters_movie_info_idx),
                                                                                     get_op_movie_info_idx->estimated_cardinality,
                                                                                     get_op_movie_info_idx->extra_info);

    vector<JoinCondition> cond_movie_info_idx;
    JoinCondition join_condition_movie_info_idx;
    join_condition_movie_info_idx.left = make_uniq<BoundReferenceExpression>("info_type_id_rowid", LogicalType::BIGINT, 1);
    join_condition_movie_info_idx.right = make_uniq<BoundReferenceExpression>("info_type_rowid", LogicalType::BIGINT, 0);
    join_condition_movie_info_idx.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_movie_info_idx = make_uniq<RAIInfo>();
    rai_info_movie_info_idx->rai = table_movie_info_idx.GetStorage().info->rais[0].get();
    rai_info_movie_info_idx->rai_type = RAIType::EDGE_SOURCE;
    rai_info_movie_info_idx->forward = true;
    rai_info_movie_info_idx->vertex = &table_info_type;
    rai_info_movie_info_idx->vertex_id = table_index_info_type_it2;
    rai_info_movie_info_idx->passing_tables[0] = table_index_movie_info_idx_;
    rai_info_movie_info_idx->left_cardinalities[0] = table_movie_info_idx.GetStorage().info->cardinality;
    rai_info_movie_info_idx->compact_list = &rai_info_movie_info_idx->rai->alist->compact_forward_list;

    join_condition_movie_info_idx.rais.push_back(move(rai_info_movie_info_idx));
    cond_movie_info_idx.push_back(move(join_condition_movie_info_idx));

    LogicalComparisonJoin join_movie_info_idx_op(JoinType::INNER);
    vector<LogicalType> output_movie_info_idx_types{LogicalType::BIGINT, LogicalType::BIGINT,
                                                    LogicalType::VARCHAR, LogicalType::BIGINT};
    join_movie_info_idx_op.types = output_movie_info_idx_types;
    vector<idx_t> right_projection_map_movie_info_idx{0};
    vector<LogicalType> delim_types_movie_info_idx;
    auto join_movie_info_idx = make_uniq<PhysicalSIPJoin>(join_movie_info_idx_op, move(scan_movie_info_idx), move(scan_info_type_it2),
                                                          move(cond_movie_info_idx),
                                                          JoinType::INNER, left_projection_map,
                                                          right_projection_map_movie_info_idx,
                                                          delim_types_movie_info_idx, 0);


    vector<idx_t> title_t_ids{COLUMN_IDENTIFIER_ROW_ID, 1};
    vector<LogicalType> get_title_t_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_title_t = "t";
    vector<LogicalType> table_types_title_t;
    vector<unique_ptr<Expression>> filter_title_t;
    unique_ptr<LogicalGet> get_op_title_t = move(
            getLogicalGet(*this, table_title, alias_title_t, table_index_title_t, table_types_title_t));
    unique_ptr<TableFilterSet> table_filters_title_t = NULL;
    unique_ptr<PhysicalTableScan> scan_title_t = make_uniq<PhysicalTableScan>(get_title_t_types,
                                                                              get_op_title_t->function,
                                                                              get_op_title_t->table_index,
                                                                              move(get_op_title_t->bind_data),
                                                                              table_types_title_t, title_t_ids,
                                                                              move(filter_title_t), vector<column_t>(),
                                                                              get_op_title_t->names,
                                                                              std::move(table_filters_title_t),
                                                                              get_op_title_t->estimated_cardinality,
                                                                              get_op_title_t->extra_info);


    vector<JoinCondition> cond_title;
    JoinCondition join_condition_title;
    join_condition_title.left = make_uniq<BoundReferenceExpression>("title_rowid", LogicalType::BIGINT, 0);
    join_condition_title.right = make_uniq<BoundReferenceExpression>("movie_id_rowid", LogicalType::BIGINT, 0);
    join_condition_title.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_title = make_uniq<RAIInfo>();
    rai_info_title->rai = table_movie_info_idx.GetStorage().info->rais[0].get();
    rai_info_title->rai_type = RAIType::TARGET_EDGE;
    rai_info_title->forward = true;
    rai_info_title->vertex = &table_title;
    rai_info_title->vertex_id = table_index_title_t;
    rai_info_title->passing_tables[0] = table_index_title_t;
    rai_info_title->left_cardinalities[0] = table_title.GetStorage().info->cardinality;
    // rai_info_movie_info_idx_->compact_list = &rai_info_movie_info_idx_->rai->alist->compact__list;

    join_condition_title.rais.push_back(move(rai_info_title));
    cond_title.push_back(move(join_condition_title));

    LogicalComparisonJoin join_title_op(JoinType::INNER);
    vector<LogicalType> output_title_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::VARCHAR};
    join_title_op.types = output_title_types;
    vector<idx_t> right_projection_map_title{2};
    vector<idx_t> merge_project_map_title;
    vector<LogicalType> delim_types_title;
    auto join_title = make_uniq<PhysicalSIPJoin>(join_title_op, move(scan_title_t), move(join_movie_info_idx),
                                                                move(cond_title), JoinType::INNER,
                                                                left_projection_map,
                                                                right_projection_map_title,
                                                                delim_types_title, 0);

    vector<idx_t> cast_info_ids{4, 7, 8};
    vector<LogicalType> get_cast_info_types{LogicalType::VARCHAR, LogicalType::BIGINT, LogicalType::BIGINT};
    string alias_cast_info = "ci";
    vector<LogicalType> table_types_cast_info;
    vector<unique_ptr<Expression>> filter_cast_info;
    unique_ptr<LogicalGet> get_op_cast_info = move(
            getLogicalGet(*this, table_cast_info, alias_cast_info, table_index_cast_info_, table_types_cast_info));
    unique_ptr<TableFilterSet> table_filters_cast_info = NULL;
    unique_ptr<PhysicalTableScan> scan_cast_info = make_uniq<PhysicalTableScan>(get_cast_info_types,
                                                                                get_op_cast_info->function,
                                                                                get_op_cast_info->table_index,
                                                                                move(get_op_cast_info->bind_data),
                                                                                table_types_cast_info, cast_info_ids,
                                                                                move(filter_cast_info),
                                                                                vector<column_t>(),
                                                                                get_op_cast_info->names,
                                                                                std::move(table_filters_cast_info),
                                                                                get_op_cast_info->estimated_cardinality,
                                                                                get_op_cast_info->extra_info);


    vector<LogicalType> filter_ci_types{LogicalType::VARCHAR, LogicalType::BIGINT, LogicalType::BIGINT};
    vector<unique_ptr<Expression>> select_list_ci;
    auto in_expression_left = make_uniq<BoundReferenceExpression>("note", LogicalType::VARCHAR, 0);
    auto in_expression_value_left = make_uniq<BoundConstantExpression>(Value("(producer)"));
    auto in_bound_function_left = make_uniq<BoundComparisonExpression>(ExpressionType::COMPARE_EQUAL,
                                                                  move(in_expression_left),
                                                                  move(in_expression_value_left));

    auto in_expression_right = make_uniq<BoundReferenceExpression>("note", LogicalType::VARCHAR, 0);
    auto in_expression_value_right = make_uniq<BoundConstantExpression>(Value("(executive producer)"));
    auto in_bound_function_right = make_uniq<BoundComparisonExpression>(ExpressionType::COMPARE_EQUAL,
                                                                  move(in_expression_right),
                                                                  move(in_expression_value_right));

    auto or_conjunction = make_uniq<BoundConjunctionExpression>(ExpressionType::CONJUNCTION_OR);
    or_conjunction->children.push_back(move(in_bound_function_left));
    or_conjunction->children.push_back(move(in_bound_function_right));

    select_list_ci.push_back(move(or_conjunction));
    unique_ptr<PhysicalFilter> filter_ci_contains = make_uniq<PhysicalFilter>(filter_ci_types, move(select_list_ci), 0);
    filter_ci_contains->children.push_back(move(scan_cast_info));

    vector<JoinCondition> cond_cast_info_;
    JoinCondition join_condition_cast_info_;
    join_condition_cast_info_.left = make_uniq<BoundReferenceExpression>("movie_id_rowid", LogicalType::BIGINT, 1);
    join_condition_cast_info_.right = make_uniq<BoundReferenceExpression>("title_rowid", LogicalType::BIGINT, 0);
    join_condition_cast_info_.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_cast_info_ = make_uniq<RAIInfo>();
    rai_info_cast_info_->rai = table_cast_info.GetStorage().info->rais[0].get();
    rai_info_cast_info_->rai_type = RAIType::EDGE_SOURCE;
    rai_info_cast_info_->forward = true;
    rai_info_cast_info_->vertex = &table_title;
    rai_info_cast_info_->vertex_id = table_index_title_t;
    rai_info_cast_info_->passing_tables[0] = table_index_cast_info_;
    rai_info_cast_info_->left_cardinalities[0] = table_cast_info.GetStorage().info->cardinality;
    rai_info_cast_info_->compact_list = &rai_info_cast_info_->rai->alist->compact_forward_list;

    join_condition_cast_info_.rais.push_back(move(rai_info_cast_info_));
    cond_cast_info_.push_back(move(join_condition_cast_info_));

    LogicalComparisonJoin join_cast_info_op(JoinType::INNER);
    vector<LogicalType> output_cast_info_types{LogicalType::VARCHAR, LogicalType::BIGINT, LogicalType::BIGINT,
                                                LogicalType::VARCHAR, LogicalType::VARCHAR};
    join_cast_info_op.types = output_cast_info_types;
    vector<idx_t> right_projection_map_cast_info_{1, 2};
    vector<idx_t> merge_project_map_cast_info_;
    vector<LogicalType> delim_types_cast_info_;
    auto join_cast_info_ = make_uniq<PhysicalSIPJoin>(join_cast_info_op, move(filter_ci_contains), move(join_title), move(cond_cast_info_),
                                                           JoinType::INNER, left_projection_map,
                                                           right_projection_map_cast_info_,
                                                           delim_types_cast_info_, 0);

    string p_gender_n = "m";
    Value p_gender = Value(p_gender_n);
    vector<idx_t> name_n_ids{COLUMN_IDENTIFIER_ROW_ID, 1, 4};
    vector<LogicalType> get_name_n_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::VARCHAR};
    string alias_name_n = "n";
    vector<LogicalType> table_types_name_n;
    vector<unique_ptr<Expression>> filter_name_n;
    unique_ptr<LogicalGet> get_op_name_n = move(
            getLogicalGet(*this, table_name, alias_name_n, table_index_name_n, table_types_name_n));
    unique_ptr<TableFilterSet> table_filters_name_n = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_n = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL, p_gender);
    table_filters_name_n->filters[2] = move(constant_filter_n);
    unique_ptr<PhysicalTableScan> scan_name_n = make_uniq<PhysicalTableScan>(get_name_n_types, get_op_name_n->function,
                                                                             get_op_name_n->table_index,
                                                                             move(get_op_name_n->bind_data),
                                                                             table_types_name_n, name_n_ids,
                                                                             move(filter_name_n), vector<column_t>(),
                                                                             get_op_name_n->names,
                                                                             std::move(table_filters_name_n),
                                                                             get_op_name_n->estimated_cardinality,
                                                                             get_op_name_n->extra_info);

    vector<LogicalType> filter_name_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::VARCHAR};
    vector<unique_ptr<Expression>> select_list_name;
    auto like_expression_left = make_uniq<BoundReferenceExpression>("name", LogicalType::VARCHAR, 1);
    auto like_expression_value = make_uniq<BoundConstantExpression>(Value("Tim"));
    vector<unique_ptr<Expression>> like_arguments;
    like_arguments.push_back(move(like_expression_left));
    like_arguments.push_back(move(like_expression_value));

    QueryErrorContext error_context_unlike(NULL, NULL);
    ScalarFunction bound_function_contains = ContainsFun::GetFunction();
    unique_ptr<FunctionData> bind_data_contains = NULL;

    auto like_bound_function = make_uniq<BoundFunctionExpression>(LogicalType::BOOLEAN,
                                                                    bound_function_contains,
                                                                    move(like_arguments),
                                                                    move(bind_data_contains), false);

    select_list_name.push_back(move(like_bound_function));
    unique_ptr<PhysicalFilter> filter_name_contains = make_uniq<PhysicalFilter>(filter_name_types, move(select_list_name), 0);
    filter_name_contains->children.push_back(move(scan_name_n));


    vector<JoinCondition> cond_name_n;
    JoinCondition join_condition_name_n;
    join_condition_name_n.left = make_uniq<BoundReferenceExpression>("name_rowid", LogicalType::BIGINT, 0);
    join_condition_name_n.right = make_uniq<BoundReferenceExpression>("person_id_rowid", LogicalType::BIGINT, 2);
    join_condition_name_n.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_name_n = make_uniq<RAIInfo>();
    rai_info_name_n->rai = table_cast_info.GetStorage().info->rais[0].get();
    rai_info_name_n->rai_type = RAIType::TARGET_EDGE;
    rai_info_name_n->forward = true;
    rai_info_name_n->vertex = &table_name;
    rai_info_name_n->vertex_id = table_index_name_n;
    rai_info_name_n->passing_tables[0] = table_index_name_n;
    rai_info_name_n->left_cardinalities[0] = table_name.GetStorage().info->cardinality;
    // rai_info_name_n->compact_list = &rai_info_name_n->rai->alist->compact__list;

    join_condition_name_n.rais.push_back(move(rai_info_name_n));
    cond_name_n.push_back(move(join_condition_name_n));

    LogicalComparisonJoin join_name_n_op(JoinType::INNER);
    vector<LogicalType> output_name_n_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::VARCHAR,
                                            LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::VARCHAR};
    join_name_n_op.types = output_name_n_types;
    vector<idx_t> right_projection_map_name_n{1, 3, 4};
    vector<idx_t> merge_project_map_name_n;
    vector<LogicalType> delim_types_name_n;
    auto join_name_n = make_uniq<PhysicalSIPJoin>(join_name_n_op, move(filter_name_contains), move(join_cast_info_), move(cond_name_n), JoinType::INNER,
                                                  left_projection_map, right_projection_map_name_n, delim_types_name_n,
                                                  0);


    vector<idx_t> movie_info_ids{6, 5, 3};
    vector<LogicalType> get_movie_info_types{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_movie_info = "mi";
    vector<LogicalType> table_types_movie_info;
    vector<unique_ptr<Expression>> filter_movie_info;
    unique_ptr<LogicalGet> get_op_movie_info = move(
            getLogicalGet(*this, table_movie_info, alias_movie_info, table_index_movie_info_,
                          table_types_movie_info));
    unique_ptr<TableFilterSet> table_filters_movie_info = NULL;
    unique_ptr<PhysicalTableScan> scan_movie_info = make_uniq<PhysicalTableScan>(get_movie_info_types,
                                                                                 get_op_movie_info->function,
                                                                                 get_op_movie_info->table_index,
                                                                                 move(get_op_movie_info->bind_data),
                                                                                 table_types_movie_info,
                                                                                 movie_info_ids,
                                                                                 move(filter_movie_info),
                                                                                 vector<column_t>(),
                                                                                 get_op_movie_info->names,
                                                                                 std::move(
                                                                                         table_filters_movie_info),
                                                                                 get_op_movie_info->estimated_cardinality,
                                                                                 get_op_movie_info->extra_info);


    vector<JoinCondition> cond_movie_info_;
    JoinCondition join_condition_movie_info_;
    join_condition_movie_info_.left = make_uniq<BoundReferenceExpression>("movie_id_rowid", LogicalType::BIGINT, 0);
    join_condition_movie_info_.right = make_uniq<BoundReferenceExpression>("movie_id_rowid", LogicalType::BIGINT, 3);
    join_condition_movie_info_.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_movie_info_ = make_uniq<RAIInfo>();
    rai_info_movie_info_->rai = table_movie_info.GetStorage().info->rais[0].get();
    rai_info_movie_info_->rai_type = RAIType::EDGE_TARGET;
    rai_info_movie_info_->forward = false;
    rai_info_movie_info_->vertex = &table_title;
    rai_info_movie_info_->vertex_id = table_index_title_t;
    rai_info_movie_info_->passing_tables[0] = table_index_movie_info_;
    rai_info_movie_info_->left_cardinalities[0] = table_movie_info.GetStorage().info->cardinality;
    rai_info_movie_info_->compact_list = &rai_info_movie_info_->rai->alist->compact_backward_list;

    join_condition_movie_info_.rais.push_back(move(rai_info_movie_info_));
    cond_movie_info_.push_back(move(join_condition_movie_info_));

    LogicalComparisonJoin join_movie_info__op(JoinType::INNER);
    vector<LogicalType> output_movie_info__types{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::VARCHAR,
                                                 LogicalType::VARCHAR, LogicalType::VARCHAR};
    join_movie_info__op.types = output_movie_info__types;
    vector<idx_t> right_projection_map_movie_info_{4, 5};
    vector<idx_t> merge_project_map_movie_info_;
    vector<LogicalType> delim_types_movie_info_;
    auto join_movie_info_ = make_uniq<PhysicalSIPJoin>(join_movie_info__op, move(scan_movie_info), move(join_name_n), move(cond_movie_info_),
                                                       JoinType::INNER, left_projection_map,
                                                       right_projection_map_movie_info_,
                                                       delim_types_movie_info_, 0);

    string p_info1_n = "budget";
    Value p_info1 = Value(p_info1_n);
    vector<idx_t> info_type_it1_ids{COLUMN_IDENTIFIER_ROW_ID, 1};
    vector<LogicalType> get_info_type_it1_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_info_type_it1 = "it1";
    vector<LogicalType> table_types_info_type_it1;
    vector<unique_ptr<Expression>> filter_info_type_it1;
    unique_ptr<LogicalGet> get_op_info_type_it1 = move(
            getLogicalGet(*this, table_info_type, alias_info_type_it1, table_index_info_type_it1,
                          table_types_info_type_it1));
    unique_ptr<TableFilterSet> table_filters_info_type_it1 = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_it1 = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL, p_info1);
    table_filters_info_type_it1->filters[1] = move(constant_filter_it1);
    unique_ptr<PhysicalTableScan> scan_info_type_it1 = make_uniq<PhysicalTableScan>(get_info_type_it1_types,
                                                                                    get_op_info_type_it1->function,
                                                                                    get_op_info_type_it1->table_index,
                                                                                    move(get_op_info_type_it1->bind_data),
                                                                                    table_types_info_type_it1,
                                                                                    info_type_it1_ids,
                                                                                    move(filter_info_type_it1),
                                                                                    vector<column_t>(),
                                                                                    get_op_info_type_it1->names,
                                                                                    std::move(
                                                                                            table_filters_info_type_it1),
                                                                                    get_op_info_type_it1->estimated_cardinality,
                                                                                    get_op_info_type_it1->extra_info);


    vector<JoinCondition> cond_info_type_it1;
    JoinCondition join_condition_info_type_it1;
    join_condition_info_type_it1.left = make_uniq<BoundReferenceExpression>("info_type_rowid", LogicalType::BIGINT, 0);
    join_condition_info_type_it1.right = make_uniq<BoundReferenceExpression>("info_type_id_rowid", LogicalType::BIGINT, 1);
    join_condition_info_type_it1.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_info_type_it1 = make_uniq<RAIInfo>();
    rai_info_info_type_it1->rai = table_movie_info.GetStorage().info->rais[0].get();
    rai_info_info_type_it1->rai_type = RAIType::SOURCE_EDGE;
    rai_info_info_type_it1->forward = false;
    rai_info_info_type_it1->vertex = &table_info_type;
    rai_info_info_type_it1->vertex_id = table_index_info_type_it1;
    rai_info_info_type_it1->passing_tables[0] = table_index_info_type_it1;
    rai_info_info_type_it1->left_cardinalities[0] = table_info_type.GetStorage().info->cardinality;
    // rai_info_info_type_it1->compact_list = &rai_info_info_type_it1->rai->alist->compact__list;

    join_condition_info_type_it1.rais.push_back(move(rai_info_info_type_it1));
    cond_info_type_it1.push_back(move(join_condition_info_type_it1));

    LogicalComparisonJoin join_info_type_it1_op(JoinType::INNER);
    vector<LogicalType> output_info_type_it1_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::VARCHAR,
                                                   LogicalType::VARCHAR, LogicalType::VARCHAR};
    join_info_type_it1_op.types = output_info_type_it1_types;
    vector<idx_t> right_projection_map_info_type_it1{2, 3, 4};
    vector<idx_t> merge_project_map_info_type_it1;
    vector<LogicalType> delim_types_info_type_it1;
    auto join_info_type_it1 = make_uniq<PhysicalSIPJoin>(join_info_type_it1_op, move(scan_info_type_it1), move(join_movie_info_),
                                                         move(cond_info_type_it1), JoinType::INNER, left_projection_map,
                                                         right_projection_map_info_type_it1, delim_types_info_type_it1,
                                                         0);

    vector<LogicalType> result_types{LogicalType::VARCHAR, LogicalType::VARCHAR, LogicalType::VARCHAR};
    vector<unique_ptr<Expression>> select_list;
    auto result_col0 = make_uniq<BoundReferenceExpression>("info", LogicalType::VARCHAR, 2);
    auto result_col1 = make_uniq<BoundReferenceExpression>("info", LogicalType::VARCHAR, 4);
    auto result_col2 = make_uniq<BoundReferenceExpression>("title", LogicalType::VARCHAR, 3);
    select_list.push_back(move(result_col0));
    select_list.push_back(move(result_col1));
    select_list.push_back(move(result_col2));
    auto projection = make_uniq<PhysicalProjection>(result_types, move(select_list), 0);
    projection->children.push_back(move(join_info_type_it1));

    // aggregate
    string agg_name = "min";
    string agg_error = "";
    QueryErrorContext error_context(NULL, NULL);
    auto min_func = Catalog::GetEntry(context, CatalogType::SCALAR_FUNCTION_ENTRY, "", "",
                                      "min", OnEntryNotFound::RETURN_NULL, error_context);
    auto& min_func_set = min_func->Cast<AggregateFunctionCatalogEntry>();
    // bind the aggregate
    FunctionBinder function_binder(context);
    vector<LogicalType> types;
    types.push_back(LogicalType::VARCHAR);
    idx_t best_function_varchar = function_binder.BindFunction(agg_name, min_func_set.functions, types, agg_error);
    auto bound_function_min_varchar = min_func_set.functions.GetFunctionByOffset(best_function_varchar);

    auto first_children = make_uniq<BoundReferenceExpression>("info", LogicalType::VARCHAR, 0);
    vector<unique_ptr<Expression>> childrenlist1;
    childrenlist1.push_back(move(first_children));
    auto aggregate1 =
            function_binder.BindAggregateFunction(bound_function_min_varchar, std::move(childrenlist1), nullptr, AggregateType::NON_DISTINCT);

    auto second_children = make_uniq<BoundReferenceExpression>("info", LogicalType::VARCHAR, 1);
    vector<unique_ptr<Expression>> childrenlist2;
    childrenlist2.push_back(move(second_children));
    auto aggregate2 =
            function_binder.BindAggregateFunction(bound_function_min_varchar, std::move(childrenlist2), nullptr, AggregateType::NON_DISTINCT);

    auto third_children = make_uniq<BoundReferenceExpression>("title", LogicalType::VARCHAR, 2);
    vector<unique_ptr<Expression>> childrenlist3;
    childrenlist3.push_back(move(third_children));
    auto aggregate3 =
            function_binder.BindAggregateFunction(bound_function_min_varchar, std::move(childrenlist3), nullptr, AggregateType::NON_DISTINCT);

    vector<unique_ptr<Expression>> aggregates;
    aggregates.push_back(move(aggregate1));
    aggregates.push_back(move(aggregate2));
    aggregates.push_back(move(aggregate3));

    vector<LogicalType> aggregate_types{LogicalType::VARCHAR, LogicalType::VARCHAR, LogicalType::VARCHAR};
    auto ungrouped_aggregate = make_uniq<PhysicalUngroupedAggregate>(aggregate_types, move(aggregates), 0);
    ungrouped_aggregate->children.push_back(move(projection));

    return ungrouped_aggregate;
}

unique_ptr<PhysicalOperator> ClientContext::GenerateJOB19aPlan(duckdb::ClientContext &context) {
    vector<idx_t> left_projection_map, right_projection_map;

    string table_vertex_company_name_cn = "company_name";
    string table_vertex_title_t = "title";
    string table_vertex_info_type_it = "info_type";
    string table_vertex_name_n = "name";
    string table_vertex_aka_name_an = "aka_name";
    string table_vertex_char_name_chn = "char_name";
    string table_vertex_role_type_rt = "role_type";
    string table_vertex_movie_companies_ = "movie_companies";
    string table_vertex_movie_info_ = "movie_info";
    string table_vertex_cast_info_ = "cast_info";

    idx_t table_index_company_name_cn = 1;
    idx_t table_index_title_t = 2;
    idx_t table_index_info_type_it = 3;
    idx_t table_index_name_n = 4;
    idx_t table_index_aka_name_an = 5;
    idx_t table_index_char_name_chn = 6;
    idx_t table_index_role_type_rt = 7;
    idx_t table_index_movie_companies_ = 8;
    idx_t table_index_movie_info_ = 9;
    idx_t table_index_cast_info_ = 13;

    auto table_or_view_company_name = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                        table_vertex_company_name_cn, OnEntryNotFound::RETURN_NULL);
    auto &table_company_name = table_or_view_company_name->Cast<TableCatalogEntry>();
    auto table_or_view_title = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_title_t,
                                                 OnEntryNotFound::RETURN_NULL);
    auto &table_title = table_or_view_title->Cast<TableCatalogEntry>();
    auto table_or_view_info_type = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_info_type_it,
                                                     OnEntryNotFound::RETURN_NULL);
    auto &table_info_type = table_or_view_info_type->Cast<TableCatalogEntry>();
    auto table_or_view_name = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_name_n,
                                                OnEntryNotFound::RETURN_NULL);
    auto &table_name = table_or_view_name->Cast<TableCatalogEntry>();
    auto table_or_view_aka_name = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_aka_name_an,
                                                    OnEntryNotFound::RETURN_NULL);
    auto &table_aka_name = table_or_view_aka_name->Cast<TableCatalogEntry>();
    auto table_or_view_char_name = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                     table_vertex_char_name_chn, OnEntryNotFound::RETURN_NULL);
    auto &table_char_name = table_or_view_char_name->Cast<TableCatalogEntry>();
    auto table_or_view_role_type = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_role_type_rt,
                                                     OnEntryNotFound::RETURN_NULL);
    auto &table_role_type = table_or_view_role_type->Cast<TableCatalogEntry>();
    auto table_or_view_movie_companies = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                           table_vertex_movie_companies_, OnEntryNotFound::RETURN_NULL);
    auto &table_movie_companies = table_or_view_movie_companies->Cast<TableCatalogEntry>();
    auto table_or_view_movie_info = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_movie_info_,
                                                      OnEntryNotFound::RETURN_NULL);
    auto &table_movie_info = table_or_view_movie_info->Cast<TableCatalogEntry>();
    auto table_or_view_cast_info = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_cast_info_,
                                                     OnEntryNotFound::RETURN_NULL);
    auto &table_cast_info = table_or_view_cast_info->Cast<TableCatalogEntry>();

    string p_role_n = "actress";
    Value p_role = Value(p_role_n);
    vector<idx_t> role_type_rt_ids{COLUMN_IDENTIFIER_ROW_ID, 1};
    vector<LogicalType> get_role_type_rt_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_role_type_rt = "rt";
    vector<LogicalType> table_types_role_type_rt;
    vector<unique_ptr<Expression>> filter_role_type_rt;
    unique_ptr<LogicalGet> get_op_role_type_rt = move(
            getLogicalGet(*this, table_role_type, alias_role_type_rt, table_index_role_type_rt,
                          table_types_role_type_rt));
    unique_ptr<TableFilterSet> table_filters_role_type_rt = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_rt = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL, p_role);
    table_filters_role_type_rt->filters[1] = move(constant_filter_rt);
    unique_ptr<PhysicalTableScan> scan_role_type_rt = make_uniq<PhysicalTableScan>(get_role_type_rt_types,
                                                                                   get_op_role_type_rt->function,
                                                                                   get_op_role_type_rt->table_index,
                                                                                   move(get_op_role_type_rt->bind_data),
                                                                                   table_types_role_type_rt,
                                                                                   role_type_rt_ids,
                                                                                   move(filter_role_type_rt),
                                                                                   vector<column_t>(),
                                                                                   get_op_role_type_rt->names,
                                                                                   std::move(
                                                                                           table_filters_role_type_rt),
                                                                                   get_op_role_type_rt->estimated_cardinality,
                                                                                   get_op_role_type_rt->extra_info);


    vector<idx_t> cast_info_ids{4, 7, 8, 9, 10};
    vector<LogicalType> get_cast_info_types{LogicalType::VARCHAR, LogicalType::BIGINT, LogicalType::BIGINT,
                                            LogicalType::BIGINT, LogicalType::BIGINT};
    string alias_cast_info = "ci";
    vector<LogicalType> table_types_cast_info;
    vector<unique_ptr<Expression>> filter_cast_info;
    unique_ptr<LogicalGet> get_op_cast_info = move(
            getLogicalGet(*this, table_cast_info, alias_cast_info, table_index_cast_info_, table_types_cast_info));
    unique_ptr<TableFilterSet> table_filters_cast_info = NULL;
    unique_ptr<PhysicalTableScan> scan_cast_info = make_uniq<PhysicalTableScan>(get_cast_info_types,
                                                                                get_op_cast_info->function,
                                                                                get_op_cast_info->table_index,
                                                                                move(get_op_cast_info->bind_data),
                                                                                table_types_cast_info, cast_info_ids,
                                                                                move(filter_cast_info),
                                                                                vector<column_t>(),
                                                                                get_op_cast_info->names,
                                                                                std::move(table_filters_cast_info),
                                                                                get_op_cast_info->estimated_cardinality,
                                                                                get_op_cast_info->extra_info);


    auto &allocator = Allocator::Get(context);
    vector<LogicalType> join_in_types {LogicalType::VARCHAR};
    auto collection =
            make_uniq<ColumnDataCollection>(context, join_in_types, ColumnDataAllocatorType::IN_MEMORY_ALLOCATOR);

    vector<LogicalType> chunk_in_types {LogicalType::VARCHAR};
    DataChunk chunk;
    chunk.SetCardinality(4);
    chunk.Initialize(allocator, chunk_in_types);
    chunk.SetValue(0, 0, Value("(voice)"));
    chunk.SetValue(0, 1, Value("(voice: Japanese version)"));
    chunk.SetValue(0, 2, Value("(voice) (uncredited)"));
    chunk.SetValue(0, 3, Value("(voice: English version)"));
    collection->Append(chunk);

    // create a chunk scan to output the result
    vector<LogicalType> ouput_in_types {LogicalType::VARCHAR};
    auto chunk_scan = make_uniq<PhysicalColumnDataScan>(ouput_in_types, PhysicalOperatorType::COLUMN_DATA_SCAN,
                                                        4, std::move(collection));

    vector<JoinCondition> cond_hash_join_;
    JoinCondition join_condition_hash_join_;
    join_condition_hash_join_.left = make_uniq<BoundReferenceExpression>("note", LogicalType::VARCHAR, 0);
    join_condition_hash_join_.right = make_uniq<BoundReferenceExpression>("", LogicalType::VARCHAR, 0);
    join_condition_hash_join_.comparison = ExpressionType::COMPARE_EQUAL;
    cond_hash_join_.push_back(move(join_condition_hash_join_));

    LogicalComparisonJoin join_hash_join_op(JoinType::MARK);
    vector<LogicalType> output_hash_join_types{LogicalType::VARCHAR, LogicalType::BIGINT, LogicalType::BIGINT,
                                               LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::BOOLEAN};
    join_hash_join_op.types = output_hash_join_types;
    vector<idx_t> right_projection_map_hash_join_;
    vector<LogicalType> delim_types_hash_join_;
    PerfectHashJoinStats joinstate;
    auto join_hash_join_ = make_uniq<PhysicalHashJoin>(join_hash_join_op, move(scan_cast_info), move(chunk_scan), move(cond_hash_join_),
                                                       JoinType::MARK, left_projection_map,
                                                       right_projection_map_hash_join_,
                                                       delim_types_hash_join_, 0, joinstate);

    vector<LogicalType> filter_in_types{LogicalType::VARCHAR, LogicalType::BIGINT, LogicalType::BIGINT,
                                        LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::BOOLEAN};
    vector<unique_ptr<Expression>> select_list_in;
    auto in_exp = make_uniq<BoundReferenceExpression>("IN (...)", LogicalType::BOOLEAN, 5);
    select_list_in.push_back(move(in_exp));
    unique_ptr<PhysicalFilter> filter_in = make_uniq<PhysicalFilter>(filter_in_types, move(select_list_in), 0);
    filter_in->children.push_back(move(join_hash_join_));

    vector<JoinCondition> cond_cast_info_;
    JoinCondition join_condition_cast_info_;
    join_condition_cast_info_.left = make_uniq<BoundReferenceExpression>("role_id_rowid", LogicalType::BIGINT, 3);
    join_condition_cast_info_.right = make_uniq<BoundReferenceExpression>("role_type_rowid", LogicalType::BIGINT, 0);
    join_condition_cast_info_.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_cast_info_ = make_uniq<RAIInfo>();
    rai_info_cast_info_->rai = table_cast_info.GetStorage().info->rais[1].get();
    rai_info_cast_info_->rai_type = RAIType::EDGE_SOURCE;
    rai_info_cast_info_->forward = true;
    rai_info_cast_info_->vertex = &table_role_type;
    rai_info_cast_info_->vertex_id = table_index_role_type_rt;
    rai_info_cast_info_->passing_tables[0] = table_index_cast_info_;
    rai_info_cast_info_->left_cardinalities[0] = table_cast_info.GetStorage().info->cardinality;
    rai_info_cast_info_->compact_list = &rai_info_cast_info_->rai->alist->compact_forward_list;

    join_condition_cast_info_.rais.push_back(move(rai_info_cast_info_));
    cond_cast_info_.push_back(move(join_condition_cast_info_));

    LogicalComparisonJoin join_cast_info_op(JoinType::INNER);
    vector<LogicalType> output_cast_info_types{LogicalType::VARCHAR, LogicalType::BIGINT, LogicalType::BIGINT,
                                               LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::BOOLEAN,
                                               LogicalType::BIGINT};
    join_cast_info_op.types = output_cast_info_types;
    vector<idx_t> right_projection_map_cast_info_{0};
    vector<idx_t> merge_project_map_cast_info_;
    vector<LogicalType> delim_types_cast_info_;
    auto join_cast_info_ = make_uniq<PhysicalSIPJoin>(join_cast_info_op, move(filter_in), move(scan_role_type_rt), move(cond_cast_info_),
                                                      JoinType::INNER, left_projection_map,
                                                      right_projection_map_cast_info_,
                                                      delim_types_cast_info_, 0);

    vector<idx_t> title_t_ids{COLUMN_IDENTIFIER_ROW_ID, 1, 4};
    vector<LogicalType> get_title_t_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::BIGINT};
    string alias_title_t = "t";
    vector<LogicalType> table_types_title_t;
    vector<unique_ptr<Expression>> filter_title_t;
    unique_ptr<LogicalGet> get_op_title_t = move(
            getLogicalGet(*this, table_title, alias_title_t, table_index_title_t, table_types_title_t));
    unique_ptr<TableFilterSet> table_filters_title_t = make_uniq<TableFilterSet>();
    unique_ptr<ConjunctionAndFilter> and_filter_t = duckdb::make_uniq<ConjunctionAndFilter>();
    unique_ptr<ConstantFilter> constant_filter_t_start = duckdb::make_uniq<ConstantFilter>(
            ExpressionType::COMPARE_GREATERTHANOREQUALTO, Value::BIGINT(2005));
    unique_ptr<ConstantFilter> constant_filter_t_end = duckdb::make_uniq<ConstantFilter>(
            ExpressionType::COMPARE_LESSTHANOREQUALTO, Value::BIGINT(2009));
    and_filter_t->child_filters.push_back(move(constant_filter_t_start));
    and_filter_t->child_filters.push_back(move(constant_filter_t_end));
    table_filters_title_t->filters[2] = move(and_filter_t);
    unique_ptr<PhysicalTableScan> scan_title_t = make_uniq<PhysicalTableScan>(get_title_t_types,
                                                                              get_op_title_t->function,
                                                                              get_op_title_t->table_index,
                                                                              move(get_op_title_t->bind_data),
                                                                              table_types_title_t, title_t_ids,
                                                                              move(filter_title_t), vector<column_t>(),
                                                                              get_op_title_t->names,
                                                                              std::move(table_filters_title_t),
                                                                              get_op_title_t->estimated_cardinality,
                                                                              get_op_title_t->extra_info);


    vector<JoinCondition> cond_title_t;
    JoinCondition join_condition_title_t;
    join_condition_title_t.left = make_uniq<BoundReferenceExpression>("title_rowid", LogicalType::BIGINT, 0);
    join_condition_title_t.right = make_uniq<BoundReferenceExpression>("movie_id_rowid", LogicalType::BIGINT, 1);
    join_condition_title_t.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_title_t = make_uniq<RAIInfo>();
    rai_info_title_t->rai = table_cast_info.GetStorage().info->rais[2].get();
    rai_info_title_t->rai_type = RAIType::TARGET_EDGE;
    rai_info_title_t->forward = true;
    rai_info_title_t->vertex = &table_title;
    rai_info_title_t->vertex_id = table_index_title_t;
    rai_info_title_t->passing_tables[0] = table_index_title_t;
    rai_info_title_t->left_cardinalities[0] = table_title.GetStorage().info->cardinality;
    // rai_info_title_t->compact_list = &rai_info_title_t->rai->alist->compact__list;

    join_condition_title_t.rais.push_back(move(rai_info_title_t));
    cond_title_t.push_back(move(join_condition_title_t));

    LogicalComparisonJoin join_title_t_op(JoinType::INNER);
    vector<LogicalType> output_title_t_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::BIGINT,
                                             LogicalType::BIGINT, LogicalType::BIGINT};
    join_title_t_op.types = output_title_t_types;
    vector<idx_t> right_projection_map_title_t{2, 4};
    vector<idx_t> merge_project_map_title_t;
    vector<LogicalType> delim_types_title_t;
    auto join_title_t = make_uniq<PhysicalSIPJoin>(join_title_t_op, move(scan_title_t), move(join_cast_info_), move(cond_title_t), JoinType::INNER,
                                                   left_projection_map, right_projection_map_title_t,
                                                   delim_types_title_t, 0);

    vector<idx_t> movie_companies_ids{4, 6, 5};
    vector<LogicalType> get_movie_companies_types{LogicalType::VARCHAR, LogicalType::BIGINT, LogicalType::BIGINT};
    string alias_movie_companies = "mc";
    vector<LogicalType> table_types_movie_companies;
    vector<unique_ptr<Expression>> filter_movie_companies;
    unique_ptr<LogicalGet> get_op_movie_companies = move(
            getLogicalGet(*this, table_movie_companies, alias_movie_companies, table_index_movie_companies_,
                          table_types_movie_companies));
    unique_ptr<TableFilterSet> table_filters_movie_companies = NULL;
    unique_ptr<PhysicalTableScan> scan_movie_companies = make_uniq<PhysicalTableScan>(get_movie_companies_types,
                                                                                      get_op_movie_companies->function,
                                                                                      get_op_movie_companies->table_index,
                                                                                      move(get_op_movie_companies->bind_data),
                                                                                      table_types_movie_companies,
                                                                                      movie_companies_ids,
                                                                                      move(filter_movie_companies),
                                                                                      vector<column_t>(),
                                                                                      get_op_movie_companies->names,
                                                                                      std::move(
                                                                                              table_filters_movie_companies),
                                                                                      get_op_movie_companies->estimated_cardinality,
                                                                                      get_op_movie_companies->extra_info);


    string p_movie_company_note1 = "(USA)"; // 933;
    string p_movie_company_note2 = "(worldwide)"; // 933;
    Value p_note1 = Value(p_movie_company_note1);
    Value p_note2 = Value(p_movie_company_note2);
    vector<LogicalType> filter_mc_types{LogicalType::VARCHAR, LogicalType::BIGINT, LogicalType::BIGINT};
    vector<unique_ptr<Expression>> select_list_movie_companies;
    auto like_expression_left = make_uniq<BoundReferenceExpression>("note", LogicalType::VARCHAR, 0);
    auto like_expression_value = make_uniq<BoundConstantExpression>(p_note1);
    vector<unique_ptr<Expression>> like_arguments1, like_arguments2;
    like_arguments1.push_back(move(like_expression_left));
    like_arguments1.push_back(move(like_expression_value));

    auto like_expression_left2 = make_uniq<BoundReferenceExpression>("note", LogicalType::VARCHAR, 0);
    auto like_expression_value2 = make_uniq<BoundConstantExpression>(p_note2);
    like_arguments2.push_back(move(like_expression_left2));
    like_arguments2.push_back(move(like_expression_value2));

    QueryErrorContext error_context_unlike(NULL, NULL);
    ScalarFunction bound_function_contains = ContainsFun::GetFunction();
    unique_ptr<FunctionData> bind_data_contains = NULL;

    auto like_bound_function = make_uniq<BoundFunctionExpression>(LogicalType::BOOLEAN,
                                                                  bound_function_contains,
                                                                  move(like_arguments1),
                                                                  move(bind_data_contains), false);

    unique_ptr<FunctionData> bind_data_contains2 = NULL;
    auto like_bound_function2 = make_uniq<BoundFunctionExpression>(LogicalType::BOOLEAN,
                                                                   bound_function_contains,
                                                                   move(like_arguments2),
                                                                   move(bind_data_contains2), false);

    auto mc_or_conjunction = make_uniq<BoundConjunctionExpression>(ExpressionType::CONJUNCTION_OR);
    mc_or_conjunction->children.push_back(move(like_bound_function));
    mc_or_conjunction->children.push_back(move(like_bound_function2));

    auto mc_not_null_bound_function = make_uniq<BoundOperatorExpression>(ExpressionType::OPERATOR_IS_NOT_NULL, LogicalType::BOOLEAN);
    auto mc_not_null = make_uniq<BoundReferenceExpression>("note", LogicalType::VARCHAR, 0);
    mc_not_null_bound_function->children.push_back(move(mc_not_null));

    auto mc_and_conjunction = make_uniq<BoundConjunctionExpression>(ExpressionType::CONJUNCTION_AND);
    mc_and_conjunction->children.push_back(move(mc_or_conjunction));
    mc_and_conjunction->children.push_back(move(mc_not_null_bound_function));

    select_list_movie_companies.push_back(move(mc_and_conjunction));
    unique_ptr<PhysicalFilter> filter_mc_contains = make_uniq<PhysicalFilter>(filter_mc_types, move(select_list_movie_companies), 0);
    filter_mc_contains->children.push_back(move(scan_movie_companies));


    vector<JoinCondition> cond_movie_companies_;
    JoinCondition join_condition_movie_companies_;
    join_condition_movie_companies_.left = make_uniq<BoundReferenceExpression>("movie_id_rowid", LogicalType::BIGINT, 1);
    join_condition_movie_companies_.right = make_uniq<BoundReferenceExpression>("title_rowid", LogicalType::BIGINT, 0);
    join_condition_movie_companies_.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_movie_companies_ = make_uniq<RAIInfo>();
    rai_info_movie_companies_->rai = table_movie_companies.GetStorage().info->rais[0].get();
    rai_info_movie_companies_->rai_type = RAIType::EDGE_TARGET;
    rai_info_movie_companies_->forward = false;
    rai_info_movie_companies_->vertex = &table_title;
    rai_info_movie_companies_->vertex_id = table_index_title_t;
    rai_info_movie_companies_->passing_tables[0] = table_index_movie_companies_;
    rai_info_movie_companies_->left_cardinalities[0] = table_movie_companies.GetStorage().info->cardinality;
    rai_info_movie_companies_->compact_list = &rai_info_movie_companies_->rai->alist->compact_backward_list;

    join_condition_movie_companies_.rais.push_back(move(rai_info_movie_companies_));
    cond_movie_companies_.push_back(move(join_condition_movie_companies_));

    LogicalComparisonJoin join_movie_companies__op(JoinType::INNER);
    vector<LogicalType> output_movie_companies__types{LogicalType::VARCHAR, LogicalType::BIGINT, LogicalType::BIGINT,
                                                      LogicalType::VARCHAR, LogicalType::BIGINT, LogicalType::BIGINT};
    join_movie_companies__op.types = output_movie_companies__types;
    vector<idx_t> right_projection_map_movie_companies_{1, 3, 4};
    vector<idx_t> merge_project_map_movie_companies_;
    vector<LogicalType> delim_types_movie_companies_;
    auto join_movie_companies_ = make_uniq<PhysicalSIPJoin>(join_movie_companies__op, move(filter_mc_contains), move(join_title_t),
                                                                 move(cond_movie_companies_), JoinType::INNER,
                                                                 left_projection_map,
                                                                 right_projection_map_movie_companies_,
                                                                 delim_types_movie_companies_, 0);

    string p_country_code_n = "[us]";
    Value p_code = Value(p_country_code_n);
    vector<idx_t> company_name_cn_ids{COLUMN_IDENTIFIER_ROW_ID, 2};
    vector<LogicalType> get_company_name_cn_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_company_name_cn = "cn";
    vector<LogicalType> table_types_company_name_cn;
    vector<unique_ptr<Expression>> filter_company_name_cn;
    unique_ptr<LogicalGet> get_op_company_name_cn = move(
            getLogicalGet(*this, table_company_name, alias_company_name_cn, table_index_company_name_cn,
                          table_types_company_name_cn));
    unique_ptr<TableFilterSet> table_filters_company_name_cn = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_cn = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL, p_code);
    table_filters_company_name_cn->filters[1] = move(constant_filter_cn);
    unique_ptr<PhysicalTableScan> scan_company_name_cn = make_uniq<PhysicalTableScan>(get_company_name_cn_types,
                                                                                      get_op_company_name_cn->function,
                                                                                      get_op_company_name_cn->table_index,
                                                                                      move(get_op_company_name_cn->bind_data),
                                                                                      table_types_company_name_cn,
                                                                                      company_name_cn_ids,
                                                                                      move(filter_company_name_cn),
                                                                                      vector<column_t>(),
                                                                                      get_op_company_name_cn->names,
                                                                                      std::move(
                                                                                              table_filters_company_name_cn),
                                                                                      get_op_company_name_cn->estimated_cardinality,
                                                                                      get_op_company_name_cn->extra_info);


    vector<JoinCondition> cond_company_name_cn;
    JoinCondition join_condition_company_name_cn;
    join_condition_company_name_cn.left = make_uniq<BoundReferenceExpression>("company_name_rowid", LogicalType::BIGINT, 0);
    join_condition_company_name_cn.right = make_uniq<BoundReferenceExpression>("company_id_rowid", LogicalType::BIGINT, 2);
    join_condition_company_name_cn.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_company_name_cn = make_uniq<RAIInfo>();
    rai_info_company_name_cn->rai = table_movie_companies.GetStorage().info->rais[0].get();
    rai_info_company_name_cn->rai_type = RAIType::SOURCE_EDGE;
    rai_info_company_name_cn->forward = false;
    rai_info_company_name_cn->vertex = &table_company_name;
    rai_info_company_name_cn->vertex_id = table_index_company_name_cn;
    rai_info_company_name_cn->passing_tables[0] = table_index_company_name_cn;
    rai_info_company_name_cn->left_cardinalities[0] = table_company_name.GetStorage().info->cardinality;
    // rai_info_company_name_cn->compact_list = &rai_info_company_name_cn->rai->alist->compact__list;

    join_condition_company_name_cn.rais.push_back(move(rai_info_company_name_cn));
    cond_company_name_cn.push_back(move(join_condition_company_name_cn));

    LogicalComparisonJoin join_company_name_cn_op(JoinType::INNER);
    vector<LogicalType> output_company_name_cn_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::BIGINT,
                                                     LogicalType::VARCHAR, LogicalType::BIGINT, LogicalType::BIGINT};
    join_company_name_cn_op.types = output_company_name_cn_types;
    vector<idx_t> right_projection_map_company_name_cn{1, 3, 4, 5};
    vector<idx_t> merge_project_map_company_name_cn;
    vector<LogicalType> delim_types_company_name_cn;
    auto join_company_name_cn = make_uniq<PhysicalSIPJoin>(join_company_name_cn_op, move(scan_company_name_cn), move(join_movie_companies_),
                                                           move(cond_company_name_cn), JoinType::INNER,
                                                           left_projection_map, right_projection_map_company_name_cn,
                                                           delim_types_company_name_cn, 0);


    vector<idx_t> movie_info_ids{6, 5, 3};
    vector<LogicalType> get_movie_info_types{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_movie_info = "i";
    vector<LogicalType> table_types_movie_info;
    vector<unique_ptr<Expression>> filter_movie_info;
    unique_ptr<LogicalGet> get_op_movie_info = move(
            getLogicalGet(*this, table_movie_info, alias_movie_info, table_index_movie_info_, table_types_movie_info));
    unique_ptr<TableFilterSet> table_filters_movie_info = NULL;
    unique_ptr<PhysicalTableScan> scan_movie_info = make_uniq<PhysicalTableScan>(get_movie_info_types,
                                                                                 get_op_movie_info->function,
                                                                                 get_op_movie_info->table_index,
                                                                                 move(get_op_movie_info->bind_data),
                                                                                 table_types_movie_info,
                                                                                 movie_info_ids,
                                                                                 move(filter_movie_info),
                                                                                 vector<column_t>(),
                                                                                 get_op_movie_info->names,
                                                                                 std::move(table_filters_movie_info),
                                                                                 get_op_movie_info->estimated_cardinality,
                                                                                 get_op_movie_info->extra_info);

    string p_movie_info_note1 = "Japan:%200%"; // 933;
    string p_movie_info_note2 = "USA:%200%"; // 933;
    Value p_note1_mi = Value(p_movie_info_note1);
    Value p_note2_mi = Value(p_movie_info_note2);
    vector<LogicalType> filter_mi_types{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::VARCHAR};
    vector<unique_ptr<Expression>> select_list_movie_info;
    auto like_expression_left_mi = make_uniq<BoundReferenceExpression>("info", LogicalType::VARCHAR, 2);
    auto like_expression_value_mi = make_uniq<BoundConstantExpression>(p_note1_mi);
    vector<unique_ptr<Expression>> like_arguments1_mi, like_arguments2_mi;
    like_arguments1_mi.push_back(move(like_expression_left_mi));
    like_arguments1_mi.push_back(move(like_expression_value_mi));

    auto like_expression_left2_mi = make_uniq<BoundReferenceExpression>("info", LogicalType::VARCHAR, 2);
    auto like_expression_value2_mi = make_uniq<BoundConstantExpression>(p_note2_mi);
    like_arguments2_mi.push_back(move(like_expression_left2_mi));
    like_arguments2_mi.push_back(move(like_expression_value2_mi));

    QueryErrorContext error_context_unlike_mi(NULL, NULL);
    ScalarFunction bound_function_like = LikeFun::GetLikeFunction();
    unique_ptr<FunctionData> bind_data_like = NULL;

    auto like_bound_function_mi = make_uniq<BoundFunctionExpression>(LogicalType::BOOLEAN,
                                                                  bound_function_like,
                                                                  move(like_arguments1_mi),
                                                                  move(bind_data_like), false);

    unique_ptr<FunctionData> bind_data_like2 = NULL;
    auto like_bound_function2_mi = make_uniq<BoundFunctionExpression>(LogicalType::BOOLEAN,
                                                                   bound_function_like,
                                                                   move(like_arguments2_mi),
                                                                   move(bind_data_like2), false);

    auto mi_or_conjunction = make_uniq<BoundConjunctionExpression>(ExpressionType::CONJUNCTION_OR);
    mi_or_conjunction->children.push_back(move(like_bound_function_mi));
    mi_or_conjunction->children.push_back(move(like_bound_function2_mi));

    auto mi_not_null_bound_function = make_uniq<BoundOperatorExpression>(ExpressionType::OPERATOR_IS_NOT_NULL, LogicalType::BOOLEAN);
    auto mi_not_null = make_uniq<BoundReferenceExpression>("info", LogicalType::VARCHAR, 2);
    mi_not_null_bound_function->children.push_back(move(mi_not_null));

    auto mi_and_conjunction = make_uniq<BoundConjunctionExpression>(ExpressionType::CONJUNCTION_AND);
    mi_and_conjunction->children.push_back(move(mi_or_conjunction));
    mi_and_conjunction->children.push_back(move(mi_not_null_bound_function));

    select_list_movie_info.push_back(move(mi_and_conjunction));
    unique_ptr<PhysicalFilter> filter_mi_contains = make_uniq<PhysicalFilter>(filter_mi_types, move(select_list_movie_info), 0);
    filter_mi_contains->children.push_back(move(scan_movie_info));


    vector<JoinCondition> cond_movie_info_;
    JoinCondition join_condition_movie_info_;
    join_condition_movie_info_.left = make_uniq<BoundReferenceExpression>("movie_id_rowid", LogicalType::BIGINT, 0);
    join_condition_movie_info_.right = make_uniq<BoundReferenceExpression>("movie_id_rowid", LogicalType::BIGINT, 2);
    join_condition_movie_info_.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_movie_info_ = make_uniq<RAIInfo>();
    rai_info_movie_info_->rai = table_movie_info.GetStorage().info->rais[0].get();
    rai_info_movie_info_->rai_type = RAIType::EDGE_TARGET;
    rai_info_movie_info_->forward = false;
    rai_info_movie_info_->vertex = &table_title;
    rai_info_movie_info_->vertex_id = table_index_title_t;
    rai_info_movie_info_->passing_tables[0] = table_index_movie_info_;
    rai_info_movie_info_->left_cardinalities[0] = table_movie_info.GetStorage().info->cardinality;
    rai_info_movie_info_->compact_list = &rai_info_movie_info_->rai->alist->compact_backward_list;

    join_condition_movie_info_.rais.push_back(move(rai_info_movie_info_));
    cond_movie_info_.push_back(move(join_condition_movie_info_));

    LogicalComparisonJoin join_movie_info__op(JoinType::INNER);
    vector<LogicalType> output_movie_info__types{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::VARCHAR,
                                                 LogicalType::VARCHAR, LogicalType::BIGINT, LogicalType::BIGINT};
    join_movie_info__op.types = output_movie_info__types;
    vector<idx_t> right_projection_map_movie_info_{3, 4, 5};
    vector<idx_t> merge_project_map_movie_info_;
    vector<LogicalType> delim_types_movie_info_;
    auto join_movie_info_ = make_uniq<PhysicalSIPJoin>(join_movie_info__op, move(filter_mi_contains), move(join_company_name_cn), move(cond_movie_info_),
                                                            JoinType::INNER, left_projection_map,
                                                            right_projection_map_movie_info_,
                                                            delim_types_movie_info_, 0);


    string p_info_n = "release dates";
    Value p_info = Value(p_info_n);
    vector<idx_t> info_type_it_ids{COLUMN_IDENTIFIER_ROW_ID, 1};
    vector<LogicalType> get_info_type_it_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_info_type_it = "it";
    vector<LogicalType> table_types_info_type_it;
    vector<unique_ptr<Expression>> filter_info_type_it;
    unique_ptr<LogicalGet> get_op_info_type_it = move(
            getLogicalGet(*this, table_info_type, alias_info_type_it, table_index_info_type_it,
                          table_types_info_type_it));
    unique_ptr<TableFilterSet> table_filters_info_type_it = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_it = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL, p_info);
    table_filters_info_type_it->filters[1] = move(constant_filter_it);
    unique_ptr<PhysicalTableScan> scan_info_type_it = make_uniq<PhysicalTableScan>(get_info_type_it_types,
                                                                                   get_op_info_type_it->function,
                                                                                   get_op_info_type_it->table_index,
                                                                                   move(get_op_info_type_it->bind_data),
                                                                                   table_types_info_type_it,
                                                                                   info_type_it_ids,
                                                                                   move(filter_info_type_it),
                                                                                   vector<column_t>(),
                                                                                   get_op_info_type_it->names,
                                                                                   std::move(
                                                                                           table_filters_info_type_it),
                                                                                   get_op_info_type_it->estimated_cardinality,
                                                                                   get_op_info_type_it->extra_info);


    vector<JoinCondition> cond_info_type_it;
    JoinCondition join_condition_info_type_it;
    join_condition_info_type_it.left = make_uniq<BoundReferenceExpression>("info_type_rowid", LogicalType::BIGINT, 0);
    join_condition_info_type_it.right = make_uniq<BoundReferenceExpression>("info_type_id_rowid", LogicalType::BIGINT, 1);
    join_condition_info_type_it.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_info_type_it = make_uniq<RAIInfo>();
    rai_info_info_type_it->rai = table_movie_info.GetStorage().info->rais[0].get();
    rai_info_info_type_it->rai_type = RAIType::SOURCE_EDGE;
    rai_info_info_type_it->forward = false;
    rai_info_info_type_it->vertex = &table_info_type;
    rai_info_info_type_it->vertex_id = table_index_info_type_it;
    rai_info_info_type_it->passing_tables[0] = table_index_info_type_it;
    rai_info_info_type_it->left_cardinalities[0] = table_info_type.GetStorage().info->cardinality;
    // rai_info_info_type_it->compact_list = &rai_info_info_type_it->rai->alist->compact__list;

    join_condition_info_type_it.rais.push_back(move(rai_info_info_type_it));
    cond_info_type_it.push_back(move(join_condition_info_type_it));

    LogicalComparisonJoin join_info_type_it_op(JoinType::INNER);
    vector<LogicalType> output_info_type_it_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::VARCHAR,
                                                  LogicalType::BIGINT, LogicalType::BIGINT};
    join_info_type_it_op.types = output_info_type_it_types;
    vector<idx_t> right_projection_map_info_type_it{3, 4, 5};
    vector<idx_t> merge_project_map_info_type_it;
    vector<LogicalType> delim_types_info_type_it;
    auto join_info_type_it = make_uniq<PhysicalSIPJoin>(join_info_type_it_op, move(scan_info_type_it), move(join_movie_info_), move(cond_info_type_it),
                                                        JoinType::INNER, left_projection_map,
                                                        right_projection_map_info_type_it, delim_types_info_type_it, 0);


    string p_gender_n = "f";
    Value p_gender = Value(p_gender_n);
    vector<idx_t> name_n_ids{COLUMN_IDENTIFIER_ROW_ID, 1, 4};
    vector<LogicalType> get_name_n_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::VARCHAR};
    string alias_name_n = "n";
    vector<LogicalType> table_types_name_n;
    vector<unique_ptr<Expression>> filter_name_n;
    unique_ptr<LogicalGet> get_op_name_n = move(
            getLogicalGet(*this, table_name, alias_name_n, table_index_name_n, table_types_name_n));
    unique_ptr<TableFilterSet> table_filters_name_n = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_n = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL, p_gender);
    table_filters_name_n->filters[2] = move(constant_filter_n);
    unique_ptr<PhysicalTableScan> scan_name_n = make_uniq<PhysicalTableScan>(get_name_n_types, get_op_name_n->function,
                                                                             get_op_name_n->table_index,
                                                                             move(get_op_name_n->bind_data),
                                                                             table_types_name_n, name_n_ids,
                                                                             move(filter_name_n), vector<column_t>(),
                                                                             get_op_name_n->names,
                                                                             std::move(table_filters_name_n),
                                                                             get_op_name_n->estimated_cardinality,
                                                                             get_op_name_n->extra_info);

    vector<LogicalType> filter_name_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::VARCHAR};
    vector<unique_ptr<Expression>> select_list_name;
    auto name_like_expression_left1 = make_uniq<BoundReferenceExpression>("name", LogicalType::VARCHAR, 1);
    auto name_like_expression_value1 = make_uniq<BoundConstantExpression>(Value("Ang"));
    vector<unique_ptr<Expression>> name_like_arguments;
    name_like_arguments.push_back(move(name_like_expression_left1));
    name_like_arguments.push_back(move(name_like_expression_value1));

    ScalarFunction name_bound_function_contains = ContainsFun::GetFunction();
    unique_ptr<FunctionData> name_bind_data_contains = NULL;

    auto name_like_bound_function = make_uniq<BoundFunctionExpression>(LogicalType::BOOLEAN,
                                                                       name_bound_function_contains,
                                                                       move(name_like_arguments),
                                                                       move(name_bind_data_contains), false);

    select_list_name.push_back(move(name_like_bound_function));
    unique_ptr<PhysicalFilter> filter_name_contains = make_uniq<PhysicalFilter>(filter_name_types,
                                                                                move(select_list_name), 0);
    filter_name_contains->children.push_back(move(scan_name_n));

    vector<JoinCondition> cond_name_n;
    JoinCondition join_condition_name_n;
    join_condition_name_n.left = make_uniq<BoundReferenceExpression>("name_rowid", LogicalType::BIGINT, 0);
    join_condition_name_n.right = make_uniq<BoundReferenceExpression>("person_id_rowid", LogicalType::BIGINT, 3);
    join_condition_name_n.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_name_n = make_uniq<RAIInfo>();
    rai_info_name_n->rai = table_cast_info.GetStorage().info->rais[0].get();
    rai_info_name_n->rai_type = RAIType::TARGET_EDGE;
    rai_info_name_n->forward = true;
    rai_info_name_n->vertex = &table_name;
    rai_info_name_n->vertex_id = table_index_name_n;
    rai_info_name_n->passing_tables[0] = table_index_name_n;
    rai_info_name_n->left_cardinalities[0] = table_name.GetStorage().info->cardinality;
    // rai_info_name_n->compact_list = &rai_info_name_n->rai->alist->compact__list;

    join_condition_name_n.rais.push_back(move(rai_info_name_n));
    cond_name_n.push_back(move(join_condition_name_n));

    LogicalComparisonJoin join_name_n_op(JoinType::INNER);
    vector<LogicalType> output_name_n_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::VARCHAR,
                                            LogicalType::VARCHAR, LogicalType::BIGINT};
    join_name_n_op.types = output_name_n_types;
    vector<idx_t> right_projection_map_name_n{2, 4};
    vector<idx_t> merge_project_map_name_n;
    vector<LogicalType> delim_types_name_n;
    auto join_name_n = make_uniq<PhysicalSIPJoin>(join_name_n_op, move(filter_name_contains), move(join_info_type_it), move(cond_name_n), JoinType::INNER,
                                                  left_projection_map, right_projection_map_name_n, delim_types_name_n,
                                                  0);


    vector<idx_t> aka_name_an_ids{8};
    vector<LogicalType> get_aka_name_an_types{LogicalType::BIGINT};
    string alias_aka_name_an = "an";
    vector<LogicalType> table_types_aka_name_an;
    vector<unique_ptr<Expression>> filter_aka_name_an;
    unique_ptr<LogicalGet> get_op_aka_name_an = move(
            getLogicalGet(*this, table_aka_name, alias_aka_name_an, table_index_aka_name_an, table_types_aka_name_an));
    unique_ptr<TableFilterSet> table_filters_aka_name_an = NULL;
    unique_ptr<PhysicalTableScan> scan_aka_name_an = make_uniq<PhysicalTableScan>(get_aka_name_an_types,
                                                                                  get_op_aka_name_an->function,
                                                                                  get_op_aka_name_an->table_index,
                                                                                  move(get_op_aka_name_an->bind_data),
                                                                                  table_types_aka_name_an,
                                                                                  aka_name_an_ids,
                                                                                  move(filter_aka_name_an),
                                                                                  vector<column_t>(),
                                                                                  get_op_aka_name_an->names,
                                                                                  std::move(table_filters_aka_name_an),
                                                                                  get_op_aka_name_an->estimated_cardinality,
                                                                                  get_op_aka_name_an->extra_info);


    vector<JoinCondition> cond_aka_name_to_name_;
    JoinCondition join_condition_aka_name_to_name_;
    join_condition_aka_name_to_name_.left = make_uniq<BoundReferenceExpression>("person_id_rowid", LogicalType::BIGINT, 0);
    join_condition_aka_name_to_name_.right = make_uniq<BoundReferenceExpression>("name_rowid", LogicalType::BIGINT, 0);
    join_condition_aka_name_to_name_.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_aka_name_to_name_ = make_uniq<RAIInfo>();
    rai_info_aka_name_to_name_->rai = table_aka_name.GetStorage().info->rais[0].get();
    rai_info_aka_name_to_name_->rai_type = RAIType::EDGE_SOURCE;
    rai_info_aka_name_to_name_->forward = true;
    rai_info_aka_name_to_name_->vertex = &table_name;
    rai_info_aka_name_to_name_->vertex_id = table_index_name_n;
    rai_info_aka_name_to_name_->passing_tables[0] = table_index_aka_name_an;
    rai_info_aka_name_to_name_->left_cardinalities[0] = table_aka_name.GetStorage().info->cardinality;
    rai_info_aka_name_to_name_->compact_list = &rai_info_aka_name_to_name_->rai->alist->compact_forward_list;

    join_condition_aka_name_to_name_.rais.push_back(move(rai_info_aka_name_to_name_));
    cond_aka_name_to_name_.push_back(move(join_condition_aka_name_to_name_));

    LogicalComparisonJoin join_aka_name_to_name__op(JoinType::INNER);
    vector<LogicalType> output_aka_name_to_name__types{LogicalType::BIGINT, LogicalType::VARCHAR,
                                                       LogicalType::VARCHAR, LogicalType::BIGINT};
    join_aka_name_to_name__op.types = output_aka_name_to_name__types;
    vector<idx_t> right_projection_map_aka_name_to_name_{1, 3, 4};
    vector<idx_t> merge_project_map_aka_name_to_name_;
    vector<LogicalType> delim_types_aka_name_to_name_;
    auto join_aka_name_to_name_ = make_uniq<PhysicalSIPJoin>(join_aka_name_to_name__op, move(scan_aka_name_an), move(join_name_n),
                                                                  move(cond_aka_name_to_name_), JoinType::INNER,
                                                                  left_projection_map,
                                                                  right_projection_map_aka_name_to_name_,
                                                                  delim_types_aka_name_to_name_, 0);


    vector<idx_t> char_name_chn_ids{COLUMN_IDENTIFIER_ROW_ID};
    vector<LogicalType> get_char_name_chn_types{LogicalType::BIGINT};
    string alias_char_name_chn = "chn";
    vector<LogicalType> table_types_char_name_chn;
    vector<unique_ptr<Expression>> filter_char_name_chn;
    unique_ptr<LogicalGet> get_op_char_name_chn = move(
            getLogicalGet(*this, table_char_name, alias_char_name_chn, table_index_char_name_chn,
                          table_types_char_name_chn));
    unique_ptr<TableFilterSet> table_filters_char_name_chn = NULL;
    unique_ptr<PhysicalTableScan> scan_char_name_chn = make_uniq<PhysicalTableScan>(get_char_name_chn_types,
                                                                                    get_op_char_name_chn->function,
                                                                                    get_op_char_name_chn->table_index,
                                                                                    move(get_op_char_name_chn->bind_data),
                                                                                    table_types_char_name_chn,
                                                                                    char_name_chn_ids,
                                                                                    move(filter_char_name_chn),
                                                                                    vector<column_t>(),
                                                                                    get_op_char_name_chn->names,
                                                                                    std::move(
                                                                                            table_filters_char_name_chn),
                                                                                    get_op_char_name_chn->estimated_cardinality,
                                                                                    get_op_char_name_chn->extra_info);


    vector<JoinCondition> cond_chn;
    JoinCondition join_condition_chn;
    join_condition_chn.left = make_uniq<BoundReferenceExpression>("char_name_rowid", LogicalType::BIGINT, 0);
    join_condition_chn.right = make_uniq<BoundReferenceExpression>("person_role_id_rowid", LogicalType::BIGINT, 3);
    join_condition_chn.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_chn = make_uniq<RAIInfo>();
    rai_info_chn->rai = table_cast_info.GetStorage().info->rais[3].get();
    rai_info_chn->rai_type = RAIType::TARGET_EDGE;
    rai_info_chn->forward = true;
    rai_info_chn->vertex = &table_char_name;
    rai_info_chn->vertex_id = table_index_char_name_chn;
    rai_info_chn->passing_tables[0] = table_index_char_name_chn;
    rai_info_chn->left_cardinalities[0] = table_char_name.GetStorage().info->cardinality;
    // rai_info_chn->compact_list = &rai_info_chn->rai->alist->compact__list;

    join_condition_chn.rais.push_back(move(rai_info_chn));
    cond_chn.push_back(move(join_condition_chn));

    LogicalComparisonJoin join_chn_op(JoinType::INNER);
    vector<LogicalType> output_chn_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::VARCHAR};
    join_chn_op.types = output_chn_types;
    vector<idx_t> right_projection_map_chn{1, 2};
    vector<idx_t> merge_project_map_chn;
    vector<LogicalType> delim_types_chn;
    auto join_chn = make_uniq<PhysicalSIPJoin>(join_chn_op, move(scan_char_name_chn), move(join_aka_name_to_name_), move(cond_chn),
                                                           JoinType::INNER, left_projection_map,
                                                           right_projection_map_chn,
                                                           delim_types_chn, 0);

    vector<LogicalType> result_types{LogicalType::VARCHAR, LogicalType::VARCHAR};
    vector<unique_ptr<Expression>> select_list;
    auto result_col0 = make_uniq<BoundReferenceExpression>("name", LogicalType::VARCHAR, 1);
    auto result_col1 = make_uniq<BoundReferenceExpression>("title", LogicalType::VARCHAR, 2);
    select_list.push_back(move(result_col0));
    select_list.push_back(move(result_col1));
    auto projection = make_uniq<PhysicalProjection>(result_types, move(select_list), 0);
    projection->children.push_back(move(join_chn));

    // aggregate
    string agg_name = "min";
    string agg_error = "";
    QueryErrorContext error_context(NULL, NULL);
    auto min_func = Catalog::GetEntry(context, CatalogType::SCALAR_FUNCTION_ENTRY, "", "",
                                      "min", OnEntryNotFound::RETURN_NULL, error_context);
    auto &min_func_set = min_func->Cast<AggregateFunctionCatalogEntry>();
    // bind the aggregate
    FunctionBinder function_binder(context);
    vector<LogicalType> types;
    types.push_back(LogicalType::VARCHAR);
    idx_t best_function_varchar = function_binder.BindFunction(agg_name, min_func_set.functions, types, agg_error);
    auto bound_function_min_varchar = min_func_set.functions.GetFunctionByOffset(best_function_varchar);

    auto first_children = make_uniq<BoundReferenceExpression>("name", LogicalType::VARCHAR, 0);
    vector<unique_ptr<Expression>> childrenlist1;
    childrenlist1.push_back(move(first_children));
    auto aggregate1 =
            function_binder.BindAggregateFunction(bound_function_min_varchar, std::move(childrenlist1), nullptr,
                                                  AggregateType::NON_DISTINCT);

    auto second_children = make_uniq<BoundReferenceExpression>("title", LogicalType::VARCHAR, 1);
    vector<unique_ptr<Expression>> childrenlist2;
    childrenlist2.push_back(move(second_children));
    auto aggregate2 =
            function_binder.BindAggregateFunction(bound_function_min_varchar, std::move(childrenlist2), nullptr,
                                                  AggregateType::NON_DISTINCT);

    vector<unique_ptr<Expression>> aggregates;
    aggregates.push_back(move(aggregate1));
    aggregates.push_back(move(aggregate2));

    vector<LogicalType> aggregate_types{LogicalType::VARCHAR, LogicalType::VARCHAR};
    auto ungrouped_aggregate = make_uniq<PhysicalUngroupedAggregate>(aggregate_types, move(aggregates), 0);
    ungrouped_aggregate->children.push_back(move(projection));

    return ungrouped_aggregate;
}

unique_ptr<PhysicalOperator> ClientContext::GenerateJOB20aPlan(ClientContext& context) {
    vector<idx_t> left_projection_map, right_projection_map;

    string table_vertex_kind_type_kt = "kind_type";
    string table_vertex_title_t = "title";
    string table_vertex_keyword_k = "keyword";
    string table_vertex_char_name_chn = "char_name";
    string table_vertex_name_n = "name";
    string table_vertex_comp_cast_type_cct1 = "comp_cast_type";
    string table_vertex_comp_cast_type_cct2 = "comp_cast_type";
    string table_vertex_movie_keyword_ = "movie_keyword";
    string table_vertex_cast_info_ = "cast_info";
    string table_vertex_complete_cast = "complete_cast";

    idx_t table_index_kind_type_kt = 1;
    idx_t table_index_title_t = 2;
    idx_t table_index_keyword_k = 3;
    idx_t table_index_char_name_chn = 4;
    idx_t table_index_name_n = 5;
    idx_t table_index_comp_cast_type_cct1 = 6;
    idx_t table_index_comp_cast_type_cct2 = 7;
    idx_t table_index_movie_keyword_ = 9;
    idx_t table_index_cast_info_ = 11;
    idx_t table_index_complete_cast = 12;

    auto table_or_view_kind_type = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_kind_type_kt,
                                                     OnEntryNotFound::RETURN_NULL);
    auto &table_kind_type = table_or_view_kind_type->Cast<TableCatalogEntry>();
    auto table_or_view_title = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_title_t,
                                                 OnEntryNotFound::RETURN_NULL);
    auto &table_title = table_or_view_title->Cast<TableCatalogEntry>();
    auto table_or_view_keyword = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_keyword_k,
                                                   OnEntryNotFound::RETURN_NULL);
    auto &table_keyword = table_or_view_keyword->Cast<TableCatalogEntry>();
    auto table_or_view_char_name = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                     table_vertex_char_name_chn, OnEntryNotFound::RETURN_NULL);
    auto &table_char_name = table_or_view_char_name->Cast<TableCatalogEntry>();
    auto table_or_view_name = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_name_n,
                                                OnEntryNotFound::RETURN_NULL);
    auto &table_name = table_or_view_name->Cast<TableCatalogEntry>();
    auto table_or_view_comp_cast_type = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                          table_vertex_comp_cast_type_cct1,
                                                          OnEntryNotFound::RETURN_NULL);
    auto &table_comp_cast_type = table_or_view_comp_cast_type->Cast<TableCatalogEntry>();
    auto table_or_view_movie_keyword = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                         table_vertex_movie_keyword_, OnEntryNotFound::RETURN_NULL);
    auto &table_movie_keyword = table_or_view_movie_keyword->Cast<TableCatalogEntry>();
    auto table_or_view_cast_info = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_cast_info_,
                                                     OnEntryNotFound::RETURN_NULL);
    auto &table_cast_info = table_or_view_cast_info->Cast<TableCatalogEntry>();
    auto table_or_view_complete_cast = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                                 table_vertex_complete_cast,
                                                                 OnEntryNotFound::RETURN_NULL);
    auto &table_complete_cast = table_or_view_complete_cast->Cast<TableCatalogEntry>();

    vector<idx_t> comp_cast_type_cct2_ids{COLUMN_IDENTIFIER_ROW_ID, 1};
    vector<LogicalType> get_comp_cast_type_cct2_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_comp_cast_type_cct2 = "cct2";
    vector<LogicalType> table_types_comp_cast_type_cct2;
    vector<unique_ptr<Expression>> filter_comp_cast_type_cct2;
    unique_ptr<LogicalGet> get_op_comp_cast_type_cct2 = move(
            getLogicalGet(*this, table_comp_cast_type, alias_comp_cast_type_cct2, table_index_comp_cast_type_cct2,
                          table_types_comp_cast_type_cct2));
    unique_ptr<TableFilterSet> table_filters_comp_cast_type_cct2 = NULL;
    unique_ptr<PhysicalTableScan> scan_comp_cast_type_cct2 = make_uniq<PhysicalTableScan>(get_comp_cast_type_cct2_types,
                                                                                          get_op_comp_cast_type_cct2->function,
                                                                                          get_op_comp_cast_type_cct2->table_index,
                                                                                          move(get_op_comp_cast_type_cct2->bind_data),
                                                                                          table_types_comp_cast_type_cct2,
                                                                                          comp_cast_type_cct2_ids,
                                                                                          move(filter_comp_cast_type_cct2),
                                                                                          vector<column_t>(),
                                                                                          get_op_comp_cast_type_cct2->names,
                                                                                          std::move(
                                                                                                  table_filters_comp_cast_type_cct2),
                                                                                          get_op_comp_cast_type_cct2->estimated_cardinality,
                                                                                          get_op_comp_cast_type_cct2->extra_info);


    vector<LogicalType> filter_cct_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    vector<unique_ptr<Expression>> select_list_cct;
    auto like_expression_left_cct = make_uniq<BoundReferenceExpression>("kind", LogicalType::VARCHAR, 1);
    auto like_expression_value_cct = make_uniq<BoundConstantExpression>(Value("complete"));
    vector<unique_ptr<Expression>> like_arguments_cct;
    like_arguments_cct.push_back(move(like_expression_left_cct));
    like_arguments_cct.push_back(move(like_expression_value_cct));

    ScalarFunction bound_function_contains = ContainsFun::GetFunction();
    unique_ptr<FunctionData> bind_data_contains = NULL;

    auto like_bound_function_cct = make_uniq<BoundFunctionExpression>(LogicalType::BOOLEAN,
                                                                    bound_function_contains,
                                                                    move(like_arguments_cct),
                                                                    move(bind_data_contains), false);

    select_list_cct.push_back(move(like_bound_function_cct));
    unique_ptr<PhysicalFilter> filter_cct_contains = make_uniq<PhysicalFilter>(filter_cct_types, move(select_list_cct), 0);
    filter_cct_contains->children.push_back(move(scan_comp_cast_type_cct2));


    vector<idx_t> complete_cast_ids{4, 5, 6};
    vector<LogicalType> get_complete_cast_types{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::BIGINT};
    string alias_complete_cast = "cc";
    vector<LogicalType> table_types_complete_cast;
    vector<unique_ptr<Expression>> filter_complete_cast;
    unique_ptr<LogicalGet> get_op_complete_cast = move(
            getLogicalGet(*this, table_complete_cast, alias_complete_cast, table_index_complete_cast,
                          table_types_complete_cast));
    unique_ptr<TableFilterSet> table_filters_complete_cast = NULL;
    unique_ptr<PhysicalTableScan> scan_complete_cast = make_uniq<PhysicalTableScan>(get_complete_cast_types,
                                                                                          get_op_complete_cast->function,
                                                                                          get_op_complete_cast->table_index,
                                                                                          move(get_op_complete_cast->bind_data),
                                                                                          table_types_complete_cast,
                                                                                          complete_cast_ids,
                                                                                          move(filter_complete_cast),
                                                                                          vector<column_t>(),
                                                                                          get_op_complete_cast->names,
                                                                                          std::move(
                                                                                                  table_filters_complete_cast),
                                                                                          get_op_complete_cast->estimated_cardinality,
                                                                                          get_op_complete_cast->extra_info);

    vector<JoinCondition> cond_complete_cast_status_;
    JoinCondition join_condition_complete_cast_status_;
    join_condition_complete_cast_status_.left = make_uniq<BoundReferenceExpression>("status_id_rowid", LogicalType::BIGINT, 2);
    join_condition_complete_cast_status_.right = make_uniq<BoundReferenceExpression>("comp_cast_type_rowid", LogicalType::BIGINT, 0);
    join_condition_complete_cast_status_.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_complete_cast_status_ = make_uniq<RAIInfo>();
    rai_info_complete_cast_status_->rai = table_complete_cast.GetStorage().info->rais[1].get();
    rai_info_complete_cast_status_->rai_type = RAIType::EDGE_SOURCE;
    rai_info_complete_cast_status_->forward = true;
    rai_info_complete_cast_status_->vertex = &table_comp_cast_type;
    rai_info_complete_cast_status_->vertex_id = table_index_comp_cast_type_cct2;
    rai_info_complete_cast_status_->passing_tables[0] = table_index_complete_cast;
    rai_info_complete_cast_status_->left_cardinalities[0] = table_complete_cast.GetStorage().info->cardinality;
    rai_info_complete_cast_status_->compact_list = &rai_info_complete_cast_status_->rai->alist->compact_forward_list;

    join_condition_complete_cast_status_.rais.push_back(move(rai_info_complete_cast_status_));
    cond_complete_cast_status_.push_back(move(join_condition_complete_cast_status_));

    LogicalComparisonJoin join_complete_cast_status__op(JoinType::INNER);
    vector<LogicalType> output_complete_cast_status__types{LogicalType::BIGINT, LogicalType::BIGINT,
                                                           LogicalType::BIGINT, LogicalType::BIGINT};
    join_complete_cast_status__op.types = output_complete_cast_status__types;
    vector<idx_t> right_projection_map_complete_cast_status_{0};
    vector<idx_t> merge_project_map_complete_cast_status_;
    vector<LogicalType> delim_types_complete_cast_status_;
    auto join_complete_cast_status_ = make_uniq<PhysicalSIPJoin>(join_complete_cast_status__op, move(scan_complete_cast), move(filter_cct_contains),
                                                                      move(cond_complete_cast_status_), JoinType::INNER,
                                                                      left_projection_map,
                                                                      right_projection_map_complete_cast_status_,
                                                                      delim_types_complete_cast_status_, 0);
    string p_kind_n = "cast";
    Value p_kind = Value(p_kind_n);
    vector<idx_t> comp_cast_type_cct1_ids{COLUMN_IDENTIFIER_ROW_ID, 1};
    vector<LogicalType> get_comp_cast_type_cct1_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_comp_cast_type_cct1 = "cct1";
    vector<LogicalType> table_types_comp_cast_type_cct1;
    vector<unique_ptr<Expression>> filter_comp_cast_type_cct1;
    unique_ptr<LogicalGet> get_op_comp_cast_type_cct1 = move(
            getLogicalGet(*this, table_comp_cast_type, alias_comp_cast_type_cct1, table_index_comp_cast_type_cct1,
                          table_types_comp_cast_type_cct1));
    unique_ptr<TableFilterSet> table_filters_comp_cast_type_cct1 = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_cct1 = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL, p_kind);
    table_filters_comp_cast_type_cct1->filters[1] = move(constant_filter_cct1);
    unique_ptr<PhysicalTableScan> scan_comp_cast_type_cct1 = make_uniq<PhysicalTableScan>(get_comp_cast_type_cct1_types,
                                                                                          get_op_comp_cast_type_cct1->function,
                                                                                          get_op_comp_cast_type_cct1->table_index,
                                                                                          move(get_op_comp_cast_type_cct1->bind_data),
                                                                                          table_types_comp_cast_type_cct1,
                                                                                          comp_cast_type_cct1_ids,
                                                                                          move(filter_comp_cast_type_cct1),
                                                                                          vector<column_t>(),
                                                                                          get_op_comp_cast_type_cct1->names,
                                                                                          std::move(
                                                                                                  table_filters_comp_cast_type_cct1),
                                                                                          get_op_comp_cast_type_cct1->estimated_cardinality,
                                                                                          get_op_comp_cast_type_cct1->extra_info);


    vector<JoinCondition> cond_comp_cast_type_cct1;
    JoinCondition join_condition_comp_cast_type_cct1;
    join_condition_comp_cast_type_cct1.left = make_uniq<BoundReferenceExpression>("comp_cast_type_rowid", LogicalType::BIGINT, 0);
    join_condition_comp_cast_type_cct1.right = make_uniq<BoundReferenceExpression>("subject_id_rowid", LogicalType::BIGINT, 0);
    join_condition_comp_cast_type_cct1.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_comp_cast_type_cct1 = make_uniq<RAIInfo>();
    rai_info_comp_cast_type_cct1->rai = table_complete_cast.GetStorage().info->rais[0].get();
    rai_info_comp_cast_type_cct1->rai_type = RAIType::SOURCE_EDGE;
    rai_info_comp_cast_type_cct1->forward = false;
    rai_info_comp_cast_type_cct1->vertex = &table_comp_cast_type;
    rai_info_comp_cast_type_cct1->vertex_id = table_index_comp_cast_type_cct1;
    rai_info_comp_cast_type_cct1->passing_tables[0] = table_index_comp_cast_type_cct1;
    rai_info_comp_cast_type_cct1->left_cardinalities[0] = table_comp_cast_type.GetStorage().info->cardinality;
    // rai_info_comp_cast_type_cct1->compact_list = &rai_info_comp_cast_type_cct1->rai->alist->compact__list;

    join_condition_comp_cast_type_cct1.rais.push_back(move(rai_info_comp_cast_type_cct1));
    cond_comp_cast_type_cct1.push_back(move(join_condition_comp_cast_type_cct1));

    LogicalComparisonJoin join_comp_cast_type_cct1_op(JoinType::INNER);
    vector<LogicalType> output_comp_cast_type_cct1_types{LogicalType::BIGINT, LogicalType::VARCHAR,
                                                         LogicalType::BIGINT};
    join_comp_cast_type_cct1_op.types = output_comp_cast_type_cct1_types;
    vector<idx_t> right_projection_map_comp_cast_type_cct1{1};
    vector<idx_t> merge_project_map_comp_cast_type_cct1;
    vector<LogicalType> delim_types_comp_cast_type_cct1;
    auto join_comp_cast_type_cct1 = make_uniq<PhysicalSIPJoin>(join_comp_cast_type_cct1_op, move(scan_comp_cast_type_cct1), move(join_complete_cast_status_),
                                                               move(cond_comp_cast_type_cct1), JoinType::INNER,
                                                               left_projection_map,
                                                               right_projection_map_comp_cast_type_cct1,
                                                               delim_types_comp_cast_type_cct1, 0);


    idx_t p_year_n = 1950;
    Value p_year = Value::BIGINT(p_year_n);
    vector<idx_t> title_t_ids{COLUMN_IDENTIFIER_ROW_ID, 1, 4, 12};
    vector<LogicalType> get_title_t_types{LogicalType::BIGINT, LogicalType::VARCHAR,
                                          LogicalType::BIGINT, LogicalType::BIGINT};
    string alias_title_t = "t";
    vector<LogicalType> table_types_title_t;
    vector<unique_ptr<Expression>> filter_title_t;
    unique_ptr<LogicalGet> get_op_title_t = move(
            getLogicalGet(*this, table_title, alias_title_t, table_index_title_t, table_types_title_t));
    unique_ptr<TableFilterSet> table_filters_title_t = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_t = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_GREATERTHAN, p_year);
    table_filters_title_t->filters[2] = move(constant_filter_t);
    unique_ptr<PhysicalTableScan> scan_title_t = make_uniq<PhysicalTableScan>(get_title_t_types,
                                                                              get_op_title_t->function,
                                                                              get_op_title_t->table_index,
                                                                              move(get_op_title_t->bind_data),
                                                                              table_types_title_t, title_t_ids,
                                                                              move(filter_title_t), vector<column_t>(),
                                                                              get_op_title_t->names,
                                                                              std::move(table_filters_title_t),
                                                                              get_op_title_t->estimated_cardinality,
                                                                              get_op_title_t->extra_info);


    vector<JoinCondition> cond_title_t;
    JoinCondition join_condition_title_t;
    join_condition_title_t.left = make_uniq<BoundReferenceExpression>("title_rowid", LogicalType::BIGINT, 0);
    join_condition_title_t.right = make_uniq<BoundReferenceExpression>("movie_id_rowid", LogicalType::BIGINT, 2);
    join_condition_title_t.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_title_t = make_uniq<RAIInfo>();
    rai_info_title_t->rai = table_complete_cast.GetStorage().info->rais[0].get();
    rai_info_title_t->rai_type = RAIType::TARGET_EDGE;
    rai_info_title_t->forward = true;
    rai_info_title_t->vertex = &table_title;
    rai_info_title_t->vertex_id = table_index_title_t;
    rai_info_title_t->passing_tables[0] = table_index_title_t;
    rai_info_title_t->left_cardinalities[0] = table_title.GetStorage().info->cardinality;
    // rai_info_title_t->compact_list = &rai_info_title_t->rai->alist->compact__list;

    join_condition_title_t.rais.push_back(move(rai_info_title_t));
    cond_title_t.push_back(move(join_condition_title_t));

    LogicalComparisonJoin join_title_t_op(JoinType::INNER);
    vector<LogicalType> output_title_t_types{LogicalType::BIGINT, LogicalType::VARCHAR,
                                             LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::BIGINT};
    join_title_t_op.types = output_title_t_types;
    vector<idx_t> right_projection_map_title_t{0};
    vector<idx_t> merge_project_map_title_t;
    vector<LogicalType> delim_types_title_t;
    auto join_title_t = make_uniq<PhysicalSIPJoin>(join_title_t_op, move(scan_title_t), move(join_comp_cast_type_cct1), move(cond_title_t), JoinType::INNER,
                                                   left_projection_map, right_projection_map_title_t,
                                                   delim_types_title_t, 0);


    string p_kt_n = "movie";
    Value p_kt = Value(p_kt_n);
    vector<idx_t> kind_type_kt_ids{COLUMN_IDENTIFIER_ROW_ID, 1};
    vector<LogicalType> get_kind_type_kt_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_kind_type_kt = "kt";
    vector<LogicalType> table_types_kind_type_kt;
    vector<unique_ptr<Expression>> filter_kind_type_kt;
    unique_ptr<LogicalGet> get_op_kind_type_kt = move(
            getLogicalGet(*this, table_kind_type, alias_kind_type_kt, table_index_kind_type_kt,
                          table_types_kind_type_kt));
    unique_ptr<TableFilterSet> table_filters_kind_type_kt = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_kt = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL, p_kt);
    table_filters_kind_type_kt->filters[1] = move(constant_filter_kt);
    unique_ptr<PhysicalTableScan> scan_kind_type_kt = make_uniq<PhysicalTableScan>(get_kind_type_kt_types,
                                                                                   get_op_kind_type_kt->function,
                                                                                   get_op_kind_type_kt->table_index,
                                                                                   move(get_op_kind_type_kt->bind_data),
                                                                                   table_types_kind_type_kt,
                                                                                   kind_type_kt_ids,
                                                                                   move(filter_kind_type_kt),
                                                                                   vector<column_t>(),
                                                                                   get_op_kind_type_kt->names,
                                                                                   std::move(
                                                                                           table_filters_kind_type_kt),
                                                                                   get_op_kind_type_kt->estimated_cardinality,
                                                                                   get_op_kind_type_kt->extra_info);


    vector<JoinCondition> cond_kind_type_kt;
    JoinCondition join_condition_kind_type_kt;
    join_condition_kind_type_kt.left = make_uniq<BoundReferenceExpression>("kind_type_rowid", LogicalType::BIGINT, 0);
    join_condition_kind_type_kt.right = make_uniq<BoundReferenceExpression>("kind_id_rowid", LogicalType::BIGINT, 3);
    join_condition_kind_type_kt.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_kind_type_kt = make_uniq<RAIInfo>();
    rai_info_kind_type_kt->rai = table_title.GetStorage().info->rais[0].get();
    rai_info_kind_type_kt->rai_type = RAIType::TARGET_EDGE;
    rai_info_kind_type_kt->forward = true;
    rai_info_kind_type_kt->vertex = &table_kind_type;
    rai_info_kind_type_kt->vertex_id = table_index_kind_type_kt;
    rai_info_kind_type_kt->passing_tables[0] = table_index_kind_type_kt;
    rai_info_kind_type_kt->left_cardinalities[0] = table_kind_type.GetStorage().info->cardinality;
    // rai_info_kind_type_kt->compact_list = &rai_info_kind_type_kt->rai->alist->compact__list;

    join_condition_kind_type_kt.rais.push_back(move(rai_info_kind_type_kt));
    cond_kind_type_kt.push_back(move(join_condition_kind_type_kt));

    LogicalComparisonJoin join_kind_type_kt_op(JoinType::INNER);
    vector<LogicalType> output_kind_type_kt_types{LogicalType::BIGINT, LogicalType::VARCHAR,
                                                  LogicalType::BIGINT, LogicalType::VARCHAR};
    join_kind_type_kt_op.types = output_kind_type_kt_types;
    vector<idx_t> right_projection_map_kind_type_kt{0, 1};
    vector<idx_t> merge_project_map_kind_type_kt;
    vector<LogicalType> delim_types_kind_type_kt;
    auto join_kind_type_kt = make_uniq<PhysicalSIPJoin>(join_kind_type_kt_op, move(scan_kind_type_kt), move(join_title_t), move(cond_kind_type_kt),
                                                        JoinType::INNER, left_projection_map,
                                                        right_projection_map_kind_type_kt, delim_types_kind_type_kt, 0);


    vector<idx_t> keyword_k_ids{COLUMN_IDENTIFIER_ROW_ID, 1};
    vector<LogicalType> get_keyword_k_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_keyword_k = "k";
    vector<LogicalType> table_types_keyword_k;
    vector<unique_ptr<Expression>> filter_keyword_k;
    unique_ptr<LogicalGet> get_op_keyword_k = move(
            getLogicalGet(*this, table_keyword, alias_keyword_k, table_index_keyword_k, table_types_keyword_k));
    unique_ptr<TableFilterSet> table_filters_keyword_k = NULL;
    unique_ptr<PhysicalTableScan> scan_keyword_k = make_uniq<PhysicalTableScan>(get_keyword_k_types,
                                                                                get_op_keyword_k->function,
                                                                                get_op_keyword_k->table_index,
                                                                                move(get_op_keyword_k->bind_data),
                                                                                table_types_keyword_k, keyword_k_ids,
                                                                                move(filter_keyword_k),
                                                                                vector<column_t>(),
                                                                                get_op_keyword_k->names,
                                                                                std::move(table_filters_keyword_k),
                                                                                get_op_keyword_k->estimated_cardinality,
                                                                                get_op_keyword_k->extra_info);

    auto &allocator = Allocator::Get(context);
    vector<LogicalType> join_in_types {LogicalType::VARCHAR};
    auto collection =
            make_uniq<ColumnDataCollection>(context, join_in_types, ColumnDataAllocatorType::IN_MEMORY_ALLOCATOR);

    vector<LogicalType> chunk_in_types {LogicalType::VARCHAR};
    DataChunk chunk;
    chunk.SetCardinality(8);
    chunk.Initialize(allocator, chunk_in_types);
    chunk.SetValue(0, 0, Value("superhero"));
    chunk.SetValue(0, 1, Value("sequel"));
    chunk.SetValue(0, 2, Value("second-part"));
    chunk.SetValue(0, 3, Value("marvel-comics"));
    chunk.SetValue(0, 4, Value("based-on-comic"));
    chunk.SetValue(0, 5, Value("tv-special"));
    chunk.SetValue(0, 6, Value("fight"));
    chunk.SetValue(0, 7, Value("violence"));
    collection->Append(chunk);

    // create a chunk scan to output the result
    vector<LogicalType> ouput_in_types {LogicalType::VARCHAR};
    auto chunk_scan = make_uniq<PhysicalColumnDataScan>(ouput_in_types, PhysicalOperatorType::COLUMN_DATA_SCAN,
                                                        8, std::move(collection));

    vector<JoinCondition> cond_hash_join_;
    JoinCondition join_condition_hash_join_;
    join_condition_hash_join_.left = make_uniq<BoundReferenceExpression>("keyword", LogicalType::VARCHAR, 1);
    join_condition_hash_join_.right = make_uniq<BoundReferenceExpression>("", LogicalType::VARCHAR, 0);
    join_condition_hash_join_.comparison = ExpressionType::COMPARE_EQUAL;
    cond_hash_join_.push_back(move(join_condition_hash_join_));

    LogicalComparisonJoin join_hash_join_op(JoinType::MARK);
    vector<LogicalType> output_hash_join_types{LogicalType::BIGINT, LogicalType::VARCHAR,
                                               LogicalType::BOOLEAN};
    join_hash_join_op.types = output_hash_join_types;
    vector<idx_t> right_projection_map_hash_join_;
    vector<LogicalType> delim_types_hash_join_;
    PerfectHashJoinStats joinstate;
    auto join_hash_join_ = make_uniq<PhysicalHashJoin>(join_hash_join_op, move(scan_keyword_k), move(chunk_scan), move(cond_hash_join_),
                                                       JoinType::MARK, left_projection_map,
                                                       right_projection_map_hash_join_,
                                                       delim_types_hash_join_, 0, joinstate);


    vector<LogicalType> filter_in_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::BOOLEAN};
    vector<unique_ptr<Expression>> select_list_in;
    auto in_exp = make_uniq<BoundReferenceExpression>("IN (...)", LogicalType::BOOLEAN, 2);
    select_list_in.push_back(move(in_exp));
    unique_ptr<PhysicalFilter> filter_in = make_uniq<PhysicalFilter>(filter_in_types, move(select_list_in), 0);
    filter_in->children.push_back(move(join_hash_join_));


    vector<JoinCondition> cond_keyword_k;
    JoinCondition join_condition_keyword_k;
    join_condition_keyword_k.left = make_uniq<BoundReferenceExpression>("keyword_rowid", LogicalType::BIGINT, 0);
    join_condition_keyword_k.right = make_uniq<BoundReferenceExpression>("title_rowid", LogicalType::BIGINT, 2);
    join_condition_keyword_k.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_keyword_k = make_uniq<RAIInfo>();
    rai_info_keyword_k->rai = table_movie_keyword.GetStorage().info->rais[0].get();
    rai_info_keyword_k->rai_type = RAIType::SOURCE_EDGE;
    rai_info_keyword_k->forward = false;
    rai_info_keyword_k->vertex = &table_keyword;
    rai_info_keyword_k->vertex_id = table_index_keyword_k;
    rai_info_keyword_k->passing_tables[0] = table_index_keyword_k;
    rai_info_keyword_k->left_cardinalities[0] = table_keyword.GetStorage().info->cardinality;
    // rai_info_keyword_k->compact_list = &rai_info_keyword_k->rai->alist->compact__list;

    join_condition_keyword_k.rais.push_back(move(rai_info_keyword_k));
    cond_keyword_k.push_back(move(join_condition_keyword_k));

    LogicalComparisonJoin join_keyword_k_op(JoinType::INNER);
    vector<LogicalType> output_keyword_k_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::BOOLEAN,
                                               LogicalType::BIGINT, LogicalType::VARCHAR};
    join_keyword_k_op.types = output_keyword_k_types;
    vector<idx_t> right_projection_map_keyword_k{2, 3};
    vector<idx_t> merge_project_map_keyword_k;
    vector<LogicalType> delim_types_keyword_k;
    auto join_keyword_k = make_uniq<PhysicalMergeSIPJoin>(join_keyword_k_op, move(filter_in), move(join_kind_type_kt), move(cond_keyword_k),
                                                     JoinType::INNER, left_projection_map,
                                                     right_projection_map_keyword_k,
                                                     merge_project_map_keyword_k,
                                                     delim_types_keyword_k, 0);


    vector<idx_t> cast_info_ids{7, 8, 10};
    vector<LogicalType> get_cast_info_types{LogicalType::BIGINT, LogicalType::BIGINT,
                                            LogicalType::BIGINT};
    string alias_cast_info = "ci";
    vector<LogicalType> table_types_cast_info;
    vector<unique_ptr<Expression>> filter_cast_info;
    unique_ptr<LogicalGet> get_op_cast_info = move(
            getLogicalGet(*this, table_cast_info, alias_cast_info, table_index_cast_info_, table_types_cast_info));
    unique_ptr<TableFilterSet> table_filters_cast_info = NULL;
    unique_ptr<PhysicalTableScan> scan_cast_info = make_uniq<PhysicalTableScan>(get_cast_info_types,
                                                                                get_op_cast_info->function,
                                                                                get_op_cast_info->table_index,
                                                                                move(get_op_cast_info->bind_data),
                                                                                table_types_cast_info, cast_info_ids,
                                                                                move(filter_cast_info),
                                                                                vector<column_t>(),
                                                                                get_op_cast_info->names,
                                                                                std::move(table_filters_cast_info),
                                                                                get_op_cast_info->estimated_cardinality,
                                                                                get_op_cast_info->extra_info);


    vector<JoinCondition> cond_cast_info_;
    JoinCondition join_condition_cast_info_;
    join_condition_cast_info_.left = make_uniq<BoundReferenceExpression>("movie_id_rowid", LogicalType::BIGINT, 0);
    join_condition_cast_info_.right = make_uniq<BoundReferenceExpression>("title_rowid", LogicalType::BIGINT, 3);
    join_condition_cast_info_.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_cast_info_ = make_uniq<RAIInfo>();
    rai_info_cast_info_->rai = table_cast_info.GetStorage().info->rais[0].get();
    rai_info_cast_info_->rai_type = RAIType::EDGE_SOURCE;
    rai_info_cast_info_->forward = true;
    rai_info_cast_info_->vertex = &table_title;
    rai_info_cast_info_->vertex_id = table_index_title_t;
    rai_info_cast_info_->passing_tables[0] = table_index_cast_info_;
    rai_info_cast_info_->left_cardinalities[0] = table_cast_info.GetStorage().info->cardinality;
    rai_info_cast_info_->compact_list = &rai_info_cast_info_->rai->alist->compact_forward_list;

    join_condition_cast_info_.rais.push_back(move(rai_info_cast_info_));
    cond_cast_info_.push_back(move(join_condition_cast_info_));

    LogicalComparisonJoin join_cast_info__op(JoinType::INNER);
    vector<LogicalType> output_cast_info__types{LogicalType::BIGINT, LogicalType::BIGINT,
                                                LogicalType::BIGINT, LogicalType::VARCHAR};
    join_cast_info__op.types = output_cast_info__types;
    vector<idx_t> right_projection_map_cast_info_{4};
    vector<idx_t> merge_project_map_cast_info_;
    vector<LogicalType> delim_types_cast_info_;
    auto join_cast_info_ = make_uniq<PhysicalSIPJoin>(join_cast_info__op, move(scan_cast_info), move(join_keyword_k), move(cond_cast_info_),
                                                           JoinType::INNER, left_projection_map,
                                                           right_projection_map_cast_info_,
                                                           delim_types_cast_info_, 0);


    vector<idx_t> char_name_chn_ids{COLUMN_IDENTIFIER_ROW_ID, 1};
    vector<LogicalType> get_char_name_chn_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_char_name_chn = "chn";
    vector<LogicalType> table_types_char_name_chn;
    vector<unique_ptr<Expression>> filter_char_name_chn;
    unique_ptr<LogicalGet> get_op_char_name_chn = move(
            getLogicalGet(*this, table_char_name, alias_char_name_chn, table_index_char_name_chn,
                          table_types_char_name_chn));
    unique_ptr<TableFilterSet> table_filters_char_name_chn = NULL;
    unique_ptr<PhysicalTableScan> scan_char_name_chn = make_uniq<PhysicalTableScan>(get_char_name_chn_types,
                                                                                    get_op_char_name_chn->function,
                                                                                    get_op_char_name_chn->table_index,
                                                                                    move(get_op_char_name_chn->bind_data),
                                                                                    table_types_char_name_chn,
                                                                                    char_name_chn_ids,
                                                                                    move(filter_char_name_chn),
                                                                                    vector<column_t>(),
                                                                                    get_op_char_name_chn->names,
                                                                                    std::move(
                                                                                            table_filters_char_name_chn),
                                                                                    get_op_char_name_chn->estimated_cardinality,
                                                                                    get_op_char_name_chn->extra_info);

    vector<LogicalType> filter_chn_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    vector<unique_ptr<Expression>> select_list_chn;
    auto unlike_expression_left_chn = make_uniq<BoundReferenceExpression>("name", LogicalType::VARCHAR, 1);
    auto unlike_expression_value_chn = make_uniq<BoundConstantExpression>(Value("Sherlock"));
    vector<unique_ptr<Expression>> unlike_arguments_chn;
    unlike_arguments_chn.push_back(move(unlike_expression_left_chn));
    unlike_arguments_chn.push_back(move(unlike_expression_value_chn));

    unique_ptr<FunctionData> bind_data_contains_chn = NULL;

    auto unlike_bound_function_chn = make_uniq<BoundFunctionExpression>(LogicalType::BOOLEAN,
                                                                    bound_function_contains,
                                                                    move(unlike_arguments_chn),
                                                                    move(bind_data_contains_chn), false);

    auto not_unlike_bound_function_chn = make_uniq<BoundOperatorExpression>(ExpressionType::OPERATOR_NOT,
                                                                        LogicalType::BOOLEAN);
    not_unlike_bound_function_chn->children.push_back(move(unlike_bound_function_chn));

    auto like_bound_function_chn = make_uniq<BoundConjunctionExpression>(ExpressionType::CONJUNCTION_OR);

    ScalarFunction bound_function_like = LikeFun::GetLikeFunction();

    auto like_expression_left_exp_chn = make_uniq<BoundReferenceExpression>("name", LogicalType::VARCHAR, 1);
    auto like_expression_left_value_chn = make_uniq<BoundConstantExpression>(Value("%Tony%Stark%"));
    vector<unique_ptr<Expression>> like_arguments_left_chn;
    like_arguments_left_chn.push_back(move(like_expression_left_exp_chn));
    like_arguments_left_chn.push_back(move(like_expression_left_value_chn));
    auto like_bound_function_left_chn = make_uniq<BoundFunctionExpression>(LogicalType::BOOLEAN,
                                                                           bound_function_like,
                                                                           move(like_arguments_left_chn),
                                                                           move(bind_data_contains_chn), false);

    auto like_expression_right_exp_chn = make_uniq<BoundReferenceExpression>("name", LogicalType::VARCHAR, 1);
    auto like_expression_right_value_chn = make_uniq<BoundConstantExpression>(Value("%Iron%Man%"));
    vector<unique_ptr<Expression>> like_arguments_right_chn;
    like_arguments_right_chn.push_back(move(like_expression_right_exp_chn));
    like_arguments_right_chn.push_back(move(like_expression_right_value_chn));
    auto like_bound_function_right_chn = make_uniq<BoundFunctionExpression>(LogicalType::BOOLEAN,
                                                                            bound_function_like,
                                                                            move(like_arguments_right_chn),
                                                                            move(bind_data_contains_chn), false);

    like_bound_function_chn->children.push_back(move(like_bound_function_left_chn));
    like_bound_function_chn->children.push_back(move(like_bound_function_right_chn));

    auto and_conjunction = make_uniq<BoundConjunctionExpression>(ExpressionType::CONJUNCTION_AND);
    and_conjunction->children.push_back(move(not_unlike_bound_function_chn));
    and_conjunction->children.push_back(move(like_bound_function_chn));

    select_list_chn.push_back(move(and_conjunction));
    unique_ptr<PhysicalFilter> filter_chn_contains = make_uniq<PhysicalFilter>(filter_chn_types, move(select_list_chn), 0);
    filter_chn_contains->children.push_back(move(scan_char_name_chn));

    vector<JoinCondition> cond_char_name_chn;
    JoinCondition join_condition_char_name_chn;
    join_condition_char_name_chn.left = make_uniq<BoundReferenceExpression>("char_name_rowid", LogicalType::BIGINT, 0);
    join_condition_char_name_chn.right = make_uniq<BoundReferenceExpression>("person_role_id_rowid", LogicalType::BIGINT, 2);
    join_condition_char_name_chn.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_char_name_chn = make_uniq<RAIInfo>();
    rai_info_char_name_chn->rai = table_cast_info.GetStorage().info->rais[3].get();
    rai_info_char_name_chn->rai_type = RAIType::TARGET_EDGE;
    rai_info_char_name_chn->forward = true;
    rai_info_char_name_chn->vertex = &table_char_name;
    rai_info_char_name_chn->vertex_id = table_index_char_name_chn;
    rai_info_char_name_chn->passing_tables[0] = table_index_char_name_chn;
    rai_info_char_name_chn->left_cardinalities[0] = table_char_name.GetStorage().info->cardinality;
    // rai_info_char_name_chn->compact_list = &rai_info_char_name_chn->rai->alist->compact__list;

    join_condition_char_name_chn.rais.push_back(move(rai_info_char_name_chn));
    cond_char_name_chn.push_back(move(join_condition_char_name_chn));

    LogicalComparisonJoin join_char_name_chn_op(JoinType::INNER);
    vector<LogicalType> output_char_name_chn_types{LogicalType::BIGINT, LogicalType::VARCHAR,
                                                   LogicalType::BIGINT, LogicalType::VARCHAR};
    join_char_name_chn_op.types = output_char_name_chn_types;
    vector<idx_t> right_projection_map_char_name_chn{1, 3};
    vector<idx_t> merge_project_map_char_name_chn;
    vector<LogicalType> delim_types_char_name_chn;
    auto join_char_name_chn = make_uniq<PhysicalSIPJoin>(join_char_name_chn_op, move(filter_chn_contains), move(join_cast_info_),
                                                         move(cond_char_name_chn), JoinType::INNER, left_projection_map,
                                                         right_projection_map_char_name_chn, delim_types_char_name_chn,
                                                         0);


    vector<idx_t> name_n_ids{COLUMN_IDENTIFIER_ROW_ID};
    vector<LogicalType> get_name_n_types{LogicalType::BIGINT};
    string alias_name_n = "n";
    vector<LogicalType> table_types_name_n;
    vector<unique_ptr<Expression>> filter_name_n;
    unique_ptr<LogicalGet> get_op_name_n = move(
            getLogicalGet(*this, table_name, alias_name_n, table_index_name_n, table_types_name_n));
    unique_ptr<TableFilterSet> table_filters_name_n = NULL;
    unique_ptr<PhysicalTableScan> scan_name_n = make_uniq<PhysicalTableScan>(get_name_n_types, get_op_name_n->function,
                                                                             get_op_name_n->table_index,
                                                                             move(get_op_name_n->bind_data),
                                                                             table_types_name_n, name_n_ids,
                                                                             move(filter_name_n), vector<column_t>(),
                                                                             get_op_name_n->names,
                                                                             std::move(table_filters_name_n),
                                                                             get_op_name_n->estimated_cardinality,
                                                                             get_op_name_n->extra_info);


    vector<JoinCondition> cond_name;
    JoinCondition join_condition_name;
    join_condition_name.left = make_uniq<BoundReferenceExpression>("name_rowid", LogicalType::BIGINT, 0);
    join_condition_name.right = make_uniq<BoundReferenceExpression>("person_id_rowid", LogicalType::BIGINT, 2);
    join_condition_name.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_name = make_uniq<RAIInfo>();
    rai_info_name->rai = table_cast_info.GetStorage().info->rais[0].get();
    rai_info_name->rai_type = RAIType::TARGET_EDGE;
    rai_info_name->forward = true;
    rai_info_name->vertex = &table_name;
    rai_info_name->vertex_id = table_index_name_n;
    rai_info_name->passing_tables[0] = table_index_name_n;
    rai_info_name->left_cardinalities[0] = table_name.GetStorage().info->cardinality;
    // rai_info_name->compact_list = &rai_info_name->rai->alist->compact__list;

    join_condition_name.rais.push_back(move(rai_info_name));
    cond_name.push_back(move(join_condition_name));

    LogicalComparisonJoin join_name_op(JoinType::INNER);
    vector<LogicalType> output_name_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    join_name_op.types = output_name_types;
    vector<idx_t> right_projection_map_name{3};
    vector<idx_t> merge_project_map_name;
    vector<LogicalType> delim_types_name;
    auto join_name = make_uniq<PhysicalSIPJoin>(join_name_op, move(scan_name_n), move(join_char_name_chn), move(cond_name),
                                                           JoinType::INNER, left_projection_map,
                                                           right_projection_map_name,
                                                           delim_types_name, 0);


    vector<LogicalType> result_types{LogicalType::VARCHAR};
    vector<unique_ptr<Expression>> select_list;
    auto result_col0 = make_uniq<BoundReferenceExpression>("title", LogicalType::VARCHAR, 1);
    select_list.push_back(move(result_col0));
    auto projection = make_uniq<PhysicalProjection>(result_types, move(select_list), 0);
    projection->children.push_back(move(join_name));

    // aggregate
    string agg_name = "min";
    string agg_error = "";
    QueryErrorContext error_context(NULL, NULL);
    auto min_func = Catalog::GetEntry(context, CatalogType::SCALAR_FUNCTION_ENTRY, "", "",
                                      "min", OnEntryNotFound::RETURN_NULL, error_context);
    auto &min_func_set = min_func->Cast<AggregateFunctionCatalogEntry>();
    // bind the aggregate
    FunctionBinder function_binder(context);
    vector<LogicalType> types;
    types.push_back(LogicalType::VARCHAR);
    idx_t best_function_varchar = function_binder.BindFunction(agg_name, min_func_set.functions, types, agg_error);
    auto bound_function_min_varchar = min_func_set.functions.GetFunctionByOffset(best_function_varchar);

    auto first_children = make_uniq<BoundReferenceExpression>("title", LogicalType::VARCHAR, 0);
    vector<unique_ptr<Expression>> childrenlist1;
    childrenlist1.push_back(move(first_children));
    auto aggregate1 =
            function_binder.BindAggregateFunction(bound_function_min_varchar, std::move(childrenlist1), nullptr,
                                                  AggregateType::NON_DISTINCT);

    vector<unique_ptr<Expression>> aggregates;
    aggregates.push_back(move(aggregate1));

    vector<LogicalType> aggregate_types{LogicalType::VARCHAR};
    auto ungrouped_aggregate = make_uniq<PhysicalUngroupedAggregate>(aggregate_types, move(aggregates), 0);
    ungrouped_aggregate->children.push_back(move(projection));

    return ungrouped_aggregate;
}

unique_ptr<PhysicalOperator> ClientContext::GenerateJOB21aPlan(duckdb::ClientContext &context) {
    vector<idx_t> left_projection_map, right_projection_map;

    string table_vertex_info_type_it = "info_type";
    string table_vertex_title_t = "title";
    string table_vertex_link_type_lt = "link_type";
    string table_vertex_keyword_k = "keyword";
    string table_vertex_company_type_ct = "company_type";
    string table_vertex_company_name_cn = "company_name";
    string table_vertex_movie_info_ = "movie_info";
    string table_vertex_movie_link_ = "movie_link";
    string table_vertex_movie_keyword_ = "movie_keyword";
    string table_vertex_movie_companies_ = "movie_companies";

    idx_t table_index_info_type_it = 1;
    idx_t table_index_title_t = 2;
    idx_t table_index_link_type_lt = 3;
    idx_t table_index_keyword_k = 4;
    idx_t table_index_company_type_ct = 5;
    idx_t table_index_company_name_cn = 6;
    idx_t table_index_movie_info_ = 7;
    idx_t table_index_movie_link_ = 8;
    idx_t table_index_movie_keyword_ = 9;
    idx_t table_index_movie_companies_ = 11;

    auto table_or_view_info_type = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_info_type_it,
                                                     OnEntryNotFound::RETURN_NULL);
    auto &table_info_type = table_or_view_info_type->Cast<TableCatalogEntry>();
    auto table_or_view_title = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_title_t,
                                                 OnEntryNotFound::RETURN_NULL);
    auto &table_title = table_or_view_title->Cast<TableCatalogEntry>();
    auto table_or_view_link_type = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_link_type_lt,
                                                     OnEntryNotFound::RETURN_NULL);
    auto &table_link_type = table_or_view_link_type->Cast<TableCatalogEntry>();
    auto table_or_view_keyword = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_keyword_k,
                                                   OnEntryNotFound::RETURN_NULL);
    auto &table_keyword = table_or_view_keyword->Cast<TableCatalogEntry>();
    auto table_or_view_company_type = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                        table_vertex_company_type_ct, OnEntryNotFound::RETURN_NULL);
    auto &table_company_type = table_or_view_company_type->Cast<TableCatalogEntry>();
    auto table_or_view_company_name = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                        table_vertex_company_name_cn, OnEntryNotFound::RETURN_NULL);
    auto &table_company_name = table_or_view_company_name->Cast<TableCatalogEntry>();
    auto table_or_view_movie_info = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_movie_info_,
                                                      OnEntryNotFound::RETURN_NULL);
    auto &table_movie_info = table_or_view_movie_info->Cast<TableCatalogEntry>();
    auto table_or_view_movie_link = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_movie_link_,
                                                      OnEntryNotFound::RETURN_NULL);
    auto &table_movie_link = table_or_view_movie_link->Cast<TableCatalogEntry>();
    auto table_or_view_movie_keyword = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                         table_vertex_movie_keyword_, OnEntryNotFound::RETURN_NULL);
    auto &table_movie_keyword = table_or_view_movie_keyword->Cast<TableCatalogEntry>();
    auto table_or_view_movie_companies = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                           table_vertex_movie_companies_, OnEntryNotFound::RETURN_NULL);
    auto &table_movie_companies = table_or_view_movie_companies->Cast<TableCatalogEntry>();

    vector<idx_t> link_type_lt_ids{COLUMN_IDENTIFIER_ROW_ID, 1};
    vector<LogicalType> get_link_type_lt_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_link_type_lt = "lt";
    vector<LogicalType> table_types_link_type_lt;
    vector<unique_ptr<Expression>> filter_link_type_lt;
    unique_ptr<LogicalGet> get_op_link_type_lt = move(
            getLogicalGet(*this, table_link_type, alias_link_type_lt, table_index_link_type_lt,
                          table_types_link_type_lt));
    unique_ptr<TableFilterSet> table_filters_link_type_lt = NULL;
    unique_ptr<PhysicalTableScan> scan_link_type_lt = make_uniq<PhysicalTableScan>(get_link_type_lt_types,
                                                                                   get_op_link_type_lt->function,
                                                                                   get_op_link_type_lt->table_index,
                                                                                   move(get_op_link_type_lt->bind_data),
                                                                                   table_types_link_type_lt,
                                                                                   link_type_lt_ids,
                                                                                   move(filter_link_type_lt),
                                                                                   vector<column_t>(),
                                                                                   get_op_link_type_lt->names,
                                                                                   std::move(
                                                                                           table_filters_link_type_lt),
                                                                                   get_op_link_type_lt->estimated_cardinality,
                                                                                   get_op_link_type_lt->extra_info);

    vector<LogicalType> filter_lt_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    vector<unique_ptr<Expression>> select_lt_list;
    auto lt_expression_left = make_uniq<BoundReferenceExpression>("link", LogicalType::VARCHAR, 1);
    auto lt_expression_value = make_uniq<BoundConstantExpression>(Value("follow"));
    vector<unique_ptr<Expression>> lt_arguments;
    lt_arguments.push_back(move(lt_expression_left));
    lt_arguments.push_back(move(lt_expression_value));

    ScalarFunction bound_function_contains = ContainsFun::GetFunction();
    unique_ptr<FunctionData> bind_data_contains = NULL;

    auto lt_bound_function = make_uniq<BoundFunctionExpression>(LogicalType::BOOLEAN,
                                                                      bound_function_contains,
                                                                      move(lt_arguments),
                                                                      move(bind_data_contains), false);

    select_lt_list.push_back(move(lt_bound_function));
    unique_ptr<PhysicalFilter> filter_lt = make_uniq<PhysicalFilter>(filter_lt_types, move(select_lt_list), 0);
    filter_lt->children.push_back(move(scan_link_type_lt));

    vector<idx_t> title_t_ids{COLUMN_IDENTIFIER_ROW_ID, 1, 4};
    vector<LogicalType> get_title_t_types{LogicalType::BIGINT, LogicalType::VARCHAR,
                                          LogicalType::BIGINT};
    string alias_title_t = "t";
    vector<LogicalType> table_types_title_t;
    vector<unique_ptr<Expression>> filter_title_t;
    unique_ptr<LogicalGet> get_op_title_t = move(
            getLogicalGet(*this, table_title, alias_title_t, table_index_title_t, table_types_title_t));
    unique_ptr<TableFilterSet> table_filters_title_t = make_uniq<TableFilterSet>();
    unique_ptr<ConjunctionAndFilter> and_filter_t = duckdb::make_uniq<ConjunctionAndFilter>();
    unique_ptr<ConstantFilter> constant_filter_t_start = duckdb::make_uniq<ConstantFilter>(
            ExpressionType::COMPARE_GREATERTHANOREQUALTO, Value::BIGINT(1950));
    unique_ptr<ConstantFilter> constant_filter_t_end = duckdb::make_uniq<ConstantFilter>(
            ExpressionType::COMPARE_LESSTHANOREQUALTO, Value::BIGINT(2000));
    and_filter_t->child_filters.push_back(move(constant_filter_t_start));
    and_filter_t->child_filters.push_back(move(constant_filter_t_end));
    table_filters_title_t->filters[2] = move(and_filter_t);
    unique_ptr<PhysicalTableScan> scan_title_t = make_uniq<PhysicalTableScan>(get_title_t_types,
                                                                              get_op_title_t->function,
                                                                              get_op_title_t->table_index,
                                                                              move(get_op_title_t->bind_data),
                                                                              table_types_title_t, title_t_ids,
                                                                              move(filter_title_t), vector<column_t>(),
                                                                              get_op_title_t->names,
                                                                              std::move(table_filters_title_t),
                                                                              get_op_title_t->estimated_cardinality,
                                                                              get_op_title_t->extra_info);

    vector<JoinCondition> cond_title_t;
    JoinCondition join_condition_title_t;
    join_condition_title_t.left = make_uniq<BoundReferenceExpression>("title_rowid", LogicalType::BIGINT, 0);
    join_condition_title_t.right = make_uniq<BoundReferenceExpression>("link_type_rowid", LogicalType::BIGINT, 0);
    join_condition_title_t.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_title_t = make_uniq<RAIInfo>();
    rai_info_title_t->rai = table_movie_link.GetStorage().info->rais[0].get();
    rai_info_title_t->rai_type = RAIType::TARGET_EDGE;
    rai_info_title_t->forward = true;
    rai_info_title_t->vertex = &table_title;
    rai_info_title_t->vertex_id = table_index_title_t;
    rai_info_title_t->passing_tables[0] = table_index_title_t;
    rai_info_title_t->left_cardinalities[0] = table_title.GetStorage().info->cardinality;
    // rai_info_title_t->compact_list = &rai_info_title_t->rai->alist->compact__list;

    join_condition_title_t.rais.push_back(move(rai_info_title_t));
    cond_title_t.push_back(move(join_condition_title_t));

    LogicalComparisonJoin join_title_t_op(JoinType::INNER);
    vector<LogicalType> output_title_t_types{LogicalType::BIGINT, LogicalType::VARCHAR,
                                             LogicalType::BIGINT, LogicalType::VARCHAR};
    join_title_t_op.types = output_title_t_types;
    vector<idx_t> right_projection_map_title_t{1};
    vector<idx_t> merge_project_map_title_t;
    vector<LogicalType> delim_types_title_t;
    auto join_title_t = make_uniq<PhysicalMergeSIPJoin>(join_title_t_op, move(scan_title_t), move(filter_lt), move(cond_title_t), JoinType::INNER,
                                                        left_projection_map, right_projection_map_title_t,
                                                        merge_project_map_title_t, delim_types_title_t, 0);


    vector<idx_t> movie_companies_ids{4, 5, 6, 7};
    vector<LogicalType> get_movie_companies_types{LogicalType::VARCHAR, LogicalType::BIGINT,
                                                  LogicalType::BIGINT, LogicalType::BIGINT};
    string alias_movie_companies = "ct";
    vector<LogicalType> table_types_movie_companies;
    vector<unique_ptr<Expression>> filter_movie_companies;
    unique_ptr<LogicalGet> get_op_movie_companies = move(
            getLogicalGet(*this, table_movie_companies, alias_movie_companies, table_index_movie_companies_,
                          table_types_movie_companies));
    unique_ptr<TableFilterSet> table_filters_movie_companies = NULL;
    unique_ptr<PhysicalTableScan> scan_movie_companies = make_uniq<PhysicalTableScan>(get_movie_companies_types,
                                                                                      get_op_movie_companies->function,
                                                                                      get_op_movie_companies->table_index,
                                                                                      move(get_op_movie_companies->bind_data),
                                                                                      table_types_movie_companies,
                                                                                      movie_companies_ids,
                                                                                      move(filter_movie_companies),
                                                                                      vector<column_t>(),
                                                                                      get_op_movie_companies->names,
                                                                                      std::move(
                                                                                              table_filters_movie_companies),
                                                                                      get_op_movie_companies->estimated_cardinality,
                                                                                      get_op_movie_companies->extra_info);

    vector<LogicalType> filter_note_types{LogicalType::VARCHAR, LogicalType::BIGINT,
                                          LogicalType::BIGINT, LogicalType::BIGINT};
    vector<unique_ptr<Expression>> select_list_note;

    auto note_null_bound_function = make_uniq<BoundOperatorExpression>(ExpressionType::OPERATOR_IS_NULL, LogicalType::BOOLEAN);
    auto note_null = make_uniq<BoundReferenceExpression>("note", LogicalType::VARCHAR, 0);
    note_null_bound_function->children.push_back(move(note_null));

    select_list_note.push_back(move(note_null_bound_function));
    unique_ptr<PhysicalFilter> filter_note_contains = make_uniq<PhysicalFilter>(filter_note_types, move(select_list_note), 0);
    filter_note_contains->children.push_back(move(scan_movie_companies));

    vector<JoinCondition> cond_movie_companies_;
    JoinCondition join_condition_movie_companies_;
    join_condition_movie_companies_.left = make_uniq<BoundReferenceExpression>("movie_id_rowid", LogicalType::BIGINT, 2);
    join_condition_movie_companies_.right = make_uniq<BoundReferenceExpression>("title_rowid", LogicalType::BIGINT, 0);
    join_condition_movie_companies_.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_movie_companies_ = make_uniq<RAIInfo>();
    rai_info_movie_companies_->rai = table_movie_companies.GetStorage().info->rais[0].get();
    rai_info_movie_companies_->rai_type = RAIType::EDGE_TARGET;
    rai_info_movie_companies_->forward = false;
    rai_info_movie_companies_->vertex = &table_title;
    rai_info_movie_companies_->vertex_id = table_index_title_t;
    rai_info_movie_companies_->passing_tables[0] = table_index_movie_companies_;
    rai_info_movie_companies_->left_cardinalities[0] = table_movie_companies.GetStorage().info->cardinality;
    rai_info_movie_companies_->compact_list = &rai_info_movie_companies_->rai->alist->compact_backward_list;

    join_condition_movie_companies_.rais.push_back(move(rai_info_movie_companies_));
    cond_movie_companies_.push_back(move(join_condition_movie_companies_));

    LogicalComparisonJoin join_movie_companies__op(JoinType::INNER);
    vector<LogicalType> output_movie_companies__types{LogicalType::VARCHAR, LogicalType::BIGINT,
                                                      LogicalType::BIGINT, LogicalType::BIGINT,
                                                      LogicalType::VARCHAR, LogicalType::VARCHAR};
    join_movie_companies__op.types = output_movie_companies__types;
    vector<idx_t> right_projection_map_movie_companies_{1, 3};
    vector<idx_t> merge_project_map_movie_companies_;
    vector<LogicalType> delim_types_movie_companies_;
    auto join_movie_companies_ = make_uniq<PhysicalSIPJoin>(join_movie_companies__op, move(filter_note_contains), move(join_title_t),
                                                                 move(cond_movie_companies_), JoinType::INNER,
                                                                 left_projection_map,
                                                                 right_projection_map_movie_companies_,
                                                                 delim_types_movie_companies_, 0);


    string p_country_code_n = "[pl]";
    Value p_code = Value(p_country_code_n);
    vector<idx_t> company_name_cn_ids{COLUMN_IDENTIFIER_ROW_ID, 1, 2};
    vector<LogicalType> get_company_name_cn_types{LogicalType::BIGINT, LogicalType::VARCHAR,
                                                  LogicalType::VARCHAR};
    string alias_company_name_cn = "cn";
    vector<LogicalType> table_types_company_name_cn;
    vector<unique_ptr<Expression>> filter_company_name_cn;
    unique_ptr<LogicalGet> get_op_company_name_cn = move(
            getLogicalGet(*this, table_company_name, alias_company_name_cn, table_index_company_name_cn,
                          table_types_company_name_cn));
    unique_ptr<TableFilterSet> table_filters_company_name_cn = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_cn = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_NOTEQUAL, p_code);
    table_filters_company_name_cn->filters[2] = move(constant_filter_cn);
    unique_ptr<PhysicalTableScan> scan_company_name_cn = make_uniq<PhysicalTableScan>(get_company_name_cn_types,
                                                                                      get_op_company_name_cn->function,
                                                                                      get_op_company_name_cn->table_index,
                                                                                      move(get_op_company_name_cn->bind_data),
                                                                                      table_types_company_name_cn,
                                                                                      company_name_cn_ids,
                                                                                      move(filter_company_name_cn),
                                                                                      vector<column_t>(),
                                                                                      get_op_company_name_cn->names,
                                                                                      std::move(
                                                                                              table_filters_company_name_cn),
                                                                                      get_op_company_name_cn->estimated_cardinality,
                                                                                      get_op_company_name_cn->extra_info);

    vector<LogicalType> filter_name_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::VARCHAR};
    vector<unique_ptr<Expression>> select_list_name;
    auto name_like_expression_left = make_uniq<BoundReferenceExpression>("name", LogicalType::VARCHAR, 1);
    auto name_like_expression_value = make_uniq<BoundConstantExpression>(Value("Film"));
    vector<unique_ptr<Expression>> name_like_arguments;
    name_like_arguments.push_back(move(name_like_expression_left));
    name_like_arguments.push_back(move(name_like_expression_value));

    unique_ptr<FunctionData> name_bind_data_contains = NULL;

    auto name_like_bound_function = make_uniq<BoundFunctionExpression>(LogicalType::BOOLEAN,
                                                                         bound_function_contains,
                                                                         move(name_like_arguments),
                                                                         move(name_bind_data_contains), false);

    unique_ptr<FunctionData> name_bind_data_contains2 = NULL;
    auto name_like_expression_left_exp = make_uniq<BoundReferenceExpression>("name", LogicalType::VARCHAR, 1);
    auto name_like_expression_left_value = make_uniq<BoundConstantExpression>(Value("Warner"));
    vector<unique_ptr<Expression>> name_like_arguments_left;
    name_like_arguments_left.push_back(move(name_like_expression_left_exp));
    name_like_arguments_left.push_back(move(name_like_expression_left_value));
    auto name_like_bound_function_left = make_uniq<BoundFunctionExpression>(LogicalType::BOOLEAN,
                                                                            bound_function_contains,
                                                                            move(name_like_arguments_left),
                                                                            move(name_bind_data_contains2), false);

    auto name_or_conjunction = make_uniq<BoundConjunctionExpression>(ExpressionType::CONJUNCTION_OR);
    name_or_conjunction->children.push_back(move(name_like_bound_function));
    name_or_conjunction->children.push_back(move(name_like_bound_function_left));

    select_list_name.push_back(move(name_or_conjunction));
    unique_ptr<PhysicalFilter> filter_name_contains = make_uniq<PhysicalFilter>(filter_name_types, move(select_list_name), 0);
    filter_name_contains->children.push_back(move(scan_company_name_cn));

    vector<JoinCondition> cond_company_name_cn;
    JoinCondition join_condition_company_name_cn;
    join_condition_company_name_cn.left = make_uniq<BoundReferenceExpression>("company_name_rowid", LogicalType::BIGINT, 0);
    join_condition_company_name_cn.right = make_uniq<BoundReferenceExpression>("company_id_rowid", LogicalType::BIGINT, 1);
    join_condition_company_name_cn.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_company_name_cn = make_uniq<RAIInfo>();
    rai_info_company_name_cn->rai = table_movie_companies.GetStorage().info->rais[0].get();
    rai_info_company_name_cn->rai_type = RAIType::SOURCE_EDGE;
    rai_info_company_name_cn->forward = false;
    rai_info_company_name_cn->vertex = &table_company_name;
    rai_info_company_name_cn->vertex_id = table_index_company_name_cn;
    rai_info_company_name_cn->passing_tables[0] = table_index_company_name_cn;
    rai_info_company_name_cn->left_cardinalities[0] = table_company_name.GetStorage().info->cardinality;
    // rai_info_company_name_cn->compact_list = &rai_info_company_name_cn->rai->alist->compact__list;

    join_condition_company_name_cn.rais.push_back(move(rai_info_company_name_cn));
    cond_company_name_cn.push_back(move(join_condition_company_name_cn));

    LogicalComparisonJoin join_company_name_cn_op(JoinType::INNER);
    vector<LogicalType> output_company_name_cn_types{LogicalType::BIGINT, LogicalType::VARCHAR,
                                                     LogicalType::VARCHAR, LogicalType::BIGINT,
                                                     LogicalType::BIGINT, LogicalType::VARCHAR,
                                                     LogicalType::VARCHAR};
    join_company_name_cn_op.types = output_company_name_cn_types;
    vector<idx_t> right_projection_map_company_name_cn{2, 3, 4, 5};
    vector<idx_t> merge_project_map_company_name_cn;
    vector<LogicalType> delim_types_company_name_cn;
    auto join_company_name_cn = make_uniq<PhysicalSIPJoin>(join_company_name_cn_op, move(filter_name_contains), move(join_movie_companies_),
                                                           move(cond_company_name_cn), JoinType::INNER,
                                                           left_projection_map, right_projection_map_company_name_cn,
                                                           delim_types_company_name_cn, 0);

    string p_kind_n = "production companies";
    Value p_kind = Value(p_kind_n);
    vector<idx_t> company_type_ct_ids{COLUMN_IDENTIFIER_ROW_ID, 1};
    vector<LogicalType> get_company_type_ct_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_company_type_ct = "ct";
    vector<LogicalType> table_types_company_type_ct;
    vector<unique_ptr<Expression>> filter_company_type_ct;
    unique_ptr<LogicalGet> get_op_company_type_ct = move(
            getLogicalGet(*this, table_company_type, alias_company_type_ct, table_index_company_type_ct,
                          table_types_company_type_ct));
    unique_ptr<TableFilterSet> table_filters_company_type_ct = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_ct = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL, p_kind);
    table_filters_company_type_ct->filters[1] = move(constant_filter_ct);
    unique_ptr<PhysicalTableScan> scan_company_type_ct = make_uniq<PhysicalTableScan>(get_company_type_ct_types,
                                                                                      get_op_company_type_ct->function,
                                                                                      get_op_company_type_ct->table_index,
                                                                                      move(get_op_company_type_ct->bind_data),
                                                                                      table_types_company_type_ct,
                                                                                      company_type_ct_ids,
                                                                                      move(filter_company_type_ct),
                                                                                      vector<column_t>(),
                                                                                      get_op_company_type_ct->names,
                                                                                      std::move(
                                                                                              table_filters_company_type_ct),
                                                                                      get_op_company_type_ct->estimated_cardinality,
                                                                                      get_op_company_type_ct->extra_info);


    vector<JoinCondition> cond_company_type_ct;
    JoinCondition join_condition_company_type_ct;
    join_condition_company_type_ct.left = make_uniq<BoundReferenceExpression>("company_type_rowid", LogicalType::BIGINT, 0);
    join_condition_company_type_ct.right = make_uniq<BoundReferenceExpression>("company_type_id_rowid", LogicalType::BIGINT, 4);
    join_condition_company_type_ct.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_company_type_ct = make_uniq<RAIInfo>();
    rai_info_company_type_ct->rai = table_movie_companies.GetStorage().info->rais[1].get();
    rai_info_company_type_ct->rai_type = RAIType::SOURCE_EDGE;
    rai_info_company_type_ct->forward = false;
    rai_info_company_type_ct->vertex = &table_company_type;
    rai_info_company_type_ct->vertex_id = table_index_company_type_ct;
    rai_info_company_type_ct->passing_tables[0] = table_index_company_type_ct;
    rai_info_company_type_ct->left_cardinalities[0] = table_company_type.GetStorage().info->cardinality;
    // rai_info_company_type_ct->compact_list = &rai_info_company_type_ct->rai->alist->compact__list;

    join_condition_company_type_ct.rais.push_back(move(rai_info_company_type_ct));
    cond_company_type_ct.push_back(move(join_condition_company_type_ct));

    LogicalComparisonJoin join_company_type_ct_op(JoinType::INNER);
    vector<LogicalType> output_company_type_ct_types{LogicalType::BIGINT, LogicalType::VARCHAR,
                                                     LogicalType::BIGINT, LogicalType::VARCHAR,
                                                     LogicalType::VARCHAR, LogicalType::VARCHAR};
    join_company_type_ct_op.types = output_company_type_ct_types;
    vector<idx_t> right_projection_map_company_type_ct{3, 1, 5, 6};
    vector<idx_t> merge_project_map_company_type_ct;
    vector<LogicalType> delim_types_company_type_ct;
    auto join_company_type_ct = make_uniq<PhysicalSIPJoin>(join_company_type_ct_op, move(scan_company_type_ct), move(join_company_name_cn),
                                                           move(cond_company_type_ct), JoinType::INNER,
                                                           left_projection_map, right_projection_map_company_type_ct,
                                                           delim_types_company_type_ct, 0);


    string p_keyword_n = "sequel";
    Value p_keyword = Value(p_keyword_n);
    vector<idx_t> keyword_k_ids{COLUMN_IDENTIFIER_ROW_ID, 1};
    vector<LogicalType> get_keyword_k_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_keyword_k = "k";
    vector<LogicalType> table_types_keyword_k;
    vector<unique_ptr<Expression>> filter_keyword_k;
    unique_ptr<LogicalGet> get_op_keyword_k = move(
            getLogicalGet(*this, table_keyword, alias_keyword_k, table_index_keyword_k, table_types_keyword_k));
    unique_ptr<TableFilterSet> table_filters_keyword_k = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_k = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL, p_keyword);
    table_filters_keyword_k->filters[1] = move(constant_filter_k);
    unique_ptr<PhysicalTableScan> scan_keyword_k = make_uniq<PhysicalTableScan>(get_keyword_k_types,
                                                                                get_op_keyword_k->function,
                                                                                get_op_keyword_k->table_index,
                                                                                move(get_op_keyword_k->bind_data),
                                                                                table_types_keyword_k, keyword_k_ids,
                                                                                move(filter_keyword_k),
                                                                                vector<column_t>(),
                                                                                get_op_keyword_k->names,
                                                                                std::move(table_filters_keyword_k),
                                                                                get_op_keyword_k->estimated_cardinality,
                                                                                get_op_keyword_k->extra_info);


    vector<JoinCondition> cond_keyword_k;
    JoinCondition join_condition_keyword_k;
    join_condition_keyword_k.left = make_uniq<BoundReferenceExpression>("keyword_rowid", LogicalType::BIGINT, 0);
    join_condition_keyword_k.right = make_uniq<BoundReferenceExpression>("movie_id_rowid", LogicalType::BIGINT, 2);
    join_condition_keyword_k.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_keyword_k = make_uniq<RAIInfo>();
    rai_info_keyword_k->rai = table_movie_keyword.GetStorage().info->rais[0].get();
    rai_info_keyword_k->rai_type = RAIType::SOURCE_EDGE;
    rai_info_keyword_k->forward = false;
    rai_info_keyword_k->vertex = &table_keyword;
    rai_info_keyword_k->vertex_id = table_index_keyword_k;
    rai_info_keyword_k->passing_tables[0] = table_index_keyword_k;
    rai_info_keyword_k->left_cardinalities[0] = table_keyword.GetStorage().info->cardinality;
    // rai_info_keyword_k->compact_list = &rai_info_keyword_k->rai->alist->compact__list;

    join_condition_keyword_k.rais.push_back(move(rai_info_keyword_k));
    cond_keyword_k.push_back(move(join_condition_keyword_k));

    LogicalComparisonJoin join_keyword_k_op(JoinType::INNER);
    vector<LogicalType> output_keyword_k_types{LogicalType::BIGINT, LogicalType::VARCHAR,
                                               LogicalType::BIGINT, LogicalType::VARCHAR,
                                               LogicalType::VARCHAR, LogicalType::VARCHAR};
    join_keyword_k_op.types = output_keyword_k_types;
    vector<idx_t> right_projection_map_keyword_k{2, 3, 4, 5};
    vector<idx_t> merge_project_map_keyword_k;
    vector<LogicalType> delim_types_keyword_k;
    auto join_keyword_k = make_uniq<PhysicalMergeSIPJoin>(join_keyword_k_op, move(scan_keyword_k), move(join_company_type_ct), move(cond_keyword_k),
                                                     JoinType::INNER, left_projection_map,
                                                     right_projection_map_keyword_k,
                                                     merge_project_map_keyword_k,
                                                     delim_types_keyword_k, 0);

    vector<idx_t> movie_info_ids{6, 3};
    vector<LogicalType> get_movie_info_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_movie_info = "i";
    vector<LogicalType> table_types_movie_info;
    vector<unique_ptr<Expression>> filter_movie_info;
    unique_ptr<LogicalGet> get_op_movie_info = move(
            getLogicalGet(*this, table_movie_info, alias_movie_info, table_index_movie_info_, table_types_movie_info));
    unique_ptr<TableFilterSet> table_filters_movie_info = NULL;
    unique_ptr<PhysicalTableScan> scan_movie_info = make_uniq<PhysicalTableScan>(get_movie_info_types,
                                                                                 get_op_movie_info->function,
                                                                                 get_op_movie_info->table_index,
                                                                                 move(get_op_movie_info->bind_data),
                                                                                 table_types_movie_info,
                                                                                 movie_info_ids,
                                                                                 move(filter_movie_info),
                                                                                 vector<column_t>(),
                                                                                 get_op_movie_info->names,
                                                                                 std::move(table_filters_movie_info),
                                                                                 get_op_movie_info->estimated_cardinality,
                                                                                 get_op_movie_info->extra_info);

    auto &allocator = Allocator::Get(context);
    vector<LogicalType> join_in_types {LogicalType::VARCHAR};
    auto collection =
            make_uniq<ColumnDataCollection>(context, join_in_types, ColumnDataAllocatorType::IN_MEMORY_ALLOCATOR);

    vector<LogicalType> chunk_in_types {LogicalType::VARCHAR};
    DataChunk chunk;
    chunk.SetCardinality(8);
    chunk.Initialize(allocator, chunk_in_types);
    chunk.SetValue(0, 0, Value("Sweden"));
    chunk.SetValue(0, 1, Value("Norway"));
    chunk.SetValue(0, 2, Value("Germany"));
    chunk.SetValue(0, 3, Value("Denmark"));
    chunk.SetValue(0, 4, Value("Swedish"));
    chunk.SetValue(0, 5, Value("Denish"));
    chunk.SetValue(0, 6, Value("Norwegian"));
    chunk.SetValue(0, 7, Value("German"));
    collection->Append(chunk);

    // create a chunk scan to output the result
    vector<LogicalType> ouput_in_types {LogicalType::VARCHAR};
    auto chunk_scan = make_uniq<PhysicalColumnDataScan>(ouput_in_types, PhysicalOperatorType::COLUMN_DATA_SCAN,
                                                        8, std::move(collection));

    vector<JoinCondition> cond_hash_join_;
    JoinCondition join_condition_hash_join_;
    join_condition_hash_join_.left = make_uniq<BoundReferenceExpression>("info", LogicalType::VARCHAR, 1);
    join_condition_hash_join_.right = make_uniq<BoundReferenceExpression>("", LogicalType::VARCHAR, 0);
    join_condition_hash_join_.comparison = ExpressionType::COMPARE_EQUAL;
    cond_hash_join_.push_back(move(join_condition_hash_join_));

    LogicalComparisonJoin join_hash_join_op(JoinType::MARK);
    vector<LogicalType> output_hash_join_types{LogicalType::BIGINT, LogicalType::VARCHAR,
                                               LogicalType::BOOLEAN};
    join_hash_join_op.types = output_hash_join_types;
    vector<idx_t> right_projection_map_hash_join_;
    vector<LogicalType> delim_types_hash_join_;
    PerfectHashJoinStats joinstate;
    auto join_hash_join_ = make_uniq<PhysicalHashJoin>(join_hash_join_op, move(scan_movie_info), move(chunk_scan), move(cond_hash_join_),
                                                       JoinType::MARK, left_projection_map,
                                                       right_projection_map_hash_join_,
                                                       delim_types_hash_join_, 0, joinstate);

    vector<LogicalType> filter_in_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::BOOLEAN};
    vector<unique_ptr<Expression>> select_list_in;
    auto in_exp = make_uniq<BoundReferenceExpression>("IN (...)", LogicalType::BOOLEAN, 2);
    select_list_in.push_back(move(in_exp));
    unique_ptr<PhysicalFilter> filter_in = make_uniq<PhysicalFilter>(filter_in_types, move(select_list_in), 0);
    filter_in->children.push_back(move(join_hash_join_));

    vector<JoinCondition> cond_movie_info_;
    JoinCondition join_condition_movie_info_;
    join_condition_movie_info_.left = make_uniq<BoundReferenceExpression>("movie_id_rowid", LogicalType::BIGINT, 0);
    join_condition_movie_info_.right = make_uniq<BoundReferenceExpression>("movie_id_rowid", LogicalType::BIGINT, 2);
    join_condition_movie_info_.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_movie_info_ = make_uniq<RAIInfo>();
    rai_info_movie_info_->rai = table_movie_info.GetStorage().info->rais[0].get();
    rai_info_movie_info_->rai_type = RAIType::EDGE_TARGET;
    rai_info_movie_info_->forward = false;
    rai_info_movie_info_->vertex = &table_title;
    rai_info_movie_info_->vertex_id = table_index_title_t;
    rai_info_movie_info_->passing_tables[0] = table_index_movie_info_;
    rai_info_movie_info_->left_cardinalities[0] = table_movie_info.GetStorage().info->cardinality;
    rai_info_movie_info_->compact_list = &rai_info_movie_info_->rai->alist->compact_backward_list;

    join_condition_movie_info_.rais.push_back(move(rai_info_movie_info_));
    cond_movie_info_.push_back(move(join_condition_movie_info_));

    LogicalComparisonJoin join_movie_info__op(JoinType::INNER);
    vector<LogicalType> output_movie_info__types{LogicalType::BIGINT, LogicalType::VARCHAR,
                                                 LogicalType::BOOLEAN, LogicalType::VARCHAR,
                                                 LogicalType::VARCHAR, LogicalType::VARCHAR};
    join_movie_info__op.types = output_movie_info__types;
    vector<idx_t> right_projection_map_movie_info_{3, 4, 5};
    vector<idx_t> merge_project_map_movie_info_;
    vector<LogicalType> delim_types_movie_info_;
    auto join_movie_info_ = make_uniq<PhysicalSIPJoin>(join_movie_info__op, move(filter_in), move(join_keyword_k), move(cond_movie_info_),
                                                            JoinType::INNER, left_projection_map,
                                                            right_projection_map_movie_info_,
                                                            delim_types_movie_info_, 0);

    vector<LogicalType> result_types{LogicalType::VARCHAR, LogicalType::VARCHAR, LogicalType::VARCHAR};
    vector<unique_ptr<Expression>> select_list;
    auto result_col0 = make_uniq<BoundReferenceExpression>("name", LogicalType::VARCHAR, 3);
    auto result_col1 = make_uniq<BoundReferenceExpression>("link", LogicalType::VARCHAR, 5);
    auto result_col2 = make_uniq<BoundReferenceExpression>("title", LogicalType::VARCHAR, 4);
    select_list.push_back(move(result_col0));
    select_list.push_back(move(result_col1));
    select_list.push_back(move(result_col2));
    auto projection = make_uniq<PhysicalProjection>(result_types, move(select_list), 0);
    projection->children.push_back(move(join_movie_info_));

    // aggregate
    string agg_name = "min";
    string agg_error = "";
    QueryErrorContext error_context(NULL, NULL);
    auto min_func = Catalog::GetEntry(context, CatalogType::SCALAR_FUNCTION_ENTRY, "", "",
                                      "min", OnEntryNotFound::RETURN_NULL, error_context);
    auto &min_func_set = min_func->Cast<AggregateFunctionCatalogEntry>();
    // bind the aggregate
    FunctionBinder function_binder(context);
    vector<LogicalType> types;
    types.push_back(LogicalType::VARCHAR);
    idx_t best_function_varchar = function_binder.BindFunction(agg_name, min_func_set.functions, types, agg_error);
    auto bound_function_min_varchar = min_func_set.functions.GetFunctionByOffset(best_function_varchar);

    auto first_children = make_uniq<BoundReferenceExpression>("name", LogicalType::VARCHAR, 0);
    vector<unique_ptr<Expression>> childrenlist1;
    childrenlist1.push_back(move(first_children));
    auto aggregate1 =
            function_binder.BindAggregateFunction(bound_function_min_varchar, std::move(childrenlist1), nullptr,
                                                  AggregateType::NON_DISTINCT);

    auto second_children = make_uniq<BoundReferenceExpression>("link", LogicalType::VARCHAR, 1);
    vector<unique_ptr<Expression>> childrenlist2;
    childrenlist2.push_back(move(second_children));
    auto aggregate2 =
            function_binder.BindAggregateFunction(bound_function_min_varchar, std::move(childrenlist2), nullptr,
                                                  AggregateType::NON_DISTINCT);

    auto third_children = make_uniq<BoundReferenceExpression>("title", LogicalType::VARCHAR, 2);
    vector<unique_ptr<Expression>> childrenlist3;
    childrenlist3.push_back(move(third_children));
    auto aggregate3 =
            function_binder.BindAggregateFunction(bound_function_min_varchar, std::move(childrenlist3), nullptr,
                                                  AggregateType::NON_DISTINCT);

    vector<unique_ptr<Expression>> aggregates;
    aggregates.push_back(move(aggregate1));
    aggregates.push_back(move(aggregate2));
    aggregates.push_back(move(aggregate3));

    vector<LogicalType> aggregate_types{LogicalType::VARCHAR, LogicalType::VARCHAR, LogicalType::VARCHAR};
    auto ungrouped_aggregate = make_uniq<PhysicalUngroupedAggregate>(aggregate_types, move(aggregates), 0);
    ungrouped_aggregate->children.push_back(move(projection));

    return ungrouped_aggregate;
}

unique_ptr<PhysicalOperator> ClientContext::GenerateJOB22aPlan(duckdb::ClientContext &context) {
    vector<idx_t> left_projection_map, right_projection_map;

    string table_vertex_info_type_it2 = "info_type";
    string table_vertex_title_t = "title";
    string table_vertex_keyword_k = "keyword";
    string table_vertex_info_type_it1 = "info_type";
    string table_vertex_kind_type_kt = "kind_type";
    string table_vertex_company_type_ct = "company_type";
    string table_vertex_company_name_cn = "company_name";
    string table_vertex_movie_info_idx_ = "movie_info_idx";
    string table_vertex_movie_keyword_ = "movie_keyword";
    string table_vertex_movie_info_ = "movie_info";
    string table_vertex_movie_companies_ = "movie_companies";

    idx_t table_index_info_type_it2 = 1;
    idx_t table_index_title_t = 2;
    idx_t table_index_keyword_k = 3;
    idx_t table_index_info_type_it1 = 4;
    idx_t table_index_kind_type_kt = 5;
    idx_t table_index_company_type_ct = 6;
    idx_t table_index_company_name_cn = 7;
    idx_t table_index_movie_info_idx_ = 8;
    idx_t table_index_movie_keyword_ = 9;
    idx_t table_index_movie_info_ = 10;
    idx_t table_index_movie_companies_ = 13;

    auto table_or_view_info_type = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                     table_vertex_info_type_it2, OnEntryNotFound::RETURN_NULL);
    auto &table_info_type = table_or_view_info_type->Cast<TableCatalogEntry>();
    auto table_or_view_title = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_title_t,
                                                 OnEntryNotFound::RETURN_NULL);
    auto &table_title = table_or_view_title->Cast<TableCatalogEntry>();
    auto table_or_view_keyword = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_keyword_k,
                                                   OnEntryNotFound::RETURN_NULL);
    auto &table_keyword = table_or_view_keyword->Cast<TableCatalogEntry>();
    auto table_or_view_kind_type = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_kind_type_kt,
                                                     OnEntryNotFound::RETURN_NULL);
    auto &table_kind_type = table_or_view_kind_type->Cast<TableCatalogEntry>();
    auto table_or_view_company_type = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                        table_vertex_company_type_ct, OnEntryNotFound::RETURN_NULL);
    auto &table_company_type = table_or_view_company_type->Cast<TableCatalogEntry>();
    auto table_or_view_company_name = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                        table_vertex_company_name_cn, OnEntryNotFound::RETURN_NULL);
    auto &table_company_name = table_or_view_company_name->Cast<TableCatalogEntry>();
    auto table_or_view_movie_info_idx = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                          table_vertex_movie_info_idx_, OnEntryNotFound::RETURN_NULL);
    auto &table_movie_info_idx = table_or_view_movie_info_idx->Cast<TableCatalogEntry>();
    auto table_or_view_movie_keyword = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                         table_vertex_movie_keyword_, OnEntryNotFound::RETURN_NULL);
    auto &table_movie_keyword = table_or_view_movie_keyword->Cast<TableCatalogEntry>();
    auto table_or_view_movie_info = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_movie_info_,
                                                      OnEntryNotFound::RETURN_NULL);
    auto &table_movie_info = table_or_view_movie_info->Cast<TableCatalogEntry>();
    auto table_or_view_movie_companies = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                           table_vertex_movie_companies_, OnEntryNotFound::RETURN_NULL);
    auto &table_movie_companies = table_or_view_movie_companies->Cast<TableCatalogEntry>();


    string p_info2_n = "rating";
    Value p_info2 = Value(p_info2_n);
    vector<idx_t> info_type_it2_ids{COLUMN_IDENTIFIER_ROW_ID, 1};
    vector<LogicalType> get_info_type_it2_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_info_type_it2 = "it2";
    vector<LogicalType> table_types_info_type_it2;
    vector<unique_ptr<Expression>> filter_info_type_it2;
    unique_ptr<LogicalGet> get_op_info_type_it2 = move(
            getLogicalGet(*this, table_info_type, alias_info_type_it2, table_index_info_type_it2,
                          table_types_info_type_it2));
    unique_ptr<TableFilterSet> table_filters_info_type_it2 = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_it2 = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL, p_info2);
    table_filters_info_type_it2->filters[1] = move(constant_filter_it2);
    unique_ptr<PhysicalTableScan> scan_info_type_it2 = make_uniq<PhysicalTableScan>(get_info_type_it2_types,
                                                                                    get_op_info_type_it2->function,
                                                                                    get_op_info_type_it2->table_index,
                                                                                    move(get_op_info_type_it2->bind_data),
                                                                                    table_types_info_type_it2,
                                                                                    info_type_it2_ids,
                                                                                    move(filter_info_type_it2),
                                                                                    vector<column_t>(),
                                                                                    get_op_info_type_it2->names,
                                                                                    std::move(
                                                                                            table_filters_info_type_it2),
                                                                                    get_op_info_type_it2->estimated_cardinality,
                                                                                    get_op_info_type_it2->extra_info);

    string p_idx_info_n = "7.0";
    Value p_idx_info = Value(p_idx_info_n);
    vector<idx_t> movie_info_idx_ids{5, 6, 3};
    vector<LogicalType> get_movie_info_idx_type{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_movie_info_idx = "mi";
    vector<LogicalType> table_types_movie_info_idx;
    vector<unique_ptr<Expression>> filter_movie_info_idx;
    unique_ptr<LogicalGet> get_op_movie_info_idx = move(
            getLogicalGet(*this, table_movie_info_idx, alias_movie_info_idx, table_index_movie_info_idx_, table_types_movie_info_idx));
    unique_ptr<TableFilterSet> table_filters_movie_info_idx = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_idx = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_LESSTHAN, p_idx_info);
    table_filters_movie_info_idx->filters[2] = move(constant_filter_idx);
    unique_ptr<PhysicalTableScan> scan_movie_info_idx = make_uniq<PhysicalTableScan>(get_movie_info_idx_type,
                                                                                     get_op_movie_info_idx->function,
                                                                                     get_op_movie_info_idx->table_index,
                                                                                     move(get_op_movie_info_idx->bind_data),
                                                                                     table_types_movie_info_idx, movie_info_idx_ids,
                                                                                     move(filter_movie_info_idx),
                                                                                     vector<column_t>(),
                                                                                     get_op_movie_info_idx->names,
                                                                                     std::move(table_filters_movie_info_idx),
                                                                                     get_op_movie_info_idx->estimated_cardinality,
                                                                                     get_op_movie_info_idx->extra_info);


    vector<JoinCondition> cond_movie_info_idx_;
    JoinCondition join_condition_movie_info_idx_;
    join_condition_movie_info_idx_.left = make_uniq<BoundReferenceExpression>("info_type_id_rowid", LogicalType::BIGINT, 0);
    join_condition_movie_info_idx_.right = make_uniq<BoundReferenceExpression>("info_type_rowid", LogicalType::BIGINT, 0);
    join_condition_movie_info_idx_.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_movie_info_idx_ = make_uniq<RAIInfo>();
    rai_info_movie_info_idx_->rai = table_movie_info_idx.GetStorage().info->rais[0].get();
    rai_info_movie_info_idx_->rai_type = RAIType::EDGE_SOURCE;
    rai_info_movie_info_idx_->forward = true;
    rai_info_movie_info_idx_->vertex = &table_info_type;
    rai_info_movie_info_idx_->vertex_id = table_index_info_type_it2;
    rai_info_movie_info_idx_->passing_tables[0] = table_index_movie_info_idx_;
    rai_info_movie_info_idx_->left_cardinalities[0] = table_movie_info_idx.GetStorage().info->cardinality;
    rai_info_movie_info_idx_->compact_list = &rai_info_movie_info_idx_->rai->alist->compact_forward_list;

    join_condition_movie_info_idx_.rais.push_back(move(rai_info_movie_info_idx_));
    cond_movie_info_idx_.push_back(move(join_condition_movie_info_idx_));

    LogicalComparisonJoin join_movie_info_idx__op(JoinType::INNER);
    vector<LogicalType> output_movie_info_idx__types{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::VARCHAR,
                                                     LogicalType::BIGINT};
    join_movie_info_idx__op.types = output_movie_info_idx__types;
    vector<idx_t> right_projection_map_movie_info_idx_{0};
    vector<idx_t> merge_project_map_movie_info_idx_;
    vector<LogicalType> delim_types_movie_info_idx_;
    auto join_movie_info_idx_ = make_uniq<PhysicalSIPJoin>(join_movie_info_idx__op, move(scan_movie_info_idx), move(scan_info_type_it2),
                                                                move(cond_movie_info_idx_), JoinType::INNER,
                                                                left_projection_map,
                                                                right_projection_map_movie_info_idx_,
                                                                delim_types_movie_info_idx_, 0);


    vector<idx_t> title_t_ids{COLUMN_IDENTIFIER_ROW_ID, 1, 4, 12};
    vector<LogicalType> get_title_t_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::BIGINT,
                                          LogicalType::BIGINT};
    string alias_title_t = "t";
    vector<LogicalType> table_types_title_t;
    vector<unique_ptr<Expression>> filter_title_t;
    unique_ptr<LogicalGet> get_op_title_t = move(
            getLogicalGet(*this, table_title, alias_title_t, table_index_title_t, table_types_title_t));
    unique_ptr<TableFilterSet> table_filters_title_t = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_t = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_GREATERTHAN, Value::BIGINT(2008));
    table_filters_title_t->filters[2] = move(constant_filter_t);
    unique_ptr<PhysicalTableScan> scan_title_t = make_uniq<PhysicalTableScan>(get_title_t_types,
                                                                              get_op_title_t->function,
                                                                              get_op_title_t->table_index,
                                                                              move(get_op_title_t->bind_data),
                                                                              table_types_title_t, title_t_ids,
                                                                              move(filter_title_t), vector<column_t>(),
                                                                              get_op_title_t->names,
                                                                              std::move(table_filters_title_t),
                                                                              get_op_title_t->estimated_cardinality,
                                                                              get_op_title_t->extra_info);


    vector<JoinCondition> cond_title_t;
    JoinCondition join_condition_title_t;
    join_condition_title_t.left = make_uniq<BoundReferenceExpression>("title_rowid", LogicalType::BIGINT, 0);
    join_condition_title_t.right = make_uniq<BoundReferenceExpression>("movie_id_rowid", LogicalType::BIGINT, 1);
    join_condition_title_t.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_title_t = make_uniq<RAIInfo>();
    rai_info_title_t->rai = table_movie_info_idx.GetStorage().info->rais[0].get();
    rai_info_title_t->rai_type = RAIType::TARGET_EDGE;
    rai_info_title_t->forward = true;
    rai_info_title_t->vertex = &table_title;
    rai_info_title_t->vertex_id = table_index_title_t;
    rai_info_title_t->passing_tables[0] = table_index_title_t;
    rai_info_title_t->left_cardinalities[0] = table_title.GetStorage().info->cardinality;
    // rai_info_title_t->compact_list = &rai_info_title_t->rai->alist->compact__list;

    join_condition_title_t.rais.push_back(move(rai_info_title_t));
    cond_title_t.push_back(move(join_condition_title_t));

    LogicalComparisonJoin join_title_t_op(JoinType::INNER);
    vector<LogicalType> output_title_t_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::BIGINT,
                                             LogicalType::BIGINT, LogicalType::VARCHAR};
    join_title_t_op.types = output_title_t_types;
    vector<idx_t> right_projection_map_title_t{2};
    vector<idx_t> merge_project_map_title_t;
    vector<LogicalType> delim_types_title_t;
    auto join_title_t = make_uniq<PhysicalSIPJoin>(join_title_t_op, move(scan_title_t), move(join_movie_info_idx_), move(cond_title_t), JoinType::INNER,
                                                   left_projection_map, right_projection_map_title_t,
                                                   delim_types_title_t, 0);

    vector<idx_t> movie_companies_ids{4, 5, 6, 7};
    vector<LogicalType> get_movie_companies_types{LogicalType::VARCHAR, LogicalType::BIGINT,
                                                  LogicalType::BIGINT, LogicalType::BIGINT};
    string alias_movie_companies = "ct";
    vector<LogicalType> table_types_movie_companies;
    vector<unique_ptr<Expression>> filter_movie_companies;
    unique_ptr<LogicalGet> get_op_movie_companies = move(
            getLogicalGet(*this, table_movie_companies, alias_movie_companies, table_index_movie_companies_,
                          table_types_movie_companies));
    unique_ptr<TableFilterSet> table_filters_movie_companies = NULL;
    unique_ptr<PhysicalTableScan> scan_movie_companies = make_uniq<PhysicalTableScan>(get_movie_companies_types,
                                                                                      get_op_movie_companies->function,
                                                                                      get_op_movie_companies->table_index,
                                                                                      move(get_op_movie_companies->bind_data),
                                                                                      table_types_movie_companies,
                                                                                      movie_companies_ids,
                                                                                      move(filter_movie_companies),
                                                                                      vector<column_t>(),
                                                                                      get_op_movie_companies->names,
                                                                                      std::move(
                                                                                              table_filters_movie_companies),
                                                                                      get_op_movie_companies->estimated_cardinality,
                                                                                      get_op_movie_companies->extra_info);


    string p_movie_company_note1 = "(USA)"; // 933;
    string p_movie_company_note2 = "%(200%)%"; // 933;
    Value p_note1 = Value(p_movie_company_note1);
    Value p_note2 = Value(p_movie_company_note2);
    vector<LogicalType> filter_mc_types{LogicalType::VARCHAR, LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::BIGINT};
    vector<unique_ptr<Expression>> select_list_movie_companies;
    auto like_expression_left = make_uniq<BoundReferenceExpression>("note", LogicalType::VARCHAR, 0);
    auto like_expression_value = make_uniq<BoundConstantExpression>(p_note1);
    vector<unique_ptr<Expression>> like_arguments1, like_arguments2;
    like_arguments1.push_back(move(like_expression_left));
    like_arguments1.push_back(move(like_expression_value));

    auto like_expression_left2 = make_uniq<BoundReferenceExpression>("note", LogicalType::VARCHAR, 0);
    auto like_expression_value2 = make_uniq<BoundConstantExpression>(p_note2);
    like_arguments2.push_back(move(like_expression_left2));
    like_arguments2.push_back(move(like_expression_value2));

    ScalarFunction bound_function_contains = ContainsFun::GetFunction();
    ScalarFunction bound_function_like = LikeFun::GetLikeFunction();
    unique_ptr<FunctionData> bind_data_contains = NULL;
    unique_ptr<FunctionData> bind_data_like = NULL;

    auto like_bound_function = make_uniq<BoundFunctionExpression>(LogicalType::BOOLEAN,
                                                                  bound_function_contains,
                                                                  move(like_arguments1),
                                                                  move(bind_data_contains), false);

    auto not_like_bound_function = make_uniq<BoundOperatorExpression>(ExpressionType::OPERATOR_NOT,
                                                                      LogicalType::BOOLEAN);
    not_like_bound_function->children.push_back(move(like_bound_function));

    auto like_bound_function2 = make_uniq<BoundFunctionExpression>(LogicalType::BOOLEAN,
                                                                   bound_function_like,
                                                                   move(like_arguments2),
                                                                   move(bind_data_like), false);


    select_list_movie_companies.push_back(move(not_like_bound_function));
    select_list_movie_companies.push_back(move(like_bound_function2));
    unique_ptr<PhysicalFilter> filter_mc_contains = make_uniq<PhysicalFilter>(filter_mc_types, move(select_list_movie_companies), 0);
    filter_mc_contains->children.push_back(move(scan_movie_companies));


    vector<JoinCondition> cond_movie_companies_;
    JoinCondition join_condition_movie_companies_;
    join_condition_movie_companies_.left = make_uniq<BoundReferenceExpression>("movie_id_rowid", LogicalType::BIGINT, 2);
    join_condition_movie_companies_.right = make_uniq<BoundReferenceExpression>("title_rowid", LogicalType::BIGINT, 0);
    join_condition_movie_companies_.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_movie_companies_ = make_uniq<RAIInfo>();
    rai_info_movie_companies_->rai = table_movie_companies.GetStorage().info->rais[0].get();
    rai_info_movie_companies_->rai_type = RAIType::EDGE_TARGET;
    rai_info_movie_companies_->forward = false;
    rai_info_movie_companies_->vertex = &table_title;
    rai_info_movie_companies_->vertex_id = table_index_title_t;
    rai_info_movie_companies_->passing_tables[0] = table_index_movie_companies_;
    rai_info_movie_companies_->left_cardinalities[0] = table_movie_companies.GetStorage().info->cardinality;
    rai_info_movie_companies_->compact_list = &rai_info_movie_companies_->rai->alist->compact_backward_list;

    join_condition_movie_companies_.rais.push_back(move(rai_info_movie_companies_));
    cond_movie_companies_.push_back(move(join_condition_movie_companies_));

    LogicalComparisonJoin join_movie_companies__op(JoinType::INNER);
    vector<LogicalType> output_movie_companies__types{LogicalType::VARCHAR, LogicalType::BIGINT,
                                                      LogicalType::BIGINT, LogicalType::BIGINT,
                                                      LogicalType::VARCHAR, LogicalType::BIGINT,
                                                      LogicalType::VARCHAR};
    join_movie_companies__op.types = output_movie_companies__types;
    vector<idx_t> right_projection_map_movie_companies_{1, 3, 4};
    vector<idx_t> merge_project_map_movie_companies_;
    vector<LogicalType> delim_types_movie_companies_;
    auto join_movie_companies_ = make_uniq<PhysicalSIPJoin>(join_movie_companies__op, move(filter_mc_contains), move(join_title_t),
                                                                 move(cond_movie_companies_), JoinType::INNER,
                                                                 left_projection_map,
                                                                 right_projection_map_movie_companies_,
                                                                 delim_types_movie_companies_, 0);


    vector<idx_t> company_name_cn_ids{COLUMN_IDENTIFIER_ROW_ID, 1, 2};
    vector<LogicalType> get_company_name_cn_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::VARCHAR};
    string alias_company_name_cn = "cn";
    vector<LogicalType> table_types_company_name_cn;
    vector<unique_ptr<Expression>> filter_company_name_cn;
    unique_ptr<LogicalGet> get_op_company_name_cn = move(
            getLogicalGet(*this, table_company_name, alias_company_name_cn, table_index_company_name_cn,
                          table_types_company_name_cn));
    unique_ptr<TableFilterSet> table_filters_company_name_cn = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_cn = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_NOTEQUAL, Value("[us]"));
    table_filters_company_name_cn->filters[2] = move(constant_filter_cn);
    unique_ptr<PhysicalTableScan> scan_company_name_cn = make_uniq<PhysicalTableScan>(get_company_name_cn_types,
                                                                                      get_op_company_name_cn->function,
                                                                                      get_op_company_name_cn->table_index,
                                                                                      move(get_op_company_name_cn->bind_data),
                                                                                      table_types_company_name_cn,
                                                                                      company_name_cn_ids,
                                                                                      move(filter_company_name_cn),
                                                                                      vector<column_t>(),
                                                                                      get_op_company_name_cn->names,
                                                                                      std::move(
                                                                                              table_filters_company_name_cn),
                                                                                      get_op_company_name_cn->estimated_cardinality,
                                                                                      get_op_company_name_cn->extra_info);


    vector<JoinCondition> cond_company_name_cn;
    JoinCondition join_condition_company_name_cn;
    join_condition_company_name_cn.left = make_uniq<BoundReferenceExpression>("company_name_rowid", LogicalType::BIGINT, 0);
    join_condition_company_name_cn.right = make_uniq<BoundReferenceExpression>("company_id_rowid", LogicalType::BIGINT, 1);
    join_condition_company_name_cn.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_company_name_cn = make_uniq<RAIInfo>();
    rai_info_company_name_cn->rai = table_movie_companies.GetStorage().info->rais[0].get();
    rai_info_company_name_cn->rai_type = RAIType::SOURCE_EDGE;
    rai_info_company_name_cn->forward = false;
    rai_info_company_name_cn->vertex = &table_company_name;
    rai_info_company_name_cn->vertex_id = table_index_company_name_cn;
    rai_info_company_name_cn->passing_tables[0] = table_index_company_name_cn;
    rai_info_company_name_cn->left_cardinalities[0] = table_company_name.GetStorage().info->cardinality;
    // rai_info_company_name_cn->compact_list = &rai_info_company_name_cn->rai->alist->compact__list;

    join_condition_company_name_cn.rais.push_back(move(rai_info_company_name_cn));
    cond_company_name_cn.push_back(move(join_condition_company_name_cn));

    LogicalComparisonJoin join_company_name_cn_op(JoinType::INNER);
    vector<LogicalType> output_company_name_cn_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::VARCHAR,
                                                     LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::VARCHAR,
                                                     LogicalType::BIGINT, LogicalType::VARCHAR};
    join_company_name_cn_op.types = output_company_name_cn_types;
    vector<idx_t> right_projection_map_company_name_cn{2, 3, 4, 5, 6};
    vector<idx_t> merge_project_map_company_name_cn;
    vector<LogicalType> delim_types_company_name_cn;
    auto join_company_name_cn = make_uniq<PhysicalSIPJoin>(join_company_name_cn_op, move(scan_company_name_cn), move(join_movie_companies_),
                                                           move(cond_company_name_cn), JoinType::INNER,
                                                           left_projection_map, right_projection_map_company_name_cn,
                                                           delim_types_company_name_cn, 0);


    vector<idx_t> company_type_ct_ids{COLUMN_IDENTIFIER_ROW_ID};
    vector<LogicalType> get_company_type_ct_types{LogicalType::BIGINT};
    string alias_company_type_ct = "ct";
    vector<LogicalType> table_types_company_type_ct;
    vector<unique_ptr<Expression>> filter_company_type_ct;
    unique_ptr<LogicalGet> get_op_company_type_ct = move(
            getLogicalGet(*this, table_company_type, alias_company_type_ct, table_index_company_type_ct,
                          table_types_company_type_ct));
    unique_ptr<TableFilterSet> table_filters_company_type_ct = NULL;
    unique_ptr<PhysicalTableScan> scan_company_type_ct = make_uniq<PhysicalTableScan>(get_company_type_ct_types,
                                                                                      get_op_company_type_ct->function,
                                                                                      get_op_company_type_ct->table_index,
                                                                                      move(get_op_company_type_ct->bind_data),
                                                                                      table_types_company_type_ct,
                                                                                      company_type_ct_ids,
                                                                                      move(filter_company_type_ct),
                                                                                      vector<column_t>(),
                                                                                      get_op_company_type_ct->names,
                                                                                      std::move(
                                                                                              table_filters_company_type_ct),
                                                                                      get_op_company_type_ct->estimated_cardinality,
                                                                                      get_op_company_type_ct->extra_info);


    vector<JoinCondition> cond_ct;
    JoinCondition join_condition_ct;
    join_condition_ct.left = make_uniq<BoundReferenceExpression>("company_type_rowid", LogicalType::BIGINT, 0);
    join_condition_ct.right = make_uniq<BoundReferenceExpression>("company_type_id_rowid", LogicalType::BIGINT, 4);
    join_condition_ct.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_ct = make_uniq<RAIInfo>();
    rai_info_ct->rai = table_movie_companies.GetStorage().info->rais[1].get();
    rai_info_ct->rai_type = RAIType::SOURCE_EDGE;
    rai_info_ct->forward = false;
    rai_info_ct->vertex = &table_company_type;
    rai_info_ct->vertex_id = table_index_company_type_ct;
    rai_info_ct->passing_tables[0] = table_index_company_type_ct;
    rai_info_ct->left_cardinalities[0] = table_company_type.GetStorage().info->cardinality;
    // rai_info_ct->compact_list = &rai_info_ct->rai->alist->compact__list;

    join_condition_ct.rais.push_back(move(rai_info_ct));
    cond_ct.push_back(move(join_condition_ct));

    LogicalComparisonJoin join_ct_op(JoinType::INNER);
    vector<LogicalType> output_ct_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::BIGINT,
                                        LogicalType::VARCHAR, LogicalType::BIGINT, LogicalType::VARCHAR};
    join_ct_op.types = output_ct_types;
    vector<idx_t> right_projection_map_ct{1, 3, 5, 6, 7};
    vector<idx_t> merge_project_map_ct;
    vector<LogicalType> delim_types_ct;
    auto join_ct = make_uniq<PhysicalSIPJoin>(join_ct_op, move(scan_company_type_ct), move(join_company_name_cn),
                                                                 move(cond_ct), JoinType::INNER,
                                                                 left_projection_map,
                                                                 right_projection_map_ct,
                                                                 delim_types_ct, 0);

    vector<idx_t> movie_info_ids{6, 5, 3};
    vector<LogicalType> get_movie_info_types{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_movie_info = "i";
    vector<LogicalType> table_types_movie_info;
    vector<unique_ptr<Expression>> filter_movie_info;
    unique_ptr<LogicalGet> get_op_movie_info = move(
            getLogicalGet(*this, table_movie_info, alias_movie_info, table_index_movie_info_, table_types_movie_info));
    unique_ptr<TableFilterSet> table_filters_movie_info = NULL;
    unique_ptr<PhysicalTableScan> scan_movie_info = make_uniq<PhysicalTableScan>(get_movie_info_types,
                                                                                 get_op_movie_info->function,
                                                                                 get_op_movie_info->table_index,
                                                                                 move(get_op_movie_info->bind_data),
                                                                                 table_types_movie_info,
                                                                                 movie_info_ids,
                                                                                 move(filter_movie_info),
                                                                                 vector<column_t>(),
                                                                                 get_op_movie_info->names,
                                                                                 std::move(table_filters_movie_info),
                                                                                 get_op_movie_info->estimated_cardinality,
                                                                                 get_op_movie_info->extra_info);

    auto &allocator_mi = Allocator::Get(context);
    vector<LogicalType> join_in_types_mi {LogicalType::VARCHAR};
    auto collection_mi =
            make_uniq<ColumnDataCollection>(context, join_in_types_mi, ColumnDataAllocatorType::IN_MEMORY_ALLOCATOR);

    vector<LogicalType> chunk_in_types_mi {LogicalType::VARCHAR};
    DataChunk chunk_mi;
    chunk_mi.SetCardinality(4);
    chunk_mi.Initialize(allocator_mi, chunk_in_types_mi);
    chunk_mi.SetValue(0, 0, Value("Germany"));
    chunk_mi.SetValue(0, 1, Value("German"));
    chunk_mi.SetValue(0, 2, Value("USA"));
    chunk_mi.SetValue(0, 3, Value("American"));
    collection_mi->Append(chunk_mi);

    // create a chunk scan to output the result
    vector<LogicalType> ouput_in_types_mi {LogicalType::VARCHAR};
    auto chunk_scan_mi = make_uniq<PhysicalColumnDataScan>(ouput_in_types_mi, PhysicalOperatorType::COLUMN_DATA_SCAN,
                                                        4, std::move(collection_mi));

    vector<JoinCondition> cond_hash_join_mi;
    JoinCondition join_condition_hash_join_mi;
    join_condition_hash_join_mi.left = make_uniq<BoundReferenceExpression>("info", LogicalType::VARCHAR, 2);
    join_condition_hash_join_mi.right = make_uniq<BoundReferenceExpression>("", LogicalType::VARCHAR, 0);
    join_condition_hash_join_mi.comparison = ExpressionType::COMPARE_EQUAL;
    cond_hash_join_mi.push_back(move(join_condition_hash_join_mi));

    LogicalComparisonJoin join_hash_join_op_mi(JoinType::MARK);
    vector<LogicalType> output_hash_join_types_mi{LogicalType::BIGINT, LogicalType::BIGINT,
                                               LogicalType::VARCHAR, LogicalType::BOOLEAN};
    join_hash_join_op_mi.types = output_hash_join_types_mi;
    vector<idx_t> right_projection_map_hash_join_mi;
    vector<LogicalType> delim_types_hash_join_mi;
    PerfectHashJoinStats joinstate_mi;
    auto join_hash_join_mi = make_uniq<PhysicalHashJoin>(join_hash_join_op_mi, move(scan_movie_info), move(chunk_scan_mi), move(cond_hash_join_mi),
                                                       JoinType::MARK, left_projection_map,
                                                       right_projection_map_hash_join_mi,
                                                       delim_types_hash_join_mi, 0, joinstate_mi);

    vector<LogicalType> filter_in_types_mi{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::BOOLEAN};
    vector<unique_ptr<Expression>> select_list_in_mi;
    auto in_exp_mi = make_uniq<BoundReferenceExpression>("IN (...)", LogicalType::BOOLEAN, 3);
    select_list_in_mi.push_back(move(in_exp_mi));
    unique_ptr<PhysicalFilter> filter_in_mi = make_uniq<PhysicalFilter>(filter_in_types_mi, move(select_list_in_mi), 0);
    filter_in_mi->children.push_back(move(join_hash_join_mi));


    vector<JoinCondition> cond_movie_info_;
    JoinCondition join_condition_movie_info_;
    join_condition_movie_info_.left = make_uniq<BoundReferenceExpression>("movie_id_rowid", LogicalType::BIGINT, 0);
    join_condition_movie_info_.right = make_uniq<BoundReferenceExpression>("movie_id_rowid", LogicalType::BIGINT, 2);
    join_condition_movie_info_.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_movie_info_ = make_uniq<RAIInfo>();
    rai_info_movie_info_->rai = table_movie_info.GetStorage().info->rais[0].get();
    rai_info_movie_info_->rai_type = RAIType::EDGE_TARGET;
    rai_info_movie_info_->forward = false;
    rai_info_movie_info_->vertex = &table_title;
    rai_info_movie_info_->vertex_id = table_index_title_t;
    rai_info_movie_info_->passing_tables[0] = table_index_movie_info_;
    rai_info_movie_info_->left_cardinalities[0] = table_movie_info.GetStorage().info->cardinality;
    rai_info_movie_info_->compact_list = &rai_info_movie_info_->rai->alist->compact_backward_list;

    join_condition_movie_info_.rais.push_back(move(rai_info_movie_info_));
    cond_movie_info_.push_back(move(join_condition_movie_info_));

    LogicalComparisonJoin join_movie_info__op(JoinType::INNER);
    vector<LogicalType> output_movie_info__types{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::VARCHAR,
                                                 LogicalType::BOOLEAN, LogicalType::VARCHAR, LogicalType::VARCHAR,
                                                 LogicalType::BIGINT, LogicalType::VARCHAR};
    join_movie_info__op.types = output_movie_info__types;
    vector<idx_t> right_projection_map_movie_info_{1, 3, 4, 5};
    vector<idx_t> merge_project_map_movie_info_;
    vector<LogicalType> delim_types_movie_info_;
    auto join_movie_info_ = make_uniq<PhysicalSIPJoin>(join_movie_info__op, move(filter_in_mi), move(join_ct), move(cond_movie_info_),
                                                       JoinType::INNER, left_projection_map,
                                                       right_projection_map_movie_info_, delim_types_movie_info_, 0);


    vector<idx_t> info_type_it1_ids{COLUMN_IDENTIFIER_ROW_ID, 1};
    vector<LogicalType> get_info_type_it1_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_info_type_it1 = "it1";
    vector<LogicalType> table_types_info_type_it1;
    vector<unique_ptr<Expression>> filter_info_type_it1;
    unique_ptr<LogicalGet> get_op_info_type_it1 = move(
            getLogicalGet(*this, table_info_type, alias_info_type_it1, table_index_info_type_it1,
                          table_types_info_type_it1));
    unique_ptr<TableFilterSet> table_filters_info_type_it1 = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_it1 = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL, Value("countries"));
    table_filters_info_type_it1->filters[1] = move(constant_filter_it1);
    unique_ptr<PhysicalTableScan> scan_info_type_it1 = make_uniq<PhysicalTableScan>(get_info_type_it1_types,
                                                                                    get_op_info_type_it1->function,
                                                                                    get_op_info_type_it1->table_index,
                                                                                    move(get_op_info_type_it1->bind_data),
                                                                                    table_types_info_type_it1,
                                                                                    info_type_it1_ids,
                                                                                    move(filter_info_type_it1),
                                                                                    vector<column_t>(),
                                                                                    get_op_info_type_it1->names,
                                                                                    std::move(
                                                                                            table_filters_info_type_it1),
                                                                                    get_op_info_type_it1->estimated_cardinality,
                                                                                    get_op_info_type_it1->extra_info);


    vector<JoinCondition> cond_info_type_it1;
    JoinCondition join_condition_info_type_it1;
    join_condition_info_type_it1.left = make_uniq<BoundReferenceExpression>("info_type_rowid", LogicalType::BIGINT, 0);
    join_condition_info_type_it1.right = make_uniq<BoundReferenceExpression>("info_type_id_rowid", LogicalType::BIGINT, 1);
    join_condition_info_type_it1.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_info_type_it1 = make_uniq<RAIInfo>();
    rai_info_info_type_it1->rai = table_movie_info.GetStorage().info->rais[0].get();
    rai_info_info_type_it1->rai_type = RAIType::SOURCE_EDGE;
    rai_info_info_type_it1->forward = false;
    rai_info_info_type_it1->vertex = &table_info_type;
    rai_info_info_type_it1->vertex_id = table_index_info_type_it1;
    rai_info_info_type_it1->passing_tables[0] = table_index_info_type_it1;
    rai_info_info_type_it1->left_cardinalities[0] = table_info_type.GetStorage().info->cardinality;
    // rai_info_info_type_it1->compact_list = &rai_info_info_type_it1->rai->alist->compact__list;

    join_condition_info_type_it1.rais.push_back(move(rai_info_info_type_it1));
    cond_info_type_it1.push_back(move(join_condition_info_type_it1));

    LogicalComparisonJoin join_info_type_it1_op(JoinType::INNER);
    vector<LogicalType> output_info_type_it1_types{LogicalType::BIGINT, LogicalType::VARCHAR,
                                                   LogicalType::BIGINT, LogicalType::VARCHAR,
                                                   LogicalType::VARCHAR, LogicalType::BIGINT,
                                                   LogicalType::VARCHAR};
    join_info_type_it1_op.types = output_info_type_it1_types;
    vector<idx_t> right_projection_map_info_type_it1{0, 4, 5, 6, 7};
    vector<idx_t> merge_project_map_info_type_it1;
    vector<LogicalType> delim_types_info_type_it1;
    auto join_info_type_it1 = make_uniq<PhysicalSIPJoin>(join_info_type_it1_op, move(scan_info_type_it1), move(join_movie_info_),
                                                         move(cond_info_type_it1), JoinType::INNER, left_projection_map,
                                                         right_projection_map_info_type_it1, delim_types_info_type_it1,
                                                         0);


    vector<idx_t> kind_type_kt_ids{COLUMN_IDENTIFIER_ROW_ID, 1};
    vector<LogicalType> get_kind_type_kt_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_kind_type_kt = "kt";
    vector<LogicalType> table_types_kind_type_kt;
    vector<unique_ptr<Expression>> filter_kind_type_kt;
    unique_ptr<LogicalGet> get_op_kind_type_kt = move(
            getLogicalGet(*this, table_kind_type, alias_kind_type_kt, table_index_kind_type_kt,
                          table_types_kind_type_kt));
    unique_ptr<TableFilterSet> table_filters_kind_type_kt = NULL;
    unique_ptr<PhysicalTableScan> scan_kind_type_kt = make_uniq<PhysicalTableScan>(get_kind_type_kt_types,
                                                                                   get_op_kind_type_kt->function,
                                                                                   get_op_kind_type_kt->table_index,
                                                                                   move(get_op_kind_type_kt->bind_data),
                                                                                   table_types_kind_type_kt,
                                                                                   kind_type_kt_ids,
                                                                                   move(filter_kind_type_kt),
                                                                                   vector<column_t>(),
                                                                                   get_op_kind_type_kt->names,
                                                                                   std::move(
                                                                                           table_filters_kind_type_kt),
                                                                                   get_op_kind_type_kt->estimated_cardinality,
                                                                                   get_op_kind_type_kt->extra_info);

    auto &allocator_kt = Allocator::Get(context);
    vector<LogicalType> join_in_types_kt {LogicalType::VARCHAR};
    auto collection_kt =
            make_uniq<ColumnDataCollection>(context, join_in_types_kt, ColumnDataAllocatorType::IN_MEMORY_ALLOCATOR);

    vector<LogicalType> chunk_in_types_kt {LogicalType::VARCHAR};
    DataChunk chunk_kt;
    chunk_kt.SetCardinality(2);
    chunk_kt.Initialize(allocator_kt, chunk_in_types_kt);
    chunk_kt.SetValue(0, 0, Value("movie"));
    chunk_kt.SetValue(0, 1, Value("episode"));
    collection_kt->Append(chunk_kt);

    // create a chunk scan to output the result
    vector<LogicalType> ouput_in_types_kt {LogicalType::VARCHAR};
    auto chunk_scan_kt = make_uniq<PhysicalColumnDataScan>(ouput_in_types_kt, PhysicalOperatorType::COLUMN_DATA_SCAN,
                                                           2, std::move(collection_kt));

    vector<JoinCondition> cond_hash_join_kt;
    JoinCondition join_condition_hash_join_kt;
    join_condition_hash_join_kt.left = make_uniq<BoundReferenceExpression>("kind", LogicalType::VARCHAR, 1);
    join_condition_hash_join_kt.right = make_uniq<BoundReferenceExpression>("", LogicalType::VARCHAR, 0);
    join_condition_hash_join_kt.comparison = ExpressionType::COMPARE_EQUAL;
    cond_hash_join_kt.push_back(move(join_condition_hash_join_kt));

    LogicalComparisonJoin join_hash_join_op_kt(JoinType::MARK);
    vector<LogicalType> output_hash_join_types_kt{LogicalType::BIGINT,
                                                  LogicalType::VARCHAR, LogicalType::BOOLEAN};
    join_hash_join_op_kt.types = output_hash_join_types_kt;
    vector<idx_t> right_projection_map_hash_join_kt;
    vector<LogicalType> delim_types_hash_join_kt;
    PerfectHashJoinStats joinstate_kt;
    auto join_hash_join_kt = make_uniq<PhysicalHashJoin>(join_hash_join_op_kt, move(scan_kind_type_kt), move(chunk_scan_kt), move(cond_hash_join_kt),
                                                         JoinType::MARK, left_projection_map,
                                                         right_projection_map_hash_join_kt,
                                                         delim_types_hash_join_kt, 0, joinstate_kt);

    vector<LogicalType> filter_in_types_kt{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::BOOLEAN};
    vector<unique_ptr<Expression>> select_list_in_kt;
    auto in_exp_kt = make_uniq<BoundReferenceExpression>("IN (...)", LogicalType::BOOLEAN, 2);
    select_list_in_kt.push_back(move(in_exp_kt));
    unique_ptr<PhysicalFilter> filter_in_kt = make_uniq<PhysicalFilter>(filter_in_types_kt, move(select_list_in_kt), 0);
    filter_in_kt->children.push_back(move(join_hash_join_kt));


    vector<JoinCondition> cond_kind_type_kt;
    JoinCondition join_condition_kind_type_kt;
    join_condition_kind_type_kt.left = make_uniq<BoundReferenceExpression>("kind_type_rowid", LogicalType::BIGINT, 0);
    join_condition_kind_type_kt.right = make_uniq<BoundReferenceExpression>("kind_id_rowid", LogicalType::BIGINT, 5);
    join_condition_kind_type_kt.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_kind_type_kt = make_uniq<RAIInfo>();
    rai_info_kind_type_kt->rai = table_title.GetStorage().info->rais[0].get();
    rai_info_kind_type_kt->rai_type = RAIType::TARGET_EDGE;
    rai_info_kind_type_kt->forward = true;
    rai_info_kind_type_kt->vertex = &table_kind_type;
    rai_info_kind_type_kt->vertex_id = table_index_kind_type_kt;
    rai_info_kind_type_kt->passing_tables[0] = table_index_kind_type_kt;
    rai_info_kind_type_kt->left_cardinalities[0] = table_kind_type.GetStorage().info->cardinality;
    // rai_info_kind_type_kt->compact_list = &rai_info_kind_type_kt->rai->alist->compact__list;

    join_condition_kind_type_kt.rais.push_back(move(rai_info_kind_type_kt));
    cond_kind_type_kt.push_back(move(join_condition_kind_type_kt));

    LogicalComparisonJoin join_kind_type_kt_op(JoinType::INNER);
    vector<LogicalType> output_kind_type_kt_types{LogicalType::BIGINT, LogicalType::VARCHAR,
                                                  LogicalType::BOOLEAN, LogicalType::BIGINT,
                                                  LogicalType::VARCHAR, LogicalType::VARCHAR,
                                                  LogicalType::VARCHAR};
    join_kind_type_kt_op.types = output_kind_type_kt_types;
    vector<idx_t> right_projection_map_kind_type_kt{2, 3, 4, 6};
    vector<idx_t> merge_project_map_kind_type_kt;
    vector<LogicalType> delim_types_kind_type_kt;
    auto join_kind_type_kt = make_uniq<PhysicalSIPJoin>(join_kind_type_kt_op, move(filter_in_kt), move(join_info_type_it1), move(cond_kind_type_kt),
                                                        JoinType::INNER, left_projection_map,
                                                        right_projection_map_kind_type_kt, delim_types_kind_type_kt, 0);



    vector<idx_t> keyword_k_ids{COLUMN_IDENTIFIER_ROW_ID, 1};
    vector<LogicalType> get_keyword_k_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_keyword_k = "k";
    vector<LogicalType> table_types_keyword_k;
    vector<unique_ptr<Expression>> filter_keyword_k;
    unique_ptr<LogicalGet> get_op_keyword_k = move(
            getLogicalGet(*this, table_keyword, alias_keyword_k, table_index_keyword_k, table_types_keyword_k));
    unique_ptr<TableFilterSet> table_filters_keyword_k = NULL;
    unique_ptr<PhysicalTableScan> scan_keyword_k = make_uniq<PhysicalTableScan>(get_keyword_k_types,
                                                                                get_op_keyword_k->function,
                                                                                get_op_keyword_k->table_index,
                                                                                move(get_op_keyword_k->bind_data),
                                                                                table_types_keyword_k, keyword_k_ids,
                                                                                move(filter_keyword_k),
                                                                                vector<column_t>(),
                                                                                get_op_keyword_k->names,
                                                                                std::move(table_filters_keyword_k),
                                                                                get_op_keyword_k->estimated_cardinality,
                                                                                get_op_keyword_k->extra_info);


    auto &allocator_k = Allocator::Get(context);
    vector<LogicalType> join_in_types_k {LogicalType::VARCHAR};
    auto collection_k =
            make_uniq<ColumnDataCollection>(context, join_in_types_k, ColumnDataAllocatorType::IN_MEMORY_ALLOCATOR);

    vector<LogicalType> chunk_in_types_k {LogicalType::VARCHAR};
    DataChunk chunk_k;
    chunk_k.SetCardinality(4);
    chunk_k.Initialize(allocator_k, chunk_in_types_k);
    chunk_k.SetValue(0, 0, Value("murder"));
    chunk_k.SetValue(0, 1, Value("murder-in-title"));
    chunk_k.SetValue(0, 2, Value("blood"));
    chunk_k.SetValue(0, 3, Value("violence"));
    collection_k->Append(chunk_k);

    // create a chunk scan to output the result
    vector<LogicalType> ouput_in_types_k {LogicalType::VARCHAR};
    auto chunk_scan_k = make_uniq<PhysicalColumnDataScan>(ouput_in_types_k, PhysicalOperatorType::COLUMN_DATA_SCAN,
                                                           4, std::move(collection_k));

    vector<JoinCondition> cond_hash_join_k;
    JoinCondition join_condition_hash_join_k;
    join_condition_hash_join_k.left = make_uniq<BoundReferenceExpression>("keyword", LogicalType::VARCHAR, 1);
    join_condition_hash_join_k.right = make_uniq<BoundReferenceExpression>("", LogicalType::VARCHAR, 0);
    join_condition_hash_join_k.comparison = ExpressionType::COMPARE_EQUAL;
    cond_hash_join_k.push_back(move(join_condition_hash_join_k));

    LogicalComparisonJoin join_hash_join_op_k(JoinType::MARK);
    vector<LogicalType> output_hash_join_types_k{LogicalType::BIGINT,
                                                  LogicalType::VARCHAR, LogicalType::BOOLEAN};
    join_hash_join_op_k.types = output_hash_join_types_k;
    vector<idx_t> right_projection_map_hash_join_k;
    vector<LogicalType> delim_types_hash_join_k;
    PerfectHashJoinStats joinstate_k;
    auto join_hash_join_k = make_uniq<PhysicalHashJoin>(join_hash_join_op_k, move(scan_keyword_k), move(chunk_scan_k), move(cond_hash_join_k),
                                                         JoinType::MARK, left_projection_map,
                                                         right_projection_map_hash_join_k,
                                                         delim_types_hash_join_k, 0, joinstate_k);

    vector<LogicalType> filter_in_types_k{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::BOOLEAN};
    vector<unique_ptr<Expression>> select_list_in_k;
    auto in_exp_k = make_uniq<BoundReferenceExpression>("IN (...)", LogicalType::BOOLEAN, 2);
    select_list_in_k.push_back(move(in_exp_k));
    unique_ptr<PhysicalFilter> filter_in_k = make_uniq<PhysicalFilter>(filter_in_types_k, move(select_list_in_k), 0);
    filter_in_k->children.push_back(move(join_hash_join_k));

    vector<JoinCondition> cond_keyword_k;
    JoinCondition join_condition_keyword_k;
    join_condition_keyword_k.left = make_uniq<BoundReferenceExpression>("keyword_rowid", LogicalType::BIGINT, 0);
    join_condition_keyword_k.right = make_uniq<BoundReferenceExpression>("movie_id_rowid", LogicalType::BIGINT, 3);
    join_condition_keyword_k.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_keyword_k = make_uniq<RAIInfo>();
    rai_info_keyword_k->rai = table_movie_keyword.GetStorage().info->rais[0].get();
    rai_info_keyword_k->rai_type = RAIType::SOURCE_EDGE;
    rai_info_keyword_k->forward = false;
    rai_info_keyword_k->vertex = &table_keyword;
    rai_info_keyword_k->vertex_id = table_index_keyword_k;
    rai_info_keyword_k->passing_tables[0] = table_index_keyword_k;
    rai_info_keyword_k->left_cardinalities[0] = table_keyword.GetStorage().info->cardinality;
    // rai_info_keyword_k->compact_list = &rai_info_keyword_k->rai->alist->compact__list;

    join_condition_keyword_k.rais.push_back(move(rai_info_keyword_k));
    cond_keyword_k.push_back(move(join_condition_keyword_k));

    LogicalComparisonJoin join_keyword_k_op(JoinType::INNER);
    vector<LogicalType> output_keyword_k_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::BOOLEAN,
                                               LogicalType::VARCHAR, LogicalType::VARCHAR, LogicalType::VARCHAR};
    join_keyword_k_op.types = output_keyword_k_types;
    vector<idx_t> right_projection_map_keyword_k{4, 5, 6};
    vector<idx_t> merge_project_map_keyword_k;
    vector<LogicalType> delim_types_keyword_k;
    auto join_keyword_k = make_uniq<PhysicalMergeSIPJoin>(join_keyword_k_op, move(filter_in_k), move(join_kind_type_kt), move(cond_keyword_k),
                                                     JoinType::INNER, left_projection_map,
                                                     right_projection_map_keyword_k,
                                                     merge_project_map_keyword_k,
                                                     delim_types_keyword_k, 0);


    vector<LogicalType> result_types{LogicalType::VARCHAR, LogicalType::VARCHAR, LogicalType::VARCHAR};
    vector<unique_ptr<Expression>> select_list;
    auto result_col0 = make_uniq<BoundReferenceExpression>("name", LogicalType::VARCHAR, 3);
    auto result_col1 = make_uniq<BoundReferenceExpression>("info", LogicalType::VARCHAR, 5);
    auto result_col2 = make_uniq<BoundReferenceExpression>("title", LogicalType::VARCHAR, 4);
    select_list.push_back(move(result_col0));
    select_list.push_back(move(result_col1));
    select_list.push_back(move(result_col2));
    auto projection = make_uniq<PhysicalProjection>(result_types, move(select_list), 0);
    projection->children.push_back(move(join_keyword_k));

    // aggregate
    string agg_name = "min";
    string agg_error = "";
    QueryErrorContext error_context(NULL, NULL);
    auto min_func = Catalog::GetEntry(context, CatalogType::SCALAR_FUNCTION_ENTRY, "", "",
                                      "min", OnEntryNotFound::RETURN_NULL, error_context);
    auto &min_func_set = min_func->Cast<AggregateFunctionCatalogEntry>();
    // bind the aggregate
    FunctionBinder function_binder(context);
    vector<LogicalType> types;
    types.push_back(LogicalType::VARCHAR);
    idx_t best_function_varchar = function_binder.BindFunction(agg_name, min_func_set.functions, types, agg_error);
    auto bound_function_min_varchar = min_func_set.functions.GetFunctionByOffset(best_function_varchar);

    auto first_children = make_uniq<BoundReferenceExpression>("name", LogicalType::VARCHAR, 0);
    vector<unique_ptr<Expression>> childrenlist1;
    childrenlist1.push_back(move(first_children));
    auto aggregate1 =
            function_binder.BindAggregateFunction(bound_function_min_varchar, std::move(childrenlist1), nullptr,
                                                  AggregateType::NON_DISTINCT);

    auto second_children = make_uniq<BoundReferenceExpression>("info", LogicalType::VARCHAR, 1);
    vector<unique_ptr<Expression>> childrenlist2;
    childrenlist2.push_back(move(second_children));
    auto aggregate2 =
            function_binder.BindAggregateFunction(bound_function_min_varchar, std::move(childrenlist2), nullptr,
                                                  AggregateType::NON_DISTINCT);

    auto third_children = make_uniq<BoundReferenceExpression>("title", LogicalType::VARCHAR, 2);
    vector<unique_ptr<Expression>> childrenlist3;
    childrenlist3.push_back(move(third_children));
    auto aggregate3 =
            function_binder.BindAggregateFunction(bound_function_min_varchar, std::move(childrenlist3), nullptr,
                                                  AggregateType::NON_DISTINCT);

    vector<unique_ptr<Expression>> aggregates;
    aggregates.push_back(move(aggregate1));
    aggregates.push_back(move(aggregate2));
    aggregates.push_back(move(aggregate3));

    vector<LogicalType> aggregate_types{LogicalType::VARCHAR, LogicalType::VARCHAR, LogicalType::VARCHAR};
    auto ungrouped_aggregate = make_uniq<PhysicalUngroupedAggregate>(aggregate_types, move(aggregates), 0);
    ungrouped_aggregate->children.push_back(move(projection));

    return ungrouped_aggregate;
}

unique_ptr<PhysicalOperator> ClientContext::GenerateJOB23aPlan(duckdb::ClientContext &context) {
    vector<idx_t> left_projection_map, right_projection_map;

    string table_vertex_kind_type_kt = "kind_type";
    string table_vertex_title_t = "title";
    string table_vertex_keyword_k = "keyword";
    string table_vertex_info_type_it1 = "info_type";
    string table_vertex_company_name_cn = "company_name";
    string table_vertex_company_type_ct = "company_type";
    string table_vertex_comp_cast_type_cct1 = "comp_cast_type";
    string table_vertex_movie_keyword_ = "movie_keyword";
    string table_vertex_movie_info_ = "movie_info";
    string table_vertex_movie_companies_ = "movie_companies";
    string table_vertex_complete_cast = "complete_cast";

    idx_t table_index_kind_type_kt = 1;
    idx_t table_index_title_t = 2;
    idx_t table_index_keyword_k = 3;
    idx_t table_index_info_type_it1 = 4;
    idx_t table_index_company_name_cn = 5;
    idx_t table_index_company_type_ct = 6;
    idx_t table_index_comp_cast_type_cct1 = 7;
    idx_t table_index_movie_keyword_ = 9;
    idx_t table_index_movie_info_ = 10;
    idx_t table_index_movie_companies_ = 12;
    idx_t table_index_complete_cast = 13;

    auto table_or_view_kind_type = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_kind_type_kt,
                                                     OnEntryNotFound::RETURN_NULL);
    auto &table_kind_type = table_or_view_kind_type->Cast<TableCatalogEntry>();
    auto table_or_view_title = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_title_t,
                                                 OnEntryNotFound::RETURN_NULL);
    auto &table_title = table_or_view_title->Cast<TableCatalogEntry>();
    auto table_or_view_keyword = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_keyword_k,
                                                   OnEntryNotFound::RETURN_NULL);
    auto &table_keyword = table_or_view_keyword->Cast<TableCatalogEntry>();
    auto table_or_view_info_type = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                     table_vertex_info_type_it1, OnEntryNotFound::RETURN_NULL);
    auto &table_info_type = table_or_view_info_type->Cast<TableCatalogEntry>();
    auto table_or_view_company_name = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                        table_vertex_company_name_cn, OnEntryNotFound::RETURN_NULL);
    auto &table_company_name = table_or_view_company_name->Cast<TableCatalogEntry>();
    auto table_or_view_company_type = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                        table_vertex_company_type_ct, OnEntryNotFound::RETURN_NULL);
    auto &table_company_type = table_or_view_company_type->Cast<TableCatalogEntry>();
    auto table_or_view_comp_cast_type = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                          table_vertex_comp_cast_type_cct1,
                                                          OnEntryNotFound::RETURN_NULL);
    auto &table_comp_cast_type = table_or_view_comp_cast_type->Cast<TableCatalogEntry>();
    auto table_or_view_movie_keyword = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                         table_vertex_movie_keyword_, OnEntryNotFound::RETURN_NULL);
    auto &table_movie_keyword = table_or_view_movie_keyword->Cast<TableCatalogEntry>();
    auto table_or_view_movie_info = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_movie_info_,
                                                      OnEntryNotFound::RETURN_NULL);
    auto &table_movie_info = table_or_view_movie_info->Cast<TableCatalogEntry>();
    auto table_or_view_movie_companies = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                           table_vertex_movie_companies_, OnEntryNotFound::RETURN_NULL);
    auto &table_movie_companies = table_or_view_movie_companies->Cast<TableCatalogEntry>();
    auto table_or_view_complete_cast = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                                table_vertex_complete_cast,
                                                                OnEntryNotFound::RETURN_NULL);
    auto &table_complete_cast = table_or_view_complete_cast->Cast<TableCatalogEntry>();

    vector<idx_t> comp_cast_type_cct1_ids{COLUMN_IDENTIFIER_ROW_ID, 1};
    vector<LogicalType> get_comp_cast_type_cct1_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_comp_cast_type_cct1 = "cct1";
    vector<LogicalType> table_types_comp_cast_type_cct1;
    vector<unique_ptr<Expression>> filter_comp_cast_type_cct1;
    unique_ptr<LogicalGet> get_op_comp_cast_type_cct1 = move(
            getLogicalGet(*this, table_comp_cast_type, alias_comp_cast_type_cct1, table_index_comp_cast_type_cct1,
                          table_types_comp_cast_type_cct1));
    unique_ptr<TableFilterSet> table_filters_comp_cast_type_cct1 = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_cct1 = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL, Value("complete+verified"));
    table_filters_comp_cast_type_cct1->filters[1] = move(constant_filter_cct1);
    unique_ptr<PhysicalTableScan> scan_comp_cast_type_cct1 = make_uniq<PhysicalTableScan>(get_comp_cast_type_cct1_types,
                                                                                          get_op_comp_cast_type_cct1->function,
                                                                                          get_op_comp_cast_type_cct1->table_index,
                                                                                          move(get_op_comp_cast_type_cct1->bind_data),
                                                                                          table_types_comp_cast_type_cct1,
                                                                                          comp_cast_type_cct1_ids,
                                                                                          move(filter_comp_cast_type_cct1),
                                                                                          vector<column_t>(),
                                                                                          get_op_comp_cast_type_cct1->names,
                                                                                          std::move(
                                                                                                  table_filters_comp_cast_type_cct1),
                                                                                          get_op_comp_cast_type_cct1->estimated_cardinality,
                                                                                          get_op_comp_cast_type_cct1->extra_info);

    vector<idx_t> title_t_ids{COLUMN_IDENTIFIER_ROW_ID, 1, 4, 12};
    vector<LogicalType> get_title_t_types{LogicalType::BIGINT, LogicalType::VARCHAR,
                                          LogicalType::BIGINT, LogicalType::BIGINT};
    string alias_title_t = "t";
    vector<LogicalType> table_types_title_t;
    vector<unique_ptr<Expression>> filter_title_t;
    unique_ptr<LogicalGet> get_op_title_t = move(
            getLogicalGet(*this, table_title, alias_title_t, table_index_title_t, table_types_title_t));
    unique_ptr<TableFilterSet> table_filters_title_t = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_t = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_GREATERTHAN, Value::BIGINT(2000));
    table_filters_title_t->filters[2] = move(constant_filter_t);
    unique_ptr<PhysicalTableScan> scan_title_t = make_uniq<PhysicalTableScan>(get_title_t_types,
                                                                              get_op_title_t->function,
                                                                              get_op_title_t->table_index,
                                                                              move(get_op_title_t->bind_data),
                                                                              table_types_title_t, title_t_ids,
                                                                              move(filter_title_t), vector<column_t>(),
                                                                              get_op_title_t->names,
                                                                              std::move(table_filters_title_t),
                                                                              get_op_title_t->estimated_cardinality,
                                                                              get_op_title_t->extra_info);


    vector<JoinCondition> cond_title_t;
    JoinCondition join_condition_title_t;
    join_condition_title_t.left = make_uniq<BoundReferenceExpression>("title_rowid", LogicalType::BIGINT, 0);
    join_condition_title_t.right = make_uniq<BoundReferenceExpression>("comp_cast_type_rowid", LogicalType::BIGINT, 0);
    join_condition_title_t.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_title_t = make_uniq<RAIInfo>();
    rai_info_title_t->rai = table_complete_cast.GetStorage().info->rais[1].get();
    rai_info_title_t->rai_type = RAIType::TARGET_EDGE;
    rai_info_title_t->forward = true;
    rai_info_title_t->vertex = &table_title;
    rai_info_title_t->vertex_id = table_index_title_t;
    rai_info_title_t->passing_tables[0] = table_index_title_t;
    rai_info_title_t->left_cardinalities[0] = table_title.GetStorage().info->cardinality;
    // rai_info_title_t->compact_list = &rai_info_title_t->rai->alist->compact__list;

    join_condition_title_t.rais.push_back(move(rai_info_title_t));
    cond_title_t.push_back(move(join_condition_title_t));

    LogicalComparisonJoin join_title_t_op(JoinType::INNER);
    vector<LogicalType> output_title_t_types{LogicalType::BIGINT, LogicalType::VARCHAR,
                                             LogicalType::BIGINT, LogicalType::BIGINT,
                                             LogicalType::BIGINT};
    join_title_t_op.types = output_title_t_types;
    vector<idx_t> right_projection_map_title_t{0};
    vector<idx_t> merge_project_map_title_t;
    vector<LogicalType> delim_types_title_t;
    auto join_title_t = make_uniq<PhysicalMergeSIPJoin>(join_title_t_op, move(scan_title_t), move(scan_comp_cast_type_cct1), move(cond_title_t), JoinType::INNER,
                                                        left_projection_map, right_projection_map_title_t,
                                                        merge_project_map_title_t, delim_types_title_t, 0);

    vector<idx_t> movie_info_ids{6, 5, 3, 4};
    vector<LogicalType> get_movie_info_types{LogicalType::BIGINT, LogicalType::BIGINT,
                                             LogicalType::VARCHAR, LogicalType::VARCHAR};
    string alias_movie_info = "i";
    vector<LogicalType> table_types_movie_info;
    vector<unique_ptr<Expression>> filter_movie_info;
    unique_ptr<LogicalGet> get_op_movie_info = move(
            getLogicalGet(*this, table_movie_info, alias_movie_info, table_index_movie_info_, table_types_movie_info));
    unique_ptr<TableFilterSet> table_filters_movie_info = NULL;
    unique_ptr<PhysicalTableScan> scan_movie_info = make_uniq<PhysicalTableScan>(get_movie_info_types,
                                                                                 get_op_movie_info->function,
                                                                                 get_op_movie_info->table_index,
                                                                                 move(get_op_movie_info->bind_data),
                                                                                 table_types_movie_info,
                                                                                 movie_info_ids,
                                                                                 move(filter_movie_info),
                                                                                 vector<column_t>(),
                                                                                 get_op_movie_info->names,
                                                                                 std::move(table_filters_movie_info),
                                                                                 get_op_movie_info->estimated_cardinality,
                                                                                 get_op_movie_info->extra_info);

    string p_movie_info_note = "internet";
    string p_movie_info_info1 = "USA:% 199%";
    string p_movie_info_info2 = "USA:% 200%";
    Value p_info_note = Value(p_movie_info_note);
    Value p_info_info1 = Value(p_movie_info_info1);
    Value p_info_info2 = Value(p_movie_info_info2);
    vector<LogicalType> filter_mi_types{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::VARCHAR};
    vector<unique_ptr<Expression>> select_list_movie_info;
    auto like_expression_left_mi = make_uniq<BoundReferenceExpression>("note", LogicalType::VARCHAR, 3);
    auto like_expression_value_mi = make_uniq<BoundConstantExpression>(p_info_note);
    vector<unique_ptr<Expression>> like_arguments1_mi, like_arguments2_mi, like_arguments3_mi;
    like_arguments1_mi.push_back(move(like_expression_left_mi));
    like_arguments1_mi.push_back(move(like_expression_value_mi));

    auto like_expression_left2_mi = make_uniq<BoundReferenceExpression>("info", LogicalType::VARCHAR, 2);
    auto like_expression_value2_mi = make_uniq<BoundConstantExpression>(p_info_info1);
    like_arguments2_mi.push_back(move(like_expression_left2_mi));
    like_arguments2_mi.push_back(move(like_expression_value2_mi));

    auto like_expression_left3_mi = make_uniq<BoundReferenceExpression>("info", LogicalType::VARCHAR, 2);
    auto like_expression_value3_mi = make_uniq<BoundConstantExpression>(p_info_info2);
    like_arguments3_mi.push_back(move(like_expression_left3_mi));
    like_arguments3_mi.push_back(move(like_expression_value3_mi));

    ScalarFunction bound_function_contains = ContainsFun::GetFunction();
    ScalarFunction bound_function_like = LikeFun::GetLikeFunction();

    unique_ptr<FunctionData> bind_data_contains_mi = NULL;
    auto like_bound_function_mi = make_uniq<BoundFunctionExpression>(LogicalType::BOOLEAN,
                                                                     bound_function_contains,
                                                                     move(like_arguments1_mi),
                                                                     move(bind_data_contains_mi), false);

    unique_ptr<FunctionData> bind_data_like_mi2 = NULL;
    auto like_bound_function2_mi = make_uniq<BoundFunctionExpression>(LogicalType::BOOLEAN,
                                                                      bound_function_like,
                                                                      move(like_arguments2_mi),
                                                                      move(bind_data_like_mi2), false);

    unique_ptr<FunctionData> bind_data_like_mi3 = NULL;
    auto like_bound_function3_mi = make_uniq<BoundFunctionExpression>(LogicalType::BOOLEAN,
                                                                      bound_function_like,
                                                                      move(like_arguments3_mi),
                                                                      move(bind_data_like_mi3), false);

    auto mi_not_null_bound_function = make_uniq<BoundOperatorExpression>(ExpressionType::OPERATOR_IS_NOT_NULL, LogicalType::BOOLEAN);
    auto mi_not_null = make_uniq<BoundReferenceExpression>("info", LogicalType::VARCHAR, 2);
    mi_not_null_bound_function->children.push_back(move(mi_not_null));

    auto or_conjunction = make_uniq<BoundConjunctionExpression>(ExpressionType::CONJUNCTION_OR);
    or_conjunction->children.push_back(move(like_bound_function2_mi));
    or_conjunction->children.push_back(move(like_bound_function3_mi));

    select_list_movie_info.push_back(move(like_bound_function_mi));
    select_list_movie_info.push_back(move(mi_not_null_bound_function));
    select_list_movie_info.push_back(move(or_conjunction));
    unique_ptr<PhysicalFilter> filter_mi_contains = make_uniq<PhysicalFilter>(filter_mi_types, move(select_list_movie_info), 0);
    filter_mi_contains->children.push_back(move(scan_movie_info));


    vector<JoinCondition> cond_movie_info_;
    JoinCondition join_condition_movie_info_;
    join_condition_movie_info_.left = make_uniq<BoundReferenceExpression>("movie_id_rowid", LogicalType::BIGINT, 0);
    join_condition_movie_info_.right = make_uniq<BoundReferenceExpression>("title_rowid", LogicalType::BIGINT, 0);
    join_condition_movie_info_.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_movie_info_ = make_uniq<RAIInfo>();
    rai_info_movie_info_->rai = table_movie_info.GetStorage().info->rais[0].get();
    rai_info_movie_info_->rai_type = RAIType::EDGE_TARGET;
    rai_info_movie_info_->forward = false;
    rai_info_movie_info_->vertex = &table_title;
    rai_info_movie_info_->vertex_id = table_index_title_t;
    rai_info_movie_info_->passing_tables[0] = table_index_movie_info_;
    rai_info_movie_info_->left_cardinalities[0] = table_movie_info.GetStorage().info->cardinality;
    rai_info_movie_info_->compact_list = &rai_info_movie_info_->rai->alist->compact_backward_list;

    join_condition_movie_info_.rais.push_back(move(rai_info_movie_info_));
    cond_movie_info_.push_back(move(join_condition_movie_info_));

    LogicalComparisonJoin join_movie_info__op(JoinType::INNER);
    vector<LogicalType> output_movie_info__types{LogicalType::BIGINT, LogicalType::BIGINT,
                                                 LogicalType::VARCHAR, LogicalType::VARCHAR,
                                                 LogicalType::VARCHAR, LogicalType::BIGINT};
    join_movie_info__op.types = output_movie_info__types;
    vector<idx_t> right_projection_map_movie_info_{1, 3};
    vector<idx_t> merge_project_map_movie_info_;
    vector<LogicalType> delim_types_movie_info_;
    auto join_movie_info_ = make_uniq<PhysicalSIPJoin>(join_movie_info__op, move(filter_mi_contains), move(join_title_t), move(cond_movie_info_),
                                                            JoinType::INNER, left_projection_map,
                                                            right_projection_map_movie_info_,
                                                            delim_types_movie_info_, 0);


    vector<idx_t> info_type_it1_ids{COLUMN_IDENTIFIER_ROW_ID, 1};
    vector<LogicalType> get_info_type_it1_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_info_type_it1 = "it1";
    vector<LogicalType> table_types_info_type_it1;
    vector<unique_ptr<Expression>> filter_info_type_it1;
    unique_ptr<LogicalGet> get_op_info_type_it1 = move(
            getLogicalGet(*this, table_info_type, alias_info_type_it1, table_index_info_type_it1,
                          table_types_info_type_it1));
    unique_ptr<TableFilterSet> table_filters_info_type_it1 = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_it1 = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL, Value("release dates"));
    table_filters_info_type_it1->filters[1] = move(constant_filter_it1);
    unique_ptr<PhysicalTableScan> scan_info_type_it1 = make_uniq<PhysicalTableScan>(get_info_type_it1_types,
                                                                                    get_op_info_type_it1->function,
                                                                                    get_op_info_type_it1->table_index,
                                                                                    move(get_op_info_type_it1->bind_data),
                                                                                    table_types_info_type_it1,
                                                                                    info_type_it1_ids,
                                                                                    move(filter_info_type_it1),
                                                                                    vector<column_t>(),
                                                                                    get_op_info_type_it1->names,
                                                                                    std::move(
                                                                                            table_filters_info_type_it1),
                                                                                    get_op_info_type_it1->estimated_cardinality,
                                                                                    get_op_info_type_it1->extra_info);


    vector<JoinCondition> cond_info_type_it1;
    JoinCondition join_condition_info_type_it1;
    join_condition_info_type_it1.left = make_uniq<BoundReferenceExpression>("info_type_rowid", LogicalType::BIGINT, 0);
    join_condition_info_type_it1.right = make_uniq<BoundReferenceExpression>("info_type_id_rowid", LogicalType::BIGINT, 1);
    join_condition_info_type_it1.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_info_type_it1 = make_uniq<RAIInfo>();
    rai_info_info_type_it1->rai = table_movie_info.GetStorage().info->rais[0].get();
    rai_info_info_type_it1->rai_type = RAIType::SOURCE_EDGE;
    rai_info_info_type_it1->forward = false;
    rai_info_info_type_it1->vertex = &table_info_type;
    rai_info_info_type_it1->vertex_id = table_index_info_type_it1;
    rai_info_info_type_it1->passing_tables[0] = table_index_info_type_it1;
    rai_info_info_type_it1->left_cardinalities[0] = table_info_type.GetStorage().info->cardinality;
    // rai_info_info_type_it1->compact_list = &rai_info_info_type_it1->rai->alist->compact__list;

    join_condition_info_type_it1.rais.push_back(move(rai_info_info_type_it1));
    cond_info_type_it1.push_back(move(join_condition_info_type_it1));

    LogicalComparisonJoin join_info_type_it1_op(JoinType::INNER);
    vector<LogicalType> output_info_type_it1_types{LogicalType::BIGINT, LogicalType::VARCHAR,
                                                   LogicalType::BIGINT, LogicalType::VARCHAR,
                                                   LogicalType::BIGINT};
    join_info_type_it1_op.types = output_info_type_it1_types;
    vector<idx_t> right_projection_map_info_type_it1{0, 4, 5};
    vector<idx_t> merge_project_map_info_type_it1;
    vector<LogicalType> delim_types_info_type_it1;
    auto join_info_type_it1 = make_uniq<PhysicalSIPJoin>(join_info_type_it1_op, move(scan_info_type_it1), move(join_movie_info_),
                                                         move(cond_info_type_it1), JoinType::INNER, left_projection_map,
                                                         right_projection_map_info_type_it1, delim_types_info_type_it1,
                                                         0);

    vector<idx_t> movie_companies_ids{5, 6, 7};
    vector<LogicalType> get_movie_companies_types{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::BIGINT};
    string alias_movie_companies = "mc";
    vector<LogicalType> table_types_movie_companies;
    vector<unique_ptr<Expression>> filter_movie_companies;
    unique_ptr<LogicalGet> get_op_movie_companies = move(
            getLogicalGet(*this, table_movie_companies, alias_movie_companies, table_index_movie_companies_,
                          table_types_movie_companies));
    unique_ptr<TableFilterSet> table_filters_movie_companies = NULL;
    unique_ptr<PhysicalTableScan> scan_movie_companies = make_uniq<PhysicalTableScan>(get_movie_companies_types,
                                                                                      get_op_movie_companies->function,
                                                                                      get_op_movie_companies->table_index,
                                                                                      move(get_op_movie_companies->bind_data),
                                                                                      table_types_movie_companies,
                                                                                      movie_companies_ids,
                                                                                      move(filter_movie_companies),
                                                                                      vector<column_t>(),
                                                                                      get_op_movie_companies->names,
                                                                                      std::move(
                                                                                              table_filters_movie_companies),
                                                                                      get_op_movie_companies->estimated_cardinality,
                                                                                      get_op_movie_companies->extra_info);


    vector<JoinCondition> cond_movie_companies_;
    JoinCondition join_condition_movie_companies_;
    join_condition_movie_companies_.left = make_uniq<BoundReferenceExpression>("movie_id_rowid", LogicalType::BIGINT, 1);
    join_condition_movie_companies_.right = make_uniq<BoundReferenceExpression>("movie_id_rowid", LogicalType::BIGINT, 2);
    join_condition_movie_companies_.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_movie_companies_ = make_uniq<RAIInfo>();
    rai_info_movie_companies_->rai = table_movie_companies.GetStorage().info->rais[0].get();
    rai_info_movie_companies_->rai_type = RAIType::EDGE_TARGET;
    rai_info_movie_companies_->forward = false;
    rai_info_movie_companies_->vertex = &table_title;
    rai_info_movie_companies_->vertex_id = table_index_title_t;
    rai_info_movie_companies_->passing_tables[0] = table_index_movie_companies_;
    rai_info_movie_companies_->left_cardinalities[0] = table_movie_companies.GetStorage().info->cardinality;
    rai_info_movie_companies_->compact_list = &rai_info_movie_companies_->rai->alist->compact_backward_list;

    join_condition_movie_companies_.rais.push_back(move(rai_info_movie_companies_));
    cond_movie_companies_.push_back(move(join_condition_movie_companies_));

    LogicalComparisonJoin join_movie_companies__op(JoinType::INNER);
    vector<LogicalType> output_movie_companies__types{LogicalType::BIGINT, LogicalType::BIGINT,
                                                      LogicalType::BIGINT, LogicalType::VARCHAR,
                                                      LogicalType::BIGINT};
    join_movie_companies__op.types = output_movie_companies__types;
    vector<idx_t> right_projection_map_movie_companies_{3, 4};
    vector<idx_t> merge_project_map_movie_companies_;
    vector<LogicalType> delim_types_movie_companies_;
    auto join_movie_companies_ = make_uniq<PhysicalSIPJoin>(join_movie_companies__op, move(scan_movie_companies), move(join_info_type_it1),
                                                                 move(cond_movie_companies_), JoinType::INNER,
                                                                 left_projection_map,
                                                                 right_projection_map_movie_companies_,
                                                                 delim_types_movie_companies_, 0);


    vector<idx_t> company_name_cn_ids{COLUMN_IDENTIFIER_ROW_ID, 1, 2};
    vector<LogicalType> get_company_name_cn_types{LogicalType::BIGINT, LogicalType::VARCHAR,
                                                  LogicalType::VARCHAR};
    string alias_company_name_cn = "cn";
    vector<LogicalType> table_types_company_name_cn;
    vector<unique_ptr<Expression>> filter_company_name_cn;
    unique_ptr<LogicalGet> get_op_company_name_cn = move(
            getLogicalGet(*this, table_company_name, alias_company_name_cn, table_index_company_name_cn,
                          table_types_company_name_cn));
    unique_ptr<TableFilterSet> table_filters_company_name_cn = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_cn = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL, Value("[us]"));
    table_filters_company_name_cn->filters[2] = move(constant_filter_cn);
    unique_ptr<PhysicalTableScan> scan_company_name_cn = make_uniq<PhysicalTableScan>(get_company_name_cn_types,
                                                                                      get_op_company_name_cn->function,
                                                                                      get_op_company_name_cn->table_index,
                                                                                      move(get_op_company_name_cn->bind_data),
                                                                                      table_types_company_name_cn,
                                                                                      company_name_cn_ids,
                                                                                      move(filter_company_name_cn),
                                                                                      vector<column_t>(),
                                                                                      get_op_company_name_cn->names,
                                                                                      std::move(
                                                                                              table_filters_company_name_cn),
                                                                                      get_op_company_name_cn->estimated_cardinality,
                                                                                      get_op_company_name_cn->extra_info);


    vector<JoinCondition> cond_company_name_cn;
    JoinCondition join_condition_company_name_cn;
    join_condition_company_name_cn.left = make_uniq<BoundReferenceExpression>("company_name_rowid", LogicalType::BIGINT, 0);
    join_condition_company_name_cn.right = make_uniq<BoundReferenceExpression>("company_id_rowid", LogicalType::BIGINT, 0);
    join_condition_company_name_cn.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_company_name_cn = make_uniq<RAIInfo>();
    rai_info_company_name_cn->rai = table_movie_companies.GetStorage().info->rais[0].get();
    rai_info_company_name_cn->rai_type = RAIType::SOURCE_EDGE;
    rai_info_company_name_cn->forward = false;
    rai_info_company_name_cn->vertex = &table_company_name;
    rai_info_company_name_cn->vertex_id = table_index_company_name_cn;
    rai_info_company_name_cn->passing_tables[0] = table_index_company_name_cn;
    rai_info_company_name_cn->left_cardinalities[0] = table_company_name.GetStorage().info->cardinality;
    // rai_info_company_name_cn->compact_list = &rai_info_company_name_cn->rai->alist->compact__list;

    join_condition_company_name_cn.rais.push_back(move(rai_info_company_name_cn));
    cond_company_name_cn.push_back(move(join_condition_company_name_cn));

    LogicalComparisonJoin join_company_name_cn_op(JoinType::INNER);
    vector<LogicalType> output_company_name_cn_types{LogicalType::BIGINT, LogicalType::VARCHAR,
                                                     LogicalType::VARCHAR, LogicalType::BIGINT,
                                                     LogicalType::BIGINT, LogicalType::VARCHAR,
                                                     LogicalType::BIGINT};
    join_company_name_cn_op.types = output_company_name_cn_types;
    vector<idx_t> right_projection_map_company_name_cn{1, 2, 3, 4};
    vector<idx_t> merge_project_map_company_name_cn;
    vector<LogicalType> delim_types_company_name_cn;
    auto join_company_name_cn = make_uniq<PhysicalSIPJoin>(join_company_name_cn_op, move(scan_company_name_cn), move(join_movie_companies_),
                                                           move(cond_company_name_cn), JoinType::INNER,
                                                           left_projection_map, right_projection_map_company_name_cn,
                                                           delim_types_company_name_cn, 0);


    vector<idx_t> kind_type_kt_ids{COLUMN_IDENTIFIER_ROW_ID, 1};
    vector<LogicalType> get_kind_type_kt_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_kind_type_kt = "kt";
    vector<LogicalType> table_types_kind_type_kt;
    vector<unique_ptr<Expression>> filter_kind_type_kt;
    unique_ptr<LogicalGet> get_op_kind_type_kt = move(
            getLogicalGet(*this, table_kind_type, alias_kind_type_kt, table_index_kind_type_kt,
                          table_types_kind_type_kt));
    unique_ptr<TableFilterSet> table_filters_kind_type_kt = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_kt = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL, Value("movie"));
    table_filters_kind_type_kt->filters[1] = move(constant_filter_kt);
    unique_ptr<PhysicalTableScan> scan_kind_type_kt = make_uniq<PhysicalTableScan>(get_kind_type_kt_types,
                                                                                   get_op_kind_type_kt->function,
                                                                                   get_op_kind_type_kt->table_index,
                                                                                   move(get_op_kind_type_kt->bind_data),
                                                                                   table_types_kind_type_kt,
                                                                                   kind_type_kt_ids,
                                                                                   move(filter_kind_type_kt),
                                                                                   vector<column_t>(),
                                                                                   get_op_kind_type_kt->names,
                                                                                   std::move(
                                                                                           table_filters_kind_type_kt),
                                                                                   get_op_kind_type_kt->estimated_cardinality,
                                                                                   get_op_kind_type_kt->extra_info);


    vector<JoinCondition> cond_kind_type_kt;
    JoinCondition join_condition_kind_type_kt;
    join_condition_kind_type_kt.left = make_uniq<BoundReferenceExpression>("kind_type_rowid", LogicalType::BIGINT, 0);
    join_condition_kind_type_kt.right = make_uniq<BoundReferenceExpression>("kind_id_rowid", LogicalType::BIGINT, 6);
    join_condition_kind_type_kt.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_kind_type_kt = make_uniq<RAIInfo>();
    rai_info_kind_type_kt->rai = table_title.GetStorage().info->rais[0].get();
    rai_info_kind_type_kt->rai_type = RAIType::TARGET_EDGE;
    rai_info_kind_type_kt->forward = true;
    rai_info_kind_type_kt->vertex = &table_kind_type;
    rai_info_kind_type_kt->vertex_id = table_index_kind_type_kt;
    rai_info_kind_type_kt->passing_tables[0] = table_index_kind_type_kt;
    rai_info_kind_type_kt->left_cardinalities[0] = table_kind_type.GetStorage().info->cardinality;
    // rai_info_kind_type_kt->compact_list = &rai_info_kind_type_kt->rai->alist->compact__list;

    join_condition_kind_type_kt.rais.push_back(move(rai_info_kind_type_kt));
    cond_kind_type_kt.push_back(move(join_condition_kind_type_kt));

    LogicalComparisonJoin join_kind_type_kt_op(JoinType::INNER);
    vector<LogicalType> output_kind_type_kt_types{LogicalType::BIGINT, LogicalType::VARCHAR,
                                                  LogicalType::BIGINT, LogicalType::BIGINT,
                                                  LogicalType::VARCHAR};
    join_kind_type_kt_op.types = output_kind_type_kt_types;
    vector<idx_t> right_projection_map_kind_type_kt{3, 4, 5};
    vector<idx_t> merge_project_map_kind_type_kt;
    vector<LogicalType> delim_types_kind_type_kt;
    auto join_kind_type_kt = make_uniq<PhysicalSIPJoin>(join_kind_type_kt_op, move(scan_kind_type_kt), move(join_company_name_cn), move(cond_kind_type_kt),
                                                        JoinType::INNER, left_projection_map,
                                                        right_projection_map_kind_type_kt, delim_types_kind_type_kt, 0);


    vector<idx_t> company_type_ct_ids{COLUMN_IDENTIFIER_ROW_ID};
    vector<LogicalType> get_company_type_ct_types{LogicalType::BIGINT};
    string alias_company_type_ct = "ct";
    vector<LogicalType> table_types_company_type_ct;
    vector<unique_ptr<Expression>> filter_company_type_ct;
    unique_ptr<LogicalGet> get_op_company_type_ct = move(
            getLogicalGet(*this, table_company_type, alias_company_type_ct, table_index_company_type_ct,
                          table_types_company_type_ct));
    unique_ptr<TableFilterSet> table_filters_company_type_ct = NULL;
    unique_ptr<PhysicalTableScan> scan_company_type_ct = make_uniq<PhysicalTableScan>(get_company_type_ct_types,
                                                                                      get_op_company_type_ct->function,
                                                                                      get_op_company_type_ct->table_index,
                                                                                      move(get_op_company_type_ct->bind_data),
                                                                                      table_types_company_type_ct,
                                                                                      company_type_ct_ids,
                                                                                      move(filter_company_type_ct),
                                                                                      vector<column_t>(),
                                                                                      get_op_company_type_ct->names,
                                                                                      std::move(
                                                                                              table_filters_company_type_ct),
                                                                                      get_op_company_type_ct->estimated_cardinality,
                                                                                      get_op_company_type_ct->extra_info);


    vector<JoinCondition> cond_ct;
    JoinCondition join_condition_ct;
    join_condition_ct.left = make_uniq<BoundReferenceExpression>("company_type_rowid", LogicalType::BIGINT, 0);
    join_condition_ct.right = make_uniq<BoundReferenceExpression>("company_type_id_rowid", LogicalType::BIGINT, 3);
    join_condition_ct.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_ct = make_uniq<RAIInfo>();
    rai_info_ct->rai = table_movie_companies.GetStorage().info->rais[1].get();
    rai_info_ct->rai_type = RAIType::SOURCE_EDGE;
    rai_info_ct->forward = false;
    rai_info_ct->vertex = &table_company_type;
    rai_info_ct->vertex_id = table_index_company_type_ct;
    rai_info_ct->passing_tables[0] = table_index_company_type_ct;
    rai_info_ct->left_cardinalities[0] = table_company_type.GetStorage().info->cardinality;
    // rai_info_ct->compact_list = &rai_info_ct->rai->alist->compact__list;

    join_condition_ct.rais.push_back(move(rai_info_ct));
    cond_ct.push_back(move(join_condition_ct));

    LogicalComparisonJoin join_ct_op(JoinType::INNER);
    vector<LogicalType> output_ct_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::BIGINT,
                                        LogicalType::VARCHAR};
    join_ct_op.types = output_ct_types;
    vector<idx_t> right_projection_map_ct{1, 2, 4};
    vector<idx_t> merge_project_map_ct;
    vector<LogicalType> delim_types_ct;
    auto join_ct = make_uniq<PhysicalSIPJoin>(join_ct_op, move(scan_company_type_ct), move(join_kind_type_kt),
                                              move(cond_ct), JoinType::INNER,
                                              left_projection_map,
                                              right_projection_map_ct,
                                              delim_types_ct, 0);


    vector<idx_t> keyword_k_ids{COLUMN_IDENTIFIER_ROW_ID};
    vector<LogicalType> get_keyword_k_types{LogicalType::BIGINT};
    string alias_keyword_k = "k";
    vector<LogicalType> table_types_keyword_k;
    vector<unique_ptr<Expression>> filter_keyword_k;
    unique_ptr<LogicalGet> get_op_keyword_k = move(
            getLogicalGet(*this, table_keyword, alias_keyword_k, table_index_keyword_k, table_types_keyword_k));
    unique_ptr<TableFilterSet> table_filters_keyword_k = NULL;
    unique_ptr<PhysicalTableScan> scan_keyword_k = make_uniq<PhysicalTableScan>(get_keyword_k_types,
                                                                                get_op_keyword_k->function,
                                                                                get_op_keyword_k->table_index,
                                                                                move(get_op_keyword_k->bind_data),
                                                                                table_types_keyword_k, keyword_k_ids,
                                                                                move(filter_keyword_k),
                                                                                vector<column_t>(),
                                                                                get_op_keyword_k->names,
                                                                                std::move(table_filters_keyword_k),
                                                                                get_op_keyword_k->estimated_cardinality,
                                                                                get_op_keyword_k->extra_info);


    vector<JoinCondition> cond_movie_keyword_;
    JoinCondition join_condition_movie_keyword_;
    join_condition_movie_keyword_.left = make_uniq<BoundReferenceExpression>("keyword_rowid", LogicalType::BIGINT, 0);
    join_condition_movie_keyword_.right = make_uniq<BoundReferenceExpression>("movie_id_rowid", LogicalType::BIGINT, 2);
    join_condition_movie_keyword_.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_movie_keyword_ = make_uniq<RAIInfo>();
    rai_info_movie_keyword_->rai = table_movie_keyword.GetStorage().info->rais[0].get();
    rai_info_movie_keyword_->rai_type = RAIType::SOURCE_EDGE;
    rai_info_movie_keyword_->forward = false;
    rai_info_movie_keyword_->vertex = &table_keyword;
    rai_info_movie_keyword_->vertex_id = table_index_keyword_k;
    rai_info_movie_keyword_->passing_tables[0] = table_index_keyword_k;
    rai_info_movie_keyword_->left_cardinalities[0] = table_keyword.GetStorage().info->cardinality;
    // rai_info_movie_keyword_->compact_list = &rai_info_movie_keyword_->rai->alist->compact__list;

    join_condition_movie_keyword_.rais.push_back(move(rai_info_movie_keyword_));
    cond_movie_keyword_.push_back(move(join_condition_movie_keyword_));

    LogicalComparisonJoin join_movie_keyword__op(JoinType::INNER);
    vector<LogicalType> output_movie_keyword__types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::VARCHAR};
    join_movie_keyword__op.types = output_movie_keyword__types;
    vector<idx_t> right_projection_map_movie_keyword_{1, 3};
    vector<idx_t> merge_project_map_movie_keyword_;
    vector<LogicalType> delim_types_movie_keyword_;
    auto join_movie_keyword_ = make_uniq<PhysicalMergeSIPJoin>(join_movie_keyword__op, move(scan_keyword_k), move(join_ct),
                                                               move(cond_movie_keyword_), JoinType::INNER,
                                                               left_projection_map, right_projection_map_movie_keyword_,
                                                               merge_project_map_movie_keyword_,
                                                               delim_types_movie_keyword_, 0);


    vector<LogicalType> result_types{LogicalType::VARCHAR, LogicalType::VARCHAR};
    vector<unique_ptr<Expression>> select_list;
    auto result_col0 = make_uniq<BoundReferenceExpression>("kind", LogicalType::VARCHAR, 1);
    auto result_col1 = make_uniq<BoundReferenceExpression>("title", LogicalType::VARCHAR, 2);
    select_list.push_back(move(result_col0));
    select_list.push_back(move(result_col1));
    auto projection = make_uniq<PhysicalProjection>(result_types, move(select_list), 0);
    projection->children.push_back(move(join_movie_keyword_));

    // aggregate
    string agg_name = "min";
    string agg_error = "";
    QueryErrorContext error_context(NULL, NULL);
    auto min_func = Catalog::GetEntry(context, CatalogType::SCALAR_FUNCTION_ENTRY, "", "",
                                      "min", OnEntryNotFound::RETURN_NULL, error_context);
    auto &min_func_set = min_func->Cast<AggregateFunctionCatalogEntry>();
    // bind the aggregate
    FunctionBinder function_binder(context);
    vector<LogicalType> types;
    types.push_back(LogicalType::VARCHAR);
    idx_t best_function_varchar = function_binder.BindFunction(agg_name, min_func_set.functions, types, agg_error);
    auto bound_function_min_varchar = min_func_set.functions.GetFunctionByOffset(best_function_varchar);

    auto first_children = make_uniq<BoundReferenceExpression>("name", LogicalType::VARCHAR, 0);
    vector<unique_ptr<Expression>> childrenlist1;
    childrenlist1.push_back(move(first_children));
    auto aggregate1 =
            function_binder.BindAggregateFunction(bound_function_min_varchar, std::move(childrenlist1), nullptr,
                                                  AggregateType::NON_DISTINCT);

    auto second_children = make_uniq<BoundReferenceExpression>("title", LogicalType::VARCHAR, 1);
    vector<unique_ptr<Expression>> childrenlist2;
    childrenlist2.push_back(move(second_children));
    auto aggregate2 =
            function_binder.BindAggregateFunction(bound_function_min_varchar, std::move(childrenlist2), nullptr,
                                                  AggregateType::NON_DISTINCT);

    vector<unique_ptr<Expression>> aggregates;
    aggregates.push_back(move(aggregate1));
    aggregates.push_back(move(aggregate2));

    vector<LogicalType> aggregate_types{LogicalType::VARCHAR, LogicalType::VARCHAR};
    auto ungrouped_aggregate = make_uniq<PhysicalUngroupedAggregate>(aggregate_types, move(aggregates), 0);
    ungrouped_aggregate->children.push_back(move(projection));

    return ungrouped_aggregate;
}

unique_ptr<PhysicalOperator> ClientContext::GenerateJOB24aPlan(ClientContext& context) {
    vector<idx_t> left_projection_map, right_projection_map;

    string table_vertex_keyword_k = "keyword";
    string table_vertex_title_t = "title";
    string table_vertex_info_type_it = "info_type";
    string table_vertex_company_name_cn = "company_name";
    string table_vertex_name_n = "name";
    string table_vertex_aka_name_an = "aka_name";
    string table_vertex_role_type_rt = "role_type";
    string table_vertex_char_name_chn = "char_name";
    string table_vertex_movie_keyword_ = "movie_keyword";
    string table_vertex_movie_info_ = "movie_info";
    string table_vertex_movie_companies_ = "movie_companies";
    string table_vertex_cast_info_ = "cast_info";

    idx_t table_index_keyword_k = 1;
    idx_t table_index_title_t = 2;
    idx_t table_index_info_type_it = 3;
    idx_t table_index_company_name_cn = 4;
    idx_t table_index_name_n = 5;
    idx_t table_index_aka_name_an = 6;
    idx_t table_index_role_type_rt = 7;
    idx_t table_index_char_name_chn = 8;
    idx_t table_index_movie_keyword_ = 9;
    idx_t table_index_movie_info_ = 10;
    idx_t table_index_movie_companies_ = 11;
    idx_t table_index_cast_info_ = 15;

    auto table_or_view_keyword = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_keyword_k,
                                                   OnEntryNotFound::RETURN_NULL);
    auto &table_keyword = table_or_view_keyword->Cast<TableCatalogEntry>();
    auto table_or_view_title = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_title_t,
                                                 OnEntryNotFound::RETURN_NULL);
    auto &table_title = table_or_view_title->Cast<TableCatalogEntry>();
    auto table_or_view_info_type = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_info_type_it,
                                                     OnEntryNotFound::RETURN_NULL);
    auto &table_info_type = table_or_view_info_type->Cast<TableCatalogEntry>();
    auto table_or_view_company_name = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                        table_vertex_company_name_cn, OnEntryNotFound::RETURN_NULL);
    auto &table_company_name = table_or_view_company_name->Cast<TableCatalogEntry>();
    auto table_or_view_name = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_name_n,
                                                OnEntryNotFound::RETURN_NULL);
    auto &table_name = table_or_view_name->Cast<TableCatalogEntry>();
    auto table_or_view_aka_name = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_aka_name_an,
                                                    OnEntryNotFound::RETURN_NULL);
    auto &table_aka_name = table_or_view_aka_name->Cast<TableCatalogEntry>();
    auto table_or_view_role_type = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_role_type_rt,
                                                     OnEntryNotFound::RETURN_NULL);
    auto &table_role_type = table_or_view_role_type->Cast<TableCatalogEntry>();
    auto table_or_view_char_name = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                     table_vertex_char_name_chn, OnEntryNotFound::RETURN_NULL);
    auto &table_char_name = table_or_view_char_name->Cast<TableCatalogEntry>();
    auto table_or_view_movie_keyword = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                         table_vertex_movie_keyword_, OnEntryNotFound::RETURN_NULL);
    auto &table_movie_keyword = table_or_view_movie_keyword->Cast<TableCatalogEntry>();
    auto table_or_view_movie_info = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_movie_info_,
                                                      OnEntryNotFound::RETURN_NULL);
    auto &table_movie_info = table_or_view_movie_info->Cast<TableCatalogEntry>();
    auto table_or_view_movie_companies = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                           table_vertex_movie_companies_, OnEntryNotFound::RETURN_NULL);
    auto &table_movie_companies = table_or_view_movie_companies->Cast<TableCatalogEntry>();
    auto table_or_view_cast_info = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_cast_info_,
                                                     OnEntryNotFound::RETURN_NULL);
    auto &table_cast_info = table_or_view_cast_info->Cast<TableCatalogEntry>();

    vector<idx_t> role_type_rt_ids{COLUMN_IDENTIFIER_ROW_ID, 1};
    vector<LogicalType> get_role_type_rt_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_role_type_rt = "rt";
    vector<LogicalType> table_types_role_type_rt;
    vector<unique_ptr<Expression>> filter_role_type_rt;
    unique_ptr<LogicalGet> get_op_role_type_rt = move(
            getLogicalGet(*this, table_role_type, alias_role_type_rt, table_index_role_type_rt,
                          table_types_role_type_rt));
    unique_ptr<TableFilterSet> table_filters_role_type_rt = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_rt = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL, Value("actress"));
    table_filters_role_type_rt->filters[1] = move(constant_filter_rt);
    unique_ptr<PhysicalTableScan> scan_role_type_rt = make_uniq<PhysicalTableScan>(get_role_type_rt_types,
                                                                                   get_op_role_type_rt->function,
                                                                                   get_op_role_type_rt->table_index,
                                                                                   move(get_op_role_type_rt->bind_data),
                                                                                   table_types_role_type_rt,
                                                                                   role_type_rt_ids,
                                                                                   move(filter_role_type_rt),
                                                                                   vector<column_t>(),
                                                                                   get_op_role_type_rt->names,
                                                                                   std::move(
                                                                                           table_filters_role_type_rt),
                                                                                   get_op_role_type_rt->estimated_cardinality,
                                                                                   get_op_role_type_rt->extra_info);

    vector<idx_t> cast_info_ids{4, 7, 8, 9, 10};
    vector<LogicalType> get_cast_info_types{LogicalType::VARCHAR, LogicalType::BIGINT,
                                            LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::BIGINT};
    string alias_cast_info = "ci";
    vector<LogicalType> table_types_cast_info;
    vector<unique_ptr<Expression>> filter_cast_info;
    unique_ptr<LogicalGet> get_op_cast_info = move(
            getLogicalGet(*this, table_cast_info, alias_cast_info, table_index_cast_info_, table_types_cast_info));
    unique_ptr<TableFilterSet> table_filters_cast_info = NULL;
    unique_ptr<PhysicalTableScan> scan_cast_info = make_uniq<PhysicalTableScan>(get_cast_info_types,
                                                                                get_op_cast_info->function,
                                                                                get_op_cast_info->table_index,
                                                                                move(get_op_cast_info->bind_data),
                                                                                table_types_cast_info, cast_info_ids,
                                                                                move(filter_cast_info),
                                                                                vector<column_t>(),
                                                                                get_op_cast_info->names,
                                                                                std::move(table_filters_cast_info),
                                                                                get_op_cast_info->estimated_cardinality,
                                                                                get_op_cast_info->extra_info);

    auto &allocator = Allocator::Get(context);
    vector<LogicalType> join_in_types {LogicalType::VARCHAR};
    auto collection =
            make_uniq<ColumnDataCollection>(context, join_in_types, ColumnDataAllocatorType::IN_MEMORY_ALLOCATOR);

    vector<LogicalType> chunk_in_types {LogicalType::VARCHAR};
    DataChunk chunk;
    chunk.SetCardinality(4);
    chunk.Initialize(allocator, chunk_in_types);
    chunk.SetValue(0, 0, Value("(voice)"));
    chunk.SetValue(0, 1, Value("(voice: Japanese version)"));
    chunk.SetValue(0, 2, Value("(voice) (uncredited)"));
    chunk.SetValue(0, 3, Value("(voice: English version)"));
    collection->Append(chunk);

    // create a chunk scan to output the result
    vector<LogicalType> ouput_in_types {LogicalType::VARCHAR};
    auto chunk_scan = make_uniq<PhysicalColumnDataScan>(ouput_in_types, PhysicalOperatorType::COLUMN_DATA_SCAN,
                                                        4, std::move(collection));

    vector<JoinCondition> cond_hash_join_;
    JoinCondition join_condition_hash_join_;
    join_condition_hash_join_.left = make_uniq<BoundReferenceExpression>("note", LogicalType::VARCHAR, 0);
    join_condition_hash_join_.right = make_uniq<BoundReferenceExpression>("", LogicalType::VARCHAR, 0);
    join_condition_hash_join_.comparison = ExpressionType::COMPARE_EQUAL;
    cond_hash_join_.push_back(move(join_condition_hash_join_));

    LogicalComparisonJoin join_hash_join_op(JoinType::MARK);
    vector<LogicalType> output_hash_join_types{LogicalType::VARCHAR, LogicalType::BIGINT, LogicalType::BIGINT,
                                               LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::BOOLEAN};
    join_hash_join_op.types = output_hash_join_types;
    vector<idx_t> right_projection_map_hash_join_;
    vector<LogicalType> delim_types_hash_join_;
    PerfectHashJoinStats joinstate;
    auto join_hash_join_ = make_uniq<PhysicalHashJoin>(join_hash_join_op, move(scan_cast_info), move(chunk_scan), move(cond_hash_join_),
                                                       JoinType::MARK, left_projection_map,
                                                       right_projection_map_hash_join_,
                                                       delim_types_hash_join_, 0, joinstate);

    vector<LogicalType> filter_in_types{LogicalType::VARCHAR, LogicalType::BIGINT, LogicalType::BIGINT,
                                        LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::BOOLEAN};
    vector<unique_ptr<Expression>> select_list_in;
    auto in_exp = make_uniq<BoundReferenceExpression>("IN (...)", LogicalType::BOOLEAN, 5);
    select_list_in.push_back(move(in_exp));
    unique_ptr<PhysicalFilter> filter_in = make_uniq<PhysicalFilter>(filter_in_types, move(select_list_in), 0);
    filter_in->children.push_back(move(join_hash_join_));

    vector<JoinCondition> cond_cast_info_;
    JoinCondition join_condition_cast_info_;
    join_condition_cast_info_.left = make_uniq<BoundReferenceExpression>("role_id_rowid", LogicalType::BIGINT, 3);
    join_condition_cast_info_.right = make_uniq<BoundReferenceExpression>("role_type_rowid", LogicalType::BIGINT, 0);
    join_condition_cast_info_.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_cast_info_ = make_uniq<RAIInfo>();
    rai_info_cast_info_->rai = table_cast_info.GetStorage().info->rais[2].get();
    rai_info_cast_info_->rai_type = RAIType::EDGE_SOURCE;
    rai_info_cast_info_->forward = true;
    rai_info_cast_info_->vertex = &table_role_type;
    rai_info_cast_info_->vertex_id = table_index_role_type_rt;
    rai_info_cast_info_->passing_tables[0] = table_index_cast_info_;
    rai_info_cast_info_->left_cardinalities[0] = table_cast_info.GetStorage().info->cardinality;
    rai_info_cast_info_->compact_list = &rai_info_cast_info_->rai->alist->compact_forward_list;

    join_condition_cast_info_.rais.push_back(move(rai_info_cast_info_));
    cond_cast_info_.push_back(move(join_condition_cast_info_));

    LogicalComparisonJoin join_cast_info__op(JoinType::INNER);
    vector<LogicalType> output_cast_info__types{LogicalType::VARCHAR, LogicalType::BIGINT, LogicalType::BIGINT,
                                                LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::BOOLEAN,
                                                LogicalType::BIGINT};
    join_cast_info__op.types = output_cast_info__types;
    vector<idx_t> right_projection_map_cast_info_{0};
    vector<idx_t> merge_project_map_cast_info_;
    vector<LogicalType> delim_types_cast_info_;
    auto join_cast_info_ = make_uniq<PhysicalSIPJoin>(join_cast_info__op, move(filter_in), move(scan_role_type_rt), move(cond_cast_info_),
                                                           JoinType::INNER, left_projection_map,
                                                           right_projection_map_cast_info_,
                                                           delim_types_cast_info_, 0);


    vector<idx_t> title_t_ids{COLUMN_IDENTIFIER_ROW_ID, 1, 4};
    vector<LogicalType> get_title_t_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::BIGINT};
    string alias_title_t = "t";
    vector<LogicalType> table_types_title_t;
    vector<unique_ptr<Expression>> filter_title_t;
    unique_ptr<LogicalGet> get_op_title_t = move(
            getLogicalGet(*this, table_title, alias_title_t, table_index_title_t, table_types_title_t));
    unique_ptr<TableFilterSet> table_filters_title_t = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_t = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_GREATERTHAN, Value(2010));
    table_filters_title_t->filters[2] = move(constant_filter_t);
    unique_ptr<PhysicalTableScan> scan_title_t = make_uniq<PhysicalTableScan>(get_title_t_types,
                                                                              get_op_title_t->function,
                                                                              get_op_title_t->table_index,
                                                                              move(get_op_title_t->bind_data),
                                                                              table_types_title_t, title_t_ids,
                                                                              move(filter_title_t), vector<column_t>(),
                                                                              get_op_title_t->names,
                                                                              std::move(table_filters_title_t),
                                                                              get_op_title_t->estimated_cardinality,
                                                                              get_op_title_t->extra_info);


    vector<JoinCondition> cond_title_t;
    JoinCondition join_condition_title_t;
    join_condition_title_t.left = make_uniq<BoundReferenceExpression>("title_rowid", LogicalType::BIGINT, 0);
    join_condition_title_t.right = make_uniq<BoundReferenceExpression>("movie_id_rowid", LogicalType::BIGINT, 1);
    join_condition_title_t.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_title_t = make_uniq<RAIInfo>();
    rai_info_title_t->rai = table_cast_info.GetStorage().info->rais[2].get();
    rai_info_title_t->rai_type = RAIType::TARGET_EDGE;
    rai_info_title_t->forward = true;
    rai_info_title_t->vertex = &table_title;
    rai_info_title_t->vertex_id = table_index_title_t;
    rai_info_title_t->passing_tables[0] = table_index_title_t;
    rai_info_title_t->left_cardinalities[0] = table_title.GetStorage().info->cardinality;
    // rai_info_title_t->compact_list = &rai_info_title_t->rai->alist->compact__list;

    join_condition_title_t.rais.push_back(move(rai_info_title_t));
    cond_title_t.push_back(move(join_condition_title_t));

    LogicalComparisonJoin join_title_t_op(JoinType::INNER);
    vector<LogicalType> output_title_t_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::BIGINT,
                                             LogicalType::BIGINT, LogicalType::BIGINT};
    join_title_t_op.types = output_title_t_types;
    vector<idx_t> right_projection_map_title_t{2, 4};
    vector<idx_t> merge_project_map_title_t;
    vector<LogicalType> delim_types_title_t;
    auto join_title_t = make_uniq<PhysicalSIPJoin>(join_title_t_op, move(scan_title_t), move(join_cast_info_), move(cond_title_t), JoinType::INNER,
                                                   left_projection_map, right_projection_map_title_t,
                                                   delim_types_title_t, 0);

    vector<idx_t> movie_info_ids{6, 5, 3};
    vector<LogicalType> get_movie_info_types{LogicalType::BIGINT, LogicalType::BIGINT,
                                             LogicalType::VARCHAR};
    string alias_movie_info = "i";
    vector<LogicalType> table_types_movie_info;
    vector<unique_ptr<Expression>> filter_movie_info;
    unique_ptr<LogicalGet> get_op_movie_info = move(
            getLogicalGet(*this, table_movie_info, alias_movie_info, table_index_movie_info_, table_types_movie_info));
    unique_ptr<TableFilterSet> table_filters_movie_info = NULL;
    unique_ptr<PhysicalTableScan> scan_movie_info = make_uniq<PhysicalTableScan>(get_movie_info_types,
                                                                                 get_op_movie_info->function,
                                                                                 get_op_movie_info->table_index,
                                                                                 move(get_op_movie_info->bind_data),
                                                                                 table_types_movie_info,
                                                                                 movie_info_ids,
                                                                                 move(filter_movie_info),
                                                                                 vector<column_t>(),
                                                                                 get_op_movie_info->names,
                                                                                 std::move(table_filters_movie_info),
                                                                                 get_op_movie_info->estimated_cardinality,
                                                                                 get_op_movie_info->extra_info);

    string p_movie_info_info1 = "Japan:%201%";
    string p_movie_info_info2 = "USA:%201%";
    Value p_info_info1 = Value(p_movie_info_info1);
    Value p_info_info2 = Value(p_movie_info_info2);
    vector<LogicalType> filter_mi_types{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::VARCHAR};
    vector<unique_ptr<Expression>> select_list_movie_info;
    vector<unique_ptr<Expression>> like_arguments2_mi, like_arguments3_mi;

    auto like_expression_left2_mi = make_uniq<BoundReferenceExpression>("info", LogicalType::VARCHAR, 2);
    auto like_expression_value2_mi = make_uniq<BoundConstantExpression>(p_info_info1);
    like_arguments2_mi.push_back(move(like_expression_left2_mi));
    like_arguments2_mi.push_back(move(like_expression_value2_mi));

    auto like_expression_left3_mi = make_uniq<BoundReferenceExpression>("info", LogicalType::VARCHAR, 2);
    auto like_expression_value3_mi = make_uniq<BoundConstantExpression>(p_info_info2);
    like_arguments3_mi.push_back(move(like_expression_left3_mi));
    like_arguments3_mi.push_back(move(like_expression_value3_mi));

    ScalarFunction bound_function_contains = ContainsFun::GetFunction();
    ScalarFunction bound_function_like = LikeFun::GetLikeFunction();

    unique_ptr<FunctionData> bind_data_like_mi2 = NULL;
    auto like_bound_function2_mi = make_uniq<BoundFunctionExpression>(LogicalType::BOOLEAN,
                                                                      bound_function_like,
                                                                      move(like_arguments2_mi),
                                                                      move(bind_data_like_mi2), false);

    unique_ptr<FunctionData> bind_data_like_mi3 = NULL;
    auto like_bound_function3_mi = make_uniq<BoundFunctionExpression>(LogicalType::BOOLEAN,
                                                                      bound_function_like,
                                                                      move(like_arguments3_mi),
                                                                      move(bind_data_like_mi3), false);

    auto mi_not_null_bound_function = make_uniq<BoundOperatorExpression>(ExpressionType::OPERATOR_IS_NOT_NULL, LogicalType::BOOLEAN);
    auto mi_not_null = make_uniq<BoundReferenceExpression>("info", LogicalType::VARCHAR, 2);
    mi_not_null_bound_function->children.push_back(move(mi_not_null));

    auto or_conjunction = make_uniq<BoundConjunctionExpression>(ExpressionType::CONJUNCTION_OR);
    or_conjunction->children.push_back(move(like_bound_function2_mi));
    or_conjunction->children.push_back(move(like_bound_function3_mi));

    select_list_movie_info.push_back(move(mi_not_null_bound_function));
    select_list_movie_info.push_back(move(or_conjunction));
    unique_ptr<PhysicalFilter> filter_mi_contains = make_uniq<PhysicalFilter>(filter_mi_types, move(select_list_movie_info), 0);
    filter_mi_contains->children.push_back(move(scan_movie_info));


    vector<JoinCondition> cond_movie_info_;
    JoinCondition join_condition_movie_info_;
    join_condition_movie_info_.left = make_uniq<BoundReferenceExpression>("movie_id_rowid", LogicalType::BIGINT, 0);
    join_condition_movie_info_.right = make_uniq<BoundReferenceExpression>("title_rowid", LogicalType::BIGINT, 0);
    join_condition_movie_info_.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_movie_info_ = make_uniq<RAIInfo>();
    rai_info_movie_info_->rai = table_movie_info.GetStorage().info->rais[0].get();
    rai_info_movie_info_->rai_type = RAIType::EDGE_TARGET;
    rai_info_movie_info_->forward = false;
    rai_info_movie_info_->vertex = &table_title;
    rai_info_movie_info_->vertex_id = table_index_title_t;
    rai_info_movie_info_->passing_tables[0] = table_index_movie_info_;
    rai_info_movie_info_->left_cardinalities[0] = table_movie_info.GetStorage().info->cardinality;
    rai_info_movie_info_->compact_list = &rai_info_movie_info_->rai->alist->compact_backward_list;

    join_condition_movie_info_.rais.push_back(move(rai_info_movie_info_));
    cond_movie_info_.push_back(move(join_condition_movie_info_));

    LogicalComparisonJoin join_movie_info__op(JoinType::INNER);
    vector<LogicalType> output_movie_info__types{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::VARCHAR,
                                                 LogicalType::VARCHAR, LogicalType::BIGINT, LogicalType::BIGINT};
    join_movie_info__op.types = output_movie_info__types;
    vector<idx_t> right_projection_map_movie_info_{1, 3, 4};
    vector<idx_t> merge_project_map_movie_info_;
    vector<LogicalType> delim_types_movie_info_;
    auto join_movie_info_ = make_uniq<PhysicalSIPJoin>(join_movie_info__op, move(filter_mi_contains), move(join_title_t), move(cond_movie_info_),
                                                            JoinType::INNER, left_projection_map,
                                                            right_projection_map_movie_info_,
                                                            delim_types_movie_info_, 0);


    vector<idx_t> info_type_it_ids{COLUMN_IDENTIFIER_ROW_ID, 1};
    vector<LogicalType> get_info_type_it_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_info_type_it = "it";
    vector<LogicalType> table_types_info_type_it;
    vector<unique_ptr<Expression>> filter_info_type_it;
    unique_ptr<LogicalGet> get_op_info_type_it = move(
            getLogicalGet(*this, table_info_type, alias_info_type_it, table_index_info_type_it,
                          table_types_info_type_it));
    unique_ptr<TableFilterSet> table_filters_info_type_it = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_it = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL, Value("release dates"));
    table_filters_info_type_it->filters[1] = move(constant_filter_it);
    unique_ptr<PhysicalTableScan> scan_info_type_it = make_uniq<PhysicalTableScan>(get_info_type_it_types,
                                                                                   get_op_info_type_it->function,
                                                                                   get_op_info_type_it->table_index,
                                                                                   move(get_op_info_type_it->bind_data),
                                                                                   table_types_info_type_it,
                                                                                   info_type_it_ids,
                                                                                   move(filter_info_type_it),
                                                                                   vector<column_t>(),
                                                                                   get_op_info_type_it->names,
                                                                                   std::move(
                                                                                           table_filters_info_type_it),
                                                                                   get_op_info_type_it->estimated_cardinality,
                                                                                   get_op_info_type_it->extra_info);


    vector<JoinCondition> cond_info_type_it;
    JoinCondition join_condition_info_type_it;
    join_condition_info_type_it.left = make_uniq<BoundReferenceExpression>("info_type_rowid", LogicalType::BIGINT, 0);
    join_condition_info_type_it.right = make_uniq<BoundReferenceExpression>("info_type_id_rowid", LogicalType::BIGINT, 1);
    join_condition_info_type_it.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_info_type_it = make_uniq<RAIInfo>();
    rai_info_info_type_it->rai = table_movie_info.GetStorage().info->rais[0].get();
    rai_info_info_type_it->rai_type = RAIType::SOURCE_EDGE;
    rai_info_info_type_it->forward = false;
    rai_info_info_type_it->vertex = &table_info_type;
    rai_info_info_type_it->vertex_id = table_index_info_type_it;
    rai_info_info_type_it->passing_tables[0] = table_index_info_type_it;
    rai_info_info_type_it->left_cardinalities[0] = table_info_type.GetStorage().info->cardinality;
    // rai_info_info_type_it->compact_list = &rai_info_info_type_it->rai->alist->compact__list;

    join_condition_info_type_it.rais.push_back(move(rai_info_info_type_it));
    cond_info_type_it.push_back(move(join_condition_info_type_it));

    LogicalComparisonJoin join_info_type_it_op(JoinType::INNER);
    vector<LogicalType> output_info_type_it_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::BIGINT,
                                                  LogicalType::VARCHAR, LogicalType::BIGINT, LogicalType::BIGINT};
    join_info_type_it_op.types = output_info_type_it_types;
    vector<idx_t> right_projection_map_info_type_it{0, 3, 4, 5};
    vector<idx_t> merge_project_map_info_type_it;
    vector<LogicalType> delim_types_info_type_it;
    auto join_info_type_it = make_uniq<PhysicalSIPJoin>(join_info_type_it_op, move(scan_info_type_it), move(join_movie_info_), move(cond_info_type_it),
                                                        JoinType::INNER, left_projection_map,
                                                        right_projection_map_info_type_it, delim_types_info_type_it, 0);


    vector<idx_t> company_name_cn_ids{COLUMN_IDENTIFIER_ROW_ID, 2};
    vector<LogicalType> get_company_name_cn_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_company_name_cn = "cn";
    vector<LogicalType> table_types_company_name_cn;
    vector<unique_ptr<Expression>> filter_company_name_cn;
    unique_ptr<LogicalGet> get_op_company_name_cn = move(
            getLogicalGet(*this, table_company_name, alias_company_name_cn, table_index_company_name_cn,
                          table_types_company_name_cn));
    unique_ptr<TableFilterSet> table_filters_company_name_cn = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_cn = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL, Value("[us]"));
    table_filters_company_name_cn->filters[1] = move(constant_filter_cn);
    unique_ptr<PhysicalTableScan> scan_company_name_cn = make_uniq<PhysicalTableScan>(get_company_name_cn_types,
                                                                                      get_op_company_name_cn->function,
                                                                                      get_op_company_name_cn->table_index,
                                                                                      move(get_op_company_name_cn->bind_data),
                                                                                      table_types_company_name_cn,
                                                                                      company_name_cn_ids,
                                                                                      move(filter_company_name_cn),
                                                                                      vector<column_t>(),
                                                                                      get_op_company_name_cn->names,
                                                                                      std::move(
                                                                                              table_filters_company_name_cn),
                                                                                      get_op_company_name_cn->estimated_cardinality,
                                                                                      get_op_company_name_cn->extra_info);


    vector<JoinCondition> cond_company_name_cn;
    JoinCondition join_condition_company_name_cn;
    join_condition_company_name_cn.left = make_uniq<BoundReferenceExpression>("company_name_rowid", LogicalType::BIGINT, 0);
    join_condition_company_name_cn.right = make_uniq<BoundReferenceExpression>("movie_id_rowid", LogicalType::BIGINT, 2);
    join_condition_company_name_cn.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_company_name_cn = make_uniq<RAIInfo>();
    rai_info_company_name_cn->rai = table_movie_companies.GetStorage().info->rais[0].get();
    rai_info_company_name_cn->rai_type = RAIType::SOURCE_EDGE;
    rai_info_company_name_cn->forward = false;
    rai_info_company_name_cn->vertex = &table_company_name;
    rai_info_company_name_cn->vertex_id = table_index_company_name_cn;
    rai_info_company_name_cn->passing_tables[0] = table_index_company_name_cn;
    rai_info_company_name_cn->left_cardinalities[0] = table_company_name.GetStorage().info->cardinality;
    // rai_info_company_name_cn->compact_list = &rai_info_company_name_cn->rai->alist->compact__list;

    join_condition_company_name_cn.rais.push_back(move(rai_info_company_name_cn));
    cond_company_name_cn.push_back(move(join_condition_company_name_cn));

    LogicalComparisonJoin join_company_name_cn_op(JoinType::INNER);
    vector<LogicalType> output_company_name_cn_types{LogicalType::BIGINT, LogicalType::VARCHAR,
                                                     LogicalType::BIGINT, LogicalType::VARCHAR,
                                                     LogicalType::BIGINT, LogicalType::BIGINT};
    join_company_name_cn_op.types = output_company_name_cn_types;
    vector<idx_t> right_projection_map_company_name_cn{2, 3, 4, 5};
    vector<idx_t> merge_project_map_company_name_cn;
    vector<LogicalType> delim_types_company_name_cn;
    auto join_company_name_cn = make_uniq<PhysicalMergeSIPJoin>(join_company_name_cn_op, move(scan_company_name_cn), move(join_info_type_it),
                                                           move(cond_company_name_cn), JoinType::INNER,
                                                           left_projection_map, right_projection_map_company_name_cn,
                                                           merge_project_map_company_name_cn, delim_types_company_name_cn, 0);




    vector<idx_t> keyword_k_ids{COLUMN_IDENTIFIER_ROW_ID, 1};
    vector<LogicalType> get_keyword_k_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_keyword_k = "k";
    vector<LogicalType> table_types_keyword_k;
    vector<unique_ptr<Expression>> filter_keyword_k;
    unique_ptr<LogicalGet> get_op_keyword_k = move(
            getLogicalGet(*this, table_keyword, alias_keyword_k, table_index_keyword_k, table_types_keyword_k));
    unique_ptr<TableFilterSet> table_filters_keyword_k = NULL;
    unique_ptr<PhysicalTableScan> scan_keyword_k = make_uniq<PhysicalTableScan>(get_keyword_k_types,
                                                                                get_op_keyword_k->function,
                                                                                get_op_keyword_k->table_index,
                                                                                move(get_op_keyword_k->bind_data),
                                                                                table_types_keyword_k, keyword_k_ids,
                                                                                move(filter_keyword_k),
                                                                                vector<column_t>(),
                                                                                get_op_keyword_k->names,
                                                                                std::move(table_filters_keyword_k),
                                                                                get_op_keyword_k->estimated_cardinality,
                                                                                get_op_keyword_k->extra_info);

    auto &allocator_k = Allocator::Get(context);
    vector<LogicalType> join_in_types_k {LogicalType::VARCHAR};
    auto collection_k =
            make_uniq<ColumnDataCollection>(context, join_in_types_k, ColumnDataAllocatorType::IN_MEMORY_ALLOCATOR);

    vector<LogicalType> chunk_in_types_k {LogicalType::VARCHAR};
    DataChunk chunk_k;
    chunk_k.SetCardinality(3);
    chunk_k.Initialize(allocator_k, chunk_in_types_k);
    chunk_k.SetValue(0, 0, Value("hero"));
    chunk_k.SetValue(0, 1, Value("martial-arts"));
    chunk_k.SetValue(0, 2, Value("hand-to-hand-combat"));
    collection_k->Append(chunk_k);

    // create a chunk scan to output the result
    vector<LogicalType> ouput_in_types_k {LogicalType::VARCHAR};
    auto chunk_scan_k = make_uniq<PhysicalColumnDataScan>(ouput_in_types_k, PhysicalOperatorType::COLUMN_DATA_SCAN,
                                                          3, std::move(collection_k));

    vector<JoinCondition> cond_hash_join_k;
    JoinCondition join_condition_hash_join_k;
    join_condition_hash_join_k.left = make_uniq<BoundReferenceExpression>("keyword", LogicalType::VARCHAR, 1);
    join_condition_hash_join_k.right = make_uniq<BoundReferenceExpression>("", LogicalType::VARCHAR, 0);
    join_condition_hash_join_k.comparison = ExpressionType::COMPARE_EQUAL;
    cond_hash_join_k.push_back(move(join_condition_hash_join_k));

    LogicalComparisonJoin join_hash_join_op_k(JoinType::MARK);
    vector<LogicalType> output_hash_join_types_k{LogicalType::BIGINT,
                                                 LogicalType::VARCHAR, LogicalType::BOOLEAN};
    join_hash_join_op_k.types = output_hash_join_types_k;
    vector<idx_t> right_projection_map_hash_join_k;
    vector<LogicalType> delim_types_hash_join_k;
    PerfectHashJoinStats joinstate_k;
    auto join_hash_join_k = make_uniq<PhysicalHashJoin>(join_hash_join_op_k, move(scan_keyword_k), move(chunk_scan_k), move(cond_hash_join_k),
                                                        JoinType::MARK, left_projection_map,
                                                        right_projection_map_hash_join_k,
                                                        delim_types_hash_join_k, 0, joinstate_k);

    vector<LogicalType> filter_in_types_k{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::BOOLEAN};
    vector<unique_ptr<Expression>> select_list_in_k;
    auto in_exp_k = make_uniq<BoundReferenceExpression>("IN (...)", LogicalType::BOOLEAN, 2);
    select_list_in_k.push_back(move(in_exp_k));
    unique_ptr<PhysicalFilter> filter_in_k = make_uniq<PhysicalFilter>(filter_in_types_k, move(select_list_in_k), 0);
    filter_in_k->children.push_back(move(join_hash_join_k));

    vector<JoinCondition> cond_keyword_k;
    JoinCondition join_condition_keyword_k;
    join_condition_keyword_k.left = make_uniq<BoundReferenceExpression>("keyword_rowid", LogicalType::BIGINT, 0);
    join_condition_keyword_k.right = make_uniq<BoundReferenceExpression>("movie_id_rowid", LogicalType::BIGINT, 2);
    join_condition_keyword_k.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_keyword_k = make_uniq<RAIInfo>();
    rai_info_keyword_k->rai = table_movie_keyword.GetStorage().info->rais[0].get();
    rai_info_keyword_k->rai_type = RAIType::SOURCE_EDGE;
    rai_info_keyword_k->forward = false;
    rai_info_keyword_k->vertex = &table_keyword;
    rai_info_keyword_k->vertex_id = table_index_keyword_k;
    rai_info_keyword_k->passing_tables[0] = table_index_keyword_k;
    rai_info_keyword_k->left_cardinalities[0] = table_keyword.GetStorage().info->cardinality;
    // rai_info_keyword_k->compact_list = &rai_info_keyword_k->rai->alist->compact__list;

    join_condition_keyword_k.rais.push_back(move(rai_info_keyword_k));
    cond_keyword_k.push_back(move(join_condition_keyword_k));

    LogicalComparisonJoin join_keyword_k_op(JoinType::INNER);
    vector<LogicalType> output_keyword_k_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::BOOLEAN,
                                               LogicalType::VARCHAR, LogicalType::BIGINT, LogicalType::BIGINT};
    join_keyword_k_op.types = output_keyword_k_types;
    vector<idx_t> right_projection_map_keyword_k{3, 4, 5};
    vector<idx_t> merge_project_map_keyword_k;
    vector<LogicalType> delim_types_keyword_k;
    auto join_keyword_k = make_uniq<PhysicalMergeSIPJoin>(join_keyword_k_op, move(filter_in_k), move(join_company_name_cn), move(cond_keyword_k),
                                                     JoinType::INNER, left_projection_map,
                                                     right_projection_map_keyword_k,
                                                     merge_project_map_keyword_k,
                                                     delim_types_keyword_k, 0);

    vector<idx_t> name_n_ids{COLUMN_IDENTIFIER_ROW_ID, 1, 4};
    vector<LogicalType> get_name_n_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::VARCHAR};
    string alias_name_n = "n";
    vector<LogicalType> table_types_name_n;
    vector<unique_ptr<Expression>> filter_name_n;
    unique_ptr<LogicalGet> get_op_name_n = move(
            getLogicalGet(*this, table_name, alias_name_n, table_index_name_n, table_types_name_n));
    unique_ptr<TableFilterSet> table_filters_name_n = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_n = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL, Value("f"));
    table_filters_name_n->filters[2] = move(constant_filter_n);
    unique_ptr<PhysicalTableScan> scan_name_n = make_uniq<PhysicalTableScan>(get_name_n_types, get_op_name_n->function,
                                                                             get_op_name_n->table_index,
                                                                             move(get_op_name_n->bind_data),
                                                                             table_types_name_n, name_n_ids,
                                                                             move(filter_name_n), vector<column_t>(),
                                                                             get_op_name_n->names,
                                                                             std::move(table_filters_name_n),
                                                                             get_op_name_n->estimated_cardinality,
                                                                             get_op_name_n->extra_info);

    vector<LogicalType> filter_name_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::VARCHAR};
    vector<unique_ptr<Expression>> select_list_name;
    auto like_expression_left_name = make_uniq<BoundReferenceExpression>("name", LogicalType::VARCHAR, 1);
    auto like_expression_value_name = make_uniq<BoundConstantExpression>(Value("An"));
    vector<unique_ptr<Expression>> like_arguments_name;
    like_arguments_name.push_back(move(like_expression_left_name));
    like_arguments_name.push_back(move(like_expression_value_name));

    unique_ptr<FunctionData> bind_data_contains = NULL;

    auto like_bound_function_name = make_uniq<BoundFunctionExpression>(LogicalType::BOOLEAN,
                                                                  bound_function_contains,
                                                                  move(like_arguments_name),
                                                                  move(bind_data_contains), false);

    select_list_name.push_back(move(like_bound_function_name));
    unique_ptr<PhysicalFilter> filter_name_contains = make_uniq<PhysicalFilter>(filter_name_types, move(select_list_name), 0);
    filter_name_contains->children.push_back(move(scan_name_n));

    vector<JoinCondition> cond_name_n;
    JoinCondition join_condition_name_n;
    join_condition_name_n.left = make_uniq<BoundReferenceExpression>("name_rowid", LogicalType::BIGINT, 0);
    join_condition_name_n.right = make_uniq<BoundReferenceExpression>("person_id_rowid", LogicalType::BIGINT, 4);
    join_condition_name_n.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_name_n = make_uniq<RAIInfo>();
    rai_info_name_n->rai = table_cast_info.GetStorage().info->rais[0].get();
    rai_info_name_n->rai_type = RAIType::TARGET_EDGE;
    rai_info_name_n->forward = true;
    rai_info_name_n->vertex = &table_name;
    rai_info_name_n->vertex_id = table_index_name_n;
    rai_info_name_n->passing_tables[0] = table_index_name_n;
    rai_info_name_n->left_cardinalities[0] = table_name.GetStorage().info->cardinality;
    // rai_info_name_n->compact_list = &rai_info_name_n->rai->alist->compact__list;

    join_condition_name_n.rais.push_back(move(rai_info_name_n));
    cond_name_n.push_back(move(join_condition_name_n));

    LogicalComparisonJoin join_name_n_op(JoinType::INNER);
    vector<LogicalType> output_name_n_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::VARCHAR,
                                            LogicalType::VARCHAR, LogicalType::BIGINT};
    join_name_n_op.types = output_name_n_types;
    vector<idx_t> right_projection_map_name_n{3, 5};
    vector<idx_t> merge_project_map_name_n;
    vector<LogicalType> delim_types_name_n;
    auto join_name_n = make_uniq<PhysicalSIPJoin>(join_name_n_op, move(filter_name_contains), move(join_keyword_k), move(cond_name_n), JoinType::INNER,
                                                  left_projection_map, right_projection_map_name_n, delim_types_name_n,
                                                  0);


    vector<idx_t> aka_name_an_ids{8};
    vector<LogicalType> get_aka_name_an_types{LogicalType::BIGINT};
    string alias_aka_name_an = "an";
    vector<LogicalType> table_types_aka_name_an;
    vector<unique_ptr<Expression>> filter_aka_name_an;
    unique_ptr<LogicalGet> get_op_aka_name_an = move(
            getLogicalGet(*this, table_aka_name, alias_aka_name_an, table_index_aka_name_an, table_types_aka_name_an));
    unique_ptr<TableFilterSet> table_filters_aka_name_an = NULL;
    unique_ptr<PhysicalTableScan> scan_aka_name_an = make_uniq<PhysicalTableScan>(get_aka_name_an_types,
                                                                                  get_op_aka_name_an->function,
                                                                                  get_op_aka_name_an->table_index,
                                                                                  move(get_op_aka_name_an->bind_data),
                                                                                  table_types_aka_name_an,
                                                                                  aka_name_an_ids,
                                                                                  move(filter_aka_name_an),
                                                                                  vector<column_t>(),
                                                                                  get_op_aka_name_an->names,
                                                                                  std::move(table_filters_aka_name_an),
                                                                                  get_op_aka_name_an->estimated_cardinality,
                                                                                  get_op_aka_name_an->extra_info);


    vector<JoinCondition> cond_aka_name_to_name_;
    JoinCondition join_condition_aka_name_to_name_;
    join_condition_aka_name_to_name_.left = make_uniq<BoundReferenceExpression>("person_id_rowid", LogicalType::BIGINT, 0);
    join_condition_aka_name_to_name_.right = make_uniq<BoundReferenceExpression>("name_rowid", LogicalType::BIGINT, 0);
    join_condition_aka_name_to_name_.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_aka_name_to_name_ = make_uniq<RAIInfo>();
    rai_info_aka_name_to_name_->rai = table_aka_name.GetStorage().info->rais[0].get();
    rai_info_aka_name_to_name_->rai_type = RAIType::EDGE_SOURCE;
    rai_info_aka_name_to_name_->forward = true;
    rai_info_aka_name_to_name_->vertex = &table_name;
    rai_info_aka_name_to_name_->vertex_id = table_index_name_n;
    rai_info_aka_name_to_name_->passing_tables[0] = table_index_aka_name_an;
    rai_info_aka_name_to_name_->left_cardinalities[0] = table_aka_name.GetStorage().info->cardinality;
    rai_info_aka_name_to_name_->compact_list = &rai_info_aka_name_to_name_->rai->alist->compact_forward_list;

    join_condition_aka_name_to_name_.rais.push_back(move(rai_info_aka_name_to_name_));
    cond_aka_name_to_name_.push_back(move(join_condition_aka_name_to_name_));

    LogicalComparisonJoin join_aka_name_to_name__op(JoinType::INNER);
    vector<LogicalType> output_aka_name_to_name__types{LogicalType::BIGINT, LogicalType::VARCHAR,
                                                       LogicalType::VARCHAR, LogicalType::BIGINT};
    join_aka_name_to_name__op.types = output_aka_name_to_name__types;
    vector<idx_t> right_projection_map_aka_name_to_name_{1, 3, 4};
    vector<idx_t> merge_project_map_aka_name_to_name_;
    vector<LogicalType> delim_types_aka_name_to_name_;
    auto join_aka_name_to_name_ = make_uniq<PhysicalSIPJoin>(join_aka_name_to_name__op, move(scan_aka_name_an), move(join_name_n),
                                                                  move(cond_aka_name_to_name_), JoinType::INNER,
                                                                  left_projection_map,
                                                                  right_projection_map_aka_name_to_name_,
                                                                  delim_types_aka_name_to_name_, 0);

    vector<idx_t> char_name_chn_ids{COLUMN_IDENTIFIER_ROW_ID, 1};
    vector<LogicalType> get_char_name_chn_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_char_name_chn = "chn";
    vector<LogicalType> table_types_char_name_chn;
    vector<unique_ptr<Expression>> filter_char_name_chn;
    unique_ptr<LogicalGet> get_op_char_name_chn = move(
            getLogicalGet(*this, table_char_name, alias_char_name_chn, table_index_char_name_chn,
                          table_types_char_name_chn));
    unique_ptr<TableFilterSet> table_filters_char_name_chn = NULL;
    unique_ptr<PhysicalTableScan> scan_char_name_chn = make_uniq<PhysicalTableScan>(get_char_name_chn_types,
                                                                                    get_op_char_name_chn->function,
                                                                                    get_op_char_name_chn->table_index,
                                                                                    move(get_op_char_name_chn->bind_data),
                                                                                    table_types_char_name_chn,
                                                                                    char_name_chn_ids,
                                                                                    move(filter_char_name_chn),
                                                                                    vector<column_t>(),
                                                                                    get_op_char_name_chn->names,
                                                                                    std::move(
                                                                                            table_filters_char_name_chn),
                                                                                    get_op_char_name_chn->estimated_cardinality,
                                                                                    get_op_char_name_chn->extra_info);

    vector<JoinCondition> cond_chn;
    JoinCondition join_condition_chn;
    join_condition_chn.left = make_uniq<BoundReferenceExpression>("char_name_rowid", LogicalType::BIGINT, 0);
    join_condition_chn.right = make_uniq<BoundReferenceExpression>("person_role_id_rowid", LogicalType::BIGINT, 3);
    join_condition_chn.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_chn = make_uniq<RAIInfo>();
    rai_info_chn->rai = table_cast_info.GetStorage().info->rais[3].get();
    rai_info_chn->rai_type = RAIType::TARGET_EDGE;
    rai_info_chn->forward = true;
    rai_info_chn->vertex = &table_char_name;
    rai_info_chn->vertex_id = table_index_char_name_chn;
    rai_info_chn->passing_tables[0] = table_index_char_name_chn;
    rai_info_chn->left_cardinalities[0] = table_char_name.GetStorage().info->cardinality;
    // rai_info_chn->compact_list = &rai_info_chn->rai->alist->compact__list;

    join_condition_chn.rais.push_back(move(rai_info_chn));
    cond_chn.push_back(move(join_condition_chn));

    LogicalComparisonJoin join_chn_op(JoinType::INNER);
    vector<LogicalType> output_chn_types{LogicalType::BIGINT, LogicalType::VARCHAR,
                                         LogicalType::VARCHAR, LogicalType::VARCHAR};
    join_chn_op.types = output_chn_types;
    vector<idx_t> right_projection_map_chn{1, 2};
    vector<idx_t> merge_project_map_chn;
    vector<LogicalType> delim_types_chn;
    auto join_chn = make_uniq<PhysicalSIPJoin>(join_chn_op, move(scan_char_name_chn), move(join_aka_name_to_name_), move(cond_chn),
                                               JoinType::INNER, left_projection_map,
                                               right_projection_map_chn,
                                               delim_types_chn, 0);

    vector<LogicalType> result_types{LogicalType::VARCHAR, LogicalType::VARCHAR, LogicalType::VARCHAR};
    vector<unique_ptr<Expression>> select_list;
    auto result_col0 = make_uniq<BoundReferenceExpression>("name", LogicalType::VARCHAR, 1);
    auto result_col1 = make_uniq<BoundReferenceExpression>("name", LogicalType::VARCHAR, 2);
    auto result_col2 = make_uniq<BoundReferenceExpression>("title", LogicalType::VARCHAR, 3);
    select_list.push_back(move(result_col0));
    select_list.push_back(move(result_col1));
    select_list.push_back(move(result_col2));
    auto projection = make_uniq<PhysicalProjection>(result_types, move(select_list), 0);
    projection->children.push_back(move(join_chn));

    // aggregate
    string agg_name = "min";
    string agg_error = "";
    QueryErrorContext error_context(NULL, NULL);
    auto min_func = Catalog::GetEntry(context, CatalogType::SCALAR_FUNCTION_ENTRY, "", "",
                                      "min", OnEntryNotFound::RETURN_NULL, error_context);
    auto &min_func_set = min_func->Cast<AggregateFunctionCatalogEntry>();
    // bind the aggregate
    FunctionBinder function_binder(context);
    vector<LogicalType> types;
    types.push_back(LogicalType::VARCHAR);
    idx_t best_function_varchar = function_binder.BindFunction(agg_name, min_func_set.functions, types, agg_error);
    auto bound_function_min_varchar = min_func_set.functions.GetFunctionByOffset(best_function_varchar);
    // std::cout << best_function_varchar << " " << bound_function_min_varchar.return_type.ToString() << std::endl;

    auto first_children = make_uniq<BoundReferenceExpression>("name", LogicalType::VARCHAR, 0);
    vector<unique_ptr<Expression>> childrenlist1;
    childrenlist1.push_back(move(first_children));
    auto aggregate1 =
            function_binder.BindAggregateFunction(bound_function_min_varchar, std::move(childrenlist1), nullptr,
                                                  AggregateType::NON_DISTINCT);

    auto second_children = make_uniq<BoundReferenceExpression>("name", LogicalType::VARCHAR, 1);
    vector<unique_ptr<Expression>> childrenlist2;
    childrenlist2.push_back(move(second_children));
    auto aggregate2 =
            function_binder.BindAggregateFunction(bound_function_min_varchar, std::move(childrenlist2), nullptr,
                                                  AggregateType::NON_DISTINCT);

    auto third_children = make_uniq<BoundReferenceExpression>("title", LogicalType::VARCHAR, 2);
    vector<unique_ptr<Expression>> childrenlist3;
    childrenlist3.push_back(move(third_children));
    auto aggregate3 =
            function_binder.BindAggregateFunction(bound_function_min_varchar, std::move(childrenlist3), nullptr,
                                                  AggregateType::NON_DISTINCT);

    vector<unique_ptr<Expression>> aggregates;
    aggregates.push_back(move(aggregate1));
    aggregates.push_back(move(aggregate2));
    aggregates.push_back(move(aggregate3));


    vector<LogicalType> aggregate_types{LogicalType::VARCHAR, LogicalType::VARCHAR, LogicalType::VARCHAR};
    auto ungrouped_aggregate = make_uniq<PhysicalUngroupedAggregate>(aggregate_types, move(aggregates), 0);
    ungrouped_aggregate->children.push_back(move(projection));

    return ungrouped_aggregate;
}

unique_ptr<PhysicalOperator> ClientContext::GenerateJOB25aPlan(duckdb::ClientContext &context) {
    vector<idx_t> left_projection_map, right_projection_map;

    string table_vertex_keyword_k = "keyword";
    string table_vertex_title_t = "title";
    string table_vertex_name_n = "name";
    string table_vertex_info_type_it2 = "info_type";
    string table_vertex_info_type_it1 = "info_type";
    string table_vertex_movie_keyword_ = "movie_keyword";
    string table_vertex_cast_info_ = "cast_info";
    string table_vertex_movie_info_idx_ = "movie_info_idx";
    string table_vertex_movie_info_ = "movie_info";

    idx_t table_index_keyword_k = 1;
    idx_t table_index_title_t = 2;
    idx_t table_index_name_n = 3;
    idx_t table_index_info_type_it2 = 4;
    idx_t table_index_info_type_it1 = 5;
    idx_t table_index_movie_keyword_ = 6;
    idx_t table_index_cast_info_ = 7;
    idx_t table_index_movie_info_idx_ = 8;
    idx_t table_index_movie_info_ = 9;
    auto table_or_view_keyword = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_keyword_k,
                                                   OnEntryNotFound::RETURN_NULL);
    auto &table_keyword = table_or_view_keyword->Cast<TableCatalogEntry>();
    auto table_or_view_title = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_title_t,
                                                 OnEntryNotFound::RETURN_NULL);
    auto &table_title = table_or_view_title->Cast<TableCatalogEntry>();
    auto table_or_view_name = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_name_n,
                                                OnEntryNotFound::RETURN_NULL);
    auto &table_name = table_or_view_name->Cast<TableCatalogEntry>();
    auto table_or_view_info_type = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                     table_vertex_info_type_it2, OnEntryNotFound::RETURN_NULL);
    auto &table_info_type = table_or_view_info_type->Cast<TableCatalogEntry>();
    auto table_or_view_movie_keyword = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                         table_vertex_movie_keyword_, OnEntryNotFound::RETURN_NULL);
    auto &table_movie_keyword = table_or_view_movie_keyword->Cast<TableCatalogEntry>();
    auto table_or_view_cast_info = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_cast_info_,
                                                     OnEntryNotFound::RETURN_NULL);
    auto &table_cast_info = table_or_view_cast_info->Cast<TableCatalogEntry>();
    auto table_or_view_movie_info_idx = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                          table_vertex_movie_info_idx_, OnEntryNotFound::RETURN_NULL);
    auto &table_movie_info_idx = table_or_view_movie_info_idx->Cast<TableCatalogEntry>();
    auto table_or_view_movie_info = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_movie_info_,
                                                      OnEntryNotFound::RETURN_NULL);
    auto &table_movie_info = table_or_view_movie_info->Cast<TableCatalogEntry>();

    vector<idx_t> info_type_it2_ids{COLUMN_IDENTIFIER_ROW_ID, 1};
    vector<LogicalType> get_info_type_it2_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_info_type_it2 = "it2";
    vector<LogicalType> table_types_info_type_it2;
    vector<unique_ptr<Expression>> filter_info_type_it2;
    unique_ptr<LogicalGet> get_op_info_type_it2 = move(
            getLogicalGet(*this, table_info_type, alias_info_type_it2, table_index_info_type_it2,
                          table_types_info_type_it2));
    unique_ptr<TableFilterSet> table_filters_info_type_it2 = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_it2 = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL, Value("votes"));
    table_filters_info_type_it2->filters[1] = move(constant_filter_it2);
    unique_ptr<PhysicalTableScan> scan_info_type_it2 = make_uniq<PhysicalTableScan>(get_info_type_it2_types,
                                                                                    get_op_info_type_it2->function,
                                                                                    get_op_info_type_it2->table_index,
                                                                                    move(get_op_info_type_it2->bind_data),
                                                                                    table_types_info_type_it2,
                                                                                    info_type_it2_ids,
                                                                                    move(filter_info_type_it2),
                                                                                    vector<column_t>(),
                                                                                    get_op_info_type_it2->names,
                                                                                    std::move(
                                                                                            table_filters_info_type_it2),
                                                                                    get_op_info_type_it2->estimated_cardinality,
                                                                                    get_op_info_type_it2->extra_info);

    vector<idx_t> movie_info_idx_ids{6, 5, 3};
    vector<LogicalType> get_movie_info_idx_type{LogicalType::BIGINT, LogicalType::BIGINT,
                                                LogicalType::VARCHAR};
    string alias_movie_info_idx = "mi";
    vector<LogicalType> table_types_movie_info_idx;
    vector<unique_ptr<Expression>> filter_movie_info_idx;
    unique_ptr<LogicalGet> get_op_movie_info_idx = move(
            getLogicalGet(*this, table_movie_info_idx, alias_movie_info_idx, table_index_movie_info_idx_, table_types_movie_info_idx));
    unique_ptr<TableFilterSet> table_filters_movie_info_idx = NULL;
    unique_ptr<PhysicalTableScan> scan_movie_info_idx = make_uniq<PhysicalTableScan>(get_movie_info_idx_type,
                                                                                     get_op_movie_info_idx->function,
                                                                                     get_op_movie_info_idx->table_index,
                                                                                     move(get_op_movie_info_idx->bind_data),
                                                                                     table_types_movie_info_idx, movie_info_idx_ids,
                                                                                     move(filter_movie_info_idx),
                                                                                     vector<column_t>(),
                                                                                     get_op_movie_info_idx->names,
                                                                                     std::move(table_filters_movie_info_idx),
                                                                                     get_op_movie_info_idx->estimated_cardinality,
                                                                                     get_op_movie_info_idx->extra_info);

    vector<JoinCondition> cond_movie_info_idx;
    JoinCondition join_condition_movie_info_idx;
    join_condition_movie_info_idx.left = make_uniq<BoundReferenceExpression>("info_type_id_rowid", LogicalType::BIGINT, 1);
    join_condition_movie_info_idx.right = make_uniq<BoundReferenceExpression>("info_type_rowid", LogicalType::BIGINT, 0);
    join_condition_movie_info_idx.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_movie_info_idx = make_uniq<RAIInfo>();
    rai_info_movie_info_idx->rai = table_movie_info_idx.GetStorage().info->rais[0].get();
    rai_info_movie_info_idx->rai_type = RAIType::EDGE_SOURCE;
    rai_info_movie_info_idx->forward = true;
    rai_info_movie_info_idx->vertex = &table_info_type;
    rai_info_movie_info_idx->vertex_id = table_index_info_type_it2;
    rai_info_movie_info_idx->passing_tables[0] = table_index_movie_info_idx_;
    rai_info_movie_info_idx->left_cardinalities[0] = table_movie_info_idx.GetStorage().info->cardinality;
    rai_info_movie_info_idx->compact_list = &rai_info_movie_info_idx->rai->alist->compact_forward_list;

    join_condition_movie_info_idx.rais.push_back(move(rai_info_movie_info_idx));
    cond_movie_info_idx.push_back(move(join_condition_movie_info_idx));

    LogicalComparisonJoin join_movie_info_idx_op(JoinType::INNER);
    vector<LogicalType> output_movie_info_idx_types{LogicalType::BIGINT, LogicalType::BIGINT,
                                                    LogicalType::VARCHAR, LogicalType::BIGINT};
    join_movie_info_idx_op.types = output_movie_info_idx_types;
    vector<idx_t> right_projection_map_movie_info_idx{0};
    vector<LogicalType> delim_types_movie_info_idx;
    auto join_movie_info_idx = make_uniq<PhysicalSIPJoin>(join_movie_info_idx_op, move(scan_movie_info_idx), move(scan_info_type_it2),
                                                          move(cond_movie_info_idx),
                                                          JoinType::INNER, left_projection_map,
                                                          right_projection_map_movie_info_idx,
                                                          delim_types_movie_info_idx, 0);

    vector<idx_t> title_t_ids{COLUMN_IDENTIFIER_ROW_ID, 1};
    vector<LogicalType> get_title_t_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_title_t = "t";
    vector<LogicalType> table_types_title_t;
    vector<unique_ptr<Expression>> filter_title_t;
    unique_ptr<LogicalGet> get_op_title_t = move(
            getLogicalGet(*this, table_title, alias_title_t, table_index_title_t, table_types_title_t));
    unique_ptr<TableFilterSet> table_filters_title_t = NULL;
    unique_ptr<PhysicalTableScan> scan_title_t = make_uniq<PhysicalTableScan>(get_title_t_types,
                                                                              get_op_title_t->function,
                                                                              get_op_title_t->table_index,
                                                                              move(get_op_title_t->bind_data),
                                                                              table_types_title_t, title_t_ids,
                                                                              move(filter_title_t), vector<column_t>(),
                                                                              get_op_title_t->names,
                                                                              std::move(table_filters_title_t),
                                                                              get_op_title_t->estimated_cardinality,
                                                                              get_op_title_t->extra_info);


    vector<JoinCondition> cond_movie_info_idx_;
    JoinCondition join_condition_movie_info_idx_;
    join_condition_movie_info_idx_.left = make_uniq<BoundReferenceExpression>("title_rowid", LogicalType::BIGINT, 0);
    join_condition_movie_info_idx_.right = make_uniq<BoundReferenceExpression>("movie_id_rowid", LogicalType::BIGINT, 0);
    join_condition_movie_info_idx_.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_movie_info_idx_ = make_uniq<RAIInfo>();
    rai_info_movie_info_idx_->rai = table_movie_info_idx.GetStorage().info->rais[0].get();
    rai_info_movie_info_idx_->rai_type = RAIType::TARGET_EDGE;
    rai_info_movie_info_idx_->forward = true;
    rai_info_movie_info_idx_->vertex = &table_title;
    rai_info_movie_info_idx_->vertex_id = table_index_title_t;
    rai_info_movie_info_idx_->passing_tables[0] = table_index_title_t;
    rai_info_movie_info_idx_->left_cardinalities[0] = table_title.GetStorage().info->cardinality;
    // rai_info_movie_info_idx_->compact_list = &rai_info_movie_info_idx_->rai->alist->compact__list;

    join_condition_movie_info_idx_.rais.push_back(move(rai_info_movie_info_idx_));
    cond_movie_info_idx_.push_back(move(join_condition_movie_info_idx_));

    LogicalComparisonJoin join_movie_info_idx__op(JoinType::INNER);
    vector<LogicalType> output_movie_info_idx__types{LogicalType::BIGINT, LogicalType::VARCHAR,
                                                     LogicalType::VARCHAR};
    join_movie_info_idx__op.types = output_movie_info_idx__types;
    vector<idx_t> right_projection_map_movie_info_idx_{2};
    vector<idx_t> merge_project_map_movie_info_idx_;
    vector<LogicalType> delim_types_movie_info_idx_;
    auto join_movie_info_idx_ = make_uniq<PhysicalSIPJoin>(join_movie_info_idx__op, move(scan_title_t), move(join_movie_info_idx),
                                                                move(cond_movie_info_idx_), JoinType::INNER,
                                                                left_projection_map,
                                                                right_projection_map_movie_info_idx_,
                                                                delim_types_movie_info_idx_, 0);

    vector<idx_t> movie_info_ids{6, 5, 3};
    vector<LogicalType> get_movie_info_types{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_movie_info = "i";
    vector<LogicalType> table_types_movie_info;
    vector<unique_ptr<Expression>> filter_movie_info;
    unique_ptr<LogicalGet> get_op_movie_info = move(
            getLogicalGet(*this, table_movie_info, alias_movie_info, table_index_movie_info_, table_types_movie_info));
    unique_ptr<TableFilterSet> table_filters_movie_info = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_info = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL, Value("Horror"));
    table_filters_movie_info->filters[2] = move(constant_filter_info);
    unique_ptr<PhysicalTableScan> scan_movie_info = make_uniq<PhysicalTableScan>(get_movie_info_types,
                                                                                 get_op_movie_info->function,
                                                                                 get_op_movie_info->table_index,
                                                                                 move(get_op_movie_info->bind_data),
                                                                                 table_types_movie_info,
                                                                                 movie_info_ids,
                                                                                 move(filter_movie_info),
                                                                                 vector<column_t>(),
                                                                                 get_op_movie_info->names,
                                                                                 std::move(table_filters_movie_info),
                                                                                 get_op_movie_info->estimated_cardinality,
                                                                                 get_op_movie_info->extra_info);


    vector<JoinCondition> cond_movie_info_;
    JoinCondition join_condition_movie_info_;
    join_condition_movie_info_.left = make_uniq<BoundReferenceExpression>("movie_id_rowid", LogicalType::BIGINT, 0);
    join_condition_movie_info_.right = make_uniq<BoundReferenceExpression>("title_rowid", LogicalType::BIGINT, 0);
    join_condition_movie_info_.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_movie_info_ = make_uniq<RAIInfo>();
    rai_info_movie_info_->rai = table_movie_info.GetStorage().info->rais[0].get();
    rai_info_movie_info_->rai_type = RAIType::EDGE_TARGET;
    rai_info_movie_info_->forward = false;
    rai_info_movie_info_->vertex = &table_title;
    rai_info_movie_info_->vertex_id = table_index_title_t;
    rai_info_movie_info_->passing_tables[0] = table_index_movie_info_;
    rai_info_movie_info_->left_cardinalities[0] = table_movie_info.GetStorage().info->cardinality;
    rai_info_movie_info_->compact_list = &rai_info_movie_info_->rai->alist->compact_backward_list;

    join_condition_movie_info_.rais.push_back(move(rai_info_movie_info_));
    cond_movie_info_.push_back(move(join_condition_movie_info_));

    LogicalComparisonJoin join_movie_info__op(JoinType::INNER);
    vector<LogicalType> output_movie_info__types{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::VARCHAR,
                                                 LogicalType::VARCHAR, LogicalType::VARCHAR};
    join_movie_info__op.types = output_movie_info__types;
    vector<idx_t> right_projection_map_movie_info_{1, 2};
    vector<idx_t> merge_project_map_movie_info_;
    vector<LogicalType> delim_types_movie_info_;
    auto join_movie_info_ = make_uniq<PhysicalSIPJoin>(join_movie_info__op, move(scan_movie_info), move(join_movie_info_idx_), move(cond_movie_info_),
                                                            JoinType::INNER, left_projection_map,
                                                            right_projection_map_movie_info_,
                                                            delim_types_movie_info_, 0);


    vector<idx_t> info_type_it1_ids{COLUMN_IDENTIFIER_ROW_ID, 1};
    vector<LogicalType> get_info_type_it1_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_info_type_it1 = "it1";
    vector<LogicalType> table_types_info_type_it1;
    vector<unique_ptr<Expression>> filter_info_type_it1;
    unique_ptr<LogicalGet> get_op_info_type_it1 = move(
            getLogicalGet(*this, table_info_type, alias_info_type_it1, table_index_info_type_it1,
                          table_types_info_type_it1));
    unique_ptr<TableFilterSet> table_filters_info_type_it1 = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_it1 = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL, Value("genres"));
    table_filters_info_type_it1->filters[1] = move(constant_filter_it1);
    unique_ptr<PhysicalTableScan> scan_info_type_it1 = make_uniq<PhysicalTableScan>(get_info_type_it1_types,
                                                                                    get_op_info_type_it1->function,
                                                                                    get_op_info_type_it1->table_index,
                                                                                    move(get_op_info_type_it1->bind_data),
                                                                                    table_types_info_type_it1,
                                                                                    info_type_it1_ids,
                                                                                    move(filter_info_type_it1),
                                                                                    vector<column_t>(),
                                                                                    get_op_info_type_it1->names,
                                                                                    std::move(
                                                                                            table_filters_info_type_it1),
                                                                                    get_op_info_type_it1->estimated_cardinality,
                                                                                    get_op_info_type_it1->extra_info);


    vector<JoinCondition> cond_info_type_it1;
    JoinCondition join_condition_info_type_it1;
    join_condition_info_type_it1.left = make_uniq<BoundReferenceExpression>("info_type_rowid", LogicalType::BIGINT, 0);
    join_condition_info_type_it1.right = make_uniq<BoundReferenceExpression>("info_type_id_rowid", LogicalType::BIGINT, 1);
    join_condition_info_type_it1.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_info_type_it1 = make_uniq<RAIInfo>();
    rai_info_info_type_it1->rai = table_movie_info.GetStorage().info->rais[0].get();
    rai_info_info_type_it1->rai_type = RAIType::SOURCE_EDGE;
    rai_info_info_type_it1->forward = false;
    rai_info_info_type_it1->vertex = &table_info_type;
    rai_info_info_type_it1->vertex_id = table_index_info_type_it1;
    rai_info_info_type_it1->passing_tables[0] = table_index_info_type_it1;
    rai_info_info_type_it1->left_cardinalities[0] = table_info_type.GetStorage().info->cardinality;
    // rai_info_info_type_it1->compact_list = &rai_info_info_type_it1->rai->alist->compact__list;

    join_condition_info_type_it1.rais.push_back(move(rai_info_info_type_it1));
    cond_info_type_it1.push_back(move(join_condition_info_type_it1));

    LogicalComparisonJoin join_info_type_it1_op(JoinType::INNER);
    vector<LogicalType> output_info_type_it1_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::BIGINT,
                                                   LogicalType::VARCHAR, LogicalType::VARCHAR, LogicalType::VARCHAR};
    join_info_type_it1_op.types = output_info_type_it1_types;
    vector<idx_t> right_projection_map_info_type_it1{0, 2, 3, 4};
    vector<idx_t> merge_project_map_info_type_it1;
    vector<LogicalType> delim_types_info_type_it1;
    auto join_info_type_it1 = make_uniq<PhysicalSIPJoin>(join_info_type_it1_op, move(scan_info_type_it1), move(join_movie_info_),
                                                         move(cond_info_type_it1), JoinType::INNER, left_projection_map,
                                                         right_projection_map_info_type_it1, delim_types_info_type_it1,
                                                         0);

    vector<idx_t> keyword_k_ids{COLUMN_IDENTIFIER_ROW_ID, 1};
    vector<LogicalType> get_keyword_k_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_keyword_k = "k";
    vector<LogicalType> table_types_keyword_k;
    vector<unique_ptr<Expression>> filter_keyword_k;
    unique_ptr<LogicalGet> get_op_keyword_k = move(
            getLogicalGet(*this, table_keyword, alias_keyword_k, table_index_keyword_k, table_types_keyword_k));
    unique_ptr<TableFilterSet> table_filters_keyword_k = NULL;
    unique_ptr<PhysicalTableScan> scan_keyword_k = make_uniq<PhysicalTableScan>(get_keyword_k_types,
                                                                                get_op_keyword_k->function,
                                                                                get_op_keyword_k->table_index,
                                                                                move(get_op_keyword_k->bind_data),
                                                                                table_types_keyword_k, keyword_k_ids,
                                                                                move(filter_keyword_k),
                                                                                vector<column_t>(),
                                                                                get_op_keyword_k->names,
                                                                                std::move(table_filters_keyword_k),
                                                                                get_op_keyword_k->estimated_cardinality,
                                                                                get_op_keyword_k->extra_info);

    auto &allocator_k = Allocator::Get(context);
    vector<LogicalType> join_in_types_k {LogicalType::VARCHAR};
    auto collection_k =
            make_uniq<ColumnDataCollection>(context, join_in_types_k, ColumnDataAllocatorType::IN_MEMORY_ALLOCATOR);

    vector<LogicalType> chunk_in_types_k {LogicalType::VARCHAR};
    DataChunk chunk_k;
    chunk_k.SetCardinality(5);
    chunk_k.Initialize(allocator_k, chunk_in_types_k);
    chunk_k.SetValue(0, 0, Value("murder"));
    chunk_k.SetValue(0, 1, Value("blood"));
    chunk_k.SetValue(0, 2, Value("gore"));
    chunk_k.SetValue(0, 3, Value("death"));
    chunk_k.SetValue(0, 4, Value("female-nudity"));
    collection_k->Append(chunk_k);

    // create a chunk scan to output the result
    vector<LogicalType> ouput_in_types_k {LogicalType::VARCHAR};
    auto chunk_scan_k = make_uniq<PhysicalColumnDataScan>(ouput_in_types_k, PhysicalOperatorType::COLUMN_DATA_SCAN,
                                                          5, std::move(collection_k));

    vector<JoinCondition> cond_hash_join_k;
    JoinCondition join_condition_hash_join_k;
    join_condition_hash_join_k.left = make_uniq<BoundReferenceExpression>("keyword", LogicalType::VARCHAR, 1);
    join_condition_hash_join_k.right = make_uniq<BoundReferenceExpression>("", LogicalType::VARCHAR, 0);
    join_condition_hash_join_k.comparison = ExpressionType::COMPARE_EQUAL;
    cond_hash_join_k.push_back(move(join_condition_hash_join_k));

    LogicalComparisonJoin join_hash_join_op_k(JoinType::MARK);
    vector<LogicalType> output_hash_join_types_k{LogicalType::BIGINT,
                                                 LogicalType::VARCHAR, LogicalType::BOOLEAN};
    join_hash_join_op_k.types = output_hash_join_types_k;
    vector<idx_t> right_projection_map_hash_join_k;
    vector<LogicalType> delim_types_hash_join_k;
    PerfectHashJoinStats joinstate_k;
    auto join_hash_join_k = make_uniq<PhysicalHashJoin>(join_hash_join_op_k, move(scan_keyword_k), move(chunk_scan_k), move(cond_hash_join_k),
                                                        JoinType::MARK, left_projection_map,
                                                        right_projection_map_hash_join_k,
                                                        delim_types_hash_join_k, 0, joinstate_k);

    vector<LogicalType> filter_in_types_k{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::BOOLEAN};
    vector<unique_ptr<Expression>> select_list_in_k;
    auto in_exp_k = make_uniq<BoundReferenceExpression>("IN (...)", LogicalType::BOOLEAN, 2);
    select_list_in_k.push_back(move(in_exp_k));
    unique_ptr<PhysicalFilter> filter_in_k = make_uniq<PhysicalFilter>(filter_in_types_k, move(select_list_in_k), 0);
    filter_in_k->children.push_back(move(join_hash_join_k));


    vector<JoinCondition> cond_keyword_k;
    JoinCondition join_condition_keyword_k;
    join_condition_keyword_k.left = make_uniq<BoundReferenceExpression>("keyword_rowid", LogicalType::BIGINT, 0);
    join_condition_keyword_k.right = make_uniq<BoundReferenceExpression>("movie_id_rowid", LogicalType::BIGINT, 2);
    join_condition_keyword_k.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_keyword_k = make_uniq<RAIInfo>();
    rai_info_keyword_k->rai = table_movie_keyword.GetStorage().info->rais[0].get();
    rai_info_keyword_k->rai_type = RAIType::SOURCE_EDGE;
    rai_info_keyword_k->forward = false;
    rai_info_keyword_k->vertex = &table_keyword;
    rai_info_keyword_k->vertex_id = table_index_keyword_k;
    rai_info_keyword_k->passing_tables[0] = table_index_keyword_k;
    rai_info_keyword_k->left_cardinalities[0] = table_keyword.GetStorage().info->cardinality;
    // rai_info_keyword_k->compact_list = &rai_info_keyword_k->rai->alist->compact__list;

    join_condition_keyword_k.rais.push_back(move(rai_info_keyword_k));
    cond_keyword_k.push_back(move(join_condition_keyword_k));

    LogicalComparisonJoin join_keyword_k_op(JoinType::INNER);
    vector<LogicalType> output_keyword_k_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::BOOLEAN,
                                               LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::VARCHAR,
                                               LogicalType::VARCHAR};
    join_keyword_k_op.types = output_keyword_k_types;
    vector<idx_t> right_projection_map_keyword_k{2, 3, 4 ,5};
    vector<idx_t> merge_project_map_keyword_k;
    vector<LogicalType> delim_types_keyword_k;
    auto join_keyword_k = make_uniq<PhysicalMergeSIPJoin>(join_keyword_k_op, move(filter_in_k), move(join_info_type_it1), move(cond_keyword_k),
                                                     JoinType::INNER, left_projection_map,
                                                     right_projection_map_keyword_k,
                                                     merge_project_map_keyword_k,
                                                     delim_types_keyword_k, 0);

    vector<idx_t> cast_info_ids{4, 7, 8};
    vector<LogicalType> get_cast_info_types{LogicalType::VARCHAR, LogicalType::BIGINT, LogicalType::BIGINT};
    string alias_cast_info = "ci";
    vector<LogicalType> table_types_cast_info;
    vector<unique_ptr<Expression>> filter_cast_info;
    unique_ptr<LogicalGet> get_op_cast_info = move(
            getLogicalGet(*this, table_cast_info, alias_cast_info, table_index_cast_info_, table_types_cast_info));
    unique_ptr<TableFilterSet> table_filters_cast_info = NULL;
    unique_ptr<PhysicalTableScan> scan_cast_info = make_uniq<PhysicalTableScan>(get_cast_info_types,
                                                                                get_op_cast_info->function,
                                                                                get_op_cast_info->table_index,
                                                                                move(get_op_cast_info->bind_data),
                                                                                table_types_cast_info, cast_info_ids,
                                                                                move(filter_cast_info),
                                                                                vector<column_t>(),
                                                                                get_op_cast_info->names,
                                                                                std::move(table_filters_cast_info),
                                                                                get_op_cast_info->estimated_cardinality,
                                                                                get_op_cast_info->extra_info);

    auto &allocator = Allocator::Get(context);
    vector<LogicalType> join_in_types{LogicalType::VARCHAR};
    auto collection =
            make_uniq<ColumnDataCollection>(context, join_in_types, ColumnDataAllocatorType::IN_MEMORY_ALLOCATOR);

    vector<LogicalType> chunk_in_types{LogicalType::VARCHAR};
    DataChunk chunk;
    chunk.SetCardinality(5);
    chunk.Initialize(allocator, chunk_in_types);
    chunk.SetValue(0, 0, Value("(writer)"));
    chunk.SetValue(0, 1, Value("(head writer)"));
    chunk.SetValue(0, 2, Value("(written by)"));
    chunk.SetValue(0, 3, Value("(story)"));
    chunk.SetValue(0, 4, Value("(story editor)"));
    collection->Append(chunk);

    // create a chunk scan to output the result
    vector<LogicalType> ouput_in_types{LogicalType::VARCHAR};
    auto chunk_scan = make_uniq<PhysicalColumnDataScan>(ouput_in_types, PhysicalOperatorType::COLUMN_DATA_SCAN,
                                                        5, std::move(collection));

    vector<JoinCondition> cond_hash_join_;
    JoinCondition join_condition_hash_join_;
    join_condition_hash_join_.left = make_uniq<BoundReferenceExpression>("note", LogicalType::VARCHAR, 0);
    join_condition_hash_join_.right = make_uniq<BoundReferenceExpression>("", LogicalType::VARCHAR, 0);
    join_condition_hash_join_.comparison = ExpressionType::COMPARE_EQUAL;
    cond_hash_join_.push_back(move(join_condition_hash_join_));

    LogicalComparisonJoin join_hash_join_op(JoinType::MARK);
    vector<LogicalType> output_hash_join_types{LogicalType::VARCHAR, LogicalType::BIGINT, LogicalType::BIGINT,
                                               LogicalType::BOOLEAN};
    join_hash_join_op.types = output_hash_join_types;
    vector<idx_t> right_projection_map_hash_join_;
    vector<LogicalType> delim_types_hash_join_;
    PerfectHashJoinStats joinstate;
    auto join_hash_join_ = make_uniq<PhysicalHashJoin>(join_hash_join_op, move(scan_cast_info), move(chunk_scan),
                                                       move(cond_hash_join_),
                                                       JoinType::MARK, left_projection_map,
                                                       right_projection_map_hash_join_,
                                                       delim_types_hash_join_, 0, joinstate);


    vector<LogicalType> filter_in_types{LogicalType::VARCHAR, LogicalType::BIGINT, LogicalType::BIGINT,
                                        LogicalType::BOOLEAN};
    vector<unique_ptr<Expression>> select_list_in;
    auto in_exp = make_uniq<BoundReferenceExpression>("IN (...)", LogicalType::BOOLEAN, 3);
    select_list_in.push_back(move(in_exp));
    unique_ptr<PhysicalFilter> filter_in = make_uniq<PhysicalFilter>(filter_in_types, move(select_list_in), 0);
    filter_in->children.push_back(move(join_hash_join_));


    vector<JoinCondition> cond_cast_info_;
    JoinCondition join_condition_cast_info_;
    join_condition_cast_info_.left = make_uniq<BoundReferenceExpression>("movie_id_rowid", LogicalType::BIGINT, 1);
    join_condition_cast_info_.right = make_uniq<BoundReferenceExpression>("movie_id_rowid", LogicalType::BIGINT, 3);
    join_condition_cast_info_.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_cast_info_ = make_uniq<RAIInfo>();
    rai_info_cast_info_->rai = table_cast_info.GetStorage().info->rais[0].get();
    rai_info_cast_info_->rai_type = RAIType::EDGE_SOURCE;
    rai_info_cast_info_->forward = true;
    rai_info_cast_info_->vertex = &table_title;
    rai_info_cast_info_->vertex_id = table_index_title_t;
    rai_info_cast_info_->passing_tables[0] = table_index_cast_info_;
    rai_info_cast_info_->left_cardinalities[0] = table_cast_info.GetStorage().info->cardinality;
    rai_info_cast_info_->compact_list = &rai_info_cast_info_->rai->alist->compact_forward_list;

    join_condition_cast_info_.rais.push_back(move(rai_info_cast_info_));
    cond_cast_info_.push_back(move(join_condition_cast_info_));

    LogicalComparisonJoin join_cast_info__op(JoinType::INNER);
    vector<LogicalType> output_cast_info__types{LogicalType::VARCHAR, LogicalType::BIGINT, LogicalType::BIGINT,
                                                LogicalType::BOOLEAN, LogicalType::VARCHAR, LogicalType::VARCHAR,
                                                LogicalType::VARCHAR};
    join_cast_info__op.types = output_cast_info__types;
    vector<idx_t> right_projection_map_cast_info_{4, 5, 6};
    vector<idx_t> merge_project_map_cast_info_;
    vector<LogicalType> delim_types_cast_info_;
    auto join_cast_info_ = make_uniq<PhysicalSIPJoin>(join_cast_info__op, move(filter_in), move(join_keyword_k), move(cond_cast_info_),
                                                           JoinType::INNER, left_projection_map,
                                                           right_projection_map_cast_info_,
                                                           delim_types_cast_info_, 0);

    vector<idx_t> name_n_ids{COLUMN_IDENTIFIER_ROW_ID, 1, 4};
    vector<LogicalType> get_name_n_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::VARCHAR};
    string alias_name_n = "n";
    vector<LogicalType> table_types_name_n;
    vector<unique_ptr<Expression>> filter_name_n;
    unique_ptr<LogicalGet> get_op_name_n = move(
            getLogicalGet(*this, table_name, alias_name_n, table_index_name_n, table_types_name_n));
    unique_ptr<TableFilterSet> table_filters_name_n = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_n = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL, Value("m"));
    table_filters_name_n->filters[2] = move(constant_filter_n);
    unique_ptr<PhysicalTableScan> scan_name_n = make_uniq<PhysicalTableScan>(get_name_n_types, get_op_name_n->function,
                                                                             get_op_name_n->table_index,
                                                                             move(get_op_name_n->bind_data),
                                                                             table_types_name_n, name_n_ids,
                                                                             move(filter_name_n), vector<column_t>(),
                                                                             get_op_name_n->names,
                                                                             std::move(table_filters_name_n),
                                                                             get_op_name_n->estimated_cardinality,
                                                                             get_op_name_n->extra_info);


    vector<JoinCondition> cond_name_n;
    JoinCondition join_condition_name_n;
    join_condition_name_n.left = make_uniq<BoundReferenceExpression>("name_rowid", LogicalType::BIGINT, 0);
    join_condition_name_n.right = make_uniq<BoundReferenceExpression>("person_id_rowid", LogicalType::BIGINT, 2);
    join_condition_name_n.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_name_n = make_uniq<RAIInfo>();
    rai_info_name_n->rai = table_cast_info.GetStorage().info->rais[0].get();
    rai_info_name_n->rai_type = RAIType::TARGET_EDGE;
    rai_info_name_n->forward = true;
    rai_info_name_n->vertex = &table_name;
    rai_info_name_n->vertex_id = table_index_name_n;
    rai_info_name_n->passing_tables[0] = table_index_name_n;
    rai_info_name_n->left_cardinalities[0] = table_name.GetStorage().info->cardinality;
    // rai_info_name_n->compact_list = &rai_info_name_n->rai->alist->compact__list;

    join_condition_name_n.rais.push_back(move(rai_info_name_n));
    cond_name_n.push_back(move(join_condition_name_n));

    LogicalComparisonJoin join_name_n_op(JoinType::INNER);
    vector<LogicalType> output_name_n_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::VARCHAR,
                                            LogicalType::VARCHAR, LogicalType::VARCHAR, LogicalType::VARCHAR};
    join_name_n_op.types = output_name_n_types;
    vector<idx_t> right_projection_map_name_n{4, 5, 6};
    vector<idx_t> merge_project_map_name_n;
    vector<LogicalType> delim_types_name_n;
    auto join_name_n = make_uniq<PhysicalSIPJoin>(join_name_n_op, move(scan_name_n), move(join_cast_info_), move(cond_name_n), JoinType::INNER,
                                                  left_projection_map, right_projection_map_name_n, delim_types_name_n,
                                                  0);


    vector<LogicalType> result_types{LogicalType::VARCHAR, LogicalType::VARCHAR, LogicalType::VARCHAR, LogicalType::VARCHAR};
    vector<unique_ptr<Expression>> select_list;
    auto result_col0 = make_uniq<BoundReferenceExpression>("info", LogicalType::VARCHAR, 3);
    auto result_col1 = make_uniq<BoundReferenceExpression>("info", LogicalType::VARCHAR, 5);
    auto result_col2 = make_uniq<BoundReferenceExpression>("name", LogicalType::VARCHAR, 1);
    auto result_col3 = make_uniq<BoundReferenceExpression>("title", LogicalType::VARCHAR, 4);
    select_list.push_back(move(result_col0));
    select_list.push_back(move(result_col1));
    select_list.push_back(move(result_col2));
    select_list.push_back(move(result_col3));
    auto projection = make_uniq<PhysicalProjection>(result_types, move(select_list), 0);
    projection->children.push_back(move(join_name_n));

    // aggregate
    string agg_name = "min";
    string agg_error = "";
    QueryErrorContext error_context(NULL, NULL);
    auto min_func = Catalog::GetEntry(context, CatalogType::SCALAR_FUNCTION_ENTRY, "", "",
                                      "min", OnEntryNotFound::RETURN_NULL, error_context);
    auto &min_func_set = min_func->Cast<AggregateFunctionCatalogEntry>();
    // bind the aggregate
    FunctionBinder function_binder(context);
    vector<LogicalType> types;
    types.push_back(LogicalType::VARCHAR);
    idx_t best_function_varchar = function_binder.BindFunction(agg_name, min_func_set.functions, types, agg_error);
    auto bound_function_min_varchar = min_func_set.functions.GetFunctionByOffset(best_function_varchar);
    // std::cout << best_function_varchar << " " << bound_function_min_varchar.return_type.ToString() << std::endl;

    auto first_children = make_uniq<BoundReferenceExpression>("info", LogicalType::VARCHAR, 0);
    vector<unique_ptr<Expression>> childrenlist1;
    childrenlist1.push_back(move(first_children));
    auto aggregate1 =
            function_binder.BindAggregateFunction(bound_function_min_varchar, std::move(childrenlist1), nullptr,
                                                  AggregateType::NON_DISTINCT);

    auto second_children = make_uniq<BoundReferenceExpression>("info", LogicalType::VARCHAR, 1);
    vector<unique_ptr<Expression>> childrenlist2;
    childrenlist2.push_back(move(second_children));
    auto aggregate2 =
            function_binder.BindAggregateFunction(bound_function_min_varchar, std::move(childrenlist2), nullptr,
                                                  AggregateType::NON_DISTINCT);

    auto third_children = make_uniq<BoundReferenceExpression>("name", LogicalType::VARCHAR, 2);
    vector<unique_ptr<Expression>> childrenlist3;
    childrenlist3.push_back(move(third_children));
    auto aggregate3 =
            function_binder.BindAggregateFunction(bound_function_min_varchar, std::move(childrenlist3), nullptr,
                                                  AggregateType::NON_DISTINCT);

    auto fourth_children = make_uniq<BoundReferenceExpression>("title", LogicalType::VARCHAR, 3);
    vector<unique_ptr<Expression>> childrenlist4;
    childrenlist4.push_back(move(fourth_children));
    auto aggregate4 =
            function_binder.BindAggregateFunction(bound_function_min_varchar, std::move(childrenlist4), nullptr,
                                                  AggregateType::NON_DISTINCT);

    vector<unique_ptr<Expression>> aggregates;
    aggregates.push_back(move(aggregate1));
    aggregates.push_back(move(aggregate2));
    aggregates.push_back(move(aggregate3));
    aggregates.push_back(move(aggregate4));

    vector<LogicalType> aggregate_types{LogicalType::VARCHAR, LogicalType::VARCHAR, LogicalType::VARCHAR, LogicalType::VARCHAR};
    auto ungrouped_aggregate = make_uniq<PhysicalUngroupedAggregate>(aggregate_types, move(aggregates), 0);
    ungrouped_aggregate->children.push_back(move(projection));

    return ungrouped_aggregate;
}

unique_ptr<PhysicalOperator> ClientContext::GenerateJOB26aPlan(duckdb::ClientContext &context) {
    vector<idx_t> left_projection_map, right_projection_map;

    string table_vertex_kind_type_kt = "kind_type";
    string table_vertex_title_t = "title";
    string table_vertex_keyword_k = "keyword";
    string table_vertex_char_name_chn = "char_name";
    string table_vertex_name_n = "name";
    string table_vertex_comp_cast_type_cct1 = "comp_cast_type";
    string table_vertex_comp_cast_type_cct2 = "comp_cast_type";
    string table_vertex_info_type_it2 = "info_type";
    string table_vertex_movie_keyword_ = "movie_keyword";
    string table_vertex_cast_info_ = "cast_info";
    string table_vertex_complete_cast_ = "complete_cast";
    string table_vertex_movie_info_idx_ = "movie_info_idx";

    idx_t table_index_kind_type_kt = 1;
    idx_t table_index_title_t = 2;
    idx_t table_index_keyword_k = 3;
    idx_t table_index_char_name_chn = 4;
    idx_t table_index_name_n = 5;
    idx_t table_index_comp_cast_type_cct1 = 6;
    idx_t table_index_comp_cast_type_cct2 = 7;
    idx_t table_index_info_type_it2 = 8;
    idx_t table_index_movie_keyword_ = 10;
    idx_t table_index_cast_info_ = 12;
    idx_t table_index_complete_cast_ = 13;
    idx_t table_index_movie_info_idx_ = 15;
    auto table_or_view_kind_type = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_kind_type_kt,
                                                     OnEntryNotFound::RETURN_NULL);
    auto &table_kind_type = table_or_view_kind_type->Cast<TableCatalogEntry>();
    auto table_or_view_title = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_title_t,
                                                 OnEntryNotFound::RETURN_NULL);
    auto &table_title = table_or_view_title->Cast<TableCatalogEntry>();
    auto table_or_view_keyword = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_keyword_k,
                                                   OnEntryNotFound::RETURN_NULL);
    auto &table_keyword = table_or_view_keyword->Cast<TableCatalogEntry>();
    auto table_or_view_char_name = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                     table_vertex_char_name_chn, OnEntryNotFound::RETURN_NULL);
    auto &table_char_name = table_or_view_char_name->Cast<TableCatalogEntry>();
    auto table_or_view_name = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_name_n,
                                                OnEntryNotFound::RETURN_NULL);
    auto &table_name = table_or_view_name->Cast<TableCatalogEntry>();
    auto table_or_view_comp_cast_type = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                          table_vertex_comp_cast_type_cct1,
                                                          OnEntryNotFound::RETURN_NULL);
    auto &table_comp_cast_type = table_or_view_comp_cast_type->Cast<TableCatalogEntry>();
    auto table_or_view_info_type = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                     table_vertex_info_type_it2, OnEntryNotFound::RETURN_NULL);
    auto &table_info_type = table_or_view_info_type->Cast<TableCatalogEntry>();
    auto table_or_view_movie_keyword = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                         table_vertex_movie_keyword_, OnEntryNotFound::RETURN_NULL);
    auto &table_movie_keyword = table_or_view_movie_keyword->Cast<TableCatalogEntry>();
    auto table_or_view_cast_info = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_cast_info_,
                                                     OnEntryNotFound::RETURN_NULL);
    auto &table_cast_info = table_or_view_cast_info->Cast<TableCatalogEntry>();
    auto table_or_view_complete_cast = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                                 table_vertex_complete_cast_,
                                                                 OnEntryNotFound::RETURN_NULL);
    auto &table_complete_cast = table_or_view_complete_cast->Cast<TableCatalogEntry>();
    auto table_or_view_movie_info_idx = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                          table_vertex_movie_info_idx_, OnEntryNotFound::RETURN_NULL);
    auto &table_movie_info_idx = table_or_view_movie_info_idx->Cast<TableCatalogEntry>();


    vector<idx_t> comp_cast_type_cct2_ids{COLUMN_IDENTIFIER_ROW_ID, 1};
    vector<LogicalType> get_comp_cast_type_cct2_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_comp_cast_type_cct2 = "cct2";
    vector<LogicalType> table_types_comp_cast_type_cct2;
    vector<unique_ptr<Expression>> filter_comp_cast_type_cct2;
    unique_ptr<LogicalGet> get_op_comp_cast_type_cct2 = move(
            getLogicalGet(*this, table_comp_cast_type, alias_comp_cast_type_cct2, table_index_comp_cast_type_cct2,
                          table_types_comp_cast_type_cct2));
    unique_ptr<TableFilterSet> table_filters_comp_cast_type_cct2 = NULL;
    unique_ptr<PhysicalTableScan> scan_comp_cast_type_cct2 = make_uniq<PhysicalTableScan>(get_comp_cast_type_cct2_types,
                                                                                          get_op_comp_cast_type_cct2->function,
                                                                                          get_op_comp_cast_type_cct2->table_index,
                                                                                          move(get_op_comp_cast_type_cct2->bind_data),
                                                                                          table_types_comp_cast_type_cct2,
                                                                                          comp_cast_type_cct2_ids,
                                                                                          move(filter_comp_cast_type_cct2),
                                                                                          vector<column_t>(),
                                                                                          get_op_comp_cast_type_cct2->names,
                                                                                          std::move(
                                                                                                  table_filters_comp_cast_type_cct2),
                                                                                          get_op_comp_cast_type_cct2->estimated_cardinality,
                                                                                          get_op_comp_cast_type_cct2->extra_info);

    vector<LogicalType> filter_cct_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    vector<unique_ptr<Expression>> select_list_cct;
    auto like_expression_left_cct = make_uniq<BoundReferenceExpression>("kind", LogicalType::VARCHAR, 1);
    auto like_expression_value_cct = make_uniq<BoundConstantExpression>(Value("complete"));
    vector<unique_ptr<Expression>> like_arguments_cct;
    like_arguments_cct.push_back(move(like_expression_left_cct));
    like_arguments_cct.push_back(move(like_expression_value_cct));

    ScalarFunction bound_function_contains = ContainsFun::GetFunction();
    unique_ptr<FunctionData> bind_data_contains = NULL;

    auto like_bound_function_cct = make_uniq<BoundFunctionExpression>(LogicalType::BOOLEAN,
                                                                       bound_function_contains,
                                                                       move(like_arguments_cct),
                                                                       move(bind_data_contains), false);

    select_list_cct.push_back(move(like_bound_function_cct));
    unique_ptr<PhysicalFilter> filter_cct_contains = make_uniq<PhysicalFilter>(filter_cct_types, move(select_list_cct), 0);
    filter_cct_contains->children.push_back(move(scan_comp_cast_type_cct2));

    vector<idx_t> complete_cast_ids{4, 5, 6};
    vector<LogicalType> get_complete_cast_types{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::BIGINT};
    string alias_complete_cast = "cc";
    vector<LogicalType> table_types_complete_cast;
    vector<unique_ptr<Expression>> filter_complete_cast;
    unique_ptr<LogicalGet> get_op_complete_cast = move(
            getLogicalGet(*this, table_complete_cast, alias_complete_cast, table_index_complete_cast_,
                          table_types_complete_cast));
    unique_ptr<TableFilterSet> table_filters_complete_cast = NULL;
    unique_ptr<PhysicalTableScan> scan_complete_cast = make_uniq<PhysicalTableScan>(get_complete_cast_types,
                                                                                    get_op_complete_cast->function,
                                                                                    get_op_complete_cast->table_index,
                                                                                    move(get_op_complete_cast->bind_data),
                                                                                    table_types_complete_cast,
                                                                                    complete_cast_ids,
                                                                                    move(filter_complete_cast),
                                                                                    vector<column_t>(),
                                                                                    get_op_complete_cast->names,
                                                                                    std::move(
                                                                                            table_filters_complete_cast),
                                                                                    get_op_complete_cast->estimated_cardinality,
                                                                                    get_op_complete_cast->extra_info);


    vector<JoinCondition> cond_complete_cast_status_;
    JoinCondition join_condition_complete_cast_status_;
    join_condition_complete_cast_status_.left = make_uniq<BoundReferenceExpression>("status_id_rowid", LogicalType::BIGINT, 2);
    join_condition_complete_cast_status_.right = make_uniq<BoundReferenceExpression>("comp_cast_type_rowid", LogicalType::BIGINT, 0);
    join_condition_complete_cast_status_.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_complete_cast_status_ = make_uniq<RAIInfo>();
    rai_info_complete_cast_status_->rai = table_complete_cast.GetStorage().info->rais[1].get();
    rai_info_complete_cast_status_->rai_type = RAIType::EDGE_SOURCE;
    rai_info_complete_cast_status_->forward = true;
    rai_info_complete_cast_status_->vertex = &table_comp_cast_type;
    rai_info_complete_cast_status_->vertex_id = table_index_comp_cast_type_cct2;
    rai_info_complete_cast_status_->passing_tables[0] = table_index_complete_cast_;
    rai_info_complete_cast_status_->left_cardinalities[0] = table_complete_cast.GetStorage().info->cardinality;
    rai_info_complete_cast_status_->compact_list = &rai_info_complete_cast_status_->rai->alist->compact_forward_list;

    join_condition_complete_cast_status_.rais.push_back(move(rai_info_complete_cast_status_));
    cond_complete_cast_status_.push_back(move(join_condition_complete_cast_status_));

    LogicalComparisonJoin join_complete_cast_status__op(JoinType::INNER);
    vector<LogicalType> output_complete_cast_status__types{LogicalType::BIGINT, LogicalType::BIGINT,
                                                           LogicalType::BIGINT, LogicalType::BIGINT};
    join_complete_cast_status__op.types = output_complete_cast_status__types;
    vector<idx_t> right_projection_map_complete_cast_status_{0};
    vector<idx_t> merge_project_map_complete_cast_status_;
    vector<LogicalType> delim_types_complete_cast_status_;
    auto join_complete_cast_status_ = make_uniq<PhysicalSIPJoin>(join_complete_cast_status__op, move(scan_complete_cast), move(filter_cct_contains),
                                                                      move(cond_complete_cast_status_), JoinType::INNER,
                                                                      left_projection_map,
                                                                      right_projection_map_complete_cast_status_,
                                                                      delim_types_complete_cast_status_, 0);


    vector<idx_t> title_t_ids{COLUMN_IDENTIFIER_ROW_ID, 1, 4, 12};
    vector<LogicalType> get_title_t_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::BIGINT,
                                          LogicalType::BIGINT};
    string alias_title_t = "t";
    vector<LogicalType> table_types_title_t;
    vector<unique_ptr<Expression>> filter_title_t;
    unique_ptr<LogicalGet> get_op_title_t = move(
            getLogicalGet(*this, table_title, alias_title_t, table_index_title_t, table_types_title_t));
    unique_ptr<TableFilterSet> table_filters_title_t = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_t = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_GREATERTHAN, Value::BIGINT(2000));
    table_filters_title_t->filters[2] = move(constant_filter_t);
    unique_ptr<PhysicalTableScan> scan_title_t = make_uniq<PhysicalTableScan>(get_title_t_types,
                                                                              get_op_title_t->function,
                                                                              get_op_title_t->table_index,
                                                                              move(get_op_title_t->bind_data),
                                                                              table_types_title_t, title_t_ids,
                                                                              move(filter_title_t), vector<column_t>(),
                                                                              get_op_title_t->names,
                                                                              std::move(table_filters_title_t),
                                                                              get_op_title_t->estimated_cardinality,
                                                                              get_op_title_t->extra_info);


    vector<JoinCondition> cond_title_t;
    JoinCondition join_condition_title_t;
    join_condition_title_t.left = make_uniq<BoundReferenceExpression>("title_rowid", LogicalType::BIGINT, 0);
    join_condition_title_t.right = make_uniq<BoundReferenceExpression>("movie_id_rowid", LogicalType::BIGINT, 1);
    join_condition_title_t.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_title_t = make_uniq<RAIInfo>();
    rai_info_title_t->rai = table_complete_cast.GetStorage().info->rais[1].get();
    rai_info_title_t->rai_type = RAIType::TARGET_EDGE;
    rai_info_title_t->forward = true;
    rai_info_title_t->vertex = &table_title;
    rai_info_title_t->vertex_id = table_index_title_t;
    rai_info_title_t->passing_tables[0] = table_index_title_t;
    rai_info_title_t->left_cardinalities[0] = table_title.GetStorage().info->cardinality;
    // rai_info_title_t->compact_list = &rai_info_title_t->rai->alist->compact__list;

    join_condition_title_t.rais.push_back(move(rai_info_title_t));
    cond_title_t.push_back(move(join_condition_title_t));

    LogicalComparisonJoin join_title_t_op(JoinType::INNER);
    vector<LogicalType> output_title_t_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::BIGINT,
                                             LogicalType::BIGINT, LogicalType::BIGINT};
    join_title_t_op.types = output_title_t_types;
    vector<idx_t> right_projection_map_title_t{0};
    vector<idx_t> merge_project_map_title_t;
    vector<LogicalType> delim_types_title_t;
    auto join_title_t = make_uniq<PhysicalSIPJoin>(join_title_t_op, move(scan_title_t), move(join_complete_cast_status_), move(cond_title_t), JoinType::INNER,
                                                   left_projection_map, right_projection_map_title_t,
                                                   delim_types_title_t, 0);

    vector<idx_t> movie_info_idx_ids{6, 5, 3};
    vector<LogicalType> get_movie_info_idx_type{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_movie_info_idx = "mi";
    vector<LogicalType> table_types_movie_info_idx;
    vector<unique_ptr<Expression>> filter_movie_info_idx;
    unique_ptr<LogicalGet> get_op_movie_info_idx = move(
            getLogicalGet(*this, table_movie_info_idx, alias_movie_info_idx, table_index_movie_info_idx_, table_types_movie_info_idx));
    unique_ptr<TableFilterSet> table_filters_movie_info_idx = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_idx = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_GREATERTHAN, Value("7.0"));
    table_filters_movie_info_idx->filters[2] = move(constant_filter_idx);
    unique_ptr<PhysicalTableScan> scan_movie_info_idx = make_uniq<PhysicalTableScan>(get_movie_info_idx_type,
                                                                                     get_op_movie_info_idx->function,
                                                                                     get_op_movie_info_idx->table_index,
                                                                                     move(get_op_movie_info_idx->bind_data),
                                                                                     table_types_movie_info_idx, movie_info_idx_ids,
                                                                                     move(filter_movie_info_idx),
                                                                                     vector<column_t>(),
                                                                                     get_op_movie_info_idx->names,
                                                                                     std::move(table_filters_movie_info_idx),
                                                                                     get_op_movie_info_idx->estimated_cardinality,
                                                                                     get_op_movie_info_idx->extra_info);


    vector<JoinCondition> cond_movie_info_idx_;
    JoinCondition join_condition_movie_info_idx_;
    join_condition_movie_info_idx_.left = make_uniq<BoundReferenceExpression>("movie_id_rowid", LogicalType::BIGINT, 0);
    join_condition_movie_info_idx_.right = make_uniq<BoundReferenceExpression>("title_rowid", LogicalType::BIGINT, 0);
    join_condition_movie_info_idx_.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_movie_info_idx_ = make_uniq<RAIInfo>();
    rai_info_movie_info_idx_->rai = table_movie_info_idx.GetStorage().info->rais[0].get();
    rai_info_movie_info_idx_->rai_type = RAIType::EDGE_TARGET;
    rai_info_movie_info_idx_->forward = false;
    rai_info_movie_info_idx_->vertex = &table_title;
    rai_info_movie_info_idx_->vertex_id = table_index_title_t;
    rai_info_movie_info_idx_->passing_tables[0] = table_index_movie_info_idx_;
    rai_info_movie_info_idx_->left_cardinalities[0] = table_movie_info_idx.GetStorage().info->cardinality;
    rai_info_movie_info_idx_->compact_list = &rai_info_movie_info_idx_->rai->alist->compact_backward_list;

    join_condition_movie_info_idx_.rais.push_back(move(rai_info_movie_info_idx_));
    cond_movie_info_idx_.push_back(move(join_condition_movie_info_idx_));

    LogicalComparisonJoin join_movie_info_idx__op(JoinType::INNER);
    vector<LogicalType> output_movie_info_idx__types{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::VARCHAR,
                                                     LogicalType::VARCHAR, LogicalType::BIGINT, LogicalType::BIGINT};
    join_movie_info_idx__op.types = output_movie_info_idx__types;
    vector<idx_t> right_projection_map_movie_info_idx_{1, 3, 4};
    vector<idx_t> merge_project_map_movie_info_idx_;
    vector<LogicalType> delim_types_movie_info_idx_;
    auto join_movie_info_idx_ = make_uniq<PhysicalSIPJoin>(join_movie_info_idx__op, move(scan_movie_info_idx), move(join_title_t),
                                                                move(cond_movie_info_idx_), JoinType::INNER,
                                                                left_projection_map,
                                                                right_projection_map_movie_info_idx_,
                                                                delim_types_movie_info_idx_, 0);


    vector<idx_t> info_type_it2_ids{COLUMN_IDENTIFIER_ROW_ID, 1};
    vector<LogicalType> get_info_type_it2_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_info_type_it2 = "it2";
    vector<LogicalType> table_types_info_type_it2;
    vector<unique_ptr<Expression>> filter_info_type_it2;
    unique_ptr<LogicalGet> get_op_info_type_it2 = move(
            getLogicalGet(*this, table_info_type, alias_info_type_it2, table_index_info_type_it2,
                          table_types_info_type_it2));
    unique_ptr<TableFilterSet> table_filters_info_type_it2 = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_it2 = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL, Value("rating"));
    table_filters_info_type_it2->filters[1] = move(constant_filter_it2);
    unique_ptr<PhysicalTableScan> scan_info_type_it2 = make_uniq<PhysicalTableScan>(get_info_type_it2_types,
                                                                                    get_op_info_type_it2->function,
                                                                                    get_op_info_type_it2->table_index,
                                                                                    move(get_op_info_type_it2->bind_data),
                                                                                    table_types_info_type_it2,
                                                                                    info_type_it2_ids,
                                                                                    move(filter_info_type_it2),
                                                                                    vector<column_t>(),
                                                                                    get_op_info_type_it2->names,
                                                                                    std::move(
                                                                                            table_filters_info_type_it2),
                                                                                    get_op_info_type_it2->estimated_cardinality,
                                                                                    get_op_info_type_it2->extra_info);


    vector<JoinCondition> cond_info_type_it2;
    JoinCondition join_condition_info_type_it2;
    join_condition_info_type_it2.left = make_uniq<BoundReferenceExpression>("info_type_rowid", LogicalType::BIGINT, 0);
    join_condition_info_type_it2.right = make_uniq<BoundReferenceExpression>("info_type_id_rowid", LogicalType::BIGINT, 1);
    join_condition_info_type_it2.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_info_type_it2 = make_uniq<RAIInfo>();
    rai_info_info_type_it2->rai = table_movie_info_idx.GetStorage().info->rais[0].get();
    rai_info_info_type_it2->rai_type = RAIType::SOURCE_EDGE;
    rai_info_info_type_it2->forward = false;
    rai_info_info_type_it2->vertex = &table_info_type;
    rai_info_info_type_it2->vertex_id = table_index_info_type_it2;
    rai_info_info_type_it2->passing_tables[0] = table_index_info_type_it2;
    rai_info_info_type_it2->left_cardinalities[0] = table_info_type.GetStorage().info->cardinality;
    // rai_info_info_type_it2->compact_list = &rai_info_info_type_it2->rai->alist->compact__list;

    join_condition_info_type_it2.rais.push_back(move(rai_info_info_type_it2));
    cond_info_type_it2.push_back(move(join_condition_info_type_it2));

    LogicalComparisonJoin join_info_type_it2_op(JoinType::INNER);
    vector<LogicalType> output_info_type_it2_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::BIGINT,
                                                   LogicalType::VARCHAR, LogicalType::VARCHAR, LogicalType::BIGINT,
                                                   LogicalType::BIGINT};
    join_info_type_it2_op.types = output_info_type_it2_types;
    vector<idx_t> right_projection_map_info_type_it2{0, 2, 3, 4, 5};
    vector<idx_t> merge_project_map_info_type_it2;
    vector<LogicalType> delim_types_info_type_it2;
    auto join_info_type_it2 = make_uniq<PhysicalSIPJoin>(join_info_type_it2_op, move(scan_info_type_it2), move(join_movie_info_idx_),
                                                         move(cond_info_type_it2), JoinType::INNER, left_projection_map,
                                                         right_projection_map_info_type_it2, delim_types_info_type_it2,
                                                         0);

    vector<idx_t> comp_cast_type_cct1_ids{COLUMN_IDENTIFIER_ROW_ID, 1};
    vector<LogicalType> get_comp_cast_type_cct1_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_comp_cast_type_cct1 = "cct1";
    vector<LogicalType> table_types_comp_cast_type_cct1;
    vector<unique_ptr<Expression>> filter_comp_cast_type_cct1;
    unique_ptr<LogicalGet> get_op_comp_cast_type_cct1 = move(
            getLogicalGet(*this, table_comp_cast_type, alias_comp_cast_type_cct1, table_index_comp_cast_type_cct1,
                          table_types_comp_cast_type_cct1));
    unique_ptr<TableFilterSet> table_filters_comp_cast_type_cct1 = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_cct1 = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL, Value("cast"));
    table_filters_comp_cast_type_cct1->filters[1] = move(constant_filter_cct1);
    unique_ptr<PhysicalTableScan> scan_comp_cast_type_cct1 = make_uniq<PhysicalTableScan>(get_comp_cast_type_cct1_types,
                                                                                          get_op_comp_cast_type_cct1->function,
                                                                                          get_op_comp_cast_type_cct1->table_index,
                                                                                          move(get_op_comp_cast_type_cct1->bind_data),
                                                                                          table_types_comp_cast_type_cct1,
                                                                                          comp_cast_type_cct1_ids,
                                                                                          move(filter_comp_cast_type_cct1),
                                                                                          vector<column_t>(),
                                                                                          get_op_comp_cast_type_cct1->names,
                                                                                          std::move(
                                                                                                  table_filters_comp_cast_type_cct1),
                                                                                          get_op_comp_cast_type_cct1->estimated_cardinality,
                                                                                          get_op_comp_cast_type_cct1->extra_info);


    vector<JoinCondition> cond_comp_cast_type_cct1;
    JoinCondition join_condition_comp_cast_type_cct1;
    join_condition_comp_cast_type_cct1.left = make_uniq<BoundReferenceExpression>("comp_cast_type_rowid", LogicalType::BIGINT, 0);
    join_condition_comp_cast_type_cct1.right = make_uniq<BoundReferenceExpression>("subject_id_rowid", LogicalType::BIGINT, 6);
    join_condition_comp_cast_type_cct1.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_comp_cast_type_cct1 = make_uniq<RAIInfo>();
    rai_info_comp_cast_type_cct1->rai = table_complete_cast.GetStorage().info->rais[0].get();
    rai_info_comp_cast_type_cct1->rai_type = RAIType::SOURCE_EDGE;
    rai_info_comp_cast_type_cct1->forward = false;
    rai_info_comp_cast_type_cct1->vertex = &table_comp_cast_type;
    rai_info_comp_cast_type_cct1->vertex_id = table_index_comp_cast_type_cct1;
    rai_info_comp_cast_type_cct1->passing_tables[0] = table_index_comp_cast_type_cct1;
    rai_info_comp_cast_type_cct1->left_cardinalities[0] = table_comp_cast_type.GetStorage().info->cardinality;
    // rai_info_comp_cast_type_cct1->compact_list = &rai_info_comp_cast_type_cct1->rai->alist->compact__list;

    join_condition_comp_cast_type_cct1.rais.push_back(move(rai_info_comp_cast_type_cct1));
    cond_comp_cast_type_cct1.push_back(move(join_condition_comp_cast_type_cct1));

    LogicalComparisonJoin join_comp_cast_type_cct1_op(JoinType::INNER);
    vector<LogicalType> output_comp_cast_type_cct1_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::BIGINT,
                                                         LogicalType::VARCHAR, LogicalType::VARCHAR, LogicalType::BIGINT};
    join_comp_cast_type_cct1_op.types = output_comp_cast_type_cct1_types;
    vector<idx_t> right_projection_map_comp_cast_type_cct1{2, 3, 4, 5};
    vector<idx_t> merge_project_map_comp_cast_type_cct1;
    vector<LogicalType> delim_types_comp_cast_type_cct1;
    auto join_comp_cast_type_cct1 = make_uniq<PhysicalSIPJoin>(join_comp_cast_type_cct1_op, move(scan_comp_cast_type_cct1), move(join_info_type_it2),
                                                               move(cond_comp_cast_type_cct1), JoinType::INNER,
                                                               left_projection_map,
                                                               right_projection_map_comp_cast_type_cct1,
                                                               delim_types_comp_cast_type_cct1, 0);


    vector<idx_t> kind_type_kt_ids{COLUMN_IDENTIFIER_ROW_ID, 1};
    vector<LogicalType> get_kind_type_kt_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_kind_type_kt = "kt";
    vector<LogicalType> table_types_kind_type_kt;
    vector<unique_ptr<Expression>> filter_kind_type_kt;
    unique_ptr<LogicalGet> get_op_kind_type_kt = move(
            getLogicalGet(*this, table_kind_type, alias_kind_type_kt, table_index_kind_type_kt,
                          table_types_kind_type_kt));
    unique_ptr<TableFilterSet> table_filters_kind_type_kt = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_kt = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL, Value("movie"));
    table_filters_kind_type_kt->filters[1] = move(constant_filter_kt);
    unique_ptr<PhysicalTableScan> scan_kind_type_kt = make_uniq<PhysicalTableScan>(get_kind_type_kt_types,
                                                                                   get_op_kind_type_kt->function,
                                                                                   get_op_kind_type_kt->table_index,
                                                                                   move(get_op_kind_type_kt->bind_data),
                                                                                   table_types_kind_type_kt,
                                                                                   kind_type_kt_ids,
                                                                                   move(filter_kind_type_kt),
                                                                                   vector<column_t>(),
                                                                                   get_op_kind_type_kt->names,
                                                                                   std::move(
                                                                                           table_filters_kind_type_kt),
                                                                                   get_op_kind_type_kt->estimated_cardinality,
                                                                                   get_op_kind_type_kt->extra_info);


    vector<JoinCondition> cond_kind_type_kt;
    JoinCondition join_condition_kind_type_kt;
    join_condition_kind_type_kt.left = make_uniq<BoundReferenceExpression>("kind_type_rowid", LogicalType::BIGINT, 0);
    join_condition_kind_type_kt.right = make_uniq<BoundReferenceExpression>("kind_id_rowid", LogicalType::BIGINT, 5);
    join_condition_kind_type_kt.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_kind_type_kt = make_uniq<RAIInfo>();
    rai_info_kind_type_kt->rai = table_title.GetStorage().info->rais[0].get();
    rai_info_kind_type_kt->rai_type = RAIType::TARGET_EDGE;
    rai_info_kind_type_kt->forward = true;
    rai_info_kind_type_kt->vertex = &table_kind_type;
    rai_info_kind_type_kt->vertex_id = table_index_kind_type_kt;
    rai_info_kind_type_kt->passing_tables[0] = table_index_kind_type_kt;
    rai_info_kind_type_kt->left_cardinalities[0] = table_kind_type.GetStorage().info->cardinality;
    // rai_info_kind_type_kt->compact_list = &rai_info_kind_type_kt->rai->alist->compact__list;

    join_condition_kind_type_kt.rais.push_back(move(rai_info_kind_type_kt));
    cond_kind_type_kt.push_back(move(join_condition_kind_type_kt));

    LogicalComparisonJoin join_kind_type_kt_op(JoinType::INNER);
    vector<LogicalType> output_kind_type_kt_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::BIGINT,
                                                  LogicalType::VARCHAR, LogicalType::VARCHAR};
    join_kind_type_kt_op.types = output_kind_type_kt_types;
    vector<idx_t> right_projection_map_kind_type_kt{2, 3, 4};
    vector<idx_t> merge_project_map_kind_type_kt;
    vector<LogicalType> delim_types_kind_type_kt;
    auto join_kind_type_kt = make_uniq<PhysicalSIPJoin>(join_kind_type_kt_op, move(scan_kind_type_kt), move(join_comp_cast_type_cct1), move(cond_kind_type_kt),
                                                        JoinType::INNER, left_projection_map,
                                                        right_projection_map_kind_type_kt, delim_types_kind_type_kt, 0);

    vector<idx_t> keyword_k_ids{COLUMN_IDENTIFIER_ROW_ID, 1};
    vector<LogicalType> get_keyword_k_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_keyword_k = "k";
    vector<LogicalType> table_types_keyword_k;
    vector<unique_ptr<Expression>> filter_keyword_k;
    unique_ptr<LogicalGet> get_op_keyword_k = move(
            getLogicalGet(*this, table_keyword, alias_keyword_k, table_index_keyword_k, table_types_keyword_k));
    unique_ptr<TableFilterSet> table_filters_keyword_k = NULL;
    unique_ptr<PhysicalTableScan> scan_keyword_k = make_uniq<PhysicalTableScan>(get_keyword_k_types,
                                                                                get_op_keyword_k->function,
                                                                                get_op_keyword_k->table_index,
                                                                                move(get_op_keyword_k->bind_data),
                                                                                table_types_keyword_k, keyword_k_ids,
                                                                                move(filter_keyword_k),
                                                                                vector<column_t>(),
                                                                                get_op_keyword_k->names,
                                                                                std::move(table_filters_keyword_k),
                                                                                get_op_keyword_k->estimated_cardinality,
                                                                                get_op_keyword_k->extra_info);


    auto &allocator_k = Allocator::Get(context);
    vector<LogicalType> join_in_types_k {LogicalType::VARCHAR};
    auto collection_k =
            make_uniq<ColumnDataCollection>(context, join_in_types_k, ColumnDataAllocatorType::IN_MEMORY_ALLOCATOR);

    vector<LogicalType> chunk_in_types_k {LogicalType::VARCHAR};
    DataChunk chunk_k;
    chunk_k.SetCardinality(10);
    chunk_k.Initialize(allocator_k, chunk_in_types_k);
    chunk_k.SetValue(0, 0, Value("superhero"));
    chunk_k.SetValue(0, 1, Value("marvel-comics"));
    chunk_k.SetValue(0, 2, Value("based-on-comic"));
    chunk_k.SetValue(0, 3, Value("tv-special"));
    chunk_k.SetValue(0, 4, Value("fight"));
    chunk_k.SetValue(0, 5, Value("violence"));
    chunk_k.SetValue(0, 6, Value("magnet"));
    chunk_k.SetValue(0, 7, Value("web"));
    chunk_k.SetValue(0, 8, Value("claw"));
    chunk_k.SetValue(0, 9, Value("laser"));
    collection_k->Append(chunk_k);

    // create a chunk scan to output the result
    vector<LogicalType> ouput_in_types_k {LogicalType::VARCHAR};
    auto chunk_scan_k = make_uniq<PhysicalColumnDataScan>(ouput_in_types_k, PhysicalOperatorType::COLUMN_DATA_SCAN,
                                                          10, std::move(collection_k));

    vector<JoinCondition> cond_hash_join_k;
    JoinCondition join_condition_hash_join_k;
    join_condition_hash_join_k.left = make_uniq<BoundReferenceExpression>("keyword", LogicalType::VARCHAR, 1);
    join_condition_hash_join_k.right = make_uniq<BoundReferenceExpression>("", LogicalType::VARCHAR, 0);
    join_condition_hash_join_k.comparison = ExpressionType::COMPARE_EQUAL;
    cond_hash_join_k.push_back(move(join_condition_hash_join_k));

    LogicalComparisonJoin join_hash_join_op_k(JoinType::MARK);
    vector<LogicalType> output_hash_join_types_k{LogicalType::BIGINT,
                                                 LogicalType::VARCHAR, LogicalType::BOOLEAN};
    join_hash_join_op_k.types = output_hash_join_types_k;
    vector<idx_t> right_projection_map_hash_join_k;
    vector<LogicalType> delim_types_hash_join_k;
    PerfectHashJoinStats joinstate_k;
    auto join_hash_join_k = make_uniq<PhysicalHashJoin>(join_hash_join_op_k, move(scan_keyword_k), move(chunk_scan_k), move(cond_hash_join_k),
                                                        JoinType::MARK, left_projection_map,
                                                        right_projection_map_hash_join_k,
                                                        delim_types_hash_join_k, 0, joinstate_k);

    vector<LogicalType> filter_in_types_k{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::BOOLEAN};
    vector<unique_ptr<Expression>> select_list_in_k;
    auto in_exp_k = make_uniq<BoundReferenceExpression>("IN (...)", LogicalType::BOOLEAN, 2);
    select_list_in_k.push_back(move(in_exp_k));
    unique_ptr<PhysicalFilter> filter_in_k = make_uniq<PhysicalFilter>(filter_in_types_k, move(select_list_in_k), 0);
    filter_in_k->children.push_back(move(join_hash_join_k));


    vector<JoinCondition> cond_keyword_k;
    JoinCondition join_condition_keyword_k;
    join_condition_keyword_k.left = make_uniq<BoundReferenceExpression>("keyword_rowid", LogicalType::BIGINT, 0);
    join_condition_keyword_k.right = make_uniq<BoundReferenceExpression>("movie_id_rowid", LogicalType::BIGINT, 2);
    join_condition_keyword_k.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_keyword_k = make_uniq<RAIInfo>();
    rai_info_keyword_k->rai = table_movie_keyword.GetStorage().info->rais[0].get();
    rai_info_keyword_k->rai_type = RAIType::SOURCE_EDGE;
    rai_info_keyword_k->forward = false;
    rai_info_keyword_k->vertex = &table_keyword;
    rai_info_keyword_k->vertex_id = table_index_keyword_k;
    rai_info_keyword_k->passing_tables[0] = table_index_keyword_k;
    rai_info_keyword_k->left_cardinalities[0] = table_keyword.GetStorage().info->cardinality;
    // rai_info_keyword_k->compact_list = &rai_info_keyword_k->rai->alist->compact__list;

    join_condition_keyword_k.rais.push_back(move(rai_info_keyword_k));
    cond_keyword_k.push_back(move(join_condition_keyword_k));

    LogicalComparisonJoin join_keyword_k_op(JoinType::INNER);
    vector<LogicalType> output_keyword_k_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::BOOLEAN,
                                               LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::VARCHAR};
    join_keyword_k_op.types = output_keyword_k_types;
    vector<idx_t> right_projection_map_keyword_k{2, 3, 4};
    vector<idx_t> merge_project_map_keyword_k;
    vector<LogicalType> delim_types_keyword_k;
    auto join_keyword_k = make_uniq<PhysicalMergeSIPJoin>(join_keyword_k_op, move(filter_in_k), move(join_kind_type_kt), move(cond_keyword_k),
                                                     JoinType::INNER, left_projection_map,
                                                     right_projection_map_keyword_k,
                                                     merge_project_map_keyword_k,
                                                     delim_types_keyword_k, 0);


    vector<idx_t> cast_info_ids{7, 8, 10};
    vector<LogicalType> get_cast_info_types{LogicalType::BIGINT,
                                            LogicalType::BIGINT, LogicalType::BIGINT};
    string alias_cast_info = "ci";
    vector<LogicalType> table_types_cast_info;
    vector<unique_ptr<Expression>> filter_cast_info;
    unique_ptr<LogicalGet> get_op_cast_info = move(
            getLogicalGet(*this, table_cast_info, alias_cast_info, table_index_cast_info_, table_types_cast_info));
    unique_ptr<TableFilterSet> table_filters_cast_info = NULL;
    unique_ptr<PhysicalTableScan> scan_cast_info = make_uniq<PhysicalTableScan>(get_cast_info_types,
                                                                                get_op_cast_info->function,
                                                                                get_op_cast_info->table_index,
                                                                                move(get_op_cast_info->bind_data),
                                                                                table_types_cast_info, cast_info_ids,
                                                                                move(filter_cast_info),
                                                                                vector<column_t>(),
                                                                                get_op_cast_info->names,
                                                                                std::move(table_filters_cast_info),
                                                                                get_op_cast_info->estimated_cardinality,
                                                                                get_op_cast_info->extra_info);


    vector<JoinCondition> cond_cast_info_;
    JoinCondition join_condition_cast_info_;
    join_condition_cast_info_.left = make_uniq<BoundReferenceExpression>("movie_id_rowid", LogicalType::BIGINT, 0);
    join_condition_cast_info_.right = make_uniq<BoundReferenceExpression>("movie_id_rowid", LogicalType::BIGINT, 3);
    join_condition_cast_info_.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_cast_info_ = make_uniq<RAIInfo>();
    rai_info_cast_info_->rai = table_cast_info.GetStorage().info->rais[0].get();
    rai_info_cast_info_->rai_type = RAIType::EDGE_SOURCE;
    rai_info_cast_info_->forward = true;
    rai_info_cast_info_->vertex = &table_title;
    rai_info_cast_info_->vertex_id = table_index_title_t;
    rai_info_cast_info_->passing_tables[0] = table_index_cast_info_;
    rai_info_cast_info_->left_cardinalities[0] = table_cast_info.GetStorage().info->cardinality;
    rai_info_cast_info_->compact_list = &rai_info_cast_info_->rai->alist->compact_forward_list;

    join_condition_cast_info_.rais.push_back(move(rai_info_cast_info_));
    cond_cast_info_.push_back(move(join_condition_cast_info_));

    LogicalComparisonJoin join_cast_info__op(JoinType::INNER);
    vector<LogicalType> output_cast_info__types{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::BIGINT,
                                                LogicalType::VARCHAR, LogicalType::VARCHAR};
    join_cast_info__op.types = output_cast_info__types;
    vector<idx_t> right_projection_map_cast_info_{4, 5};
    vector<idx_t> merge_project_map_cast_info_;
    vector<LogicalType> delim_types_cast_info_;
    auto join_cast_info_ = make_uniq<PhysicalSIPJoin>(join_cast_info__op, move(scan_cast_info), move(join_keyword_k), move(cond_cast_info_),
                                                      JoinType::INNER, left_projection_map,
                                                      right_projection_map_cast_info_,
                                                      delim_types_cast_info_, 0);


    vector<idx_t> char_name_chn_ids{COLUMN_IDENTIFIER_ROW_ID, 1};
    vector<LogicalType> get_char_name_chn_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_char_name_chn = "chn";
    vector<LogicalType> table_types_char_name_chn;
    vector<unique_ptr<Expression>> filter_char_name_chn;
    unique_ptr<LogicalGet> get_op_char_name_chn = move(
            getLogicalGet(*this, table_char_name, alias_char_name_chn, table_index_char_name_chn,
                          table_types_char_name_chn));
    unique_ptr<TableFilterSet> table_filters_char_name_chn = NULL;
    unique_ptr<PhysicalTableScan> scan_char_name_chn = make_uniq<PhysicalTableScan>(get_char_name_chn_types,
                                                                                    get_op_char_name_chn->function,
                                                                                    get_op_char_name_chn->table_index,
                                                                                    move(get_op_char_name_chn->bind_data),
                                                                                    table_types_char_name_chn,
                                                                                    char_name_chn_ids,
                                                                                    move(filter_char_name_chn),
                                                                                    vector<column_t>(),
                                                                                    get_op_char_name_chn->names,
                                                                                    std::move(
                                                                                            table_filters_char_name_chn),
                                                                                    get_op_char_name_chn->estimated_cardinality,
                                                                                    get_op_char_name_chn->extra_info);


    vector<LogicalType> filter_chn_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    vector<unique_ptr<Expression>> select_list_chn;

    unique_ptr<FunctionData> bind_data_contains_chn = NULL;
    auto like_bound_function_chn = make_uniq<BoundConjunctionExpression>(ExpressionType::CONJUNCTION_OR);

    ScalarFunction bound_function_like = LikeFun::GetLikeFunction();

    auto like_expression_left_exp_chn = make_uniq<BoundReferenceExpression>("name", LogicalType::VARCHAR, 1);
    auto like_expression_left_value_chn = make_uniq<BoundConstantExpression>(Value("man"));
    vector<unique_ptr<Expression>> like_arguments_left_chn;
    like_arguments_left_chn.push_back(move(like_expression_left_exp_chn));
    like_arguments_left_chn.push_back(move(like_expression_left_value_chn));
    auto like_bound_function_left_chn = make_uniq<BoundFunctionExpression>(LogicalType::BOOLEAN,
                                                                           bound_function_contains,
                                                                           move(like_arguments_left_chn),
                                                                           move(bind_data_contains_chn), false);

    auto like_expression_right_exp_chn = make_uniq<BoundReferenceExpression>("name", LogicalType::VARCHAR, 1);
    auto like_expression_right_value_chn = make_uniq<BoundConstantExpression>(Value("Man"));
    vector<unique_ptr<Expression>> like_arguments_right_chn;
    like_arguments_right_chn.push_back(move(like_expression_right_exp_chn));
    like_arguments_right_chn.push_back(move(like_expression_right_value_chn));
    auto like_bound_function_right_chn = make_uniq<BoundFunctionExpression>(LogicalType::BOOLEAN,
                                                                            bound_function_contains,
                                                                            move(like_arguments_right_chn),
                                                                            move(bind_data_contains_chn), false);

    like_bound_function_chn->children.push_back(move(like_bound_function_left_chn));
    like_bound_function_chn->children.push_back(move(like_bound_function_right_chn));

    auto chn_not_null_bound_function = make_uniq<BoundOperatorExpression>(ExpressionType::OPERATOR_IS_NOT_NULL, LogicalType::BOOLEAN);
    auto chn_not_null = make_uniq<BoundReferenceExpression>("name", LogicalType::VARCHAR, 1);
    chn_not_null_bound_function->children.push_back(move(chn_not_null));

    auto and_conjunction = make_uniq<BoundConjunctionExpression>(ExpressionType::CONJUNCTION_AND);
    and_conjunction->children.push_back(move(chn_not_null_bound_function));
    and_conjunction->children.push_back(move(like_bound_function_chn));

    select_list_chn.push_back(move(and_conjunction));
    unique_ptr<PhysicalFilter> filter_chn_contains = make_uniq<PhysicalFilter>(filter_chn_types, move(select_list_chn), 0);
    filter_chn_contains->children.push_back(move(scan_char_name_chn));


    vector<JoinCondition> cond_char_name_chn;
    JoinCondition join_condition_char_name_chn;
    join_condition_char_name_chn.left = make_uniq<BoundReferenceExpression>("char_name_rowid", LogicalType::BIGINT, 0);
    join_condition_char_name_chn.right = make_uniq<BoundReferenceExpression>("person_role_id_rowid", LogicalType::BIGINT, 2);
    join_condition_char_name_chn.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_char_name_chn = make_uniq<RAIInfo>();
    rai_info_char_name_chn->rai = table_cast_info.GetStorage().info->rais[3].get();
    rai_info_char_name_chn->rai_type = RAIType::TARGET_EDGE;
    rai_info_char_name_chn->forward = true;
    rai_info_char_name_chn->vertex = &table_char_name;
    rai_info_char_name_chn->vertex_id = table_index_char_name_chn;
    rai_info_char_name_chn->passing_tables[0] = table_index_char_name_chn;
    rai_info_char_name_chn->left_cardinalities[0] = table_char_name.GetStorage().info->cardinality;
    // rai_info_char_name_chn->compact_list = &rai_info_char_name_chn->rai->alist->compact__list;

    join_condition_char_name_chn.rais.push_back(move(rai_info_char_name_chn));
    cond_char_name_chn.push_back(move(join_condition_char_name_chn));

    LogicalComparisonJoin join_char_name_chn_op(JoinType::INNER);
    vector<LogicalType> output_char_name_chn_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::BIGINT,
                                                   LogicalType::VARCHAR, LogicalType::VARCHAR};
    join_char_name_chn_op.types = output_char_name_chn_types;
    vector<idx_t> right_projection_map_char_name_chn{1, 3, 4};
    vector<idx_t> merge_project_map_char_name_chn;
    vector<LogicalType> delim_types_char_name_chn;
    auto join_char_name_chn = make_uniq<PhysicalSIPJoin>(join_char_name_chn_op, move(filter_chn_contains), move(join_cast_info_),
                                                         move(cond_char_name_chn), JoinType::INNER, left_projection_map,
                                                         right_projection_map_char_name_chn, delim_types_char_name_chn,
                                                         0);


    vector<idx_t> name_n_ids{COLUMN_IDENTIFIER_ROW_ID, 1};
    vector<LogicalType> get_name_n_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_name_n = "n";
    vector<LogicalType> table_types_name_n;
    vector<unique_ptr<Expression>> filter_name_n;
    unique_ptr<LogicalGet> get_op_name_n = move(
            getLogicalGet(*this, table_name, alias_name_n, table_index_name_n, table_types_name_n));
    unique_ptr<TableFilterSet> table_filters_name_n = NULL;
    unique_ptr<PhysicalTableScan> scan_name_n = make_uniq<PhysicalTableScan>(get_name_n_types, get_op_name_n->function,
                                                                             get_op_name_n->table_index,
                                                                             move(get_op_name_n->bind_data),
                                                                             table_types_name_n, name_n_ids,
                                                                             move(filter_name_n), vector<column_t>(),
                                                                             get_op_name_n->names,
                                                                             std::move(table_filters_name_n),
                                                                             get_op_name_n->estimated_cardinality,
                                                                             get_op_name_n->extra_info);


    vector<JoinCondition> cond_name_n;
    JoinCondition join_condition_name_n;
    join_condition_name_n.left = make_uniq<BoundReferenceExpression>("name_rowid", LogicalType::BIGINT, 0);
    join_condition_name_n.right = make_uniq<BoundReferenceExpression>("person_id_rowid", LogicalType::BIGINT, 2);
    join_condition_name_n.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_name_n = make_uniq<RAIInfo>();
    rai_info_name_n->rai = table_cast_info.GetStorage().info->rais[0].get();
    rai_info_name_n->rai_type = RAIType::TARGET_EDGE;
    rai_info_name_n->forward = true;
    rai_info_name_n->vertex = &table_name;
    rai_info_name_n->vertex_id = table_index_name_n;
    rai_info_name_n->passing_tables[0] = table_index_name_n;
    rai_info_name_n->left_cardinalities[0] = table_name.GetStorage().info->cardinality;
    // rai_info_name_n->compact_list = &rai_info_name_n->rai->alist->compact__list;

    join_condition_name_n.rais.push_back(move(rai_info_name_n));
    cond_name_n.push_back(move(join_condition_name_n));

    LogicalComparisonJoin join_name_n_op(JoinType::INNER);
    vector<LogicalType> output_name_n_types{LogicalType::BIGINT, LogicalType::VARCHAR,
                                            LogicalType::VARCHAR, LogicalType::VARCHAR,
                                            LogicalType::VARCHAR};
    join_name_n_op.types = output_name_n_types;
    vector<idx_t> right_projection_map_name_n{1, 3, 4};
    vector<idx_t> merge_project_map_name_n;
    vector<LogicalType> delim_types_name_n;
    auto join_name_n = make_uniq<PhysicalSIPJoin>(join_name_n_op, move(scan_name_n), move(join_char_name_chn), move(cond_name_n), JoinType::INNER,
                                                       left_projection_map, right_projection_map_name_n,
                                                       delim_types_name_n,
                                                       0);

    vector<LogicalType> result_types{LogicalType::VARCHAR, LogicalType::VARCHAR,
                                     LogicalType::VARCHAR, LogicalType::VARCHAR};
    vector<unique_ptr<Expression>> select_list;
    auto result_col0 = make_uniq<BoundReferenceExpression>("name", LogicalType::VARCHAR, 2);
    auto result_col1 = make_uniq<BoundReferenceExpression>("info", LogicalType::VARCHAR, 3);
    auto result_col2 = make_uniq<BoundReferenceExpression>("name", LogicalType::VARCHAR, 1);
    auto result_col3 = make_uniq<BoundReferenceExpression>("title", LogicalType::VARCHAR, 4);
    select_list.push_back(move(result_col0));
    select_list.push_back(move(result_col1));
    select_list.push_back(move(result_col2));
    select_list.push_back(move(result_col3));
    auto projection = make_uniq<PhysicalProjection>(result_types, move(select_list), 0);
    projection->children.push_back(move(join_name_n));

    // aggregate
    string agg_name = "min";
    string agg_error = "";
    QueryErrorContext error_context(NULL, NULL);
    auto min_func = Catalog::GetEntry(context, CatalogType::SCALAR_FUNCTION_ENTRY, "", "",
                                      "min", OnEntryNotFound::RETURN_NULL, error_context);
    auto &min_func_set = min_func->Cast<AggregateFunctionCatalogEntry>();
    // bind the aggregate
    FunctionBinder function_binder(context);
    vector<LogicalType> types;
    types.push_back(LogicalType::VARCHAR);
    idx_t best_function_varchar = function_binder.BindFunction(agg_name, min_func_set.functions, types, agg_error);
    auto bound_function_min_varchar = min_func_set.functions.GetFunctionByOffset(best_function_varchar);
    // std::cout << best_function_varchar << " " << bound_function_min_varchar.return_type.ToString() << std::endl;

    auto first_children = make_uniq<BoundReferenceExpression>("name", LogicalType::VARCHAR, 0);
    vector<unique_ptr<Expression>> childrenlist1;
    childrenlist1.push_back(move(first_children));
    auto aggregate1 =
            function_binder.BindAggregateFunction(bound_function_min_varchar, std::move(childrenlist1), nullptr,
                                                  AggregateType::NON_DISTINCT);

    auto second_children = make_uniq<BoundReferenceExpression>("info", LogicalType::VARCHAR, 1);
    vector<unique_ptr<Expression>> childrenlist2;
    childrenlist2.push_back(move(second_children));
    auto aggregate2 =
            function_binder.BindAggregateFunction(bound_function_min_varchar, std::move(childrenlist2), nullptr,
                                                  AggregateType::NON_DISTINCT);

    auto third_children = make_uniq<BoundReferenceExpression>("name", LogicalType::VARCHAR, 2);
    vector<unique_ptr<Expression>> childrenlist3;
    childrenlist3.push_back(move(third_children));
    auto aggregate3 =
            function_binder.BindAggregateFunction(bound_function_min_varchar, std::move(childrenlist3), nullptr,
                                                  AggregateType::NON_DISTINCT);

    auto fourth_children = make_uniq<BoundReferenceExpression>("title", LogicalType::VARCHAR, 3);
    vector<unique_ptr<Expression>> childrenlist4;
    childrenlist4.push_back(move(fourth_children));
    auto aggregate4 =
            function_binder.BindAggregateFunction(bound_function_min_varchar, std::move(childrenlist4), nullptr,
                                                  AggregateType::NON_DISTINCT);

    vector<unique_ptr<Expression>> aggregates;
    aggregates.push_back(move(aggregate1));
    aggregates.push_back(move(aggregate2));
    aggregates.push_back(move(aggregate3));
    aggregates.push_back(move(aggregate4));

    vector<LogicalType> aggregate_types{LogicalType::VARCHAR, LogicalType::VARCHAR, LogicalType::VARCHAR, LogicalType::VARCHAR};
    auto ungrouped_aggregate = make_uniq<PhysicalUngroupedAggregate>(aggregate_types, move(aggregates), 0);
    ungrouped_aggregate->children.push_back(move(projection));

    return ungrouped_aggregate;
}

unique_ptr<PhysicalOperator> ClientContext::GenerateJOB27aPlan(duckdb::ClientContext &context) {
    vector<idx_t> left_projection_map, right_projection_map;

    string table_vertex_link_type_lt = "link_type";
    string table_vertex_title_t = "title";
    string table_vertex_keyword_k = "keyword";
    string table_vertex_company_name_cn = "company_name";
    string table_vertex_company_type_ct = "company_type";
    string table_vertex_info_type_ = "info_type";
    string table_vertex_comp_cast_type_cct1 = "comp_cast_type";
    string table_vertex_comp_cast_type_cct2 = "comp_cast_type";
    string table_vertex_movie_link_ = "movie_link";
    string table_vertex_movie_keyword_ = "movie_keyword";
    string table_vertex_movie_companies_ = "movie_companies";
    string table_vertex_movie_info_ = "movie_info";
    string table_vertex_complete_cast = "complete_cast";

    idx_t table_index_link_type_lt = 1;
    idx_t table_index_title_t = 2;
    idx_t table_index_keyword_k = 3;
    idx_t table_index_company_name_cn = 4;
    idx_t table_index_company_type_ct = 5;
    idx_t table_index_info_type_ = 6;
    idx_t table_index_comp_cast_type_cct1 = 7;
    idx_t table_index_comp_cast_type_cct2 = 8;
    idx_t table_index_movie_link_ = 9;
    idx_t table_index_movie_keyword_ = 10;
    idx_t table_index_movie_companies_ = 12;
    idx_t table_index_movie_info_ = 13;
    idx_t table_index_complete_cast = 14;

    auto table_or_view_link_type = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_link_type_lt,
                                                     OnEntryNotFound::RETURN_NULL);
    auto &table_link_type = table_or_view_link_type->Cast<TableCatalogEntry>();
    auto table_or_view_title = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_title_t,
                                                 OnEntryNotFound::RETURN_NULL);
    auto &table_title = table_or_view_title->Cast<TableCatalogEntry>();
    auto table_or_view_keyword = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_keyword_k,
                                                   OnEntryNotFound::RETURN_NULL);
    auto &table_keyword = table_or_view_keyword->Cast<TableCatalogEntry>();
    auto table_or_view_company_name = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                        table_vertex_company_name_cn, OnEntryNotFound::RETURN_NULL);
    auto &table_company_name = table_or_view_company_name->Cast<TableCatalogEntry>();
    auto table_or_view_company_type = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                        table_vertex_company_type_ct, OnEntryNotFound::RETURN_NULL);
    auto &table_company_type = table_or_view_company_type->Cast<TableCatalogEntry>();
    auto table_or_view_info_type = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_info_type_,
                                                     OnEntryNotFound::RETURN_NULL);
    auto &table_info_type = table_or_view_info_type->Cast<TableCatalogEntry>();
    auto table_or_view_comp_cast_type = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                          table_vertex_comp_cast_type_cct1,
                                                          OnEntryNotFound::RETURN_NULL);
    auto &table_comp_cast_type = table_or_view_comp_cast_type->Cast<TableCatalogEntry>();
    auto table_or_view_movie_link = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_movie_link_,
                                                      OnEntryNotFound::RETURN_NULL);
    auto &table_movie_link = table_or_view_movie_link->Cast<TableCatalogEntry>();
    auto table_or_view_movie_keyword = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                         table_vertex_movie_keyword_, OnEntryNotFound::RETURN_NULL);
    auto &table_movie_keyword = table_or_view_movie_keyword->Cast<TableCatalogEntry>();
    auto table_or_view_movie_companies = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                           table_vertex_movie_companies_, OnEntryNotFound::RETURN_NULL);
    auto &table_movie_companies = table_or_view_movie_companies->Cast<TableCatalogEntry>();
    auto table_or_view_movie_info = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_movie_info_,
                                                      OnEntryNotFound::RETURN_NULL);
    auto &table_movie_info = table_or_view_movie_info->Cast<TableCatalogEntry>();
    auto table_or_view_complete_cast = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                                 table_vertex_complete_cast,
                                                                 OnEntryNotFound::RETURN_NULL);
    auto &table_complete_cast = table_or_view_complete_cast->Cast<TableCatalogEntry>();

    vector<idx_t> link_type_lt_ids{COLUMN_IDENTIFIER_ROW_ID, 1};
    vector<LogicalType> get_link_type_lt_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_link_type_lt = "lt";
    vector<LogicalType> table_types_link_type_lt;
    vector<unique_ptr<Expression>> filter_link_type_lt;
    unique_ptr<LogicalGet> get_op_link_type_lt = move(
            getLogicalGet(*this, table_link_type, alias_link_type_lt, table_index_link_type_lt,
                          table_types_link_type_lt));
    unique_ptr<TableFilterSet> table_filters_link_type_lt = NULL;
    unique_ptr<PhysicalTableScan> scan_link_type_lt = make_uniq<PhysicalTableScan>(get_link_type_lt_types,
                                                                                   get_op_link_type_lt->function,
                                                                                   get_op_link_type_lt->table_index,
                                                                                   move(get_op_link_type_lt->bind_data),
                                                                                   table_types_link_type_lt,
                                                                                   link_type_lt_ids,
                                                                                   move(filter_link_type_lt),
                                                                                   vector<column_t>(),
                                                                                   get_op_link_type_lt->names,
                                                                                   std::move(
                                                                                           table_filters_link_type_lt),
                                                                                   get_op_link_type_lt->estimated_cardinality,
                                                                                   get_op_link_type_lt->extra_info);

    vector<LogicalType> filter_link_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    vector<unique_ptr<Expression>> select_list_link;
    auto link_like_expression_left = make_uniq<BoundReferenceExpression>("link", LogicalType::VARCHAR, 1);
    auto link_like_expression_value = make_uniq<BoundConstantExpression>(Value("follow"));
    vector<unique_ptr<Expression>> link_like_arguments;
    link_like_arguments.push_back(move(link_like_expression_left));
    link_like_arguments.push_back(move(link_like_expression_value));

    QueryErrorContext error_context_like(NULL, NULL);
    ScalarFunction link_bound_function_contains = ContainsFun::GetFunction();
    unique_ptr<FunctionData> link_bind_data_contains = NULL;

    auto link_like_bound_function = make_uniq<BoundFunctionExpression>(LogicalType::BOOLEAN,
                                                                       link_bound_function_contains,
                                                                       move(link_like_arguments),
                                                                       move(link_bind_data_contains), false);


    select_list_link.push_back(move(link_like_bound_function));
    unique_ptr<PhysicalFilter> filter_link_contains = make_uniq<PhysicalFilter>(filter_link_types, move(select_list_link), 0);
    filter_link_contains->children.push_back(move(scan_link_type_lt));


    vector<idx_t> title_t_ids{COLUMN_IDENTIFIER_ROW_ID, 1, 4};
    vector<LogicalType> get_title_t_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::BIGINT};
    string alias_title_t = "t";
    vector<LogicalType> table_types_title_t;
    vector<unique_ptr<Expression>> filter_title_t;
    unique_ptr<LogicalGet> get_op_title_t = move(
            getLogicalGet(*this, table_title, alias_title_t, table_index_title_t, table_types_title_t));
    unique_ptr<TableFilterSet> table_filters_title_t = make_uniq<TableFilterSet>();
    unique_ptr<ConjunctionAndFilter> and_filter_t = duckdb::make_uniq<ConjunctionAndFilter>();
    unique_ptr<ConstantFilter> constant_filter_t_start = duckdb::make_uniq<ConstantFilter>(
            ExpressionType::COMPARE_GREATERTHANOREQUALTO, Value::BIGINT(1950));
    unique_ptr<ConstantFilter> constant_filter_t_end = duckdb::make_uniq<ConstantFilter>(
            ExpressionType::COMPARE_LESSTHANOREQUALTO, Value::BIGINT(2000));
    and_filter_t->child_filters.push_back(move(constant_filter_t_start));
    and_filter_t->child_filters.push_back(move(constant_filter_t_end));
    table_filters_title_t->filters[2] = move(and_filter_t);
    unique_ptr<PhysicalTableScan> scan_title_t = make_uniq<PhysicalTableScan>(get_title_t_types,
                                                                              get_op_title_t->function,
                                                                              get_op_title_t->table_index,
                                                                              move(get_op_title_t->bind_data),
                                                                              table_types_title_t, title_t_ids,
                                                                              move(filter_title_t), vector<column_t>(),
                                                                              get_op_title_t->names,
                                                                              std::move(table_filters_title_t),
                                                                              get_op_title_t->estimated_cardinality,
                                                                              get_op_title_t->extra_info);


    vector<JoinCondition> cond_title_t;
    JoinCondition join_condition_title_t;
    join_condition_title_t.left = make_uniq<BoundReferenceExpression>("title_rowid", LogicalType::BIGINT, 0);
    join_condition_title_t.right = make_uniq<BoundReferenceExpression>("link_type_rowid", LogicalType::BIGINT, 0);
    join_condition_title_t.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_title_t = make_uniq<RAIInfo>();
    rai_info_title_t->rai = table_movie_link.GetStorage().info->rais[0].get();
    rai_info_title_t->rai_type = RAIType::TARGET_EDGE;
    rai_info_title_t->forward = true;
    rai_info_title_t->vertex = &table_title;
    rai_info_title_t->vertex_id = table_index_title_t;
    rai_info_title_t->passing_tables[0] = table_index_title_t;
    rai_info_title_t->left_cardinalities[0] = table_title.GetStorage().info->cardinality;
    // rai_info_title_t->compact_list = &rai_info_title_t->rai->alist->compact__list;

    join_condition_title_t.rais.push_back(move(rai_info_title_t));
    cond_title_t.push_back(move(join_condition_title_t));

    LogicalComparisonJoin join_title_t_op(JoinType::INNER);
    vector<LogicalType> output_title_t_types{LogicalType::BIGINT, LogicalType::VARCHAR,
                                             LogicalType::BIGINT, LogicalType::VARCHAR};
    join_title_t_op.types = output_title_t_types;
    vector<idx_t> right_projection_map_title_t{1};
    vector<idx_t> merge_project_map_title_t;
    vector<LogicalType> delim_types_title_t;
    auto join_title_t = make_uniq<PhysicalMergeSIPJoin>(join_title_t_op, move(scan_title_t), move(filter_link_contains), move(cond_title_t), JoinType::INNER,
                                                   left_projection_map, right_projection_map_title_t,
                                                   merge_project_map_title_t, delim_types_title_t, 0);

    vector<idx_t> complete_cast_ids{4, 5, 6};
    vector<LogicalType> get_complete_cast_types{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::BIGINT};
    string alias_complete_cast = "cc";
    vector<LogicalType> table_types_complete_cast;
    vector<unique_ptr<Expression>> filter_complete_cast;
    unique_ptr<LogicalGet> get_op_complete_cast = move(
            getLogicalGet(*this, table_complete_cast, alias_complete_cast, table_index_complete_cast,
                          table_types_complete_cast));
    unique_ptr<TableFilterSet> table_filters_complete_cast = NULL;
    unique_ptr<PhysicalTableScan> scan_complete_cast = make_uniq<PhysicalTableScan>(get_complete_cast_types,
                                                                                    get_op_complete_cast->function,
                                                                                    get_op_complete_cast->table_index,
                                                                                    move(get_op_complete_cast->bind_data),
                                                                                    table_types_complete_cast,
                                                                                    complete_cast_ids,
                                                                                    move(filter_complete_cast),
                                                                                    vector<column_t>(),
                                                                                    get_op_complete_cast->names,
                                                                                    std::move(
                                                                                            table_filters_complete_cast),
                                                                                    get_op_complete_cast->estimated_cardinality,
                                                                                    get_op_complete_cast->extra_info);


    vector<JoinCondition> cond_complete_cast_status_;
    JoinCondition join_condition_complete_cast_status_;
    join_condition_complete_cast_status_.left = make_uniq<BoundReferenceExpression>("movie_id_rowid", LogicalType::BIGINT, 1);
    join_condition_complete_cast_status_.right = make_uniq<BoundReferenceExpression>("title_rowid", LogicalType::BIGINT, 0);
    join_condition_complete_cast_status_.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_complete_cast_status_ = make_uniq<RAIInfo>();
    rai_info_complete_cast_status_->rai = table_complete_cast.GetStorage().info->rais[0].get();
    rai_info_complete_cast_status_->rai_type = RAIType::EDGE_TARGET;
    rai_info_complete_cast_status_->forward = false;
    rai_info_complete_cast_status_->vertex = &table_title;
    rai_info_complete_cast_status_->vertex_id = table_index_title_t;
    rai_info_complete_cast_status_->passing_tables[0] = table_index_complete_cast;
    rai_info_complete_cast_status_->left_cardinalities[0] = table_complete_cast.GetStorage().info->cardinality;
    rai_info_complete_cast_status_->compact_list = &rai_info_complete_cast_status_->rai->alist->compact_backward_list;

    join_condition_complete_cast_status_.rais.push_back(move(rai_info_complete_cast_status_));
    cond_complete_cast_status_.push_back(move(join_condition_complete_cast_status_));

    LogicalComparisonJoin join_complete_cast_status__op(JoinType::INNER);
    vector<LogicalType> output_complete_cast_status__types{LogicalType::BIGINT, LogicalType::BIGINT,
                                                           LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::VARCHAR};
    join_complete_cast_status__op.types = output_complete_cast_status__types;
    vector<idx_t> right_projection_map_complete_cast_status_{1, 3};
    vector<idx_t> merge_project_map_complete_cast_status_;
    vector<LogicalType> delim_types_complete_cast_status_;
    auto join_complete_cast_status_ = make_uniq<PhysicalSIPJoin>(join_complete_cast_status__op, move(scan_complete_cast), move(join_title_t),
                                                                      move(cond_complete_cast_status_), JoinType::INNER,
                                                                      left_projection_map,
                                                                      right_projection_map_complete_cast_status_,
                                                                      delim_types_complete_cast_status_, 0);



    vector<idx_t> comp_cast_type_cct2_ids{COLUMN_IDENTIFIER_ROW_ID, 1};
    vector<LogicalType> get_comp_cast_type_cct2_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_comp_cast_type_cct2 = "cct2";
    vector<LogicalType> table_types_comp_cast_type_cct2;
    vector<unique_ptr<Expression>> filter_comp_cast_type_cct2;
    unique_ptr<LogicalGet> get_op_comp_cast_type_cct2 = move(
            getLogicalGet(*this, table_comp_cast_type, alias_comp_cast_type_cct2, table_index_comp_cast_type_cct2,
                          table_types_comp_cast_type_cct2));
    unique_ptr<TableFilterSet> table_filters_comp_cast_type_cct2 = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_cct2 = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL, Value("complete"));
    table_filters_comp_cast_type_cct2->filters[1] = move(constant_filter_cct2);
    unique_ptr<PhysicalTableScan> scan_comp_cast_type_cct2 = make_uniq<PhysicalTableScan>(get_comp_cast_type_cct2_types,
                                                                                          get_op_comp_cast_type_cct2->function,
                                                                                          get_op_comp_cast_type_cct2->table_index,
                                                                                          move(get_op_comp_cast_type_cct2->bind_data),
                                                                                          table_types_comp_cast_type_cct2,
                                                                                          comp_cast_type_cct2_ids,
                                                                                          move(filter_comp_cast_type_cct2),
                                                                                          vector<column_t>(),
                                                                                          get_op_comp_cast_type_cct2->names,
                                                                                          std::move(
                                                                                                  table_filters_comp_cast_type_cct2),
                                                                                          get_op_comp_cast_type_cct2->estimated_cardinality,
                                                                                          get_op_comp_cast_type_cct2->extra_info);


    vector<JoinCondition> cond_comp_cast_type_cct2;
    JoinCondition join_condition_comp_cast_type_cct2;
    join_condition_comp_cast_type_cct2.left = make_uniq<BoundReferenceExpression>("comp_cast_type_rowid", LogicalType::BIGINT, 0);
    join_condition_comp_cast_type_cct2.right = make_uniq<BoundReferenceExpression>("status_id_rowid", LogicalType::BIGINT, 2);
    join_condition_comp_cast_type_cct2.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_comp_cast_type_cct2 = make_uniq<RAIInfo>();
    rai_info_comp_cast_type_cct2->rai = table_complete_cast.GetStorage().info->rais[1].get();
    rai_info_comp_cast_type_cct2->rai_type = RAIType::SOURCE_EDGE;
    rai_info_comp_cast_type_cct2->forward = false;
    rai_info_comp_cast_type_cct2->vertex = &table_comp_cast_type;
    rai_info_comp_cast_type_cct2->vertex_id = table_index_comp_cast_type_cct2;
    rai_info_comp_cast_type_cct2->passing_tables[0] = table_index_comp_cast_type_cct2;
    rai_info_comp_cast_type_cct2->left_cardinalities[0] = table_comp_cast_type.GetStorage().info->cardinality;
    // rai_info_comp_cast_type_cct2->compact_list = &rai_info_comp_cast_type_cct2->rai->alist->compact__list;

    join_condition_comp_cast_type_cct2.rais.push_back(move(rai_info_comp_cast_type_cct2));
    cond_comp_cast_type_cct2.push_back(move(join_condition_comp_cast_type_cct2));

    LogicalComparisonJoin join_comp_cast_type_cct2_op(JoinType::INNER);
    vector<LogicalType> output_comp_cast_type_cct2_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::BIGINT,
                                                         LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::VARCHAR};
    join_comp_cast_type_cct2_op.types = output_comp_cast_type_cct2_types;
    vector<idx_t> right_projection_map_comp_cast_type_cct2{0, 1, 3, 4};
    vector<idx_t> merge_project_map_comp_cast_type_cct2;
    vector<LogicalType> delim_types_comp_cast_type_cct2;
    auto join_comp_cast_type_cct2 = make_uniq<PhysicalSIPJoin>(join_comp_cast_type_cct2_op, move(scan_comp_cast_type_cct2), move(join_complete_cast_status_),
                                                               move(cond_comp_cast_type_cct2), JoinType::INNER,
                                                               left_projection_map,
                                                               right_projection_map_comp_cast_type_cct2,
                                                               delim_types_comp_cast_type_cct2, 0);


    vector<idx_t> comp_cast_type_cct1_ids{COLUMN_IDENTIFIER_ROW_ID, 1};
    vector<LogicalType> get_comp_cast_type_cct1_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_comp_cast_type_cct1 = "cct1";
    vector<LogicalType> table_types_comp_cast_type_cct1;
    vector<unique_ptr<Expression>> filter_comp_cast_type_cct1;
    unique_ptr<LogicalGet> get_op_comp_cast_type_cct1 = move(
            getLogicalGet(*this, table_comp_cast_type, alias_comp_cast_type_cct1, table_index_comp_cast_type_cct1,
                          table_types_comp_cast_type_cct1));
    unique_ptr<TableFilterSet> table_filters_comp_cast_type_cct1 = NULL;
    unique_ptr<PhysicalTableScan> scan_comp_cast_type_cct1 = make_uniq<PhysicalTableScan>(get_comp_cast_type_cct1_types,
                                                                                          get_op_comp_cast_type_cct1->function,
                                                                                          get_op_comp_cast_type_cct1->table_index,
                                                                                          move(get_op_comp_cast_type_cct1->bind_data),
                                                                                          table_types_comp_cast_type_cct1,
                                                                                          comp_cast_type_cct1_ids,
                                                                                          move(filter_comp_cast_type_cct1),
                                                                                          vector<column_t>(),
                                                                                          get_op_comp_cast_type_cct1->names,
                                                                                          std::move(
                                                                                                  table_filters_comp_cast_type_cct1),
                                                                                          get_op_comp_cast_type_cct1->estimated_cardinality,
                                                                                          get_op_comp_cast_type_cct1->extra_info);

    auto &allocator = Allocator::Get(context);
    vector<LogicalType> join_in_types {LogicalType::VARCHAR};
    auto collection =
            make_uniq<ColumnDataCollection>(context, join_in_types, ColumnDataAllocatorType::IN_MEMORY_ALLOCATOR);

    vector<LogicalType> chunk_in_types {LogicalType::VARCHAR};
    DataChunk chunk;
    chunk.SetCardinality(2);
    chunk.Initialize(allocator, chunk_in_types);
    chunk.SetValue(0, 0, Value("cast"));
    chunk.SetValue(0, 1, Value("crew"));
    collection->Append(chunk);

    // create a chunk scan to output the result
    vector<LogicalType> ouput_in_types {LogicalType::VARCHAR};
    auto chunk_scan = make_uniq<PhysicalColumnDataScan>(ouput_in_types, PhysicalOperatorType::COLUMN_DATA_SCAN,
                                                        2, std::move(collection));

    vector<JoinCondition> cond_hash_join_;
    JoinCondition join_condition_hash_join_;
    join_condition_hash_join_.left = make_uniq<BoundReferenceExpression>("kind", LogicalType::VARCHAR, 1);
    join_condition_hash_join_.right = make_uniq<BoundReferenceExpression>("", LogicalType::VARCHAR, 0);
    join_condition_hash_join_.comparison = ExpressionType::COMPARE_EQUAL;
    cond_hash_join_.push_back(move(join_condition_hash_join_));

    LogicalComparisonJoin join_hash_join_op(JoinType::MARK);
    vector<LogicalType> output_hash_join_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::BOOLEAN};
    join_hash_join_op.types = output_hash_join_types;
    vector<idx_t> right_projection_map_hash_join_;
    vector<LogicalType> delim_types_hash_join_;
    PerfectHashJoinStats joinstate;
    auto join_hash_join_ = make_uniq<PhysicalHashJoin>(join_hash_join_op, move(scan_comp_cast_type_cct1), move(chunk_scan), move(cond_hash_join_),
                                                       JoinType::MARK, left_projection_map,
                                                       right_projection_map_hash_join_,
                                                       delim_types_hash_join_, 0, joinstate);

    vector<LogicalType> filter_in_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::BOOLEAN};
    vector<unique_ptr<Expression>> select_list_in;
    auto in_exp = make_uniq<BoundReferenceExpression>("IN (...)", LogicalType::BOOLEAN, 2);
    select_list_in.push_back(move(in_exp));
    unique_ptr<PhysicalFilter> filter_in = make_uniq<PhysicalFilter>(filter_in_types, move(select_list_in), 0);
    filter_in->children.push_back(move(join_hash_join_));


    vector<JoinCondition> cond_comp_cast_type_cct1;
    JoinCondition join_condition_comp_cast_type_cct1;
    join_condition_comp_cast_type_cct1.left = make_uniq<BoundReferenceExpression>("comp_cast_type_rowid", LogicalType::BIGINT, 0);
    join_condition_comp_cast_type_cct1.right = make_uniq<BoundReferenceExpression>("subject_id_rowid", LogicalType::BIGINT, 2);
    join_condition_comp_cast_type_cct1.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_comp_cast_type_cct1 = make_uniq<RAIInfo>();
    rai_info_comp_cast_type_cct1->rai = table_complete_cast.GetStorage().info->rais[0].get();
    rai_info_comp_cast_type_cct1->rai_type = RAIType::SOURCE_EDGE;
    rai_info_comp_cast_type_cct1->forward = false;
    rai_info_comp_cast_type_cct1->vertex = &table_comp_cast_type;
    rai_info_comp_cast_type_cct1->vertex_id = table_index_comp_cast_type_cct1;
    rai_info_comp_cast_type_cct1->passing_tables[0] = table_index_comp_cast_type_cct1;
    rai_info_comp_cast_type_cct1->left_cardinalities[0] = table_comp_cast_type.GetStorage().info->cardinality;
    // rai_info_comp_cast_type_cct1->compact_list = &rai_info_comp_cast_type_cct1->rai->alist->compact__list;

    join_condition_comp_cast_type_cct1.rais.push_back(move(rai_info_comp_cast_type_cct1));
    cond_comp_cast_type_cct1.push_back(move(join_condition_comp_cast_type_cct1));

    LogicalComparisonJoin join_comp_cast_type_cct1_op(JoinType::INNER);
    vector<LogicalType> output_comp_cast_type_cct1_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::BOOLEAN,
                                                         LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::VARCHAR};
    join_comp_cast_type_cct1_op.types = output_comp_cast_type_cct1_types;
    vector<idx_t> right_projection_map_comp_cast_type_cct1{3, 4, 5};
    vector<idx_t> merge_project_map_comp_cast_type_cct1;
    vector<LogicalType> delim_types_comp_cast_type_cct1;
    auto join_comp_cast_type_cct1 = make_uniq<PhysicalSIPJoin>(join_comp_cast_type_cct1_op, move(filter_in), move(join_comp_cast_type_cct2),
                                                               move(cond_comp_cast_type_cct1), JoinType::INNER,
                                                               left_projection_map,
                                                               right_projection_map_comp_cast_type_cct1,
                                                               delim_types_comp_cast_type_cct1, 0);


    vector<idx_t> movie_companies_ids{4, 5, 6, 7};
    vector<LogicalType> get_movie_companies_types{LogicalType::VARCHAR, LogicalType::BIGINT,
                                                  LogicalType::BIGINT, LogicalType::BIGINT};
    string alias_movie_companies = "ct";
    vector<LogicalType> table_types_movie_companies;
    vector<unique_ptr<Expression>> filter_movie_companies;
    unique_ptr<LogicalGet> get_op_movie_companies = move(
            getLogicalGet(*this, table_movie_companies, alias_movie_companies, table_index_movie_companies_,
                          table_types_movie_companies));
    unique_ptr<TableFilterSet> table_filters_movie_companies = NULL;
    unique_ptr<PhysicalTableScan> scan_movie_companies = make_uniq<PhysicalTableScan>(get_movie_companies_types,
                                                                                      get_op_movie_companies->function,
                                                                                      get_op_movie_companies->table_index,
                                                                                      move(get_op_movie_companies->bind_data),
                                                                                      table_types_movie_companies,
                                                                                      movie_companies_ids,
                                                                                      move(filter_movie_companies),
                                                                                      vector<column_t>(),
                                                                                      get_op_movie_companies->names,
                                                                                      std::move(
                                                                                              table_filters_movie_companies),
                                                                                      get_op_movie_companies->estimated_cardinality,
                                                                                      get_op_movie_companies->extra_info);



    vector<LogicalType> filter_mc_types{LogicalType::VARCHAR, LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::BIGINT};
    vector<unique_ptr<Expression>> select_list_movie_companies;

    auto note_null_bound_function = make_uniq<BoundOperatorExpression>(ExpressionType::OPERATOR_IS_NULL, LogicalType::BOOLEAN);
    auto note_null = make_uniq<BoundReferenceExpression>("note", LogicalType::VARCHAR, 0);
    note_null_bound_function->children.push_back(move(note_null));

    select_list_movie_companies.push_back(move(note_null_bound_function));
    unique_ptr<PhysicalFilter> filter_mc_contains = make_uniq<PhysicalFilter>(filter_mc_types, move(select_list_movie_companies), 0);
    filter_mc_contains->children.push_back(move(scan_movie_companies));

    vector<JoinCondition> cond_movie_companies_;
    JoinCondition join_condition_movie_companies_;
    join_condition_movie_companies_.left = make_uniq<BoundReferenceExpression>("movie_id_rowid", LogicalType::BIGINT, 2);
    join_condition_movie_companies_.right = make_uniq<BoundReferenceExpression>("movie_id_rowid", LogicalType::BIGINT, 3);
    join_condition_movie_companies_.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_movie_companies_ = make_uniq<RAIInfo>();
    rai_info_movie_companies_->rai = table_movie_companies.GetStorage().info->rais[0].get();
    rai_info_movie_companies_->rai_type = RAIType::EDGE_TARGET;
    rai_info_movie_companies_->forward = false;
    rai_info_movie_companies_->vertex = &table_title;
    rai_info_movie_companies_->vertex_id = table_index_title_t;
    rai_info_movie_companies_->passing_tables[0] = table_index_movie_companies_;
    rai_info_movie_companies_->left_cardinalities[0] = table_movie_companies.GetStorage().info->cardinality;
    rai_info_movie_companies_->compact_list = &rai_info_movie_companies_->rai->alist->compact_backward_list;

    join_condition_movie_companies_.rais.push_back(move(rai_info_movie_companies_));
    cond_movie_companies_.push_back(move(join_condition_movie_companies_));

    LogicalComparisonJoin join_movie_companies__op(JoinType::INNER);
    vector<LogicalType> output_movie_companies__types{LogicalType::VARCHAR, LogicalType::BIGINT, LogicalType::BIGINT,
                                                      LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::VARCHAR};
    join_movie_companies__op.types = output_movie_companies__types;
    vector<idx_t> right_projection_map_movie_companies_{4, 5};
    vector<idx_t> merge_project_map_movie_companies_;
    vector<LogicalType> delim_types_movie_companies_;
    auto join_movie_companies_ = make_uniq<PhysicalSIPJoin>(join_movie_companies__op, move(filter_mc_contains), move(join_comp_cast_type_cct1),
                                                                 move(cond_movie_companies_), JoinType::INNER,
                                                                 left_projection_map,
                                                                 right_projection_map_movie_companies_,
                                                                 delim_types_movie_companies_, 0);


    vector<idx_t> company_name_cn_ids{COLUMN_IDENTIFIER_ROW_ID, 1, 2};
    vector<LogicalType> get_company_name_cn_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::VARCHAR};
    string alias_company_name_cn = "cn";
    vector<LogicalType> table_types_company_name_cn;
    vector<unique_ptr<Expression>> filter_company_name_cn;
    unique_ptr<LogicalGet> get_op_company_name_cn = move(
            getLogicalGet(*this, table_company_name, alias_company_name_cn, table_index_company_name_cn,
                          table_types_company_name_cn));
    unique_ptr<TableFilterSet> table_filters_company_name_cn = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_cn = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_NOTEQUAL, Value("[pl]"));
    table_filters_company_name_cn->filters[2] = move(constant_filter_cn);
    unique_ptr<PhysicalTableScan> scan_company_name_cn = make_uniq<PhysicalTableScan>(get_company_name_cn_types,
                                                                                      get_op_company_name_cn->function,
                                                                                      get_op_company_name_cn->table_index,
                                                                                      move(get_op_company_name_cn->bind_data),
                                                                                      table_types_company_name_cn,
                                                                                      company_name_cn_ids,
                                                                                      move(filter_company_name_cn),
                                                                                      vector<column_t>(),
                                                                                      get_op_company_name_cn->names,
                                                                                      std::move(
                                                                                              table_filters_company_name_cn),
                                                                                      get_op_company_name_cn->estimated_cardinality,
                                                                                      get_op_company_name_cn->extra_info);

    vector<LogicalType> filter_name_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::VARCHAR};
    vector<unique_ptr<Expression>> select_list_name;
    auto name_left = make_uniq<BoundReferenceExpression>("name", LogicalType::VARCHAR, 1);
    auto name_value = make_uniq<BoundConstantExpression>(Value("Film"));
    vector<unique_ptr<Expression>> name_left_arguments;
    name_left_arguments.push_back(move(name_left));
    name_left_arguments.push_back(move(name_value));

    unique_ptr<FunctionData> name_left_bind_data_contains = NULL;
    auto name_left_bound_function = make_uniq<BoundFunctionExpression>(LogicalType::BOOLEAN,
                                                                       link_bound_function_contains,
                                                                       move(name_left_arguments),
                                                                       move(name_left_bind_data_contains), false);


    auto name_right = make_uniq<BoundReferenceExpression>("name", LogicalType::VARCHAR, 1);
    auto name_value_right = make_uniq<BoundConstantExpression>(Value("Warner"));
    vector<unique_ptr<Expression>> name_right_arguments;
    name_right_arguments.push_back(move(name_right));
    name_right_arguments.push_back(move(name_value_right));

    unique_ptr<FunctionData> name_right_bind_data_contains = NULL;
    auto name_right_bound_function = make_uniq<BoundFunctionExpression>(LogicalType::BOOLEAN,
                                                                        link_bound_function_contains,
                                                                        move(name_right_arguments),
                                                                        move(name_right_bind_data_contains), false);

    auto or_conjunction = make_uniq<BoundConjunctionExpression>(ExpressionType::CONJUNCTION_OR);
    or_conjunction->children.push_back(move(name_left_bound_function));
    or_conjunction->children.push_back(move(name_right_bound_function));

    select_list_name.push_back(move(or_conjunction));
    unique_ptr<PhysicalFilter> filter_name = make_uniq<PhysicalFilter>(filter_name_types, move(select_list_name), 0);
    filter_name->children.push_back(move(scan_company_name_cn));


    vector<JoinCondition> cond_company_name_cn;
    JoinCondition join_condition_company_name_cn;
    join_condition_company_name_cn.left = make_uniq<BoundReferenceExpression>("company_name_rowid", LogicalType::BIGINT, 0);
    join_condition_company_name_cn.right = make_uniq<BoundReferenceExpression>("company_id_rowid", LogicalType::BIGINT, 1);
    join_condition_company_name_cn.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_company_name_cn = make_uniq<RAIInfo>();
    rai_info_company_name_cn->rai = table_movie_companies.GetStorage().info->rais[0].get();
    rai_info_company_name_cn->rai_type = RAIType::SOURCE_EDGE;
    rai_info_company_name_cn->forward = false;
    rai_info_company_name_cn->vertex = &table_company_name;
    rai_info_company_name_cn->vertex_id = table_index_company_name_cn;
    rai_info_company_name_cn->passing_tables[0] = table_index_company_name_cn;
    rai_info_company_name_cn->left_cardinalities[0] = table_company_name.GetStorage().info->cardinality;
    // rai_info_company_name_cn->compact_list = &rai_info_company_name_cn->rai->alist->compact__list;

    join_condition_company_name_cn.rais.push_back(move(rai_info_company_name_cn));
    cond_company_name_cn.push_back(move(join_condition_company_name_cn));

    LogicalComparisonJoin join_company_name_cn_op(JoinType::INNER);
    vector<LogicalType> output_company_name_cn_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::VARCHAR,
                                                     LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::VARCHAR,
                                                     LogicalType::VARCHAR};
    join_company_name_cn_op.types = output_company_name_cn_types;
    vector<idx_t> right_projection_map_company_name_cn{2, 3, 4, 5};
    vector<idx_t> merge_project_map_company_name_cn;
    vector<LogicalType> delim_types_company_name_cn;
    auto join_company_name_cn = make_uniq<PhysicalSIPJoin>(join_company_name_cn_op, move(filter_name), move(join_movie_companies_),
                                                           move(cond_company_name_cn), JoinType::INNER,
                                                           left_projection_map, right_projection_map_company_name_cn,
                                                           delim_types_company_name_cn, 0);

    vector<idx_t> company_type_ct_ids{COLUMN_IDENTIFIER_ROW_ID, 1};
    vector<LogicalType> get_company_type_ct_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_company_type_ct = "ct";
    vector<LogicalType> table_types_company_type_ct;
    vector<unique_ptr<Expression>> filter_company_type_ct;
    unique_ptr<LogicalGet> get_op_company_type_ct = move(
            getLogicalGet(*this, table_company_type, alias_company_type_ct, table_index_company_type_ct,
                          table_types_company_type_ct));
    unique_ptr<TableFilterSet> table_filters_company_type_ct = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_ct = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL, Value("production companies"));
    table_filters_company_type_ct->filters[1] = move(constant_filter_ct);
    unique_ptr<PhysicalTableScan> scan_company_type_ct = make_uniq<PhysicalTableScan>(get_company_type_ct_types,
                                                                                      get_op_company_type_ct->function,
                                                                                      get_op_company_type_ct->table_index,
                                                                                      move(get_op_company_type_ct->bind_data),
                                                                                      table_types_company_type_ct,
                                                                                      company_type_ct_ids,
                                                                                      move(filter_company_type_ct),
                                                                                      vector<column_t>(),
                                                                                      get_op_company_type_ct->names,
                                                                                      std::move(
                                                                                              table_filters_company_type_ct),
                                                                                      get_op_company_type_ct->estimated_cardinality,
                                                                                      get_op_company_type_ct->extra_info);


    vector<JoinCondition> cond_company_type_ct;
    JoinCondition join_condition_company_type_ct;
    join_condition_company_type_ct.left = make_uniq<BoundReferenceExpression>("company_type_rowid", LogicalType::BIGINT, 0);
    join_condition_company_type_ct.right = make_uniq<BoundReferenceExpression>("company_type_id_rowid", LogicalType::BIGINT, 4);
    join_condition_company_type_ct.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_company_type_ct = make_uniq<RAIInfo>();
    rai_info_company_type_ct->rai = table_movie_companies.GetStorage().info->rais[1].get();
    rai_info_company_type_ct->rai_type = RAIType::SOURCE_EDGE;
    rai_info_company_type_ct->forward = false;
    rai_info_company_type_ct->vertex = &table_company_type;
    rai_info_company_type_ct->vertex_id = table_index_company_type_ct;
    rai_info_company_type_ct->passing_tables[0] = table_index_company_type_ct;
    rai_info_company_type_ct->left_cardinalities[0] = table_company_type.GetStorage().info->cardinality;
    // rai_info_company_type_ct->compact_list = &rai_info_company_type_ct->rai->alist->compact__list;

    join_condition_company_type_ct.rais.push_back(move(rai_info_company_type_ct));
    cond_company_type_ct.push_back(move(join_condition_company_type_ct));

    LogicalComparisonJoin join_company_type_ct_op(JoinType::INNER);
    vector<LogicalType> output_company_type_ct_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::VARCHAR,
                                                     LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::VARCHAR};
    join_company_type_ct_op.types = output_company_type_ct_types;
    vector<idx_t> right_projection_map_company_type_ct{1, 3, 5, 6};
    vector<idx_t> merge_project_map_company_type_ct;
    vector<LogicalType> delim_types_company_type_ct;
    auto join_company_type_ct = make_uniq<PhysicalSIPJoin>(join_company_type_ct_op, move(scan_company_type_ct), move(join_company_name_cn),
                                                           move(cond_company_type_ct), JoinType::INNER,
                                                           left_projection_map, right_projection_map_company_type_ct,
                                                           delim_types_company_type_ct, 0);

    vector<idx_t> keyword_k_ids{COLUMN_IDENTIFIER_ROW_ID, 1};
    vector<LogicalType> get_keyword_k_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_keyword_k = "k";
    vector<LogicalType> table_types_keyword_k;
    vector<unique_ptr<Expression>> filter_keyword_k;
    unique_ptr<LogicalGet> get_op_keyword_k = move(
            getLogicalGet(*this, table_keyword, alias_keyword_k, table_index_keyword_k, table_types_keyword_k));
    unique_ptr<TableFilterSet> table_filters_keyword_k = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_k = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL, Value("sequel"));
    table_filters_keyword_k->filters[1] = move(constant_filter_k);
    unique_ptr<PhysicalTableScan> scan_keyword_k = make_uniq<PhysicalTableScan>(get_keyword_k_types,
                                                                                get_op_keyword_k->function,
                                                                                get_op_keyword_k->table_index,
                                                                                move(get_op_keyword_k->bind_data),
                                                                                table_types_keyword_k, keyword_k_ids,
                                                                                move(filter_keyword_k),
                                                                                vector<column_t>(),
                                                                                get_op_keyword_k->names,
                                                                                std::move(table_filters_keyword_k),
                                                                                get_op_keyword_k->estimated_cardinality,
                                                                                get_op_keyword_k->extra_info);


    vector<JoinCondition> cond_keyword_k;
    JoinCondition join_condition_keyword_k;
    join_condition_keyword_k.left = make_uniq<BoundReferenceExpression>("keyword_rowid", LogicalType::BIGINT, 0);
    join_condition_keyword_k.right = make_uniq<BoundReferenceExpression>("movie_id_rowid", LogicalType::BIGINT, 3);
    join_condition_keyword_k.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_keyword_k = make_uniq<RAIInfo>();
    rai_info_keyword_k->rai = table_movie_keyword.GetStorage().info->rais[0].get();
    rai_info_keyword_k->rai_type = RAIType::SOURCE_EDGE;
    rai_info_keyword_k->forward = false;
    rai_info_keyword_k->vertex = &table_keyword;
    rai_info_keyword_k->vertex_id = table_index_keyword_k;
    rai_info_keyword_k->passing_tables[0] = table_index_keyword_k;
    rai_info_keyword_k->left_cardinalities[0] = table_keyword.GetStorage().info->cardinality;
    // rai_info_keyword_k->compact_list = &rai_info_keyword_k->rai->alist->compact__list;

    join_condition_keyword_k.rais.push_back(move(rai_info_keyword_k));
    cond_keyword_k.push_back(move(join_condition_keyword_k));

    LogicalComparisonJoin join_keyword_k_op(JoinType::INNER);
    vector<LogicalType> output_keyword_k_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::VARCHAR,
                                               LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::VARCHAR};
    join_keyword_k_op.types = output_keyword_k_types;
    vector<idx_t> right_projection_map_keyword_k{2, 3, 4, 5};
    vector<idx_t> merge_project_map_keyword_k;
    vector<LogicalType> delim_types_keyword_k;
    auto join_keyword_k = make_uniq<PhysicalMergeSIPJoin>(join_keyword_k_op, move(scan_keyword_k), move(join_company_type_ct), move(cond_keyword_k),
                                                     JoinType::INNER, left_projection_map,
                                                     right_projection_map_keyword_k,
                                                     merge_project_map_keyword_k,
                                                     delim_types_keyword_k, 0);

    vector<idx_t> movie_info_ids{6, 3};
    vector<LogicalType> get_movie_info_types{LogicalType::BIGINT,  LogicalType::VARCHAR};
    string alias_movie_info = "i";
    vector<LogicalType> table_types_movie_info;
    vector<unique_ptr<Expression>> filter_movie_info;
    unique_ptr<LogicalGet> get_op_movie_info = move(
            getLogicalGet(*this, table_movie_info, alias_movie_info, table_index_movie_info_, table_types_movie_info));
    unique_ptr<TableFilterSet> table_filters_movie_info = NULL;
    unique_ptr<PhysicalTableScan> scan_movie_info = make_uniq<PhysicalTableScan>(get_movie_info_types,
                                                                                 get_op_movie_info->function,
                                                                                 get_op_movie_info->table_index,
                                                                                 move(get_op_movie_info->bind_data),
                                                                                 table_types_movie_info,
                                                                                 movie_info_ids,
                                                                                 move(filter_movie_info),
                                                                                 vector<column_t>(),
                                                                                 get_op_movie_info->names,
                                                                                 std::move(table_filters_movie_info),
                                                                                 get_op_movie_info->estimated_cardinality,
                                                                                 get_op_movie_info->extra_info);

    auto &allocator_mi = Allocator::Get(context);
    vector<LogicalType> join_in_types_mi {LogicalType::VARCHAR};
    auto collection_mi =
            make_uniq<ColumnDataCollection>(context, join_in_types_mi, ColumnDataAllocatorType::IN_MEMORY_ALLOCATOR);

    vector<LogicalType> chunk_in_types_mi {LogicalType::VARCHAR};
    DataChunk chunk_mi;
    chunk_mi.SetCardinality(4);
    chunk_mi.Initialize(allocator_mi, chunk_in_types_mi);
    chunk_mi.SetValue(0, 0, Value("Sweden"));
    chunk_mi.SetValue(0, 1, Value("Germany"));
    chunk_mi.SetValue(0, 2, Value("Swedish"));
    chunk_mi.SetValue(0, 3, Value("German"));
    collection_mi->Append(chunk_mi);

    // create a chunk scan to output the result
    vector<LogicalType> ouput_in_types_mi {LogicalType::VARCHAR};
    auto chunk_scan_mi = make_uniq<PhysicalColumnDataScan>(ouput_in_types_mi, PhysicalOperatorType::COLUMN_DATA_SCAN,
                                                           4, std::move(collection_mi));

    vector<JoinCondition> cond_hash_join_mi;
    JoinCondition join_condition_hash_join_mi;
    join_condition_hash_join_mi.left = make_uniq<BoundReferenceExpression>("info", LogicalType::VARCHAR, 1);
    join_condition_hash_join_mi.right = make_uniq<BoundReferenceExpression>("", LogicalType::VARCHAR, 0);
    join_condition_hash_join_mi.comparison = ExpressionType::COMPARE_EQUAL;
    cond_hash_join_mi.push_back(move(join_condition_hash_join_mi));

    LogicalComparisonJoin join_hash_join_op_mi(JoinType::MARK);
    vector<LogicalType> output_hash_join_types_mi{LogicalType::BIGINT,  LogicalType::VARCHAR, LogicalType::BOOLEAN};
    join_hash_join_op_mi.types = output_hash_join_types_mi;
    vector<idx_t> right_projection_map_hash_join_mi;
    vector<LogicalType> delim_types_hash_join_mi;
    PerfectHashJoinStats joinstate_mi;
    auto join_hash_join_mi = make_uniq<PhysicalHashJoin>(join_hash_join_op_mi, move(scan_movie_info), move(chunk_scan_mi), move(cond_hash_join_mi),
                                                         JoinType::MARK, left_projection_map,
                                                         right_projection_map_hash_join_mi,
                                                         delim_types_hash_join_mi, 0, joinstate_mi);

    vector<LogicalType> filter_in_types_mi{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::BOOLEAN};
    vector<unique_ptr<Expression>> select_list_in_mi;
    auto in_exp_mi = make_uniq<BoundReferenceExpression>("IN (...)", LogicalType::BOOLEAN, 2);
    select_list_in_mi.push_back(move(in_exp_mi));
    unique_ptr<PhysicalFilter> filter_in_mi = make_uniq<PhysicalFilter>(filter_in_types_mi, move(select_list_in_mi), 0);
    filter_in_mi->children.push_back(move(join_hash_join_mi));

    vector<JoinCondition> cond_movie_info_;
    JoinCondition join_condition_movie_info_;
    join_condition_movie_info_.left = make_uniq<BoundReferenceExpression>("movie_id_rowid", LogicalType::BIGINT, 0);
    join_condition_movie_info_.right = make_uniq<BoundReferenceExpression>("movie_id_rowid", LogicalType::BIGINT, 3);
    join_condition_movie_info_.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_movie_info_ = make_uniq<RAIInfo>();
    rai_info_movie_info_->rai = table_movie_info.GetStorage().info->rais[0].get();
    rai_info_movie_info_->rai_type = RAIType::EDGE_TARGET;
    rai_info_movie_info_->forward = false;
    rai_info_movie_info_->vertex = &table_title;
    rai_info_movie_info_->vertex_id = table_index_title_t;
    rai_info_movie_info_->passing_tables[0] = table_index_movie_info_;
    rai_info_movie_info_->left_cardinalities[0] = table_movie_info.GetStorage().info->cardinality;
    rai_info_movie_info_->compact_list = &rai_info_movie_info_->rai->alist->compact_backward_list;

    join_condition_movie_info_.rais.push_back(move(rai_info_movie_info_));
    cond_movie_info_.push_back(move(join_condition_movie_info_));

    LogicalComparisonJoin join_movie_info__op(JoinType::INNER);
    vector<LogicalType> output_movie_info__types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::BOOLEAN,
                                                 LogicalType::VARCHAR, LogicalType::VARCHAR, LogicalType::VARCHAR};
    join_movie_info__op.types = output_movie_info__types;
    vector<idx_t> right_projection_map_movie_info_{2, 4, 5};
    vector<idx_t> merge_project_map_movie_info_;
    vector<LogicalType> delim_types_movie_info_;
    auto join_movie_info_ = make_uniq<PhysicalSIPJoin>(join_movie_info__op, move(filter_in_mi), move(join_keyword_k), move(cond_movie_info_),
                                                            JoinType::INNER, left_projection_map,
                                                            right_projection_map_movie_info_,
                                                            delim_types_movie_info_, 0);


    vector<LogicalType> result_types{LogicalType::VARCHAR, LogicalType::VARCHAR, LogicalType::VARCHAR};
    vector<unique_ptr<Expression>> select_list;
    auto result_col0 = make_uniq<BoundReferenceExpression>("name", LogicalType::VARCHAR, 3);
    auto result_col1 = make_uniq<BoundReferenceExpression>("link", LogicalType::VARCHAR, 5);
    auto result_col2 = make_uniq<BoundReferenceExpression>("title", LogicalType::VARCHAR, 4);
    select_list.push_back(move(result_col0));
    select_list.push_back(move(result_col1));
    select_list.push_back(move(result_col2));
    auto projection = make_uniq<PhysicalProjection>(result_types, move(select_list), 0);
    projection->children.push_back(move(join_movie_info_));

    // aggregate
    string agg_name = "min";
    string agg_error = "";
    QueryErrorContext error_context(NULL, NULL);
    auto min_func = Catalog::GetEntry(context, CatalogType::SCALAR_FUNCTION_ENTRY, "", "",
                                      "min", OnEntryNotFound::RETURN_NULL, error_context);
    auto &min_func_set = min_func->Cast<AggregateFunctionCatalogEntry>();
    // bind the aggregate
    FunctionBinder function_binder(context);
    vector<LogicalType> types;
    types.push_back(LogicalType::VARCHAR);
    idx_t best_function_varchar = function_binder.BindFunction(agg_name, min_func_set.functions, types, agg_error);
    auto bound_function_min_varchar = min_func_set.functions.GetFunctionByOffset(best_function_varchar);
    // std::cout << best_function_varchar << " " << bound_function_min_varchar.return_type.ToString() << std::endl;

    auto first_children = make_uniq<BoundReferenceExpression>("name", LogicalType::VARCHAR, 0);
    vector<unique_ptr<Expression>> childrenlist1;
    childrenlist1.push_back(move(first_children));
    auto aggregate1 =
            function_binder.BindAggregateFunction(bound_function_min_varchar, std::move(childrenlist1), nullptr,
                                                  AggregateType::NON_DISTINCT);

    auto second_children = make_uniq<BoundReferenceExpression>("name", LogicalType::VARCHAR, 1);
    vector<unique_ptr<Expression>> childrenlist2;
    childrenlist2.push_back(move(second_children));
    auto aggregate2 =
            function_binder.BindAggregateFunction(bound_function_min_varchar, std::move(childrenlist2), nullptr,
                                                  AggregateType::NON_DISTINCT);

    auto third_children = make_uniq<BoundReferenceExpression>("title", LogicalType::VARCHAR, 2);
    vector<unique_ptr<Expression>> childrenlist3;
    childrenlist3.push_back(move(third_children));
    auto aggregate3 =
            function_binder.BindAggregateFunction(bound_function_min_varchar, std::move(childrenlist3), nullptr,
                                                  AggregateType::NON_DISTINCT);

    vector<unique_ptr<Expression>> aggregates;
    aggregates.push_back(move(aggregate1));
    aggregates.push_back(move(aggregate2));
    aggregates.push_back(move(aggregate3));


    vector<LogicalType> aggregate_types{LogicalType::VARCHAR, LogicalType::VARCHAR, LogicalType::VARCHAR};
    auto ungrouped_aggregate = make_uniq<PhysicalUngroupedAggregate>(aggregate_types, move(aggregates), 0);
    ungrouped_aggregate->children.push_back(move(projection));

    return ungrouped_aggregate;
}

unique_ptr<PhysicalOperator> ClientContext::GenerateJOB28aPlan(duckdb::ClientContext &context) {
    vector<idx_t> left_projection_map, right_projection_map;

    string table_vertex_keyword_k = "keyword";
    string table_vertex_title_t = "title";
    string table_vertex_kind_type_kt = "kind_type";
    string table_vertex_info_type_it1 = "info_type";
    string table_vertex_info_type_it2 = "info_type";
    string table_vertex_company_type_ct = "company_type";
    string table_vertex_company_name_cn = "company_name";
    string table_vertex_comp_cast_type_cct1 = "comp_cast_type";
    string table_vertex_comp_cast_type_cct2 = "comp_cast_type";
    string table_vertex_movie_keyword_ = "movie_keyword";
    string table_vertex_movie_info_ = "movie_info";
    string table_vertex_movie_info_idx_ = "movie_info_idx";
    string table_vertex_movie_companies_ = "movie_companies";
    string table_vertex_complete_cast = "complete_cast";

    idx_t table_index_keyword_k = 1;
    idx_t table_index_title_t = 2;
    idx_t table_index_kind_type_kt = 3;
    idx_t table_index_info_type_it1 = 4;
    idx_t table_index_info_type_it2 = 5;
    idx_t table_index_company_type_ct = 6;
    idx_t table_index_company_name_cn = 7;
    idx_t table_index_comp_cast_type_cct1 = 8;
    idx_t table_index_comp_cast_type_cct2 = 9;
    idx_t table_index_movie_keyword_ = 10;
    idx_t table_index_movie_info_ = 12;
    idx_t table_index_movie_info_idx_ = 13;
    idx_t table_index_movie_companies_ = 15;
    idx_t table_index_complete_cast = 16;

    auto table_or_view_keyword = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_keyword_k,
                                                   OnEntryNotFound::RETURN_NULL);
    auto &table_keyword = table_or_view_keyword->Cast<TableCatalogEntry>();
    auto table_or_view_title = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_title_t,
                                                 OnEntryNotFound::RETURN_NULL);
    auto &table_title = table_or_view_title->Cast<TableCatalogEntry>();
    auto table_or_view_kind_type = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_kind_type_kt,
                                                     OnEntryNotFound::RETURN_NULL);
    auto &table_kind_type = table_or_view_kind_type->Cast<TableCatalogEntry>();
    auto table_or_view_info_type = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                     table_vertex_info_type_it1, OnEntryNotFound::RETURN_NULL);
    auto &table_info_type = table_or_view_info_type->Cast<TableCatalogEntry>();
    auto table_or_view_company_type = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                        table_vertex_company_type_ct, OnEntryNotFound::RETURN_NULL);
    auto &table_company_type = table_or_view_company_type->Cast<TableCatalogEntry>();
    auto table_or_view_company_name = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                        table_vertex_company_name_cn, OnEntryNotFound::RETURN_NULL);
    auto &table_company_name = table_or_view_company_name->Cast<TableCatalogEntry>();
    auto table_or_view_comp_cast_type = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                          table_vertex_comp_cast_type_cct1,
                                                          OnEntryNotFound::RETURN_NULL);
    auto &table_comp_cast_type = table_or_view_comp_cast_type->Cast<TableCatalogEntry>();
    auto table_or_view_movie_keyword = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                         table_vertex_movie_keyword_, OnEntryNotFound::RETURN_NULL);
    auto &table_movie_keyword = table_or_view_movie_keyword->Cast<TableCatalogEntry>();
    auto table_or_view_movie_info = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_movie_info_,
                                                      OnEntryNotFound::RETURN_NULL);
    auto &table_movie_info = table_or_view_movie_info->Cast<TableCatalogEntry>();
    auto table_or_view_movie_info_idx = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                          table_vertex_movie_info_idx_, OnEntryNotFound::RETURN_NULL);
    auto &table_movie_info_idx = table_or_view_movie_info_idx->Cast<TableCatalogEntry>();
    auto table_or_view_movie_companies = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                           table_vertex_movie_companies_, OnEntryNotFound::RETURN_NULL);
    auto &table_movie_companies = table_or_view_movie_companies->Cast<TableCatalogEntry>();
    auto table_or_view_complete_cast = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                                 table_vertex_complete_cast,
                                                                 OnEntryNotFound::RETURN_NULL);
    auto &table_complete_cast = table_or_view_complete_cast->Cast<TableCatalogEntry>();

    vector<idx_t> comp_cast_type_cct2_ids{COLUMN_IDENTIFIER_ROW_ID, 1};
    vector<LogicalType> get_comp_cast_type_cct2_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_comp_cast_type_cct2 = "cct2";
    vector<LogicalType> table_types_comp_cast_type_cct2;
    vector<unique_ptr<Expression>> filter_comp_cast_type_cct2;
    unique_ptr<LogicalGet> get_op_comp_cast_type_cct2 = move(
            getLogicalGet(*this, table_comp_cast_type, alias_comp_cast_type_cct2, table_index_comp_cast_type_cct2,
                          table_types_comp_cast_type_cct2));
    unique_ptr<TableFilterSet> table_filters_comp_cast_type_cct2 = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_cct2 = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_NOTEQUAL, Value("complete+verified"));
    table_filters_comp_cast_type_cct2->filters[1] = move(constant_filter_cct2);
    unique_ptr<PhysicalTableScan> scan_comp_cast_type_cct2 = make_uniq<PhysicalTableScan>(get_comp_cast_type_cct2_types,
                                                                                          get_op_comp_cast_type_cct2->function,
                                                                                          get_op_comp_cast_type_cct2->table_index,
                                                                                          move(get_op_comp_cast_type_cct2->bind_data),
                                                                                          table_types_comp_cast_type_cct2,
                                                                                          comp_cast_type_cct2_ids,
                                                                                          move(filter_comp_cast_type_cct2),
                                                                                          vector<column_t>(),
                                                                                          get_op_comp_cast_type_cct2->names,
                                                                                          std::move(
                                                                                                  table_filters_comp_cast_type_cct2),
                                                                                          get_op_comp_cast_type_cct2->estimated_cardinality,
                                                                                          get_op_comp_cast_type_cct2->extra_info);

    vector<idx_t> complete_cast_ids{4, 5, 6};
    vector<LogicalType> get_complete_cast_types{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::BIGINT};
    string alias_complete_cast = "cc";
    vector<LogicalType> table_types_complete_cast;
    vector<unique_ptr<Expression>> filter_complete_cast;
    unique_ptr<LogicalGet> get_op_complete_cast = move(
            getLogicalGet(*this, table_complete_cast, alias_complete_cast, table_index_complete_cast,
                          table_types_complete_cast));
    unique_ptr<TableFilterSet> table_filters_complete_cast = NULL;
    unique_ptr<PhysicalTableScan> scan_complete_cast = make_uniq<PhysicalTableScan>(get_complete_cast_types,
                                                                                    get_op_complete_cast->function,
                                                                                    get_op_complete_cast->table_index,
                                                                                    move(get_op_complete_cast->bind_data),
                                                                                    table_types_complete_cast,
                                                                                    complete_cast_ids,
                                                                                    move(filter_complete_cast),
                                                                                    vector<column_t>(),
                                                                                    get_op_complete_cast->names,
                                                                                    std::move(
                                                                                            table_filters_complete_cast),
                                                                                    get_op_complete_cast->estimated_cardinality,
                                                                                    get_op_complete_cast->extra_info);


    vector<JoinCondition> cond_complete_cast_status_;
    JoinCondition join_condition_complete_cast_status_;
    join_condition_complete_cast_status_.left = make_uniq<BoundReferenceExpression>("status_id_rowid", LogicalType::BIGINT, 2);
    join_condition_complete_cast_status_.right = make_uniq<BoundReferenceExpression>("comp_cast_type_rowid", LogicalType::BIGINT, 0);
    join_condition_complete_cast_status_.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_complete_cast_status_ = make_uniq<RAIInfo>();
    rai_info_complete_cast_status_->rai = table_complete_cast.GetStorage().info->rais[1].get();
    rai_info_complete_cast_status_->rai_type = RAIType::EDGE_SOURCE;
    rai_info_complete_cast_status_->forward = true;
    rai_info_complete_cast_status_->vertex = &table_comp_cast_type;
    rai_info_complete_cast_status_->vertex_id = table_index_comp_cast_type_cct2;
    rai_info_complete_cast_status_->passing_tables[0] = table_index_complete_cast;
    rai_info_complete_cast_status_->left_cardinalities[0] = table_complete_cast.GetStorage().info->cardinality;
    rai_info_complete_cast_status_->compact_list = &rai_info_complete_cast_status_->rai->alist->compact_forward_list;

    join_condition_complete_cast_status_.rais.push_back(move(rai_info_complete_cast_status_));
    cond_complete_cast_status_.push_back(move(join_condition_complete_cast_status_));

    LogicalComparisonJoin join_complete_cast_status__op(JoinType::INNER);
    vector<LogicalType> output_complete_cast_status__types{LogicalType::BIGINT, LogicalType::BIGINT,
                                                           LogicalType::BIGINT, LogicalType::BIGINT};
    join_complete_cast_status__op.types = output_complete_cast_status__types;
    vector<idx_t> right_projection_map_complete_cast_status_{0};
    vector<idx_t> merge_project_map_complete_cast_status_;
    vector<LogicalType> delim_types_complete_cast_status_;
    auto join_complete_cast_status_ = make_uniq<PhysicalSIPJoin>(join_complete_cast_status__op, move(scan_complete_cast), move(scan_comp_cast_type_cct2),
                                                                      move(cond_complete_cast_status_), JoinType::INNER,
                                                                      left_projection_map,
                                                                      right_projection_map_complete_cast_status_,
                                                                      delim_types_complete_cast_status_, 0);


    vector<idx_t> title_t_ids{COLUMN_IDENTIFIER_ROW_ID, 1, 4, 12};
    vector<LogicalType> get_title_t_types{LogicalType::BIGINT, LogicalType::VARCHAR,
                                          LogicalType::BIGINT, LogicalType::BIGINT};
    string alias_title_t = "t";
    vector<LogicalType> table_types_title_t;
    vector<unique_ptr<Expression>> filter_title_t;
    unique_ptr<LogicalGet> get_op_title_t = move(
            getLogicalGet(*this, table_title, alias_title_t, table_index_title_t, table_types_title_t));
    unique_ptr<TableFilterSet> table_filters_title_t = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_t = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_GREATERTHAN, Value::BIGINT(2000));
    table_filters_title_t->filters[2] = move(constant_filter_t);
    unique_ptr<PhysicalTableScan> scan_title_t = make_uniq<PhysicalTableScan>(get_title_t_types,
                                                                              get_op_title_t->function,
                                                                              get_op_title_t->table_index,
                                                                              move(get_op_title_t->bind_data),
                                                                              table_types_title_t, title_t_ids,
                                                                              move(filter_title_t), vector<column_t>(),
                                                                              get_op_title_t->names,
                                                                              std::move(table_filters_title_t),
                                                                              get_op_title_t->estimated_cardinality,
                                                                              get_op_title_t->extra_info);


    vector<JoinCondition> cond_title_t;
    JoinCondition join_condition_title_t;
    join_condition_title_t.left = make_uniq<BoundReferenceExpression>("title_rowid", LogicalType::BIGINT, 0);
    join_condition_title_t.right = make_uniq<BoundReferenceExpression>("movie_id_rowid", LogicalType::BIGINT, 1);
    join_condition_title_t.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_title_t = make_uniq<RAIInfo>();
    rai_info_title_t->rai = table_complete_cast.GetStorage().info->rais[1].get();
    rai_info_title_t->rai_type = RAIType::TARGET_EDGE;
    rai_info_title_t->forward = true;
    rai_info_title_t->vertex = &table_title;
    rai_info_title_t->vertex_id = table_index_title_t;
    rai_info_title_t->passing_tables[0] = table_index_title_t;
    rai_info_title_t->left_cardinalities[0] = table_title.GetStorage().info->cardinality;
    // rai_info_title_t->compact_list = &rai_info_title_t->rai->alist->compact__list;

    join_condition_title_t.rais.push_back(move(rai_info_title_t));
    cond_title_t.push_back(move(join_condition_title_t));

    LogicalComparisonJoin join_title_t_op(JoinType::INNER);
    vector<LogicalType> output_title_t_types{LogicalType::BIGINT, LogicalType::VARCHAR,
                                             LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::BIGINT};
    join_title_t_op.types = output_title_t_types;
    vector<idx_t> right_projection_map_title_t{0};
    vector<idx_t> merge_project_map_title_t;
    vector<LogicalType> delim_types_title_t;
    auto join_title_t = make_uniq<PhysicalSIPJoin>(join_title_t_op, move(scan_title_t), move(join_complete_cast_status_), move(cond_title_t), JoinType::INNER,
                                                   left_projection_map, right_projection_map_title_t,
                                                   delim_types_title_t, 0);

    vector<idx_t> movie_info_idx_ids{6, 5, 3};
    vector<LogicalType> get_movie_info_idx_type{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_movie_info_idx = "mi";
    vector<LogicalType> table_types_movie_info_idx;
    vector<unique_ptr<Expression>> filter_movie_info_idx;
    unique_ptr<LogicalGet> get_op_movie_info_idx = move(
            getLogicalGet(*this, table_movie_info_idx, alias_movie_info_idx, table_index_movie_info_idx_, table_types_movie_info_idx));
    unique_ptr<TableFilterSet> table_filters_movie_info_idx = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_idx = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_LESSTHAN, Value("8.5"));
    table_filters_movie_info_idx->filters[2] = move(constant_filter_idx);
    unique_ptr<PhysicalTableScan> scan_movie_info_idx = make_uniq<PhysicalTableScan>(get_movie_info_idx_type,
                                                                                     get_op_movie_info_idx->function,
                                                                                     get_op_movie_info_idx->table_index,
                                                                                     move(get_op_movie_info_idx->bind_data),
                                                                                     table_types_movie_info_idx, movie_info_idx_ids,
                                                                                     move(filter_movie_info_idx),
                                                                                     vector<column_t>(),
                                                                                     get_op_movie_info_idx->names,
                                                                                     std::move(table_filters_movie_info_idx),
                                                                                     get_op_movie_info_idx->estimated_cardinality,
                                                                                     get_op_movie_info_idx->extra_info);


    vector<JoinCondition> cond_movie_info_idx_;
    JoinCondition join_condition_movie_info_idx_;
    join_condition_movie_info_idx_.left = make_uniq<BoundReferenceExpression>("movie_id_rowid", LogicalType::BIGINT, 0);
    join_condition_movie_info_idx_.right = make_uniq<BoundReferenceExpression>("title_rowid", LogicalType::BIGINT, 0);
    join_condition_movie_info_idx_.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_movie_info_idx_ = make_uniq<RAIInfo>();
    rai_info_movie_info_idx_->rai = table_movie_info_idx.GetStorage().info->rais[0].get();
    rai_info_movie_info_idx_->rai_type = RAIType::EDGE_TARGET;
    rai_info_movie_info_idx_->forward = false;
    rai_info_movie_info_idx_->vertex = &table_title;
    rai_info_movie_info_idx_->vertex_id = table_index_title_t;
    rai_info_movie_info_idx_->passing_tables[0] = table_index_movie_info_idx_;
    rai_info_movie_info_idx_->left_cardinalities[0] = table_movie_info_idx.GetStorage().info->cardinality;
    rai_info_movie_info_idx_->compact_list = &rai_info_movie_info_idx_->rai->alist->compact_backward_list;

    join_condition_movie_info_idx_.rais.push_back(move(rai_info_movie_info_idx_));
    cond_movie_info_idx_.push_back(move(join_condition_movie_info_idx_));

    LogicalComparisonJoin join_movie_info_idx__op(JoinType::INNER);
    vector<LogicalType> output_movie_info_idx__types{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::VARCHAR,
                                                     LogicalType::VARCHAR, LogicalType::BIGINT, LogicalType::BIGINT};
    join_movie_info_idx__op.types = output_movie_info_idx__types;
    vector<idx_t> right_projection_map_movie_info_idx_{1, 3, 4};
    vector<idx_t> merge_project_map_movie_info_idx_;
    vector<LogicalType> delim_types_movie_info_idx_;
    auto join_movie_info_idx_ = make_uniq<PhysicalSIPJoin>(join_movie_info_idx__op, move(scan_movie_info_idx), move(join_title_t),
                                                                move(cond_movie_info_idx_), JoinType::INNER,
                                                                left_projection_map,
                                                                right_projection_map_movie_info_idx_,
                                                                delim_types_movie_info_idx_, 0);


    vector<idx_t> info_type_it2_ids{COLUMN_IDENTIFIER_ROW_ID, 1};
    vector<LogicalType> get_info_type_it2_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_info_type_it2 = "it2";
    vector<LogicalType> table_types_info_type_it2;
    vector<unique_ptr<Expression>> filter_info_type_it2;
    unique_ptr<LogicalGet> get_op_info_type_it2 = move(
            getLogicalGet(*this, table_info_type, alias_info_type_it2, table_index_info_type_it2,
                          table_types_info_type_it2));
    unique_ptr<TableFilterSet> table_filters_info_type_it2 = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_it2 = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL, Value("rating"));
    table_filters_info_type_it2->filters[1] = move(constant_filter_it2);
    unique_ptr<PhysicalTableScan> scan_info_type_it2 = make_uniq<PhysicalTableScan>(get_info_type_it2_types,
                                                                                    get_op_info_type_it2->function,
                                                                                    get_op_info_type_it2->table_index,
                                                                                    move(get_op_info_type_it2->bind_data),
                                                                                    table_types_info_type_it2,
                                                                                    info_type_it2_ids,
                                                                                    move(filter_info_type_it2),
                                                                                    vector<column_t>(),
                                                                                    get_op_info_type_it2->names,
                                                                                    std::move(
                                                                                            table_filters_info_type_it2),
                                                                                    get_op_info_type_it2->estimated_cardinality,
                                                                                    get_op_info_type_it2->extra_info);


    vector<JoinCondition> cond_info_type_it2;
    JoinCondition join_condition_info_type_it2;
    join_condition_info_type_it2.left = make_uniq<BoundReferenceExpression>("info_type_rowid", LogicalType::BIGINT, 0);
    join_condition_info_type_it2.right = make_uniq<BoundReferenceExpression>("info_type_id_rowid", LogicalType::BIGINT, 1);
    join_condition_info_type_it2.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_info_type_it2 = make_uniq<RAIInfo>();
    rai_info_info_type_it2->rai = table_movie_info_idx.GetStorage().info->rais[0].get();
    rai_info_info_type_it2->rai_type = RAIType::SOURCE_EDGE;
    rai_info_info_type_it2->forward = false;
    rai_info_info_type_it2->vertex = &table_info_type;
    rai_info_info_type_it2->vertex_id = table_index_info_type_it2;
    rai_info_info_type_it2->passing_tables[0] = table_index_info_type_it2;
    rai_info_info_type_it2->left_cardinalities[0] = table_info_type.GetStorage().info->cardinality;
    // rai_info_info_type_it2->compact_list = &rai_info_info_type_it2->rai->alist->compact__list;

    join_condition_info_type_it2.rais.push_back(move(rai_info_info_type_it2));
    cond_info_type_it2.push_back(move(join_condition_info_type_it2));

    LogicalComparisonJoin join_info_type_it2_op(JoinType::INNER);
    vector<LogicalType> output_info_type_it2_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::BIGINT,
                                                   LogicalType::VARCHAR, LogicalType::VARCHAR, LogicalType::BIGINT,
                                                   LogicalType::BIGINT};
    join_info_type_it2_op.types = output_info_type_it2_types;
    vector<idx_t> right_projection_map_info_type_it2{0, 2, 3, 4, 5};
    vector<idx_t> merge_project_map_info_type_it2;
    vector<LogicalType> delim_types_info_type_it2;
    auto join_info_type_it2 = make_uniq<PhysicalSIPJoin>(join_info_type_it2_op, move(scan_info_type_it2), move(join_movie_info_idx_),
                                                         move(cond_info_type_it2), JoinType::INNER, left_projection_map,
                                                         right_projection_map_info_type_it2, delim_types_info_type_it2,
                                                         0);


    vector<idx_t> comp_cast_type_cct1_ids{COLUMN_IDENTIFIER_ROW_ID, 1};
    vector<LogicalType> get_comp_cast_type_cct1_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_comp_cast_type_cct1 = "cct1";
    vector<LogicalType> table_types_comp_cast_type_cct1;
    vector<unique_ptr<Expression>> filter_comp_cast_type_cct1;
    unique_ptr<LogicalGet> get_op_comp_cast_type_cct1 = move(
            getLogicalGet(*this, table_comp_cast_type, alias_comp_cast_type_cct1, table_index_comp_cast_type_cct1,
                          table_types_comp_cast_type_cct1));
    unique_ptr<TableFilterSet> table_filters_comp_cast_type_cct1 = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_cct1 = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL, Value("crew"));
    table_filters_comp_cast_type_cct1->filters[1] = move(constant_filter_cct1);
    unique_ptr<PhysicalTableScan> scan_comp_cast_type_cct1 = make_uniq<PhysicalTableScan>(get_comp_cast_type_cct1_types,
                                                                                          get_op_comp_cast_type_cct1->function,
                                                                                          get_op_comp_cast_type_cct1->table_index,
                                                                                          move(get_op_comp_cast_type_cct1->bind_data),
                                                                                          table_types_comp_cast_type_cct1,
                                                                                          comp_cast_type_cct1_ids,
                                                                                          move(filter_comp_cast_type_cct1),
                                                                                          vector<column_t>(),
                                                                                          get_op_comp_cast_type_cct1->names,
                                                                                          std::move(
                                                                                                  table_filters_comp_cast_type_cct1),
                                                                                          get_op_comp_cast_type_cct1->estimated_cardinality,
                                                                                          get_op_comp_cast_type_cct1->extra_info);


    vector<JoinCondition> cond_comp_cast_type_cct1;
    JoinCondition join_condition_comp_cast_type_cct1;
    join_condition_comp_cast_type_cct1.left = make_uniq<BoundReferenceExpression>("comp_cast_type_rowid", LogicalType::BIGINT, 0);
    join_condition_comp_cast_type_cct1.right = make_uniq<BoundReferenceExpression>("subject_id_rowid", LogicalType::BIGINT, 6);
    join_condition_comp_cast_type_cct1.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_comp_cast_type_cct1 = make_uniq<RAIInfo>();
    rai_info_comp_cast_type_cct1->rai = table_complete_cast.GetStorage().info->rais[0].get();
    rai_info_comp_cast_type_cct1->rai_type = RAIType::SOURCE_EDGE;
    rai_info_comp_cast_type_cct1->forward = false;
    rai_info_comp_cast_type_cct1->vertex = &table_comp_cast_type;
    rai_info_comp_cast_type_cct1->vertex_id = table_index_comp_cast_type_cct1;
    rai_info_comp_cast_type_cct1->passing_tables[0] = table_index_comp_cast_type_cct1;
    rai_info_comp_cast_type_cct1->left_cardinalities[0] = table_comp_cast_type.GetStorage().info->cardinality;
    // rai_info_comp_cast_type_cct1->compact_list = &rai_info_comp_cast_type_cct1->rai->alist->compact__list;

    join_condition_comp_cast_type_cct1.rais.push_back(move(rai_info_comp_cast_type_cct1));
    cond_comp_cast_type_cct1.push_back(move(join_condition_comp_cast_type_cct1));

    LogicalComparisonJoin join_comp_cast_type_cct1_op(JoinType::INNER);
    vector<LogicalType> output_comp_cast_type_cct1_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::BIGINT,
                                                         LogicalType::VARCHAR, LogicalType::VARCHAR, LogicalType::BIGINT};
    join_comp_cast_type_cct1_op.types = output_comp_cast_type_cct1_types;
    vector<idx_t> right_projection_map_comp_cast_type_cct1{2, 3, 4, 5};
    vector<idx_t> merge_project_map_comp_cast_type_cct1;
    vector<LogicalType> delim_types_comp_cast_type_cct1;
    auto join_comp_cast_type_cct1 = make_uniq<PhysicalSIPJoin>(join_comp_cast_type_cct1_op, move(scan_comp_cast_type_cct1), move(join_info_type_it2),
                                                               move(cond_comp_cast_type_cct1), JoinType::INNER,
                                                               left_projection_map,
                                                               right_projection_map_comp_cast_type_cct1,
                                                               delim_types_comp_cast_type_cct1, 0);


    vector<idx_t> movie_companies_ids{4, 5, 6, 7};
    vector<LogicalType> get_movie_companies_types{LogicalType::VARCHAR, LogicalType::BIGINT,
                                                  LogicalType::BIGINT, LogicalType::BIGINT};
    string alias_movie_companies = "ct";
    vector<LogicalType> table_types_movie_companies;
    vector<unique_ptr<Expression>> filter_movie_companies;
    unique_ptr<LogicalGet> get_op_movie_companies = move(
            getLogicalGet(*this, table_movie_companies, alias_movie_companies, table_index_movie_companies_,
                          table_types_movie_companies));
    unique_ptr<TableFilterSet> table_filters_movie_companies = NULL;
    unique_ptr<PhysicalTableScan> scan_movie_companies = make_uniq<PhysicalTableScan>(get_movie_companies_types,
                                                                                      get_op_movie_companies->function,
                                                                                      get_op_movie_companies->table_index,
                                                                                      move(get_op_movie_companies->bind_data),
                                                                                      table_types_movie_companies,
                                                                                      movie_companies_ids,
                                                                                      move(filter_movie_companies),
                                                                                      vector<column_t>(),
                                                                                      get_op_movie_companies->names,
                                                                                      std::move(
                                                                                              table_filters_movie_companies),
                                                                                      get_op_movie_companies->estimated_cardinality,
                                                                                      get_op_movie_companies->extra_info);


    string p_movie_company_note1 = "(USA)"; // 933;
    string p_movie_company_note2 = "%(200%)%"; // 933;
    Value p_note1 = Value(p_movie_company_note1);
    Value p_note2 = Value(p_movie_company_note2);
    vector<LogicalType> filter_mc_types{LogicalType::VARCHAR, LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::BIGINT};
    vector<unique_ptr<Expression>> select_list_movie_companies;
    auto like_expression_left = make_uniq<BoundReferenceExpression>("note", LogicalType::VARCHAR, 0);
    auto like_expression_value = make_uniq<BoundConstantExpression>(p_note1);
    vector<unique_ptr<Expression>> like_arguments1, like_arguments2;
    like_arguments1.push_back(move(like_expression_left));
    like_arguments1.push_back(move(like_expression_value));

    auto like_expression_left2 = make_uniq<BoundReferenceExpression>("note", LogicalType::VARCHAR, 0);
    auto like_expression_value2 = make_uniq<BoundConstantExpression>(p_note2);
    like_arguments2.push_back(move(like_expression_left2));
    like_arguments2.push_back(move(like_expression_value2));

    ScalarFunction bound_function_contains = ContainsFun::GetFunction();
    ScalarFunction bound_function_like = LikeFun::GetLikeFunction();
    unique_ptr<FunctionData> bind_data_contains = NULL;

    auto like_bound_function = make_uniq<BoundFunctionExpression>(LogicalType::BOOLEAN,
                                                                  bound_function_contains,
                                                                  move(like_arguments1),
                                                                  move(bind_data_contains), false);

    auto not_unlike_bound_function = make_uniq<BoundOperatorExpression>(ExpressionType::OPERATOR_NOT,
                                                                        LogicalType::BOOLEAN);
    not_unlike_bound_function->children.push_back(move(like_bound_function));

    unique_ptr<FunctionData> bind_data_contains2 = NULL;
    auto like_bound_function2 = make_uniq<BoundFunctionExpression>(LogicalType::BOOLEAN,
                                                                   bound_function_like,
                                                                   move(like_arguments2),
                                                                   move(bind_data_contains2), false);


    select_list_movie_companies.push_back(move(not_unlike_bound_function));
    select_list_movie_companies.push_back(move(like_bound_function2));
    unique_ptr<PhysicalFilter> filter_mc_contains = make_uniq<PhysicalFilter>(filter_mc_types, move(select_list_movie_companies), 0);
    filter_mc_contains->children.push_back(move(scan_movie_companies));


    vector<JoinCondition> cond_movie_companies_;
    JoinCondition join_condition_movie_companies_;
    join_condition_movie_companies_.left = make_uniq<BoundReferenceExpression>("movie_id_rowid", LogicalType::BIGINT, 2);
    join_condition_movie_companies_.right = make_uniq<BoundReferenceExpression>("movie_id_rowid", LogicalType::BIGINT, 2);
    join_condition_movie_companies_.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_movie_companies_ = make_uniq<RAIInfo>();
    rai_info_movie_companies_->rai = table_movie_companies.GetStorage().info->rais[0].get();
    rai_info_movie_companies_->rai_type = RAIType::EDGE_TARGET;
    rai_info_movie_companies_->forward = false;
    rai_info_movie_companies_->vertex = &table_title;
    rai_info_movie_companies_->vertex_id = table_index_title_t;
    rai_info_movie_companies_->passing_tables[0] = table_index_movie_companies_;
    rai_info_movie_companies_->left_cardinalities[0] = table_movie_companies.GetStorage().info->cardinality;
    rai_info_movie_companies_->compact_list = &rai_info_movie_companies_->rai->alist->compact_backward_list;

    join_condition_movie_companies_.rais.push_back(move(rai_info_movie_companies_));
    cond_movie_companies_.push_back(move(join_condition_movie_companies_));

    LogicalComparisonJoin join_movie_companies__op(JoinType::INNER);
    vector<LogicalType> output_movie_companies__types{LogicalType::VARCHAR, LogicalType::BIGINT, LogicalType::BIGINT,
                                                      LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::VARCHAR,
                                                      LogicalType::BIGINT};
    join_movie_companies__op.types = output_movie_companies__types;
    vector<idx_t> right_projection_map_movie_companies_{3, 4, 5};
    vector<idx_t> merge_project_map_movie_companies_;
    vector<LogicalType> delim_types_movie_companies_;
    auto join_movie_companies_ = make_uniq<PhysicalSIPJoin>(join_movie_companies__op, move(filter_mc_contains), move(join_comp_cast_type_cct1),
                                                                 move(cond_movie_companies_), JoinType::INNER,
                                                                 left_projection_map,
                                                                 right_projection_map_movie_companies_,
                                                                 delim_types_movie_companies_, 0);


    vector<idx_t> company_name_cn_ids{COLUMN_IDENTIFIER_ROW_ID, 1, 2};
    vector<LogicalType> get_company_name_cn_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::VARCHAR};
    string alias_company_name_cn = "cn";
    vector<LogicalType> table_types_company_name_cn;
    vector<unique_ptr<Expression>> filter_company_name_cn;
    unique_ptr<LogicalGet> get_op_company_name_cn = move(
            getLogicalGet(*this, table_company_name, alias_company_name_cn, table_index_company_name_cn,
                          table_types_company_name_cn));
    unique_ptr<TableFilterSet> table_filters_company_name_cn = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_cn = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_NOTEQUAL, Value("[us]"));
    table_filters_company_name_cn->filters[2] = move(constant_filter_cn);
    unique_ptr<PhysicalTableScan> scan_company_name_cn = make_uniq<PhysicalTableScan>(get_company_name_cn_types,
                                                                                      get_op_company_name_cn->function,
                                                                                      get_op_company_name_cn->table_index,
                                                                                      move(get_op_company_name_cn->bind_data),
                                                                                      table_types_company_name_cn,
                                                                                      company_name_cn_ids,
                                                                                      move(filter_company_name_cn),
                                                                                      vector<column_t>(),
                                                                                      get_op_company_name_cn->names,
                                                                                      std::move(
                                                                                              table_filters_company_name_cn),
                                                                                      get_op_company_name_cn->estimated_cardinality,
                                                                                      get_op_company_name_cn->extra_info);


    vector<JoinCondition> cond_company_name_cn;
    JoinCondition join_condition_company_name_cn;
    join_condition_company_name_cn.left = make_uniq<BoundReferenceExpression>("company_name_rowid", LogicalType::BIGINT, 0);
    join_condition_company_name_cn.right = make_uniq<BoundReferenceExpression>("company_id_rowid", LogicalType::BIGINT, 1);
    join_condition_company_name_cn.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_company_name_cn = make_uniq<RAIInfo>();
    rai_info_company_name_cn->rai = table_movie_companies.GetStorage().info->rais[0].get();
    rai_info_company_name_cn->rai_type = RAIType::SOURCE_EDGE;
    rai_info_company_name_cn->forward = false;
    rai_info_company_name_cn->vertex = &table_company_name;
    rai_info_company_name_cn->vertex_id = table_index_company_name_cn;
    rai_info_company_name_cn->passing_tables[0] = table_index_company_name_cn;
    rai_info_company_name_cn->left_cardinalities[0] = table_company_name.GetStorage().info->cardinality;
    // rai_info_company_name_cn->compact_list = &rai_info_company_name_cn->rai->alist->compact__list;

    join_condition_company_name_cn.rais.push_back(move(rai_info_company_name_cn));
    cond_company_name_cn.push_back(move(join_condition_company_name_cn));

    LogicalComparisonJoin join_company_name_cn_op(JoinType::INNER);
    vector<LogicalType> output_company_name_cn_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::VARCHAR,
                                                     LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::VARCHAR,
                                                     LogicalType::VARCHAR, LogicalType::BIGINT};
    join_company_name_cn_op.types = output_company_name_cn_types;
    vector<idx_t> right_projection_map_company_name_cn{2, 3, 4, 5, 6};
    vector<idx_t> merge_project_map_company_name_cn;
    vector<LogicalType> delim_types_company_name_cn;
    auto join_company_name_cn = make_uniq<PhysicalSIPJoin>(join_company_name_cn_op, move(scan_company_name_cn), move(join_movie_companies_),
                                                           move(cond_company_name_cn), JoinType::INNER,
                                                           left_projection_map, right_projection_map_company_name_cn,
                                                           delim_types_company_name_cn, 0);


    vector<idx_t> company_type_ct_ids{COLUMN_IDENTIFIER_ROW_ID};
    vector<LogicalType> get_company_type_ct_types{LogicalType::BIGINT};
    string alias_company_type_ct = "ct";
    vector<LogicalType> table_types_company_type_ct;
    vector<unique_ptr<Expression>> filter_company_type_ct;
    unique_ptr<LogicalGet> get_op_company_type_ct = move(
            getLogicalGet(*this, table_company_type, alias_company_type_ct, table_index_company_type_ct,
                          table_types_company_type_ct));
    unique_ptr<TableFilterSet> table_filters_company_type_ct = NULL;
    unique_ptr<PhysicalTableScan> scan_company_type_ct = make_uniq<PhysicalTableScan>(get_company_type_ct_types,
                                                                                      get_op_company_type_ct->function,
                                                                                      get_op_company_type_ct->table_index,
                                                                                      move(get_op_company_type_ct->bind_data),
                                                                                      table_types_company_type_ct,
                                                                                      company_type_ct_ids,
                                                                                      move(filter_company_type_ct),
                                                                                      vector<column_t>(),
                                                                                      get_op_company_type_ct->names,
                                                                                      std::move(
                                                                                              table_filters_company_type_ct),
                                                                                      get_op_company_type_ct->estimated_cardinality,
                                                                                      get_op_company_type_ct->extra_info);


    vector<JoinCondition> cond_ct;
    JoinCondition join_condition_ct;
    join_condition_ct.left = make_uniq<BoundReferenceExpression>("company_type_rowid", LogicalType::BIGINT, 0);
    join_condition_ct.right = make_uniq<BoundReferenceExpression>("company_type_id_rowid", LogicalType::BIGINT, 4);
    join_condition_ct.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_ct = make_uniq<RAIInfo>();
    rai_info_ct->rai = table_movie_companies.GetStorage().info->rais[1].get();
    rai_info_ct->rai_type = RAIType::SOURCE_EDGE;
    rai_info_ct->forward = false;
    rai_info_ct->vertex = &table_company_type;
    rai_info_ct->vertex_id = table_index_company_type_ct;
    rai_info_ct->passing_tables[0] = table_index_company_type_ct;
    rai_info_ct->left_cardinalities[0] = table_company_type.GetStorage().info->cardinality;
    // rai_info_ct->compact_list = &rai_info_ct->rai->alist->compact__list;

    join_condition_ct.rais.push_back(move(rai_info_ct));
    cond_ct.push_back(move(join_condition_ct));

    LogicalComparisonJoin join_ct_op(JoinType::INNER);
    vector<LogicalType> output_ct_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::BIGINT,
                                        LogicalType::VARCHAR, LogicalType::VARCHAR, LogicalType::BIGINT};
    join_ct_op.types = output_ct_types;
    vector<idx_t> right_projection_map_ct{1, 3, 5, 6, 7};
    vector<idx_t> merge_project_map_ct;
    vector<LogicalType> delim_types_ct;
    auto join_ct = make_uniq<PhysicalSIPJoin>(join_ct_op, move(scan_company_type_ct), move(join_company_name_cn),
                                              move(cond_ct), JoinType::INNER,
                                              left_projection_map,
                                              right_projection_map_ct,
                                              delim_types_ct, 0);

    vector<idx_t> movie_info_ids{6, 5, 3};
    vector<LogicalType> get_movie_info_types{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_movie_info = "i";
    vector<LogicalType> table_types_movie_info;
    vector<unique_ptr<Expression>> filter_movie_info;
    unique_ptr<LogicalGet> get_op_movie_info = move(
            getLogicalGet(*this, table_movie_info, alias_movie_info, table_index_movie_info_, table_types_movie_info));
    unique_ptr<TableFilterSet> table_filters_movie_info = NULL;
    unique_ptr<PhysicalTableScan> scan_movie_info = make_uniq<PhysicalTableScan>(get_movie_info_types,
                                                                                 get_op_movie_info->function,
                                                                                 get_op_movie_info->table_index,
                                                                                 move(get_op_movie_info->bind_data),
                                                                                 table_types_movie_info,
                                                                                 movie_info_ids,
                                                                                 move(filter_movie_info),
                                                                                 vector<column_t>(),
                                                                                 get_op_movie_info->names,
                                                                                 std::move(table_filters_movie_info),
                                                                                 get_op_movie_info->estimated_cardinality,
                                                                                 get_op_movie_info->extra_info);

    auto &allocator_mi = Allocator::Get(context);
    vector<LogicalType> join_in_types_mi {LogicalType::VARCHAR};
    auto collection_mi =
            make_uniq<ColumnDataCollection>(context, join_in_types_mi, ColumnDataAllocatorType::IN_MEMORY_ALLOCATOR);

    vector<LogicalType> chunk_in_types_mi {LogicalType::VARCHAR};
    DataChunk chunk_mi;
    chunk_mi.SetCardinality(10);
    chunk_mi.Initialize(allocator_mi, chunk_in_types_mi);
    chunk_mi.SetValue(0, 0, Value("Sweden"));
    chunk_mi.SetValue(0, 1, Value("Norway"));
    chunk_mi.SetValue(0, 2, Value("Germany"));
    chunk_mi.SetValue(0, 3, Value("Denmark"));
    chunk_mi.SetValue(0, 4, Value("Swedish"));
    chunk_mi.SetValue(0, 5, Value("Danish"));
    chunk_mi.SetValue(0, 6, Value("Norwegian"));
    chunk_mi.SetValue(0, 7, Value("German"));
    chunk_mi.SetValue(0, 8, Value("USA"));
    chunk_mi.SetValue(0, 9, Value("American"));
    collection_mi->Append(chunk_mi);

    // create a chunk scan to output the result
    vector<LogicalType> ouput_in_types_mi {LogicalType::VARCHAR};
    auto chunk_scan_mi = make_uniq<PhysicalColumnDataScan>(ouput_in_types_mi, PhysicalOperatorType::COLUMN_DATA_SCAN,
                                                           10, std::move(collection_mi));

    vector<JoinCondition> cond_hash_join_mi;
    JoinCondition join_condition_hash_join_mi;
    join_condition_hash_join_mi.left = make_uniq<BoundReferenceExpression>("info", LogicalType::VARCHAR, 2);
    join_condition_hash_join_mi.right = make_uniq<BoundReferenceExpression>("", LogicalType::VARCHAR, 0);
    join_condition_hash_join_mi.comparison = ExpressionType::COMPARE_EQUAL;
    cond_hash_join_mi.push_back(move(join_condition_hash_join_mi));

    LogicalComparisonJoin join_hash_join_op_mi(JoinType::MARK);
    vector<LogicalType> output_hash_join_types_mi{LogicalType::BIGINT, LogicalType::BIGINT,
                                                  LogicalType::VARCHAR, LogicalType::BOOLEAN};
    join_hash_join_op_mi.types = output_hash_join_types_mi;
    vector<idx_t> right_projection_map_hash_join_mi;
    vector<LogicalType> delim_types_hash_join_mi;
    PerfectHashJoinStats joinstate_mi;
    auto join_hash_join_mi = make_uniq<PhysicalHashJoin>(join_hash_join_op_mi, move(scan_movie_info), move(chunk_scan_mi), move(cond_hash_join_mi),
                                                         JoinType::MARK, left_projection_map,
                                                         right_projection_map_hash_join_mi,
                                                         delim_types_hash_join_mi, 0, joinstate_mi);

    vector<LogicalType> filter_in_types_mi{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::BOOLEAN};
    vector<unique_ptr<Expression>> select_list_in_mi;
    auto in_exp_mi = make_uniq<BoundReferenceExpression>("IN (...)", LogicalType::BOOLEAN, 3);
    select_list_in_mi.push_back(move(in_exp_mi));
    unique_ptr<PhysicalFilter> filter_in_mi = make_uniq<PhysicalFilter>(filter_in_types_mi, move(select_list_in_mi), 0);
    filter_in_mi->children.push_back(move(join_hash_join_mi));

    vector<JoinCondition> cond_movie_info_;
    JoinCondition join_condition_movie_info_;
    join_condition_movie_info_.left = make_uniq<BoundReferenceExpression>("movie_id_rowid", LogicalType::BIGINT, 0);
    join_condition_movie_info_.right = make_uniq<BoundReferenceExpression>("movie_id_rowid", LogicalType::BIGINT, 2);
    join_condition_movie_info_.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_movie_info_ = make_uniq<RAIInfo>();
    rai_info_movie_info_->rai = table_movie_info.GetStorage().info->rais[0].get();
    rai_info_movie_info_->rai_type = RAIType::EDGE_TARGET;
    rai_info_movie_info_->forward = false;
    rai_info_movie_info_->vertex = &table_title;
    rai_info_movie_info_->vertex_id = table_index_title_t;
    rai_info_movie_info_->passing_tables[0] = table_index_movie_info_;
    rai_info_movie_info_->left_cardinalities[0] = table_movie_info.GetStorage().info->cardinality;
    rai_info_movie_info_->compact_list = &rai_info_movie_info_->rai->alist->compact_backward_list;

    join_condition_movie_info_.rais.push_back(move(rai_info_movie_info_));
    cond_movie_info_.push_back(move(join_condition_movie_info_));

    LogicalComparisonJoin join_movie_info__op(JoinType::INNER);
    vector<LogicalType> output_movie_info__types{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::VARCHAR,
                                                 LogicalType::BOOLEAN, LogicalType::VARCHAR, LogicalType::VARCHAR,
                                                 LogicalType::VARCHAR, LogicalType::BIGINT};
    join_movie_info__op.types = output_movie_info__types;
    vector<idx_t> right_projection_map_movie_info_{1, 3, 4, 5};
    vector<idx_t> merge_project_map_movie_info_;
    vector<LogicalType> delim_types_movie_info_;
    auto join_movie_info_ = make_uniq<PhysicalSIPJoin>(join_movie_info__op, move(filter_in_mi), move(join_ct), move(cond_movie_info_),
                                                            JoinType::INNER, left_projection_map,
                                                            right_projection_map_movie_info_,
                                                            delim_types_movie_info_, 0);


    vector<idx_t> info_type_it1_ids{COLUMN_IDENTIFIER_ROW_ID, 1};
    vector<LogicalType> get_info_type_it1_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_info_type_it1 = "it1";
    vector<LogicalType> table_types_info_type_it1;
    vector<unique_ptr<Expression>> filter_info_type_it1;
    unique_ptr<LogicalGet> get_op_info_type_it1 = move(
            getLogicalGet(*this, table_info_type, alias_info_type_it1, table_index_info_type_it1,
                          table_types_info_type_it1));
    unique_ptr<TableFilterSet> table_filters_info_type_it1 = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_it1 = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL, Value("countries"));
    table_filters_info_type_it1->filters[1] = move(constant_filter_it1);
    unique_ptr<PhysicalTableScan> scan_info_type_it1 = make_uniq<PhysicalTableScan>(get_info_type_it1_types,
                                                                                    get_op_info_type_it1->function,
                                                                                    get_op_info_type_it1->table_index,
                                                                                    move(get_op_info_type_it1->bind_data),
                                                                                    table_types_info_type_it1,
                                                                                    info_type_it1_ids,
                                                                                    move(filter_info_type_it1),
                                                                                    vector<column_t>(),
                                                                                    get_op_info_type_it1->names,
                                                                                    std::move(
                                                                                            table_filters_info_type_it1),
                                                                                    get_op_info_type_it1->estimated_cardinality,
                                                                                    get_op_info_type_it1->extra_info);


    vector<JoinCondition> cond_info_type_it1;
    JoinCondition join_condition_info_type_it1;
    join_condition_info_type_it1.left = make_uniq<BoundReferenceExpression>("info_type_rowid", LogicalType::BIGINT, 0);
    join_condition_info_type_it1.right = make_uniq<BoundReferenceExpression>("info_type_id_rowid", LogicalType::BIGINT, 1);
    join_condition_info_type_it1.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_info_type_it1 = make_uniq<RAIInfo>();
    rai_info_info_type_it1->rai = table_movie_info.GetStorage().info->rais[0].get();
    rai_info_info_type_it1->rai_type = RAIType::SOURCE_EDGE;
    rai_info_info_type_it1->forward = false;
    rai_info_info_type_it1->vertex = &table_info_type;
    rai_info_info_type_it1->vertex_id = table_index_info_type_it1;
    rai_info_info_type_it1->passing_tables[0] = table_index_info_type_it1;
    rai_info_info_type_it1->left_cardinalities[0] = table_info_type.GetStorage().info->cardinality;
    // rai_info_info_type_it1->compact_list = &rai_info_info_type_it1->rai->alist->compact__list;

    join_condition_info_type_it1.rais.push_back(move(rai_info_info_type_it1));
    cond_info_type_it1.push_back(move(join_condition_info_type_it1));

    LogicalComparisonJoin join_info_type_it1_op(JoinType::INNER);
    vector<LogicalType> output_info_type_it1_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::BIGINT,
                                                   LogicalType::VARCHAR, LogicalType::VARCHAR, LogicalType::VARCHAR,
                                                   LogicalType::BIGINT};
    join_info_type_it1_op.types = output_info_type_it1_types;
    vector<idx_t> right_projection_map_info_type_it1{0, 4, 5, 6, 7};
    vector<idx_t> merge_project_map_info_type_it1;
    vector<LogicalType> delim_types_info_type_it1;
    auto join_info_type_it1 = make_uniq<PhysicalSIPJoin>(join_info_type_it1_op, move(scan_info_type_it1), move(join_movie_info_),
                                                         move(cond_info_type_it1), JoinType::INNER, left_projection_map,
                                                         right_projection_map_info_type_it1, delim_types_info_type_it1,
                                                         0);

    vector<idx_t> kind_type_kt_ids{COLUMN_IDENTIFIER_ROW_ID, 1};
    vector<LogicalType> get_kind_type_kt_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_kind_type_kt = "kt";
    vector<LogicalType> table_types_kind_type_kt;
    vector<unique_ptr<Expression>> filter_kind_type_kt;
    unique_ptr<LogicalGet> get_op_kind_type_kt = move(
            getLogicalGet(*this, table_kind_type, alias_kind_type_kt, table_index_kind_type_kt,
                          table_types_kind_type_kt));
    unique_ptr<TableFilterSet> table_filters_kind_type_kt = NULL;
    unique_ptr<PhysicalTableScan> scan_kind_type_kt = make_uniq<PhysicalTableScan>(get_kind_type_kt_types,
                                                                                   get_op_kind_type_kt->function,
                                                                                   get_op_kind_type_kt->table_index,
                                                                                   move(get_op_kind_type_kt->bind_data),
                                                                                   table_types_kind_type_kt,
                                                                                   kind_type_kt_ids,
                                                                                   move(filter_kind_type_kt),
                                                                                   vector<column_t>(),
                                                                                   get_op_kind_type_kt->names,
                                                                                   std::move(
                                                                                           table_filters_kind_type_kt),
                                                                                   get_op_kind_type_kt->estimated_cardinality,
                                                                                   get_op_kind_type_kt->extra_info);

    auto &allocator_kt = Allocator::Get(context);
    vector<LogicalType> join_in_types_kt {LogicalType::VARCHAR};
    auto collection_kt =
            make_uniq<ColumnDataCollection>(context, join_in_types_kt, ColumnDataAllocatorType::IN_MEMORY_ALLOCATOR);

    vector<LogicalType> chunk_in_types_kt {LogicalType::VARCHAR};
    DataChunk chunk_kt;
    chunk_kt.SetCardinality(2);
    chunk_kt.Initialize(allocator_kt, chunk_in_types_kt);
    chunk_kt.SetValue(0, 0, Value("movie"));
    chunk_kt.SetValue(0, 1, Value("episode"));
    collection_kt->Append(chunk_kt);

    // create a chunk scan to output the result
    vector<LogicalType> ouput_in_types_kt {LogicalType::VARCHAR};
    auto chunk_scan_kt = make_uniq<PhysicalColumnDataScan>(ouput_in_types_kt, PhysicalOperatorType::COLUMN_DATA_SCAN,
                                                           2, std::move(collection_kt));

    vector<JoinCondition> cond_hash_join_kt;
    JoinCondition join_condition_hash_join_kt;
    join_condition_hash_join_kt.left = make_uniq<BoundReferenceExpression>("kind", LogicalType::VARCHAR, 1);
    join_condition_hash_join_kt.right = make_uniq<BoundReferenceExpression>("", LogicalType::VARCHAR, 0);
    join_condition_hash_join_kt.comparison = ExpressionType::COMPARE_EQUAL;
    cond_hash_join_kt.push_back(move(join_condition_hash_join_kt));

    LogicalComparisonJoin join_hash_join_op_kt(JoinType::MARK);
    vector<LogicalType> output_hash_join_types_kt{LogicalType::BIGINT,
                                                  LogicalType::VARCHAR, LogicalType::BOOLEAN};
    join_hash_join_op_kt.types = output_hash_join_types_kt;
    vector<idx_t> right_projection_map_hash_join_kt;
    vector<LogicalType> delim_types_hash_join_kt;
    PerfectHashJoinStats joinstate_kt;
    auto join_hash_join_kt = make_uniq<PhysicalHashJoin>(join_hash_join_op_kt, move(scan_kind_type_kt), move(chunk_scan_kt), move(cond_hash_join_kt),
                                                         JoinType::MARK, left_projection_map,
                                                         right_projection_map_hash_join_kt,
                                                         delim_types_hash_join_kt, 0, joinstate_kt);

    vector<LogicalType> filter_in_types_kt{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::BOOLEAN};
    vector<unique_ptr<Expression>> select_list_in_kt;
    auto in_exp_kt = make_uniq<BoundReferenceExpression>("IN (...)", LogicalType::BOOLEAN, 2);
    select_list_in_kt.push_back(move(in_exp_kt));
    unique_ptr<PhysicalFilter> filter_in_kt = make_uniq<PhysicalFilter>(filter_in_types_kt, move(select_list_in_kt), 0);
    filter_in_kt->children.push_back(move(join_hash_join_kt));


    vector<JoinCondition> cond_kind_type_kt;
    JoinCondition join_condition_kind_type_kt;
    join_condition_kind_type_kt.left = make_uniq<BoundReferenceExpression>("kind_type_rowid", LogicalType::BIGINT, 0);
    join_condition_kind_type_kt.right = make_uniq<BoundReferenceExpression>("kind_id_rowid", LogicalType::BIGINT, 6);
    join_condition_kind_type_kt.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_kind_type_kt = make_uniq<RAIInfo>();
    rai_info_kind_type_kt->rai = table_title.GetStorage().info->rais[0].get();
    rai_info_kind_type_kt->rai_type = RAIType::TARGET_EDGE;
    rai_info_kind_type_kt->forward = true;
    rai_info_kind_type_kt->vertex = &table_kind_type;
    rai_info_kind_type_kt->vertex_id = table_index_kind_type_kt;
    rai_info_kind_type_kt->passing_tables[0] = table_index_kind_type_kt;
    rai_info_kind_type_kt->left_cardinalities[0] = table_kind_type.GetStorage().info->cardinality;
    // rai_info_kind_type_kt->compact_list = &rai_info_kind_type_kt->rai->alist->compact__list;

    join_condition_kind_type_kt.rais.push_back(move(rai_info_kind_type_kt));
    cond_kind_type_kt.push_back(move(join_condition_kind_type_kt));

    LogicalComparisonJoin join_kind_type_kt_op(JoinType::INNER);
    vector<LogicalType> output_kind_type_kt_types{LogicalType::BIGINT, LogicalType::VARCHAR,
                                                  LogicalType::BOOLEAN, LogicalType::BIGINT,
                                                  LogicalType::VARCHAR, LogicalType::VARCHAR,
                                                  LogicalType::VARCHAR};
    join_kind_type_kt_op.types = output_kind_type_kt_types;
    vector<idx_t> right_projection_map_kind_type_kt{2, 3, 4, 5};
    vector<idx_t> merge_project_map_kind_type_kt;
    vector<LogicalType> delim_types_kind_type_kt;
    auto join_kind_type_kt = make_uniq<PhysicalSIPJoin>(join_kind_type_kt_op, move(filter_in_kt), move(join_info_type_it1), move(cond_kind_type_kt),
                                                        JoinType::INNER, left_projection_map,
                                                        right_projection_map_kind_type_kt, delim_types_kind_type_kt, 0);


    vector<idx_t> keyword_k_ids{COLUMN_IDENTIFIER_ROW_ID, 1};
    vector<LogicalType> get_keyword_k_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_keyword_k = "k";
    vector<LogicalType> table_types_keyword_k;
    vector<unique_ptr<Expression>> filter_keyword_k;
    unique_ptr<LogicalGet> get_op_keyword_k = move(
            getLogicalGet(*this, table_keyword, alias_keyword_k, table_index_keyword_k, table_types_keyword_k));
    unique_ptr<TableFilterSet> table_filters_keyword_k = NULL;
    unique_ptr<PhysicalTableScan> scan_keyword_k = make_uniq<PhysicalTableScan>(get_keyword_k_types,
                                                                                get_op_keyword_k->function,
                                                                                get_op_keyword_k->table_index,
                                                                                move(get_op_keyword_k->bind_data),
                                                                                table_types_keyword_k, keyword_k_ids,
                                                                                move(filter_keyword_k),
                                                                                vector<column_t>(),
                                                                                get_op_keyword_k->names,
                                                                                std::move(table_filters_keyword_k),
                                                                                get_op_keyword_k->estimated_cardinality,
                                                                                get_op_keyword_k->extra_info);

    auto &allocator_k = Allocator::Get(context);
    vector<LogicalType> join_in_types_k {LogicalType::VARCHAR};
    auto collection_k =
            make_uniq<ColumnDataCollection>(context, join_in_types_k, ColumnDataAllocatorType::IN_MEMORY_ALLOCATOR);

    vector<LogicalType> chunk_in_types_k {LogicalType::VARCHAR};
    DataChunk chunk_k;
    chunk_k.SetCardinality(4);
    chunk_k.Initialize(allocator_k, chunk_in_types_k);
    chunk_k.SetValue(0, 0, Value("murder"));
    chunk_k.SetValue(0, 1, Value("murder-in-title"));
    chunk_k.SetValue(0, 2, Value("blood"));
    chunk_k.SetValue(0, 3, Value("violence"));
    collection_k->Append(chunk_k);

    // create a chunk scan to output the result
    vector<LogicalType> ouput_in_types_k {LogicalType::VARCHAR};
    auto chunk_scan_k = make_uniq<PhysicalColumnDataScan>(ouput_in_types_k, PhysicalOperatorType::COLUMN_DATA_SCAN,
                                                          4, std::move(collection_k));

    vector<JoinCondition> cond_hash_join_k;
    JoinCondition join_condition_hash_join_k;
    join_condition_hash_join_k.left = make_uniq<BoundReferenceExpression>("keyword", LogicalType::VARCHAR, 1);
    join_condition_hash_join_k.right = make_uniq<BoundReferenceExpression>("", LogicalType::VARCHAR, 0);
    join_condition_hash_join_k.comparison = ExpressionType::COMPARE_EQUAL;
    cond_hash_join_k.push_back(move(join_condition_hash_join_k));

    LogicalComparisonJoin join_hash_join_op_k(JoinType::MARK);
    vector<LogicalType> output_hash_join_types_k{LogicalType::BIGINT,
                                                 LogicalType::VARCHAR, LogicalType::BOOLEAN};
    join_hash_join_op_k.types = output_hash_join_types_k;
    vector<idx_t> right_projection_map_hash_join_k;
    vector<LogicalType> delim_types_hash_join_k;
    PerfectHashJoinStats joinstate_k;
    auto join_hash_join_k = make_uniq<PhysicalHashJoin>(join_hash_join_op_k, move(scan_keyword_k), move(chunk_scan_k), move(cond_hash_join_k),
                                                        JoinType::MARK, left_projection_map,
                                                        right_projection_map_hash_join_k,
                                                        delim_types_hash_join_k, 0, joinstate_k);

    vector<LogicalType> filter_in_types_k{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::BOOLEAN};
    vector<unique_ptr<Expression>> select_list_in_k;
    auto in_exp_k = make_uniq<BoundReferenceExpression>("IN (...)", LogicalType::BOOLEAN, 2);
    select_list_in_k.push_back(move(in_exp_k));
    unique_ptr<PhysicalFilter> filter_in_k = make_uniq<PhysicalFilter>(filter_in_types_k, move(select_list_in_k), 0);
    filter_in_k->children.push_back(move(join_hash_join_k));

    vector<JoinCondition> cond_keyword_k;
    JoinCondition join_condition_keyword_k;
    join_condition_keyword_k.left = make_uniq<BoundReferenceExpression>("keyword_rowid", LogicalType::BIGINT, 0);
    join_condition_keyword_k.right = make_uniq<BoundReferenceExpression>("movie_id_rowid", LogicalType::BIGINT, 3);
    join_condition_keyword_k.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_keyword_k = make_uniq<RAIInfo>();
    rai_info_keyword_k->rai = table_movie_keyword.GetStorage().info->rais[0].get();
    rai_info_keyword_k->rai_type = RAIType::SOURCE_EDGE;
    rai_info_keyword_k->forward = false;
    rai_info_keyword_k->vertex = &table_keyword;
    rai_info_keyword_k->vertex_id = table_index_keyword_k;
    rai_info_keyword_k->passing_tables[0] = table_index_keyword_k;
    rai_info_keyword_k->left_cardinalities[0] = table_keyword.GetStorage().info->cardinality;
    // rai_info_keyword_k->compact_list = &rai_info_keyword_k->rai->alist->compact__list;

    join_condition_keyword_k.rais.push_back(move(rai_info_keyword_k));
    cond_keyword_k.push_back(move(join_condition_keyword_k));

    LogicalComparisonJoin join_keyword_k_op(JoinType::INNER);
    vector<LogicalType> output_keyword_k_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::BOOLEAN,
                                               LogicalType::VARCHAR, LogicalType::VARCHAR, LogicalType::VARCHAR};
    join_keyword_k_op.types = output_keyword_k_types;
    vector<idx_t> right_projection_map_keyword_k{4, 5, 6};
    vector<idx_t> merge_project_map_keyword_k;
    vector<LogicalType> delim_types_keyword_k;
    auto join_keyword_k = make_uniq<PhysicalMergeSIPJoin>(join_keyword_k_op, move(filter_in_k), move(join_kind_type_kt), move(cond_keyword_k),
                                                     JoinType::INNER, left_projection_map,
                                                     right_projection_map_keyword_k,
                                                     merge_project_map_keyword_k,
                                                     delim_types_keyword_k, 0);


    vector<LogicalType> result_types{LogicalType::VARCHAR, LogicalType::VARCHAR, LogicalType::VARCHAR};
    vector<unique_ptr<Expression>> select_list;
    auto result_col0 = make_uniq<BoundReferenceExpression>("name", LogicalType::VARCHAR, 3);
    auto result_col1 = make_uniq<BoundReferenceExpression>("info", LogicalType::VARCHAR, 4);
    auto result_col2 = make_uniq<BoundReferenceExpression>("title", LogicalType::VARCHAR, 5);
    select_list.push_back(move(result_col0));
    select_list.push_back(move(result_col1));
    select_list.push_back(move(result_col2));
    auto projection = make_uniq<PhysicalProjection>(result_types, move(select_list), 0);
    projection->children.push_back(move(join_keyword_k));

    // aggregate
    string agg_name = "min";
    string agg_error = "";
    QueryErrorContext error_context(NULL, NULL);
    auto min_func = Catalog::GetEntry(context, CatalogType::SCALAR_FUNCTION_ENTRY, "", "",
                                      "min", OnEntryNotFound::RETURN_NULL, error_context);
    auto &min_func_set = min_func->Cast<AggregateFunctionCatalogEntry>();
    // bind the aggregate
    FunctionBinder function_binder(context);
    vector<LogicalType> types;
    types.push_back(LogicalType::VARCHAR);
    idx_t best_function_varchar = function_binder.BindFunction(agg_name, min_func_set.functions, types, agg_error);
    auto bound_function_min_varchar = min_func_set.functions.GetFunctionByOffset(best_function_varchar);
    // std::cout << best_function_varchar << " " << bound_function_min_varchar.return_type.ToString() << std::endl;

    auto first_children = make_uniq<BoundReferenceExpression>("name", LogicalType::VARCHAR, 0);
    vector<unique_ptr<Expression>> childrenlist1;
    childrenlist1.push_back(move(first_children));
    auto aggregate1 =
            function_binder.BindAggregateFunction(bound_function_min_varchar, std::move(childrenlist1), nullptr,
                                                  AggregateType::NON_DISTINCT);

    auto second_children = make_uniq<BoundReferenceExpression>("info", LogicalType::VARCHAR, 1);
    vector<unique_ptr<Expression>> childrenlist2;
    childrenlist2.push_back(move(second_children));
    auto aggregate2 =
            function_binder.BindAggregateFunction(bound_function_min_varchar, std::move(childrenlist2), nullptr,
                                                  AggregateType::NON_DISTINCT);

    auto third_children = make_uniq<BoundReferenceExpression>("title", LogicalType::VARCHAR, 2);
    vector<unique_ptr<Expression>> childrenlist3;
    childrenlist3.push_back(move(third_children));
    auto aggregate3 =
            function_binder.BindAggregateFunction(bound_function_min_varchar, std::move(childrenlist3), nullptr,
                                                  AggregateType::NON_DISTINCT);

    vector<unique_ptr<Expression>> aggregates;
    aggregates.push_back(move(aggregate1));
    aggregates.push_back(move(aggregate2));
    aggregates.push_back(move(aggregate3));


    vector<LogicalType> aggregate_types{LogicalType::VARCHAR, LogicalType::VARCHAR, LogicalType::VARCHAR};
    auto ungrouped_aggregate = make_uniq<PhysicalUngroupedAggregate>(aggregate_types, move(aggregates), 0);
    ungrouped_aggregate->children.push_back(move(projection));

    return ungrouped_aggregate;
}

unique_ptr<PhysicalOperator> ClientContext::GenerateJOB29aPlan(duckdb::ClientContext &context) {
    vector<idx_t> left_projection_map, right_projection_map;

    string table_vertex_info_type_it = "info_type";
    string table_vertex_title_t = "title";
    string table_vertex_company_name_cn = "company_name";
    string table_vertex_name_n = "name";
    string table_vertex_aka_name_an = "aka_name";
    string table_vertex_info_type_it3 = "info_type";
    string table_vertex_role_type_rt = "role_type";
    string table_vertex_char_name_chn = "char_name";
    string table_vertex_keyword_k = "keyword";
    string table_vertex_comp_cast_type_cct1 = "comp_cast_type";
    string table_vertex_comp_cast_type_cct2 = "comp_cast_type";
    string table_vertex_movie_info_ = "movie_info";
    string table_vertex_movie_companies_ = "movie_companies";
    string table_vertex_cast_info_ = "cast_info";
    string table_vertex_person_info_ = "person_info";
    string table_vertex_movie_keyword_ = "movie_keyword";
    string table_vertex_complete_cast = "complete_cast";

    idx_t table_index_info_type_it = 1;
    idx_t table_index_title_t = 2;
    idx_t table_index_company_name_cn = 3;
    idx_t table_index_name_n = 4;
    idx_t table_index_aka_name_an = 5;
    idx_t table_index_info_type_it3 = 6;
    idx_t table_index_role_type_rt = 7;
    idx_t table_index_char_name_chn = 8;
    idx_t table_index_keyword_k = 9;
    idx_t table_index_comp_cast_type_cct1 = 10;
    idx_t table_index_comp_cast_type_cct2 = 11;
    idx_t table_index_movie_info_ = 12;
    idx_t table_index_movie_companies_ = 13;
    idx_t table_index_cast_info_ = 18;
    idx_t table_index_person_info_ = 16;
    idx_t table_index_movie_keyword_ = 19;
    idx_t table_index_complete_cast = 20;

    auto table_or_view_info_type = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_info_type_it,
                                                     OnEntryNotFound::RETURN_NULL);
    auto &table_info_type = table_or_view_info_type->Cast<TableCatalogEntry>();
    auto table_or_view_title = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_title_t,
                                                 OnEntryNotFound::RETURN_NULL);
    auto &table_title = table_or_view_title->Cast<TableCatalogEntry>();
    auto table_or_view_company_name = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                        table_vertex_company_name_cn, OnEntryNotFound::RETURN_NULL);
    auto &table_company_name = table_or_view_company_name->Cast<TableCatalogEntry>();
    auto table_or_view_name = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_name_n,
                                                OnEntryNotFound::RETURN_NULL);
    auto &table_name = table_or_view_name->Cast<TableCatalogEntry>();
    auto table_or_view_aka_name = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_aka_name_an,
                                                    OnEntryNotFound::RETURN_NULL);
    auto &table_aka_name = table_or_view_aka_name->Cast<TableCatalogEntry>();
    auto table_or_view_role_type = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_role_type_rt,
                                                     OnEntryNotFound::RETURN_NULL);
    auto &table_role_type = table_or_view_role_type->Cast<TableCatalogEntry>();
    auto table_or_view_char_name = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                     table_vertex_char_name_chn, OnEntryNotFound::RETURN_NULL);
    auto &table_char_name = table_or_view_char_name->Cast<TableCatalogEntry>();
    auto table_or_view_keyword = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_keyword_k,
                                                   OnEntryNotFound::RETURN_NULL);
    auto &table_keyword = table_or_view_keyword->Cast<TableCatalogEntry>();
    auto table_or_view_comp_cast_type = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                          table_vertex_comp_cast_type_cct1,
                                                          OnEntryNotFound::RETURN_NULL);
    auto &table_comp_cast_type = table_or_view_comp_cast_type->Cast<TableCatalogEntry>();
    auto table_or_view_movie_info = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_movie_info_,
                                                      OnEntryNotFound::RETURN_NULL);
    auto &table_movie_info = table_or_view_movie_info->Cast<TableCatalogEntry>();
    auto table_or_view_movie_companies = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                           table_vertex_movie_companies_, OnEntryNotFound::RETURN_NULL);
    auto &table_movie_companies = table_or_view_movie_companies->Cast<TableCatalogEntry>();
    auto table_or_view_cast_info = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_cast_info_,
                                                     OnEntryNotFound::RETURN_NULL);
    auto &table_cast_info = table_or_view_cast_info->Cast<TableCatalogEntry>();
    auto table_or_view_person_info = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                       table_vertex_person_info_, OnEntryNotFound::RETURN_NULL);
    auto &table_person_info = table_or_view_person_info->Cast<TableCatalogEntry>();
    auto table_or_view_movie_keyword = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                         table_vertex_movie_keyword_, OnEntryNotFound::RETURN_NULL);
    auto &table_movie_keyword = table_or_view_movie_keyword->Cast<TableCatalogEntry>();
    auto table_or_view_complete_cast = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                         table_vertex_complete_cast, OnEntryNotFound::RETURN_NULL);
    auto &table_complete_cast = table_or_view_complete_cast->Cast<TableCatalogEntry>();


    vector<idx_t> comp_cast_type_cct2_ids{COLUMN_IDENTIFIER_ROW_ID, 1};
    vector<LogicalType> get_comp_cast_type_cct2_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_comp_cast_type_cct2 = "cct2";
    vector<LogicalType> table_types_comp_cast_type_cct2;
    vector<unique_ptr<Expression>> filter_comp_cast_type_cct2;
    unique_ptr<LogicalGet> get_op_comp_cast_type_cct2 = move(
            getLogicalGet(*this, table_comp_cast_type, alias_comp_cast_type_cct2, table_index_comp_cast_type_cct2,
                          table_types_comp_cast_type_cct2));
    unique_ptr<TableFilterSet> table_filters_comp_cast_type_cct2 = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_cct2 = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL, Value("complete+verified"));
    table_filters_comp_cast_type_cct2->filters[1] = move(constant_filter_cct2);
    unique_ptr<PhysicalTableScan> scan_comp_cast_type_cct2 = make_uniq<PhysicalTableScan>(get_comp_cast_type_cct2_types,
                                                                                          get_op_comp_cast_type_cct2->function,
                                                                                          get_op_comp_cast_type_cct2->table_index,
                                                                                          move(get_op_comp_cast_type_cct2->bind_data),
                                                                                          table_types_comp_cast_type_cct2,
                                                                                          comp_cast_type_cct2_ids,
                                                                                          move(filter_comp_cast_type_cct2),
                                                                                          vector<column_t>(),
                                                                                          get_op_comp_cast_type_cct2->names,
                                                                                          std::move(
                                                                                                  table_filters_comp_cast_type_cct2),
                                                                                          get_op_comp_cast_type_cct2->estimated_cardinality,
                                                                                          get_op_comp_cast_type_cct2->extra_info);

    vector<idx_t> complete_cast_ids{4, 5, 6};
    vector<LogicalType> get_complete_cast_types{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::BIGINT};
    string alias_complete_cast = "cc";
    vector<LogicalType> table_types_complete_cast;
    vector<unique_ptr<Expression>> filter_complete_cast;
    unique_ptr<LogicalGet> get_op_complete_cast = move(
            getLogicalGet(*this, table_complete_cast, alias_complete_cast, table_index_complete_cast,
                          table_types_complete_cast));
    unique_ptr<TableFilterSet> table_filters_complete_cast = NULL;
    unique_ptr<PhysicalTableScan> scan_complete_cast = make_uniq<PhysicalTableScan>(get_complete_cast_types,
                                                                                    get_op_complete_cast->function,
                                                                                    get_op_complete_cast->table_index,
                                                                                    move(get_op_complete_cast->bind_data),
                                                                                    table_types_complete_cast,
                                                                                    complete_cast_ids,
                                                                                    move(filter_complete_cast),
                                                                                    vector<column_t>(),
                                                                                    get_op_complete_cast->names,
                                                                                    std::move(
                                                                                            table_filters_complete_cast),
                                                                                    get_op_complete_cast->estimated_cardinality,
                                                                                    get_op_complete_cast->extra_info);


    vector<JoinCondition> cond_complete_cast_status_;
    JoinCondition join_condition_complete_cast_status_;
    join_condition_complete_cast_status_.left = make_uniq<BoundReferenceExpression>("status_id_rowid", LogicalType::BIGINT, 2);
    join_condition_complete_cast_status_.right = make_uniq<BoundReferenceExpression>("comp_cast_type_rowid", LogicalType::BIGINT, 0);
    join_condition_complete_cast_status_.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_complete_cast_status_ = make_uniq<RAIInfo>();
    rai_info_complete_cast_status_->rai = table_complete_cast.GetStorage().info->rais[1].get();
    rai_info_complete_cast_status_->rai_type = RAIType::EDGE_SOURCE;
    rai_info_complete_cast_status_->forward = true;
    rai_info_complete_cast_status_->vertex = &table_comp_cast_type;
    rai_info_complete_cast_status_->vertex_id = table_index_comp_cast_type_cct2;
    rai_info_complete_cast_status_->passing_tables[0] = table_index_complete_cast;
    rai_info_complete_cast_status_->left_cardinalities[0] = table_complete_cast.GetStorage().info->cardinality;
    rai_info_complete_cast_status_->compact_list = &rai_info_complete_cast_status_->rai->alist->compact_forward_list;

    join_condition_complete_cast_status_.rais.push_back(move(rai_info_complete_cast_status_));
    cond_complete_cast_status_.push_back(move(join_condition_complete_cast_status_));

    LogicalComparisonJoin join_complete_cast_status__op(JoinType::INNER);
    vector<LogicalType> output_complete_cast_status__types{LogicalType::BIGINT, LogicalType::BIGINT,
                                                           LogicalType::BIGINT, LogicalType::BIGINT};
    join_complete_cast_status__op.types = output_complete_cast_status__types;
    vector<idx_t> right_projection_map_complete_cast_status_{0};
    vector<idx_t> merge_project_map_complete_cast_status_;
    vector<LogicalType> delim_types_complete_cast_status_;
    auto join_complete_cast_status_ = make_uniq<PhysicalSIPJoin>(join_complete_cast_status__op, move(scan_complete_cast), move(scan_comp_cast_type_cct2),
                                                                      move(cond_complete_cast_status_), JoinType::INNER,
                                                                      left_projection_map,
                                                                      right_projection_map_complete_cast_status_,
                                                                      delim_types_complete_cast_status_, 0);


    vector<idx_t> comp_cast_type_cct1_ids{COLUMN_IDENTIFIER_ROW_ID, 1};
    vector<LogicalType> get_comp_cast_type_cct1_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_comp_cast_type_cct1 = "cct1";
    vector<LogicalType> table_types_comp_cast_type_cct1;
    vector<unique_ptr<Expression>> filter_comp_cast_type_cct1;
    unique_ptr<LogicalGet> get_op_comp_cast_type_cct1 = move(
            getLogicalGet(*this, table_comp_cast_type, alias_comp_cast_type_cct1, table_index_comp_cast_type_cct1,
                          table_types_comp_cast_type_cct1));
    unique_ptr<TableFilterSet> table_filters_comp_cast_type_cct1 = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_cct1 = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL, Value("cast"));
    table_filters_comp_cast_type_cct1->filters[1] = move(constant_filter_cct1);
    unique_ptr<PhysicalTableScan> scan_comp_cast_type_cct1 = make_uniq<PhysicalTableScan>(get_comp_cast_type_cct1_types,
                                                                                          get_op_comp_cast_type_cct1->function,
                                                                                          get_op_comp_cast_type_cct1->table_index,
                                                                                          move(get_op_comp_cast_type_cct1->bind_data),
                                                                                          table_types_comp_cast_type_cct1,
                                                                                          comp_cast_type_cct1_ids,
                                                                                          move(filter_comp_cast_type_cct1),
                                                                                          vector<column_t>(),
                                                                                          get_op_comp_cast_type_cct1->names,
                                                                                          std::move(
                                                                                                  table_filters_comp_cast_type_cct1),
                                                                                          get_op_comp_cast_type_cct1->estimated_cardinality,
                                                                                          get_op_comp_cast_type_cct1->extra_info);


    vector<JoinCondition> cond_comp_cast_type_cct1;
    JoinCondition join_condition_comp_cast_type_cct1;
    join_condition_comp_cast_type_cct1.left = make_uniq<BoundReferenceExpression>("comp_cast_type_rowid", LogicalType::BIGINT, 0);
    join_condition_comp_cast_type_cct1.right = make_uniq<BoundReferenceExpression>("subject_id_rowid", LogicalType::BIGINT, 0);
    join_condition_comp_cast_type_cct1.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_comp_cast_type_cct1 = make_uniq<RAIInfo>();
    rai_info_comp_cast_type_cct1->rai = table_complete_cast.GetStorage().info->rais[0].get();
    rai_info_comp_cast_type_cct1->rai_type = RAIType::SOURCE_EDGE;
    rai_info_comp_cast_type_cct1->forward = false;
    rai_info_comp_cast_type_cct1->vertex = &table_comp_cast_type;
    rai_info_comp_cast_type_cct1->vertex_id = table_index_comp_cast_type_cct1;
    rai_info_comp_cast_type_cct1->passing_tables[0] = table_index_comp_cast_type_cct1;
    rai_info_comp_cast_type_cct1->left_cardinalities[0] = table_comp_cast_type.GetStorage().info->cardinality;
    // rai_info_comp_cast_type_cct1->compact_list = &rai_info_comp_cast_type_cct1->rai->alist->compact__list;

    join_condition_comp_cast_type_cct1.rais.push_back(move(rai_info_comp_cast_type_cct1));
    cond_comp_cast_type_cct1.push_back(move(join_condition_comp_cast_type_cct1));

    LogicalComparisonJoin join_comp_cast_type_cct1_op(JoinType::INNER);
    vector<LogicalType> output_comp_cast_type_cct1_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::BIGINT};
    join_comp_cast_type_cct1_op.types = output_comp_cast_type_cct1_types;
    vector<idx_t> right_projection_map_comp_cast_type_cct1{1};
    vector<idx_t> merge_project_map_comp_cast_type_cct1;
    vector<LogicalType> delim_types_comp_cast_type_cct1;
    auto join_comp_cast_type_cct1 = make_uniq<PhysicalSIPJoin>(join_comp_cast_type_cct1_op, move(scan_comp_cast_type_cct1), move(join_complete_cast_status_),
                                                               move(cond_comp_cast_type_cct1), JoinType::INNER,
                                                               left_projection_map,
                                                               right_projection_map_comp_cast_type_cct1,
                                                               delim_types_comp_cast_type_cct1, 0);


    vector<idx_t> title_t_ids{COLUMN_IDENTIFIER_ROW_ID, 1, 4};
    vector<LogicalType> get_title_t_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::BIGINT};
    string alias_title_t = "t";
    vector<LogicalType> table_types_title_t;
    vector<unique_ptr<Expression>> filter_title_t;
    unique_ptr<LogicalGet> get_op_title_t = move(
            getLogicalGet(*this, table_title, alias_title_t, table_index_title_t, table_types_title_t));
    unique_ptr<TableFilterSet> table_filters_title_t = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_t_title = duckdb::make_uniq<ConstantFilter>(
            ExpressionType::COMPARE_EQUAL, Value("Shrek 2"));
    table_filters_title_t->filters[1] = move(constant_filter_t_title);
    unique_ptr<ConjunctionAndFilter> constant_filter_t_year = duckdb::make_uniq<ConjunctionAndFilter>();
    unique_ptr<ConstantFilter> constant_filter_t_start = duckdb::make_uniq<ConstantFilter>(
            ExpressionType::COMPARE_GREATERTHANOREQUALTO, Value::BIGINT(2000));
    unique_ptr<ConstantFilter> constant_filter_t_end = duckdb::make_uniq<ConstantFilter>(
            ExpressionType::COMPARE_LESSTHANOREQUALTO, Value::BIGINT(2010));
    constant_filter_t_year->child_filters.push_back(move(constant_filter_t_start));
    constant_filter_t_year->child_filters.push_back(move(constant_filter_t_end));
    table_filters_title_t->filters[2] = move(constant_filter_t_year);
    unique_ptr<PhysicalTableScan> scan_title_t = make_uniq<PhysicalTableScan>(get_title_t_types,
                                                                              get_op_title_t->function,
                                                                              get_op_title_t->table_index,
                                                                              move(get_op_title_t->bind_data),
                                                                              table_types_title_t, title_t_ids,
                                                                              move(filter_title_t), vector<column_t>(),
                                                                              get_op_title_t->names,
                                                                              std::move(table_filters_title_t),
                                                                              get_op_title_t->estimated_cardinality,
                                                                              get_op_title_t->extra_info);


    vector<JoinCondition> cond_title_t;
    JoinCondition join_condition_title_t;
    join_condition_title_t.left = make_uniq<BoundReferenceExpression>("title_rowid", LogicalType::BIGINT, 0);
    join_condition_title_t.right = make_uniq<BoundReferenceExpression>("movie_id_rowid", LogicalType::BIGINT, 2);
    join_condition_title_t.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_title_t = make_uniq<RAIInfo>();
    rai_info_title_t->rai = table_complete_cast.GetStorage().info->rais[0].get();
    rai_info_title_t->rai_type = RAIType::TARGET_EDGE;
    rai_info_title_t->forward = true;
    rai_info_title_t->vertex = &table_title;
    rai_info_title_t->vertex_id = table_index_title_t;
    rai_info_title_t->passing_tables[0] = table_index_title_t;
    rai_info_title_t->left_cardinalities[0] = table_title.GetStorage().info->cardinality;
    // rai_info_title_t->compact_list = &rai_info_title_t->rai->alist->compact__list;

    join_condition_title_t.rais.push_back(move(rai_info_title_t));
    cond_title_t.push_back(move(join_condition_title_t));

    LogicalComparisonJoin join_title_t_op(JoinType::INNER);
    vector<LogicalType> output_title_t_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::BIGINT,
                                             LogicalType::BIGINT};
    join_title_t_op.types = output_title_t_types;
    vector<idx_t> right_projection_map_title_t{0};
    vector<idx_t> merge_project_map_title_t;
    vector<LogicalType> delim_types_title_t;
    auto join_title_t = make_uniq<PhysicalSIPJoin>(join_title_t_op, move(scan_title_t), move(join_comp_cast_type_cct1), move(cond_title_t), JoinType::INNER,
                                                   left_projection_map, right_projection_map_title_t,
                                                   delim_types_title_t, 0);

    vector<idx_t> cast_info_ids{4, 7, 8, 9, 10};
    vector<LogicalType> get_cast_info_types{LogicalType::VARCHAR, LogicalType::BIGINT, LogicalType::BIGINT,
                                            LogicalType::BIGINT, LogicalType::BIGINT};
    string alias_cast_info = "ci";
    vector<LogicalType> table_types_cast_info;
    vector<unique_ptr<Expression>> filter_cast_info;
    unique_ptr<LogicalGet> get_op_cast_info = move(
            getLogicalGet(*this, table_cast_info, alias_cast_info, table_index_cast_info_, table_types_cast_info));
    unique_ptr<TableFilterSet> table_filters_cast_info = NULL;
    unique_ptr<PhysicalTableScan> scan_cast_info = make_uniq<PhysicalTableScan>(get_cast_info_types,
                                                                                get_op_cast_info->function,
                                                                                get_op_cast_info->table_index,
                                                                                move(get_op_cast_info->bind_data),
                                                                                table_types_cast_info, cast_info_ids,
                                                                                move(filter_cast_info),
                                                                                vector<column_t>(),
                                                                                get_op_cast_info->names,
                                                                                std::move(table_filters_cast_info),
                                                                                get_op_cast_info->estimated_cardinality,
                                                                                get_op_cast_info->extra_info);

    auto &allocator = Allocator::Get(context);
    vector<LogicalType> join_in_types{LogicalType::VARCHAR};
    auto collection =
            make_uniq<ColumnDataCollection>(context, join_in_types, ColumnDataAllocatorType::IN_MEMORY_ALLOCATOR);

    vector<LogicalType> chunk_in_types{LogicalType::VARCHAR};
    DataChunk chunk;
    chunk.SetCardinality(3);
    chunk.Initialize(allocator, chunk_in_types);
    chunk.SetValue(0, 0, Value("(voice)"));
    chunk.SetValue(0, 1, Value("(voice) (uncredited)"));
    chunk.SetValue(0, 2, Value("(voice: English version)"));
    collection->Append(chunk);

    // create a chunk scan to output the result
    vector<LogicalType> ouput_in_types{LogicalType::VARCHAR};
    auto chunk_scan = make_uniq<PhysicalColumnDataScan>(ouput_in_types, PhysicalOperatorType::COLUMN_DATA_SCAN,
                                                        3, std::move(collection));

    vector<JoinCondition> cond_hash_join_;
    JoinCondition join_condition_hash_join_;
    join_condition_hash_join_.left = make_uniq<BoundReferenceExpression>("note", LogicalType::VARCHAR, 0);
    join_condition_hash_join_.right = make_uniq<BoundReferenceExpression>("", LogicalType::VARCHAR, 0);
    join_condition_hash_join_.comparison = ExpressionType::COMPARE_EQUAL;
    cond_hash_join_.push_back(move(join_condition_hash_join_));

    LogicalComparisonJoin join_hash_join_op(JoinType::MARK);
    vector<LogicalType> output_hash_join_types{LogicalType::VARCHAR, LogicalType::BIGINT, LogicalType::BIGINT,
                                               LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::BOOLEAN};
    join_hash_join_op.types = output_hash_join_types;
    vector<idx_t> right_projection_map_hash_join_;
    vector<LogicalType> delim_types_hash_join_;
    PerfectHashJoinStats joinstate;
    auto join_hash_join_ = make_uniq<PhysicalHashJoin>(join_hash_join_op, move(scan_cast_info), move(chunk_scan),
                                                       move(cond_hash_join_),
                                                       JoinType::MARK, left_projection_map,
                                                       right_projection_map_hash_join_,
                                                       delim_types_hash_join_, 0, joinstate);


    vector<LogicalType> filter_in_types{LogicalType::VARCHAR, LogicalType::BIGINT, LogicalType::BIGINT,
                                        LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::BOOLEAN};
    vector<unique_ptr<Expression>> select_list_in;
    auto in_exp = make_uniq<BoundReferenceExpression>("IN (...)", LogicalType::BOOLEAN, 5);
    select_list_in.push_back(move(in_exp));
    unique_ptr<PhysicalFilter> filter_in = make_uniq<PhysicalFilter>(filter_in_types, move(select_list_in), 0);
    filter_in->children.push_back(move(join_hash_join_));


    vector<JoinCondition> cond_cast_info_;
    JoinCondition join_condition_cast_info_;
    join_condition_cast_info_.left = make_uniq<BoundReferenceExpression>("movie_id_rowid", LogicalType::BIGINT, 1);
    join_condition_cast_info_.right = make_uniq<BoundReferenceExpression>("title_rowid", LogicalType::BIGINT, 0);
    join_condition_cast_info_.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_cast_info_ = make_uniq<RAIInfo>();
    rai_info_cast_info_->rai = table_cast_info.GetStorage().info->rais[0].get();
    rai_info_cast_info_->rai_type = RAIType::EDGE_SOURCE;
    rai_info_cast_info_->forward = true;
    rai_info_cast_info_->vertex = &table_title;
    rai_info_cast_info_->vertex_id = table_index_title_t;
    rai_info_cast_info_->passing_tables[0] = table_index_cast_info_;
    rai_info_cast_info_->left_cardinalities[0] = table_cast_info.GetStorage().info->cardinality;
    rai_info_cast_info_->compact_list = &rai_info_cast_info_->rai->alist->compact_forward_list;

    join_condition_cast_info_.rais.push_back(move(rai_info_cast_info_));
    cond_cast_info_.push_back(move(join_condition_cast_info_));

    LogicalComparisonJoin join_cast_info__op(JoinType::INNER);
    vector<LogicalType> output_cast_info__types{LogicalType::VARCHAR, LogicalType::BIGINT, LogicalType::BIGINT,
                                                LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::BOOLEAN,
                                                LogicalType::VARCHAR};
    join_cast_info__op.types = output_cast_info__types;
    vector<idx_t> right_projection_map_cast_info_{1};
    vector<idx_t> merge_project_map_cast_info_;
    vector<LogicalType> delim_types_cast_info_;
    auto join_cast_info_ = make_uniq<PhysicalSIPJoin>(join_cast_info__op, move(filter_in), move(join_title_t), move(cond_cast_info_),
                                                           JoinType::INNER, left_projection_map,
                                                           right_projection_map_cast_info_,
                                                           delim_types_cast_info_, 0);


    vector<idx_t> role_type_rt_ids{COLUMN_IDENTIFIER_ROW_ID, 1};
    vector<LogicalType> get_role_type_rt_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_role_type_rt = "rt";
    vector<LogicalType> table_types_role_type_rt;
    vector<unique_ptr<Expression>> filter_role_type_rt;
    unique_ptr<LogicalGet> get_op_role_type_rt = move(
            getLogicalGet(*this, table_role_type, alias_role_type_rt, table_index_role_type_rt,
                          table_types_role_type_rt));
    unique_ptr<TableFilterSet> table_filters_role_type_rt = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_rt = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL, Value("actress"));
    table_filters_role_type_rt->filters[1] = move(constant_filter_rt);
    unique_ptr<PhysicalTableScan> scan_role_type_rt = make_uniq<PhysicalTableScan>(get_role_type_rt_types,
                                                                                   get_op_role_type_rt->function,
                                                                                   get_op_role_type_rt->table_index,
                                                                                   move(get_op_role_type_rt->bind_data),
                                                                                   table_types_role_type_rt,
                                                                                   role_type_rt_ids,
                                                                                   move(filter_role_type_rt),
                                                                                   vector<column_t>(),
                                                                                   get_op_role_type_rt->names,
                                                                                   std::move(
                                                                                           table_filters_role_type_rt),
                                                                                   get_op_role_type_rt->estimated_cardinality,
                                                                                   get_op_role_type_rt->extra_info);


    vector<JoinCondition> cond_role_type_rt;
    JoinCondition join_condition_role_type_rt;
    join_condition_role_type_rt.left = make_uniq<BoundReferenceExpression>("role_type_rowid", LogicalType::BIGINT, 0);
    join_condition_role_type_rt.right = make_uniq<BoundReferenceExpression>("role_id_rowid", LogicalType::BIGINT, 3);
    join_condition_role_type_rt.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_role_type_rt = make_uniq<RAIInfo>();
    rai_info_role_type_rt->rai = table_cast_info.GetStorage().info->rais[2].get();
    rai_info_role_type_rt->rai_type = RAIType::SOURCE_EDGE;
    rai_info_role_type_rt->forward = false;
    rai_info_role_type_rt->vertex = &table_role_type;
    rai_info_role_type_rt->vertex_id = table_index_role_type_rt;
    rai_info_role_type_rt->passing_tables[0] = table_index_role_type_rt;
    rai_info_role_type_rt->left_cardinalities[0] = table_role_type.GetStorage().info->cardinality;
    // rai_info_role_type_rt->compact_list = &rai_info_role_type_rt->rai->alist->compact__list;

    join_condition_role_type_rt.rais.push_back(move(rai_info_role_type_rt));
    cond_role_type_rt.push_back(move(join_condition_role_type_rt));

    LogicalComparisonJoin join_role_type_rt_op(JoinType::INNER);
    vector<LogicalType> output_role_type_rt_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::BIGINT,
                                                  LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::VARCHAR};
    join_role_type_rt_op.types = output_role_type_rt_types;
    vector<idx_t> right_projection_map_role_type_rt{1, 2, 4, 6};
    vector<idx_t> merge_project_map_role_type_rt;
    vector<LogicalType> delim_types_role_type_rt;
    auto join_role_type_rt = make_uniq<PhysicalSIPJoin>(join_role_type_rt_op, move(scan_role_type_rt), move(join_cast_info_), move(cond_role_type_rt),
                                                        JoinType::INNER, left_projection_map,
                                                        right_projection_map_role_type_rt, delim_types_role_type_rt, 0);


    vector<idx_t> movie_info_ids{6, 5, 3};
    vector<LogicalType> get_movie_info_types{LogicalType::BIGINT, LogicalType::BIGINT,
                                             LogicalType::VARCHAR};
    string alias_movie_info = "i";
    vector<LogicalType> table_types_movie_info;
    vector<unique_ptr<Expression>> filter_movie_info;
    unique_ptr<LogicalGet> get_op_movie_info = move(
            getLogicalGet(*this, table_movie_info, alias_movie_info, table_index_movie_info_, table_types_movie_info));
    unique_ptr<TableFilterSet> table_filters_movie_info = NULL;
    unique_ptr<PhysicalTableScan> scan_movie_info = make_uniq<PhysicalTableScan>(get_movie_info_types,
                                                                                 get_op_movie_info->function,
                                                                                 get_op_movie_info->table_index,
                                                                                 move(get_op_movie_info->bind_data),
                                                                                 table_types_movie_info,
                                                                                 movie_info_ids,
                                                                                 move(filter_movie_info),
                                                                                 vector<column_t>(),
                                                                                 get_op_movie_info->names,
                                                                                 std::move(table_filters_movie_info),
                                                                                 get_op_movie_info->estimated_cardinality,
                                                                                 get_op_movie_info->extra_info);

    string p_movie_info_info1 = "Japan:%200%";
    string p_movie_info_info2 = "USA:%200%";
    Value p_info_info1 = Value(p_movie_info_info1);
    Value p_info_info2 = Value(p_movie_info_info2);
    vector<LogicalType> filter_mi_types{LogicalType::BIGINT, LogicalType::BIGINT,
                                        LogicalType::VARCHAR};
    vector<unique_ptr<Expression>> select_list_movie_info;
    auto like_expression_left_mi = make_uniq<BoundReferenceExpression>("info", LogicalType::VARCHAR, 2);
    auto like_expression_value_mi = make_uniq<BoundConstantExpression>(p_info_info1);
    vector<unique_ptr<Expression>> like_arguments1_mi, like_arguments2_mi;
    like_arguments1_mi.push_back(move(like_expression_left_mi));
    like_arguments1_mi.push_back(move(like_expression_value_mi));

    auto like_expression_left2_mi = make_uniq<BoundReferenceExpression>("info", LogicalType::VARCHAR, 2);
    auto like_expression_value2_mi = make_uniq<BoundConstantExpression>(p_info_info2);
    like_arguments2_mi.push_back(move(like_expression_left2_mi));
    like_arguments2_mi.push_back(move(like_expression_value2_mi));

    ScalarFunction bound_function_like = LikeFun::GetLikeFunction();
    unique_ptr<FunctionData> bind_data_contains_mi = NULL;
    auto like_bound_function_mi = make_uniq<BoundFunctionExpression>(LogicalType::BOOLEAN,
                                                                     bound_function_like,
                                                                     move(like_arguments1_mi),
                                                                     move(bind_data_contains_mi), false);

    unique_ptr<FunctionData> bind_data_like_mi = NULL;
    auto like_bound_function2_mi = make_uniq<BoundFunctionExpression>(LogicalType::BOOLEAN,
                                                                      bound_function_like,
                                                                      move(like_arguments2_mi),
                                                                      move(bind_data_like_mi), false);

    auto or_conjunction = make_uniq<BoundConjunctionExpression>(ExpressionType::CONJUNCTION_OR);
    or_conjunction->children.push_back(move(like_bound_function_mi));
    or_conjunction->children.push_back(move(like_bound_function2_mi));

    auto mi_not_null_bound_function = make_uniq<BoundOperatorExpression>(ExpressionType::OPERATOR_IS_NOT_NULL, LogicalType::BOOLEAN);
    auto mi_not_null = make_uniq<BoundReferenceExpression>("info", LogicalType::VARCHAR, 2);
    mi_not_null_bound_function->children.push_back(move(mi_not_null));

    select_list_movie_info.push_back(move(or_conjunction));
    select_list_movie_info.push_back(move(mi_not_null_bound_function));
    unique_ptr<PhysicalFilter> filter_mi_contains = make_uniq<PhysicalFilter>(filter_mi_types, move(select_list_movie_info), 0);
    filter_mi_contains->children.push_back(move(scan_movie_info));


    vector<JoinCondition> cond_movie_info_;
    JoinCondition join_condition_movie_info_;
    join_condition_movie_info_.left = make_uniq<BoundReferenceExpression>("movie_id_rowid", LogicalType::BIGINT, 0);
    join_condition_movie_info_.right = make_uniq<BoundReferenceExpression>("movie_id_rowid", LogicalType::BIGINT, 2);
    join_condition_movie_info_.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_movie_info_ = make_uniq<RAIInfo>();
    rai_info_movie_info_->rai = table_movie_info.GetStorage().info->rais[0].get();
    rai_info_movie_info_->rai_type = RAIType::EDGE_TARGET;
    rai_info_movie_info_->forward = false;
    rai_info_movie_info_->vertex = &table_title;
    rai_info_movie_info_->vertex_id = table_index_title_t;
    rai_info_movie_info_->passing_tables[0] = table_index_movie_info_;
    rai_info_movie_info_->left_cardinalities[0] = table_movie_info.GetStorage().info->cardinality;
    rai_info_movie_info_->compact_list = &rai_info_movie_info_->rai->alist->compact_backward_list;

    join_condition_movie_info_.rais.push_back(move(rai_info_movie_info_));
    cond_movie_info_.push_back(move(join_condition_movie_info_));

    LogicalComparisonJoin join_movie_info__op(JoinType::INNER);
    vector<LogicalType> output_movie_info__types{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::VARCHAR,
                                                 LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::VARCHAR};
    join_movie_info__op.types = output_movie_info__types;
    vector<idx_t> right_projection_map_movie_info_{3, 4, 5};
    vector<idx_t> merge_project_map_movie_info_;
    vector<LogicalType> delim_types_movie_info_;
    auto join_movie_info_ = make_uniq<PhysicalSIPJoin>(join_movie_info__op, move(filter_mi_contains), move(join_role_type_rt), move(cond_movie_info_),
                                                            JoinType::INNER, left_projection_map,
                                                            right_projection_map_movie_info_,
                                                            delim_types_movie_info_, 0);


    vector<idx_t> info_type_it_ids{COLUMN_IDENTIFIER_ROW_ID, 1};
    vector<LogicalType> get_info_type_it_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_info_type_it = "it";
    vector<LogicalType> table_types_info_type_it;
    vector<unique_ptr<Expression>> filter_info_type_it;
    unique_ptr<LogicalGet> get_op_info_type_it = move(
            getLogicalGet(*this, table_info_type, alias_info_type_it, table_index_info_type_it,
                          table_types_info_type_it));
    unique_ptr<TableFilterSet> table_filters_info_type_it = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_it = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL, Value("release dates"));
    table_filters_info_type_it->filters[1] = move(constant_filter_it);
    unique_ptr<PhysicalTableScan> scan_info_type_it = make_uniq<PhysicalTableScan>(get_info_type_it_types,
                                                                                   get_op_info_type_it->function,
                                                                                   get_op_info_type_it->table_index,
                                                                                   move(get_op_info_type_it->bind_data),
                                                                                   table_types_info_type_it,
                                                                                   info_type_it_ids,
                                                                                   move(filter_info_type_it),
                                                                                   vector<column_t>(),
                                                                                   get_op_info_type_it->names,
                                                                                   std::move(
                                                                                           table_filters_info_type_it),
                                                                                   get_op_info_type_it->estimated_cardinality,
                                                                                   get_op_info_type_it->extra_info);


    vector<JoinCondition> cond_info_type_it;
    JoinCondition join_condition_info_type_it;
    join_condition_info_type_it.left = make_uniq<BoundReferenceExpression>("info_type_rowid", LogicalType::BIGINT, 0);
    join_condition_info_type_it.right = make_uniq<BoundReferenceExpression>("info_type_id_rowid", LogicalType::BIGINT, 1);
    join_condition_info_type_it.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_info_type_it = make_uniq<RAIInfo>();
    rai_info_info_type_it->rai = table_movie_info.GetStorage().info->rais[0].get();
    rai_info_info_type_it->rai_type = RAIType::SOURCE_EDGE;
    rai_info_info_type_it->forward = false;
    rai_info_info_type_it->vertex = &table_info_type;
    rai_info_info_type_it->vertex_id = table_index_info_type_it;
    rai_info_info_type_it->passing_tables[0] = table_index_info_type_it;
    rai_info_info_type_it->left_cardinalities[0] = table_info_type.GetStorage().info->cardinality;
    // rai_info_info_type_it->compact_list = &rai_info_info_type_it->rai->alist->compact__list;

    join_condition_info_type_it.rais.push_back(move(rai_info_info_type_it));
    cond_info_type_it.push_back(move(join_condition_info_type_it));

    LogicalComparisonJoin join_info_type_it_op(JoinType::INNER);
    vector<LogicalType> output_info_type_it_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::BIGINT,
                                                  LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::VARCHAR};
    join_info_type_it_op.types = output_info_type_it_types;
    vector<idx_t> right_projection_map_info_type_it{0, 3, 4, 5};
    vector<idx_t> merge_project_map_info_type_it;
    vector<LogicalType> delim_types_info_type_it;
    auto join_info_type_it = make_uniq<PhysicalSIPJoin>(join_info_type_it_op, move(scan_info_type_it), move(join_movie_info_), move(cond_info_type_it),
                                                        JoinType::INNER, left_projection_map,
                                                        right_projection_map_info_type_it, delim_types_info_type_it, 0);

    vector<idx_t> name_n_ids{COLUMN_IDENTIFIER_ROW_ID, 1, 4};
    vector<LogicalType> get_name_n_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::VARCHAR};
    string alias_name_n = "n";
    vector<LogicalType> table_types_name_n;
    vector<unique_ptr<Expression>> filter_name_n;
    unique_ptr<LogicalGet> get_op_name_n = move(
            getLogicalGet(*this, table_name, alias_name_n, table_index_name_n, table_types_name_n));
    unique_ptr<TableFilterSet> table_filters_name_n = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_n = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL, Value("f"));
    table_filters_name_n->filters[2] = move(constant_filter_n);
    unique_ptr<PhysicalTableScan> scan_name_n = make_uniq<PhysicalTableScan>(get_name_n_types, get_op_name_n->function,
                                                                             get_op_name_n->table_index,
                                                                             move(get_op_name_n->bind_data),
                                                                             table_types_name_n, name_n_ids,
                                                                             move(filter_name_n), vector<column_t>(),
                                                                             get_op_name_n->names,
                                                                             std::move(table_filters_name_n),
                                                                             get_op_name_n->estimated_cardinality,
                                                                             get_op_name_n->extra_info);

    vector<LogicalType> filter_name_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::VARCHAR};
    vector<unique_ptr<Expression>> select_list_name;
    auto like_expression_left_name = make_uniq<BoundReferenceExpression>("name", LogicalType::VARCHAR, 1);
    auto like_expression_value_name = make_uniq<BoundConstantExpression>(Value("An"));
    vector<unique_ptr<Expression>> like_arguments_name;
    like_arguments_name.push_back(move(like_expression_left_name));
    like_arguments_name.push_back(move(like_expression_value_name));

    unique_ptr<FunctionData> bind_data_contains = NULL;
    ScalarFunction bound_function_contains = ContainsFun::GetFunction();
    auto like_bound_function_name = make_uniq<BoundFunctionExpression>(LogicalType::BOOLEAN,
                                                                       bound_function_contains,
                                                                       move(like_arguments_name),
                                                                       move(bind_data_contains), false);

    select_list_name.push_back(move(like_bound_function_name));
    unique_ptr<PhysicalFilter> filter_name_contains = make_uniq<PhysicalFilter>(filter_name_types, move(select_list_name), 0);
    filter_name_contains->children.push_back(move(scan_name_n));


    vector<JoinCondition> cond_name_n;
    JoinCondition join_condition_name_n;
    join_condition_name_n.left = make_uniq<BoundReferenceExpression>("name_rowid", LogicalType::BIGINT, 0);
    join_condition_name_n.right = make_uniq<BoundReferenceExpression>("person_id_rowid", LogicalType::BIGINT, 3);
    join_condition_name_n.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_name_n = make_uniq<RAIInfo>();
    rai_info_name_n->rai = table_cast_info.GetStorage().info->rais[0].get();
    rai_info_name_n->rai_type = RAIType::TARGET_EDGE;
    rai_info_name_n->forward = true;
    rai_info_name_n->vertex = &table_name;
    rai_info_name_n->vertex_id = table_index_name_n;
    rai_info_name_n->passing_tables[0] = table_index_name_n;
    rai_info_name_n->left_cardinalities[0] = table_name.GetStorage().info->cardinality;
    // rai_info_name_n->compact_list = &rai_info_name_n->rai->alist->compact__list;

    join_condition_name_n.rais.push_back(move(rai_info_name_n));
    cond_name_n.push_back(move(join_condition_name_n));

    LogicalComparisonJoin join_name_n_op(JoinType::INNER);
    vector<LogicalType> output_name_n_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::VARCHAR,
                                            LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::VARCHAR};
    join_name_n_op.types = output_name_n_types;
    vector<idx_t> right_projection_map_name_n{2, 4, 5};
    vector<idx_t> merge_project_map_name_n;
    vector<LogicalType> delim_types_name_n;
    auto join_name_n = make_uniq<PhysicalSIPJoin>(join_name_n_op, move(filter_name_contains), move(join_info_type_it), move(cond_name_n), JoinType::INNER,
                                                  left_projection_map, right_projection_map_name_n, delim_types_name_n,
                                                  0);


    vector<idx_t> info_type_it3_ids{COLUMN_IDENTIFIER_ROW_ID, 1};
    vector<LogicalType> get_info_type_it3_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_info_type_it3 = "it3";
    vector<LogicalType> table_types_info_type_it3;
    vector<unique_ptr<Expression>> filter_info_type_it3;
    unique_ptr<LogicalGet> get_op_info_type_it3 = move(
            getLogicalGet(*this, table_info_type, alias_info_type_it3, table_index_info_type_it3,
                          table_types_info_type_it3));
    unique_ptr<TableFilterSet> table_filters_info_type_it3 = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_it3 = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL, Value("trivia"));
    table_filters_info_type_it3->filters[1] = move(constant_filter_it3);
    unique_ptr<PhysicalTableScan> scan_info_type_it3 = make_uniq<PhysicalTableScan>(get_info_type_it3_types,
                                                                                    get_op_info_type_it3->function,
                                                                                    get_op_info_type_it3->table_index,
                                                                                    move(get_op_info_type_it3->bind_data),
                                                                                    table_types_info_type_it3,
                                                                                    info_type_it3_ids,
                                                                                    move(filter_info_type_it3),
                                                                                    vector<column_t>(),
                                                                                    get_op_info_type_it3->names,
                                                                                    std::move(
                                                                                            table_filters_info_type_it3),
                                                                                    get_op_info_type_it3->estimated_cardinality,
                                                                                    get_op_info_type_it3->extra_info);


    vector<JoinCondition> cond_info_type_it3;
    JoinCondition join_condition_info_type_it3;
    join_condition_info_type_it3.left = make_uniq<BoundReferenceExpression>("info_type_rowid", LogicalType::BIGINT, 0);
    join_condition_info_type_it3.right = make_uniq<BoundReferenceExpression>("name_rowid", LogicalType::BIGINT, 0);
    join_condition_info_type_it3.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_info_type_it3 = make_uniq<RAIInfo>();
    rai_info_info_type_it3->rai = table_person_info.GetStorage().info->rais[0].get();
    rai_info_info_type_it3->rai_type = RAIType::SOURCE_EDGE;
    rai_info_info_type_it3->forward = false;
    rai_info_info_type_it3->vertex = &table_info_type;
    rai_info_info_type_it3->vertex_id = table_index_info_type_it3;
    rai_info_info_type_it3->passing_tables[0] = table_index_info_type_it3;
    rai_info_info_type_it3->left_cardinalities[0] = table_info_type.GetStorage().info->cardinality;
    // rai_info_info_type_it3->compact_list = &rai_info_info_type_it3->rai->alist->compact__list;

    join_condition_info_type_it3.rais.push_back(move(rai_info_info_type_it3));
    cond_info_type_it3.push_back(move(join_condition_info_type_it3));

    LogicalComparisonJoin join_info_type_it3_op(JoinType::INNER);
    vector<LogicalType> output_info_type_it3_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::BIGINT,
                                                   LogicalType::VARCHAR, LogicalType::BIGINT, LogicalType::BIGINT,
                                                   LogicalType::VARCHAR};
    join_info_type_it3_op.types = output_info_type_it3_types;
    vector<idx_t> right_projection_map_info_type_it3{0, 1, 3, 4, 5};
    vector<idx_t> merge_project_map_info_type_it3;
    vector<LogicalType> delim_types_info_type_it3;
    auto join_info_type_it3 = make_uniq<PhysicalMergeSIPJoin>(join_info_type_it3_op, move(scan_info_type_it3), move(join_name_n),
                                                         move(cond_info_type_it3), JoinType::INNER, left_projection_map,
                                                         right_projection_map_info_type_it3,
                                                         merge_project_map_info_type_it3,
                                                         delim_types_info_type_it3,
                                                         0);


    vector<idx_t> company_name_cn_ids{COLUMN_IDENTIFIER_ROW_ID, 2};
    vector<LogicalType> get_company_name_cn_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_company_name_cn = "cn";
    vector<LogicalType> table_types_company_name_cn;
    vector<unique_ptr<Expression>> filter_company_name_cn;
    unique_ptr<LogicalGet> get_op_company_name_cn = move(
            getLogicalGet(*this, table_company_name, alias_company_name_cn, table_index_company_name_cn,
                          table_types_company_name_cn));
    unique_ptr<TableFilterSet> table_filters_company_name_cn = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_cn = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL, Value("[us]"));
    table_filters_company_name_cn->filters[1] = move(constant_filter_cn);
    unique_ptr<PhysicalTableScan> scan_company_name_cn = make_uniq<PhysicalTableScan>(get_company_name_cn_types,
                                                                                      get_op_company_name_cn->function,
                                                                                      get_op_company_name_cn->table_index,
                                                                                      move(get_op_company_name_cn->bind_data),
                                                                                      table_types_company_name_cn,
                                                                                      company_name_cn_ids,
                                                                                      move(filter_company_name_cn),
                                                                                      vector<column_t>(),
                                                                                      get_op_company_name_cn->names,
                                                                                      std::move(
                                                                                              table_filters_company_name_cn),
                                                                                      get_op_company_name_cn->estimated_cardinality,
                                                                                      get_op_company_name_cn->extra_info);


    vector<JoinCondition> cond_company_name_cn;
    JoinCondition join_condition_company_name_cn;
    join_condition_company_name_cn.left = make_uniq<BoundReferenceExpression>("company_name_rowid", LogicalType::BIGINT, 0);
    join_condition_company_name_cn.right = make_uniq<BoundReferenceExpression>("movie_id_rowid", LogicalType::BIGINT, 4);
    join_condition_company_name_cn.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_company_name_cn = make_uniq<RAIInfo>();
    rai_info_company_name_cn->rai = table_movie_companies.GetStorage().info->rais[0].get();
    rai_info_company_name_cn->rai_type = RAIType::SOURCE_EDGE;
    rai_info_company_name_cn->forward = false;
    rai_info_company_name_cn->vertex = &table_company_name;
    rai_info_company_name_cn->vertex_id = table_index_company_name_cn;
    rai_info_company_name_cn->passing_tables[0] = table_index_company_name_cn;
    rai_info_company_name_cn->left_cardinalities[0] = table_company_name.GetStorage().info->cardinality;
    // rai_info_company_name_cn->compact_list = &rai_info_company_name_cn->rai->alist->compact__list;

    join_condition_company_name_cn.rais.push_back(move(rai_info_company_name_cn));
    cond_company_name_cn.push_back(move(join_condition_company_name_cn));

    LogicalComparisonJoin join_company_name_cn_op(JoinType::INNER);
    vector<LogicalType> output_company_name_cn_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::BIGINT,
                                                     LogicalType::VARCHAR, LogicalType::BIGINT, LogicalType::BIGINT,
                                                     LogicalType::VARCHAR};
    join_company_name_cn_op.types = output_company_name_cn_types;
    vector<idx_t> right_projection_map_company_name_cn{2, 3, 4, 5, 6};
    vector<idx_t> merge_project_map_company_name_cn;
    vector<LogicalType> delim_types_company_name_cn;
    auto join_company_name_cn = make_uniq<PhysicalMergeSIPJoin>(join_company_name_cn_op, move(scan_company_name_cn), move(join_info_type_it3),
                                                           move(cond_company_name_cn), JoinType::INNER,
                                                           left_projection_map, right_projection_map_company_name_cn,
                                                           merge_project_map_company_name_cn, delim_types_company_name_cn, 0);


    vector<idx_t> char_name_chn_ids{COLUMN_IDENTIFIER_ROW_ID, 1};
    vector<LogicalType> get_char_name_chn_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_char_name_chn = "chn";
    vector<LogicalType> table_types_char_name_chn;
    vector<unique_ptr<Expression>> filter_char_name_chn;
    unique_ptr<LogicalGet> get_op_char_name_chn = move(
            getLogicalGet(*this, table_char_name, alias_char_name_chn, table_index_char_name_chn,
                          table_types_char_name_chn));
    unique_ptr<TableFilterSet> table_filters_char_name_chn = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_chn = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL, Value("Queen"));
    table_filters_char_name_chn->filters[1] = move(constant_filter_chn);
    unique_ptr<PhysicalTableScan> scan_char_name_chn = make_uniq<PhysicalTableScan>(get_char_name_chn_types,
                                                                                    get_op_char_name_chn->function,
                                                                                    get_op_char_name_chn->table_index,
                                                                                    move(get_op_char_name_chn->bind_data),
                                                                                    table_types_char_name_chn,
                                                                                    char_name_chn_ids,
                                                                                    move(filter_char_name_chn),
                                                                                    vector<column_t>(),
                                                                                    get_op_char_name_chn->names,
                                                                                    std::move(
                                                                                            table_filters_char_name_chn),
                                                                                    get_op_char_name_chn->estimated_cardinality,
                                                                                    get_op_char_name_chn->extra_info);


    vector<JoinCondition> cond_char_name_chn;
    JoinCondition join_condition_char_name_chn;
    join_condition_char_name_chn.left = make_uniq<BoundReferenceExpression>("char_name_rowid", LogicalType::BIGINT, 0);
    join_condition_char_name_chn.right = make_uniq<BoundReferenceExpression>("person_role_id_rowid", LogicalType::BIGINT, 5);
    join_condition_char_name_chn.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_char_name_chn = make_uniq<RAIInfo>();
    rai_info_char_name_chn->rai = table_cast_info.GetStorage().info->rais[3].get();
    rai_info_char_name_chn->rai_type = RAIType::TARGET_EDGE;
    rai_info_char_name_chn->forward = true;
    rai_info_char_name_chn->vertex = &table_char_name;
    rai_info_char_name_chn->vertex_id = table_index_char_name_chn;
    rai_info_char_name_chn->passing_tables[0] = table_index_char_name_chn;
    rai_info_char_name_chn->left_cardinalities[0] = table_char_name.GetStorage().info->cardinality;
    // rai_info_char_name_chn->compact_list = &rai_info_char_name_chn->rai->alist->compact__list;

    join_condition_char_name_chn.rais.push_back(move(rai_info_char_name_chn));
    cond_char_name_chn.push_back(move(join_condition_char_name_chn));

    LogicalComparisonJoin join_char_name_chn_op(JoinType::INNER);
    vector<LogicalType> output_char_name_chn_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::BIGINT,
                                                   LogicalType::VARCHAR, LogicalType::BIGINT, LogicalType::VARCHAR};
    join_char_name_chn_op.types = output_char_name_chn_types;
    vector<idx_t> right_projection_map_char_name_chn{2, 3, 4, 6};
    vector<idx_t> merge_project_map_char_name_chn;
    vector<LogicalType> delim_types_char_name_chn;
    auto join_char_name_chn = make_uniq<PhysicalSIPJoin>(join_char_name_chn_op, move(scan_char_name_chn), move(join_company_name_cn),
                                                         move(cond_char_name_chn), JoinType::INNER, left_projection_map,
                                                         right_projection_map_char_name_chn, delim_types_char_name_chn,
                                                         0);


    vector<idx_t> aka_name_an_ids{8};
    vector<LogicalType> get_aka_name_an_types{LogicalType::BIGINT};
    string alias_aka_name_an = "an";
    vector<LogicalType> table_types_aka_name_an;
    vector<unique_ptr<Expression>> filter_aka_name_an;
    unique_ptr<LogicalGet> get_op_aka_name_an = move(
            getLogicalGet(*this, table_aka_name, alias_aka_name_an, table_index_aka_name_an, table_types_aka_name_an));
    unique_ptr<TableFilterSet> table_filters_aka_name_an = NULL;
    unique_ptr<PhysicalTableScan> scan_aka_name_an = make_uniq<PhysicalTableScan>(get_aka_name_an_types,
                                                                                  get_op_aka_name_an->function,
                                                                                  get_op_aka_name_an->table_index,
                                                                                  move(get_op_aka_name_an->bind_data),
                                                                                  table_types_aka_name_an,
                                                                                  aka_name_an_ids,
                                                                                  move(filter_aka_name_an),
                                                                                  vector<column_t>(),
                                                                                  get_op_aka_name_an->names,
                                                                                  std::move(table_filters_aka_name_an),
                                                                                  get_op_aka_name_an->estimated_cardinality,
                                                                                  get_op_aka_name_an->extra_info);


    vector<JoinCondition> cond_aka_name_to_name_;
    JoinCondition join_condition_aka_name_to_name_;
    join_condition_aka_name_to_name_.left = make_uniq<BoundReferenceExpression>("person_id_rowid", LogicalType::BIGINT, 0);
    join_condition_aka_name_to_name_.right = make_uniq<BoundReferenceExpression>("name_rowid", LogicalType::BIGINT, 2);
    join_condition_aka_name_to_name_.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_aka_name_to_name_ = make_uniq<RAIInfo>();
    rai_info_aka_name_to_name_->rai = table_aka_name.GetStorage().info->rais[0].get();
    rai_info_aka_name_to_name_->rai_type = RAIType::EDGE_SOURCE;
    rai_info_aka_name_to_name_->forward = true;
    rai_info_aka_name_to_name_->vertex = &table_name;
    rai_info_aka_name_to_name_->vertex_id = table_index_name_n;
    rai_info_aka_name_to_name_->passing_tables[0] = table_index_aka_name_an;
    rai_info_aka_name_to_name_->left_cardinalities[0] = table_aka_name.GetStorage().info->cardinality;
    rai_info_aka_name_to_name_->compact_list = &rai_info_aka_name_to_name_->rai->alist->compact_forward_list;

    join_condition_aka_name_to_name_.rais.push_back(move(rai_info_aka_name_to_name_));
    cond_aka_name_to_name_.push_back(move(join_condition_aka_name_to_name_));

    LogicalComparisonJoin join_aka_name_to_name__op(JoinType::INNER);
    vector<LogicalType> output_aka_name_to_name__types{LogicalType::BIGINT, LogicalType::VARCHAR,
                                                       LogicalType::VARCHAR, LogicalType::BIGINT, LogicalType::VARCHAR};
    join_aka_name_to_name__op.types = output_aka_name_to_name__types;
    vector<idx_t> right_projection_map_aka_name_to_name_{1, 3, 4, 5};
    vector<idx_t> merge_project_map_aka_name_to_name_;
    vector<LogicalType> delim_types_aka_name_to_name_;
    auto join_aka_name_to_name_ = make_uniq<PhysicalSIPJoin>(join_aka_name_to_name__op, move(scan_aka_name_an), move(join_char_name_chn),
                                                                  move(cond_aka_name_to_name_), JoinType::INNER,
                                                                  left_projection_map,
                                                                  right_projection_map_aka_name_to_name_,
                                                                  delim_types_aka_name_to_name_, 0);

    vector<idx_t> keyword_k_ids{COLUMN_IDENTIFIER_ROW_ID, 1};
    vector<LogicalType> get_keyword_k_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_keyword_k = "k";
    vector<LogicalType> table_types_keyword_k;
    vector<unique_ptr<Expression>> filter_keyword_k;
    unique_ptr<LogicalGet> get_op_keyword_k = move(
            getLogicalGet(*this, table_keyword, alias_keyword_k, table_index_keyword_k, table_types_keyword_k));
    unique_ptr<TableFilterSet> table_filters_keyword_k = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_k = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL, Value("computer-animation"));
    table_filters_keyword_k->filters[1] = move(constant_filter_k);
    unique_ptr<PhysicalTableScan> scan_keyword_k = make_uniq<PhysicalTableScan>(get_keyword_k_types,
                                                                                get_op_keyword_k->function,
                                                                                get_op_keyword_k->table_index,
                                                                                move(get_op_keyword_k->bind_data),
                                                                                table_types_keyword_k, keyword_k_ids,
                                                                                move(filter_keyword_k),
                                                                                vector<column_t>(),
                                                                                get_op_keyword_k->names,
                                                                                std::move(table_filters_keyword_k),
                                                                                get_op_keyword_k->estimated_cardinality,
                                                                                get_op_keyword_k->extra_info);


    vector<JoinCondition> cond_keyword_k;
    JoinCondition join_condition_keyword_k;
    join_condition_keyword_k.left = make_uniq<BoundReferenceExpression>("keyword_rowid", LogicalType::BIGINT, 0);
    join_condition_keyword_k.right = make_uniq<BoundReferenceExpression>("movie_id_rowid", LogicalType::BIGINT, 3);
    join_condition_keyword_k.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_keyword_k = make_uniq<RAIInfo>();
    rai_info_keyword_k->rai = table_movie_keyword.GetStorage().info->rais[0].get();
    rai_info_keyword_k->rai_type = RAIType::SOURCE_EDGE;
    rai_info_keyword_k->forward = false;
    rai_info_keyword_k->vertex = &table_keyword;
    rai_info_keyword_k->vertex_id = table_index_keyword_k;
    rai_info_keyword_k->passing_tables[0] = table_index_keyword_k;
    rai_info_keyword_k->left_cardinalities[0] = table_keyword.GetStorage().info->cardinality;
    // rai_info_keyword_k->compact_list = &rai_info_keyword_k->rai->alist->compact__list;

    join_condition_keyword_k.rais.push_back(move(rai_info_keyword_k));
    cond_keyword_k.push_back(move(join_condition_keyword_k));

    LogicalComparisonJoin join_keyword_k_op(JoinType::INNER);
    vector<LogicalType> output_keyword_k_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::VARCHAR,
                                               LogicalType::VARCHAR, LogicalType::VARCHAR};
    join_keyword_k_op.types = output_keyword_k_types;
    vector<idx_t> right_projection_map_keyword_k{1, 2, 4};
    vector<idx_t> merge_project_map_keyword_k;
    vector<LogicalType> delim_types_keyword_k;
    auto join_keyword_k = make_uniq<PhysicalMergeSIPJoin>(join_keyword_k_op, move(scan_keyword_k), move(join_aka_name_to_name_), move(cond_keyword_k),
                                                     JoinType::INNER, left_projection_map,
                                                     right_projection_map_keyword_k,
                                                     merge_project_map_keyword_k,
                                                     delim_types_keyword_k, 0);


    vector<LogicalType> result_types{LogicalType::VARCHAR, LogicalType::VARCHAR, LogicalType::VARCHAR};
    vector<unique_ptr<Expression>> select_list;
    auto result_col0 = make_uniq<BoundReferenceExpression>("name", LogicalType::VARCHAR, 2);
    auto result_col1 = make_uniq<BoundReferenceExpression>("name", LogicalType::VARCHAR, 3);
    auto result_col2 = make_uniq<BoundReferenceExpression>("title", LogicalType::VARCHAR, 4);
    select_list.push_back(move(result_col0));
    select_list.push_back(move(result_col1));
    select_list.push_back(move(result_col2));
    auto projection = make_uniq<PhysicalProjection>(result_types, move(select_list), 0);
    projection->children.push_back(move(join_keyword_k));

    // aggregate
    string agg_name = "min";
    string agg_error = "";
    QueryErrorContext error_context(NULL, NULL);
    auto min_func = Catalog::GetEntry(context, CatalogType::SCALAR_FUNCTION_ENTRY, "", "",
                                      "min", OnEntryNotFound::RETURN_NULL, error_context);
    auto &min_func_set = min_func->Cast<AggregateFunctionCatalogEntry>();
    // bind the aggregate
    FunctionBinder function_binder(context);
    vector<LogicalType> types;
    types.push_back(LogicalType::VARCHAR);
    idx_t best_function_varchar = function_binder.BindFunction(agg_name, min_func_set.functions, types, agg_error);
    auto bound_function_min_varchar = min_func_set.functions.GetFunctionByOffset(best_function_varchar);
    // std::cout << best_function_varchar << " " << bound_function_min_varchar.return_type.ToString() << std::endl;

    auto first_children = make_uniq<BoundReferenceExpression>("name", LogicalType::VARCHAR, 0);
    vector<unique_ptr<Expression>> childrenlist1;
    childrenlist1.push_back(move(first_children));
    auto aggregate1 =
            function_binder.BindAggregateFunction(bound_function_min_varchar, std::move(childrenlist1), nullptr,
                                                  AggregateType::NON_DISTINCT);

    auto second_children = make_uniq<BoundReferenceExpression>("name", LogicalType::VARCHAR, 1);
    vector<unique_ptr<Expression>> childrenlist2;
    childrenlist2.push_back(move(second_children));
    auto aggregate2 =
            function_binder.BindAggregateFunction(bound_function_min_varchar, std::move(childrenlist2), nullptr,
                                                  AggregateType::NON_DISTINCT);

    auto third_children = make_uniq<BoundReferenceExpression>("title", LogicalType::VARCHAR, 2);
    vector<unique_ptr<Expression>> childrenlist3;
    childrenlist3.push_back(move(third_children));
    auto aggregate3 =
            function_binder.BindAggregateFunction(bound_function_min_varchar, std::move(childrenlist3), nullptr,
                                                  AggregateType::NON_DISTINCT);

    vector<unique_ptr<Expression>> aggregates;
    aggregates.push_back(move(aggregate1));
    aggregates.push_back(move(aggregate2));
    aggregates.push_back(move(aggregate3));


    vector<LogicalType> aggregate_types{LogicalType::VARCHAR, LogicalType::VARCHAR, LogicalType::VARCHAR};
    auto ungrouped_aggregate = make_uniq<PhysicalUngroupedAggregate>(aggregate_types, move(aggregates), 0);
    ungrouped_aggregate->children.push_back(move(projection));

    return ungrouped_aggregate;
}

unique_ptr<PhysicalOperator> ClientContext::GenerateJOB30aPlan(duckdb::ClientContext &context) {
    vector<idx_t> left_projection_map, right_projection_map;

    string table_vertex_info_type_it1 = "info_type";
    string table_vertex_title_t = "title";
    string table_vertex_info_type_it2 = "info_type";
    string table_vertex_name_n = "name";
    string table_vertex_keyword_k = "keyword";
    string table_vertex_comp_cast_type_cct1 = "comp_cast_type";
    string table_vertex_comp_cast_type_cct2 = "comp_cast_type";
    string table_vertex_movie_info_ = "movie_info";
    string table_vertex_movie_info_idx_ = "movie_info_idx";
    string table_vertex_cast_info_ = "cast_info";
    string table_vertex_movie_keyword_ = "movie_keyword";
    string table_vertex_complete_cast = "complete_cast";

    idx_t table_index_info_type_it1 = 1;
    idx_t table_index_title_t = 2;
    idx_t table_index_info_type_it2 = 3;
    idx_t table_index_name_n = 4;
    idx_t table_index_keyword_k = 5;
    idx_t table_index_comp_cast_type_cct1 = 6;
    idx_t table_index_comp_cast_type_cct2 = 7;
    idx_t table_index_movie_info_ = 8;
    idx_t table_index_movie_info_idx_ = 9;
    idx_t table_index_cast_info_ = 10;
    idx_t table_index_movie_keyword_ = 11;
    idx_t table_index_complete_cast = 12;

    auto table_or_view_info_type = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                     table_vertex_info_type_it1, OnEntryNotFound::RETURN_NULL);
    auto &table_info_type = table_or_view_info_type->Cast<TableCatalogEntry>();
    auto table_or_view_title = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_title_t,
                                                 OnEntryNotFound::RETURN_NULL);
    auto &table_title = table_or_view_title->Cast<TableCatalogEntry>();
    auto table_or_view_name = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_name_n,
                                                OnEntryNotFound::RETURN_NULL);
    auto &table_name = table_or_view_name->Cast<TableCatalogEntry>();
    auto table_or_view_keyword = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_keyword_k,
                                                   OnEntryNotFound::RETURN_NULL);
    auto &table_keyword = table_or_view_keyword->Cast<TableCatalogEntry>();
    auto table_or_view_comp_cast_type = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                          table_vertex_comp_cast_type_cct1,
                                                          OnEntryNotFound::RETURN_NULL);
    auto &table_comp_cast_type = table_or_view_comp_cast_type->Cast<TableCatalogEntry>();
    auto table_or_view_movie_info = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_movie_info_,
                                                      OnEntryNotFound::RETURN_NULL);
    auto &table_movie_info = table_or_view_movie_info->Cast<TableCatalogEntry>();
    auto table_or_view_movie_info_idx = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                          table_vertex_movie_info_idx_, OnEntryNotFound::RETURN_NULL);
    auto &table_movie_info_idx = table_or_view_movie_info_idx->Cast<TableCatalogEntry>();
    auto table_or_view_cast_info = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_cast_info_,
                                                     OnEntryNotFound::RETURN_NULL);
    auto &table_cast_info = table_or_view_cast_info->Cast<TableCatalogEntry>();
    auto table_or_view_movie_keyword = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                         table_vertex_movie_keyword_, OnEntryNotFound::RETURN_NULL);
    auto &table_movie_keyword = table_or_view_movie_keyword->Cast<TableCatalogEntry>();
    auto table_or_view_complete_cast = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                                 table_vertex_complete_cast,
                                                                 OnEntryNotFound::RETURN_NULL);
    auto &table_complete_cast = table_or_view_complete_cast->Cast<TableCatalogEntry>();

    vector<idx_t> comp_cast_type_cct2_ids{COLUMN_IDENTIFIER_ROW_ID, 1};
    vector<LogicalType> get_comp_cast_type_cct2_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_comp_cast_type_cct2 = "cct2";
    vector<LogicalType> table_types_comp_cast_type_cct2;
    vector<unique_ptr<Expression>> filter_comp_cast_type_cct2;
    unique_ptr<LogicalGet> get_op_comp_cast_type_cct2 = move(
            getLogicalGet(*this, table_comp_cast_type, alias_comp_cast_type_cct2, table_index_comp_cast_type_cct2,
                          table_types_comp_cast_type_cct2));
    unique_ptr<TableFilterSet> table_filters_comp_cast_type_cct2 = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_cct2 = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL, Value("complete+verified"));
    table_filters_comp_cast_type_cct2->filters[1] = move(constant_filter_cct2);
    unique_ptr<PhysicalTableScan> scan_comp_cast_type_cct2 = make_uniq<PhysicalTableScan>(get_comp_cast_type_cct2_types,
                                                                                          get_op_comp_cast_type_cct2->function,
                                                                                          get_op_comp_cast_type_cct2->table_index,
                                                                                          move(get_op_comp_cast_type_cct2->bind_data),
                                                                                          table_types_comp_cast_type_cct2,
                                                                                          comp_cast_type_cct2_ids,
                                                                                          move(filter_comp_cast_type_cct2),
                                                                                          vector<column_t>(),
                                                                                          get_op_comp_cast_type_cct2->names,
                                                                                          std::move(
                                                                                                  table_filters_comp_cast_type_cct2),
                                                                                          get_op_comp_cast_type_cct2->estimated_cardinality,
                                                                                          get_op_comp_cast_type_cct2->extra_info);


    vector<idx_t> complete_cast_ids{4, 5, 6};
    vector<LogicalType> get_complete_cast_types{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::BIGINT};
    string alias_complete_cast = "cc";
    vector<LogicalType> table_types_complete_cast;
    vector<unique_ptr<Expression>> filter_complete_cast;
    unique_ptr<LogicalGet> get_op_complete_cast = move(
            getLogicalGet(*this, table_complete_cast, alias_complete_cast, table_index_complete_cast,
                          table_types_complete_cast));
    unique_ptr<TableFilterSet> table_filters_complete_cast = NULL;
    unique_ptr<PhysicalTableScan> scan_complete_cast = make_uniq<PhysicalTableScan>(get_complete_cast_types,
                                                                                    get_op_complete_cast->function,
                                                                                    get_op_complete_cast->table_index,
                                                                                    move(get_op_complete_cast->bind_data),
                                                                                    table_types_complete_cast,
                                                                                    complete_cast_ids,
                                                                                    move(filter_complete_cast),
                                                                                    vector<column_t>(),
                                                                                    get_op_complete_cast->names,
                                                                                    std::move(
                                                                                            table_filters_complete_cast),
                                                                                    get_op_complete_cast->estimated_cardinality,
                                                                                    get_op_complete_cast->extra_info);


    vector<JoinCondition> cond_complete_cast_status_;
    JoinCondition join_condition_complete_cast_status_;
    join_condition_complete_cast_status_.left = make_uniq<BoundReferenceExpression>("status_id_rowid", LogicalType::BIGINT, 2);
    join_condition_complete_cast_status_.right = make_uniq<BoundReferenceExpression>("comp_cast_type_rowid", LogicalType::BIGINT, 0);
    join_condition_complete_cast_status_.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_complete_cast_status_ = make_uniq<RAIInfo>();
    rai_info_complete_cast_status_->rai = table_complete_cast.GetStorage().info->rais[1].get();
    rai_info_complete_cast_status_->rai_type = RAIType::EDGE_SOURCE;
    rai_info_complete_cast_status_->forward = true;
    rai_info_complete_cast_status_->vertex = &table_comp_cast_type;
    rai_info_complete_cast_status_->vertex_id = table_index_comp_cast_type_cct2;
    rai_info_complete_cast_status_->passing_tables[0] = table_index_complete_cast;
    rai_info_complete_cast_status_->left_cardinalities[0] = table_complete_cast.GetStorage().info->cardinality;
    rai_info_complete_cast_status_->compact_list = &rai_info_complete_cast_status_->rai->alist->compact_forward_list;

    join_condition_complete_cast_status_.rais.push_back(move(rai_info_complete_cast_status_));
    cond_complete_cast_status_.push_back(move(join_condition_complete_cast_status_));

    LogicalComparisonJoin join_complete_cast_status__op(JoinType::INNER);
    vector<LogicalType> output_complete_cast_status__types{LogicalType::BIGINT, LogicalType::BIGINT,
                                                           LogicalType::BIGINT, LogicalType::BIGINT};
    join_complete_cast_status__op.types = output_complete_cast_status__types;
    vector<idx_t> right_projection_map_complete_cast_status_{0};
    vector<idx_t> merge_project_map_complete_cast_status_;
    vector<LogicalType> delim_types_complete_cast_status_;
    auto join_complete_cast_status_ = make_uniq<PhysicalSIPJoin>(join_complete_cast_status__op, move(scan_complete_cast), move(scan_comp_cast_type_cct2),
                                                                 move(cond_complete_cast_status_), JoinType::INNER,
                                                                 left_projection_map,
                                                                 right_projection_map_complete_cast_status_,
                                                                 delim_types_complete_cast_status_, 0);



    vector<idx_t> comp_cast_type_cct1_ids{COLUMN_IDENTIFIER_ROW_ID, 1};
    vector<LogicalType> get_comp_cast_type_cct1_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_comp_cast_type_cct1 = "cct1";
    vector<LogicalType> table_types_comp_cast_type_cct1;
    vector<unique_ptr<Expression>> filter_comp_cast_type_cct1;
    unique_ptr<LogicalGet> get_op_comp_cast_type_cct1 = move(
            getLogicalGet(*this, table_comp_cast_type, alias_comp_cast_type_cct1, table_index_comp_cast_type_cct1,
                          table_types_comp_cast_type_cct1));
    unique_ptr<TableFilterSet> table_filters_comp_cast_type_cct1 = NULL;
    unique_ptr<PhysicalTableScan> scan_comp_cast_type_cct1 = make_uniq<PhysicalTableScan>(get_comp_cast_type_cct1_types,
                                                                                          get_op_comp_cast_type_cct1->function,
                                                                                          get_op_comp_cast_type_cct1->table_index,
                                                                                          move(get_op_comp_cast_type_cct1->bind_data),
                                                                                          table_types_comp_cast_type_cct1,
                                                                                          comp_cast_type_cct1_ids,
                                                                                          move(filter_comp_cast_type_cct1),
                                                                                          vector<column_t>(),
                                                                                          get_op_comp_cast_type_cct1->names,
                                                                                          std::move(
                                                                                                  table_filters_comp_cast_type_cct1),
                                                                                          get_op_comp_cast_type_cct1->estimated_cardinality,
                                                                                          get_op_comp_cast_type_cct1->extra_info);


    auto &allocator = Allocator::Get(context);
    vector<LogicalType> join_in_types {LogicalType::VARCHAR};
    auto collection =
            make_uniq<ColumnDataCollection>(context, join_in_types, ColumnDataAllocatorType::IN_MEMORY_ALLOCATOR);

    vector<LogicalType> chunk_in_types {LogicalType::VARCHAR};
    DataChunk chunk;
    chunk.SetCardinality(2);
    chunk.Initialize(allocator, chunk_in_types);
    chunk.SetValue(0, 0, Value("cast"));
    chunk.SetValue(0, 1, Value("crew"));
    collection->Append(chunk);

    // create a chunk scan to output the result
    vector<LogicalType> ouput_in_types {LogicalType::VARCHAR};
    auto chunk_scan = make_uniq<PhysicalColumnDataScan>(ouput_in_types, PhysicalOperatorType::COLUMN_DATA_SCAN,
                                                        2, std::move(collection));

    vector<JoinCondition> cond_hash_join_;
    JoinCondition join_condition_hash_join_;
    join_condition_hash_join_.left = make_uniq<BoundReferenceExpression>("kind", LogicalType::VARCHAR, 1);
    join_condition_hash_join_.right = make_uniq<BoundReferenceExpression>("", LogicalType::VARCHAR, 0);
    join_condition_hash_join_.comparison = ExpressionType::COMPARE_EQUAL;
    cond_hash_join_.push_back(move(join_condition_hash_join_));

    LogicalComparisonJoin join_hash_join_op(JoinType::MARK);
    vector<LogicalType> output_hash_join_types{LogicalType::BIGINT,
                                               LogicalType::VARCHAR, LogicalType::BOOLEAN};
    join_hash_join_op.types = output_hash_join_types;
    vector<idx_t> right_projection_map_hash_join_;
    vector<LogicalType> delim_types_hash_join_;
    PerfectHashJoinStats joinstate;
    auto join_hash_join_ = make_uniq<PhysicalHashJoin>(join_hash_join_op, move(scan_comp_cast_type_cct1), move(chunk_scan), move(cond_hash_join_),
                                                       JoinType::MARK, left_projection_map,
                                                       right_projection_map_hash_join_,
                                                       delim_types_hash_join_, 0, joinstate);

    vector<LogicalType> filter_in_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::BOOLEAN};
    vector<unique_ptr<Expression>> select_list_in;
    auto in_exp = make_uniq<BoundReferenceExpression>("IN (...)", LogicalType::BOOLEAN, 2);
    select_list_in.push_back(move(in_exp));
    unique_ptr<PhysicalFilter> filter_in = make_uniq<PhysicalFilter>(filter_in_types, move(select_list_in), 0);
    filter_in->children.push_back(move(join_hash_join_));


    vector<JoinCondition> cond_comp_cast_type_cct1;
    JoinCondition join_condition_comp_cast_type_cct1;
    join_condition_comp_cast_type_cct1.left = make_uniq<BoundReferenceExpression>("comp_cast_type_rowid", LogicalType::BIGINT, 0);
    join_condition_comp_cast_type_cct1.right = make_uniq<BoundReferenceExpression>("subject_id_rowid", LogicalType::BIGINT, 0);
    join_condition_comp_cast_type_cct1.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_comp_cast_type_cct1 = make_uniq<RAIInfo>();
    rai_info_comp_cast_type_cct1->rai = table_complete_cast.GetStorage().info->rais[0].get();
    rai_info_comp_cast_type_cct1->rai_type = RAIType::SOURCE_EDGE;
    rai_info_comp_cast_type_cct1->forward = false;
    rai_info_comp_cast_type_cct1->vertex = &table_comp_cast_type;
    rai_info_comp_cast_type_cct1->vertex_id = table_index_comp_cast_type_cct1;
    rai_info_comp_cast_type_cct1->passing_tables[0] = table_index_comp_cast_type_cct1;
    rai_info_comp_cast_type_cct1->left_cardinalities[0] = table_comp_cast_type.GetStorage().info->cardinality;
    // rai_info_comp_cast_type_cct1->compact_list = &rai_info_comp_cast_type_cct1->rai->alist->compact__list;

    join_condition_comp_cast_type_cct1.rais.push_back(move(rai_info_comp_cast_type_cct1));
    cond_comp_cast_type_cct1.push_back(move(join_condition_comp_cast_type_cct1));

    LogicalComparisonJoin join_comp_cast_type_cct1_op(JoinType::INNER);
    vector<LogicalType> output_comp_cast_type_cct1_types{LogicalType::BIGINT, LogicalType::VARCHAR,
                                                         LogicalType::BOOLEAN, LogicalType::BIGINT};
    join_comp_cast_type_cct1_op.types = output_comp_cast_type_cct1_types;
    vector<idx_t> right_projection_map_comp_cast_type_cct1{1};
    vector<idx_t> merge_project_map_comp_cast_type_cct1;
    vector<LogicalType> delim_types_comp_cast_type_cct1;
    auto join_comp_cast_type_cct1 = make_uniq<PhysicalSIPJoin>(join_comp_cast_type_cct1_op, move(filter_in), move(join_complete_cast_status_),
                                                               move(cond_comp_cast_type_cct1), JoinType::INNER,
                                                               left_projection_map,
                                                               right_projection_map_comp_cast_type_cct1,
                                                               delim_types_comp_cast_type_cct1, 0);


    vector<idx_t> title_t_ids{COLUMN_IDENTIFIER_ROW_ID, 1, 4};
    vector<LogicalType> get_title_t_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::BIGINT};
    string alias_title_t = "t";
    vector<LogicalType> table_types_title_t;
    vector<unique_ptr<Expression>> filter_title_t;
    unique_ptr<LogicalGet> get_op_title_t = move(
            getLogicalGet(*this, table_title, alias_title_t, table_index_title_t, table_types_title_t));
    unique_ptr<TableFilterSet> table_filters_title_t = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_t = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_GREATERTHAN, Value::BIGINT(2000));
    table_filters_title_t->filters[2] = move(constant_filter_t);
    unique_ptr<PhysicalTableScan> scan_title_t = make_uniq<PhysicalTableScan>(get_title_t_types,
                                                                              get_op_title_t->function,
                                                                              get_op_title_t->table_index,
                                                                              move(get_op_title_t->bind_data),
                                                                              table_types_title_t, title_t_ids,
                                                                              move(filter_title_t), vector<column_t>(),
                                                                              get_op_title_t->names,
                                                                              std::move(table_filters_title_t),
                                                                              get_op_title_t->estimated_cardinality,
                                                                              get_op_title_t->extra_info);


    vector<JoinCondition> cond_title_t;
    JoinCondition join_condition_title_t;
    join_condition_title_t.left = make_uniq<BoundReferenceExpression>("title_rowid", LogicalType::BIGINT, 0);
    join_condition_title_t.right = make_uniq<BoundReferenceExpression>("movie_id_rowid", LogicalType::BIGINT, 3);
    join_condition_title_t.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_title_t = make_uniq<RAIInfo>();
    rai_info_title_t->rai = table_complete_cast.GetStorage().info->rais[0].get();
    rai_info_title_t->rai_type = RAIType::TARGET_EDGE;
    rai_info_title_t->forward = true;
    rai_info_title_t->vertex = &table_title;
    rai_info_title_t->vertex_id = table_index_title_t;
    rai_info_title_t->passing_tables[0] = table_index_title_t;
    rai_info_title_t->left_cardinalities[0] = table_title.GetStorage().info->cardinality;
    // rai_info_title_t->compact_list = &rai_info_title_t->rai->alist->compact__list;

    join_condition_title_t.rais.push_back(move(rai_info_title_t));
    cond_title_t.push_back(move(join_condition_title_t));

    LogicalComparisonJoin join_title_t_op(JoinType::INNER);
    vector<LogicalType> output_title_t_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::BIGINT,
                                             LogicalType::BIGINT};
    join_title_t_op.types = output_title_t_types;
    vector<idx_t> right_projection_map_title_t{0};
    vector<idx_t> merge_project_map_title_t;
    vector<LogicalType> delim_types_title_t;
    auto join_title_t = make_uniq<PhysicalSIPJoin>(join_title_t_op, move(scan_title_t), move(join_comp_cast_type_cct1), move(cond_title_t), JoinType::INNER,
                                                   left_projection_map, right_projection_map_title_t,
                                                   delim_types_title_t, 0);

    vector<idx_t> movie_info_idx_ids{6, 5, 3};
    vector<LogicalType> get_movie_info_idx_type{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_movie_info_idx = "mi";
    vector<LogicalType> table_types_movie_info_idx;
    vector<unique_ptr<Expression>> filter_movie_info_idx;
    unique_ptr<LogicalGet> get_op_movie_info_idx = move(
            getLogicalGet(*this, table_movie_info_idx, alias_movie_info_idx, table_index_movie_info_idx_, table_types_movie_info_idx));
    unique_ptr<TableFilterSet> table_filters_movie_info_idx = NULL;
    unique_ptr<PhysicalTableScan> scan_movie_info_idx = make_uniq<PhysicalTableScan>(get_movie_info_idx_type,
                                                                                     get_op_movie_info_idx->function,
                                                                                     get_op_movie_info_idx->table_index,
                                                                                     move(get_op_movie_info_idx->bind_data),
                                                                                     table_types_movie_info_idx, movie_info_idx_ids,
                                                                                     move(filter_movie_info_idx),
                                                                                     vector<column_t>(),
                                                                                     get_op_movie_info_idx->names,
                                                                                     std::move(table_filters_movie_info_idx),
                                                                                     get_op_movie_info_idx->estimated_cardinality,
                                                                                     get_op_movie_info_idx->extra_info);


    vector<JoinCondition> cond_movie_info_idx_;
    JoinCondition join_condition_movie_info_idx_;
    join_condition_movie_info_idx_.left = make_uniq<BoundReferenceExpression>("movie_id_rowid", LogicalType::BIGINT, 0);
    join_condition_movie_info_idx_.right = make_uniq<BoundReferenceExpression>("title_rowid", LogicalType::BIGINT, 0);
    join_condition_movie_info_idx_.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_movie_info_idx_ = make_uniq<RAIInfo>();
    rai_info_movie_info_idx_->rai = table_movie_info_idx.GetStorage().info->rais[0].get();
    rai_info_movie_info_idx_->rai_type = RAIType::EDGE_TARGET;
    rai_info_movie_info_idx_->forward = false;
    rai_info_movie_info_idx_->vertex = &table_title;
    rai_info_movie_info_idx_->vertex_id = table_index_title_t;
    rai_info_movie_info_idx_->passing_tables[0] = table_index_movie_info_idx_;
    rai_info_movie_info_idx_->left_cardinalities[0] = table_movie_info_idx.GetStorage().info->cardinality;
    rai_info_movie_info_idx_->compact_list = &rai_info_movie_info_idx_->rai->alist->compact_backward_list;

    join_condition_movie_info_idx_.rais.push_back(move(rai_info_movie_info_idx_));
    cond_movie_info_idx_.push_back(move(join_condition_movie_info_idx_));

    LogicalComparisonJoin join_movie_info_idx__op(JoinType::INNER);
    vector<LogicalType> output_movie_info_idx__types{LogicalType::BIGINT, LogicalType::BIGINT,
                                                     LogicalType::VARCHAR, LogicalType::VARCHAR};
    join_movie_info_idx__op.types = output_movie_info_idx__types;
    vector<idx_t> right_projection_map_movie_info_idx_{1};
    vector<idx_t> merge_project_map_movie_info_idx_;
    vector<LogicalType> delim_types_movie_info_idx_;
    auto join_movie_info_idx_ = make_uniq<PhysicalSIPJoin>(join_movie_info_idx__op, move(scan_movie_info_idx), move(join_title_t),
                                                                move(cond_movie_info_idx_), JoinType::INNER,
                                                                left_projection_map,
                                                                right_projection_map_movie_info_idx_,
                                                                delim_types_movie_info_idx_, 0);


    vector<idx_t> info_type_it2_ids{COLUMN_IDENTIFIER_ROW_ID, 1};
    vector<LogicalType> get_info_type_it2_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_info_type_it2 = "it2";
    vector<LogicalType> table_types_info_type_it2;
    vector<unique_ptr<Expression>> filter_info_type_it2;
    unique_ptr<LogicalGet> get_op_info_type_it2 = move(
            getLogicalGet(*this, table_info_type, alias_info_type_it2, table_index_info_type_it2,
                          table_types_info_type_it2));
    unique_ptr<TableFilterSet> table_filters_info_type_it2 = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_it2 = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL, Value("votes"));
    table_filters_info_type_it2->filters[1] = move(constant_filter_it2);
    unique_ptr<PhysicalTableScan> scan_info_type_it2 = make_uniq<PhysicalTableScan>(get_info_type_it2_types,
                                                                                    get_op_info_type_it2->function,
                                                                                    get_op_info_type_it2->table_index,
                                                                                    move(get_op_info_type_it2->bind_data),
                                                                                    table_types_info_type_it2,
                                                                                    info_type_it2_ids,
                                                                                    move(filter_info_type_it2),
                                                                                    vector<column_t>(),
                                                                                    get_op_info_type_it2->names,
                                                                                    std::move(
                                                                                            table_filters_info_type_it2),
                                                                                    get_op_info_type_it2->estimated_cardinality,
                                                                                    get_op_info_type_it2->extra_info);


    vector<JoinCondition> cond_info_type_it2;
    JoinCondition join_condition_info_type_it2;
    join_condition_info_type_it2.left = make_uniq<BoundReferenceExpression>("info_type_rowid", LogicalType::BIGINT, 0);
    join_condition_info_type_it2.right = make_uniq<BoundReferenceExpression>("info_type_id_rowid", LogicalType::BIGINT, 1);
    join_condition_info_type_it2.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_info_type_it2 = make_uniq<RAIInfo>();
    rai_info_info_type_it2->rai = table_movie_info_idx.GetStorage().info->rais[0].get();
    rai_info_info_type_it2->rai_type = RAIType::SOURCE_EDGE;
    rai_info_info_type_it2->forward = false;
    rai_info_info_type_it2->vertex = &table_info_type;
    rai_info_info_type_it2->vertex_id = table_index_info_type_it2;
    rai_info_info_type_it2->passing_tables[0] = table_index_info_type_it2;
    rai_info_info_type_it2->left_cardinalities[0] = table_info_type.GetStorage().info->cardinality;
    // rai_info_info_type_it2->compact_list = &rai_info_info_type_it2->rai->alist->compact__list;

    join_condition_info_type_it2.rais.push_back(move(rai_info_info_type_it2));
    cond_info_type_it2.push_back(move(join_condition_info_type_it2));

    LogicalComparisonJoin join_info_type_it2_op(JoinType::INNER);
    vector<LogicalType> output_info_type_it2_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::BIGINT,
                                                   LogicalType::VARCHAR, LogicalType::VARCHAR};
    join_info_type_it2_op.types = output_info_type_it2_types;
    vector<idx_t> right_projection_map_info_type_it2{0, 2, 3};
    vector<idx_t> merge_project_map_info_type_it2;
    vector<LogicalType> delim_types_info_type_it2;
    auto join_info_type_it2 = make_uniq<PhysicalSIPJoin>(join_info_type_it2_op, move(scan_info_type_it2), move(join_movie_info_idx_),
                                                         move(cond_info_type_it2), JoinType::INNER, left_projection_map,
                                                         right_projection_map_info_type_it2, delim_types_info_type_it2,
                                                         0);



    vector<idx_t> movie_info_ids{6, 5, 3};
    vector<LogicalType> get_movie_info_types{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_movie_info = "i";
    vector<LogicalType> table_types_movie_info;
    vector<unique_ptr<Expression>> filter_movie_info;
    unique_ptr<LogicalGet> get_op_movie_info = move(
            getLogicalGet(*this, table_movie_info, alias_movie_info, table_index_movie_info_, table_types_movie_info));
    unique_ptr<TableFilterSet> table_filters_movie_info = NULL;
    unique_ptr<PhysicalTableScan> scan_movie_info = make_uniq<PhysicalTableScan>(get_movie_info_types,
                                                                                 get_op_movie_info->function,
                                                                                 get_op_movie_info->table_index,
                                                                                 move(get_op_movie_info->bind_data),
                                                                                 table_types_movie_info,
                                                                                 movie_info_ids,
                                                                                 move(filter_movie_info),
                                                                                 vector<column_t>(),
                                                                                 get_op_movie_info->names,
                                                                                 std::move(table_filters_movie_info),
                                                                                 get_op_movie_info->estimated_cardinality,
                                                                                 get_op_movie_info->extra_info);

    auto &allocator_mi = Allocator::Get(context);
    vector<LogicalType> join_in_types_mi {LogicalType::VARCHAR};
    auto collection_mi =
            make_uniq<ColumnDataCollection>(context, join_in_types_mi, ColumnDataAllocatorType::IN_MEMORY_ALLOCATOR);

    vector<LogicalType> chunk_in_types_mi {LogicalType::VARCHAR};
    DataChunk chunk_mi;
    chunk_mi.SetCardinality(2);
    chunk_mi.Initialize(allocator_mi, chunk_in_types_mi);
    chunk_mi.SetValue(0, 0, Value("Horror"));
    chunk_mi.SetValue(0, 1, Value("Thriller"));
    collection_mi->Append(chunk_mi);

    // create a chunk scan to output the result
    vector<LogicalType> ouput_in_types_mi {LogicalType::VARCHAR};
    auto chunk_scan_mi = make_uniq<PhysicalColumnDataScan>(ouput_in_types_mi, PhysicalOperatorType::COLUMN_DATA_SCAN,
                                                           2, std::move(collection_mi));

    vector<JoinCondition> cond_hash_join_mi;
    JoinCondition join_condition_hash_join_mi;
    join_condition_hash_join_mi.left = make_uniq<BoundReferenceExpression>("info", LogicalType::VARCHAR, 2);
    join_condition_hash_join_mi.right = make_uniq<BoundReferenceExpression>("", LogicalType::VARCHAR, 0);
    join_condition_hash_join_mi.comparison = ExpressionType::COMPARE_EQUAL;
    cond_hash_join_mi.push_back(move(join_condition_hash_join_mi));

    LogicalComparisonJoin join_hash_join_op_mi(JoinType::MARK);
    vector<LogicalType> output_hash_join_types_mi{LogicalType::BIGINT, LogicalType::BIGINT,
                                                  LogicalType::VARCHAR, LogicalType::BOOLEAN};
    join_hash_join_op_mi.types = output_hash_join_types_mi;
    vector<idx_t> right_projection_map_hash_join_mi;
    vector<LogicalType> delim_types_hash_join_mi;
    PerfectHashJoinStats joinstate_mi;
    auto join_hash_join_mi = make_uniq<PhysicalHashJoin>(join_hash_join_op_mi, move(scan_movie_info), move(chunk_scan_mi), move(cond_hash_join_mi),
                                                         JoinType::MARK, left_projection_map,
                                                         right_projection_map_hash_join_mi,
                                                         delim_types_hash_join_mi, 0, joinstate_mi);


    vector<LogicalType> filter_in_types_mi{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::BOOLEAN};
    vector<unique_ptr<Expression>> select_list_in_mi;
    auto in_exp_mi = make_uniq<BoundReferenceExpression>("IN (...)", LogicalType::BOOLEAN, 3);
    select_list_in_mi.push_back(move(in_exp_mi));
    unique_ptr<PhysicalFilter> filter_in_mi = make_uniq<PhysicalFilter>(filter_in_types_mi, move(select_list_in_mi), 0);
    filter_in_mi->children.push_back(move(join_hash_join_mi));


    vector<JoinCondition> cond_movie_info_;
    JoinCondition join_condition_movie_info_;
    join_condition_movie_info_.left = make_uniq<BoundReferenceExpression>("movie_id_rowid", LogicalType::BIGINT, 0);
    join_condition_movie_info_.right = make_uniq<BoundReferenceExpression>("movie_id_rowid", LogicalType::BIGINT, 2);
    join_condition_movie_info_.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_movie_info_ = make_uniq<RAIInfo>();
    rai_info_movie_info_->rai = table_movie_info.GetStorage().info->rais[0].get();
    rai_info_movie_info_->rai_type = RAIType::EDGE_TARGET;
    rai_info_movie_info_->forward = false;
    rai_info_movie_info_->vertex = &table_title;
    rai_info_movie_info_->vertex_id = table_index_title_t;
    rai_info_movie_info_->passing_tables[0] = table_index_movie_info_;
    rai_info_movie_info_->left_cardinalities[0] = table_movie_info.GetStorage().info->cardinality;
    rai_info_movie_info_->compact_list = &rai_info_movie_info_->rai->alist->compact_backward_list;

    join_condition_movie_info_.rais.push_back(move(rai_info_movie_info_));
    cond_movie_info_.push_back(move(join_condition_movie_info_));

    LogicalComparisonJoin join_movie_info__op(JoinType::INNER);
    vector<LogicalType> output_movie_info__types{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::VARCHAR,
                                                 LogicalType::BOOLEAN, LogicalType::VARCHAR, LogicalType::VARCHAR};
    join_movie_info__op.types = output_movie_info__types;
    vector<idx_t> right_projection_map_movie_info_{3, 4};
    vector<idx_t> merge_project_map_movie_info_;
    vector<LogicalType> delim_types_movie_info_;
    auto join_movie_info_ = make_uniq<PhysicalSIPJoin>(join_movie_info__op, move(filter_in_mi), move(join_info_type_it2), move(cond_movie_info_),
                                                            JoinType::INNER, left_projection_map,
                                                            right_projection_map_movie_info_,
                                                            delim_types_movie_info_, 0);

    vector<idx_t> info_type_it1_ids{COLUMN_IDENTIFIER_ROW_ID, 1};
    vector<LogicalType> get_info_type_it1_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_info_type_it1 = "it1";
    vector<LogicalType> table_types_info_type_it1;
    vector<unique_ptr<Expression>> filter_info_type_it1;
    unique_ptr<LogicalGet> get_op_info_type_it1 = move(
            getLogicalGet(*this, table_info_type, alias_info_type_it1, table_index_info_type_it1,
                          table_types_info_type_it1));
    unique_ptr<TableFilterSet> table_filters_info_type_it1 = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_it1 = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL, Value("genres"));
    table_filters_info_type_it1->filters[1] = move(constant_filter_it1);
    unique_ptr<PhysicalTableScan> scan_info_type_it1 = make_uniq<PhysicalTableScan>(get_info_type_it1_types,
                                                                                    get_op_info_type_it1->function,
                                                                                    get_op_info_type_it1->table_index,
                                                                                    move(get_op_info_type_it1->bind_data),
                                                                                    table_types_info_type_it1,
                                                                                    info_type_it1_ids,
                                                                                    move(filter_info_type_it1),
                                                                                    vector<column_t>(),
                                                                                    get_op_info_type_it1->names,
                                                                                    std::move(
                                                                                            table_filters_info_type_it1),
                                                                                    get_op_info_type_it1->estimated_cardinality,
                                                                                    get_op_info_type_it1->extra_info);


    vector<JoinCondition> cond_info_type_it1;
    JoinCondition join_condition_info_type_it1;
    join_condition_info_type_it1.left = make_uniq<BoundReferenceExpression>("info_type_rowid", LogicalType::BIGINT, 0);
    join_condition_info_type_it1.right = make_uniq<BoundReferenceExpression>("info_type_id_rowid", LogicalType::BIGINT, 1);
    join_condition_info_type_it1.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_info_type_it1 = make_uniq<RAIInfo>();
    rai_info_info_type_it1->rai = table_movie_info.GetStorage().info->rais[0].get();
    rai_info_info_type_it1->rai_type = RAIType::SOURCE_EDGE;
    rai_info_info_type_it1->forward = false;
    rai_info_info_type_it1->vertex = &table_info_type;
    rai_info_info_type_it1->vertex_id = table_index_info_type_it1;
    rai_info_info_type_it1->passing_tables[0] = table_index_info_type_it1;
    rai_info_info_type_it1->left_cardinalities[0] = table_info_type.GetStorage().info->cardinality;
    // rai_info_info_type_it1->compact_list = &rai_info_info_type_it1->rai->alist->compact__list;

    join_condition_info_type_it1.rais.push_back(move(rai_info_info_type_it1));
    cond_info_type_it1.push_back(move(join_condition_info_type_it1));

    LogicalComparisonJoin join_info_type_it1_op(JoinType::INNER);
    vector<LogicalType> output_info_type_it1_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::BIGINT,
                                                   LogicalType::VARCHAR, LogicalType::VARCHAR, LogicalType::VARCHAR};
    join_info_type_it1_op.types = output_info_type_it1_types;
    vector<idx_t> right_projection_map_info_type_it1{0, 2, 4, 5};
    vector<idx_t> merge_project_map_info_type_it1;
    vector<LogicalType> delim_types_info_type_it1;
    auto join_info_type_it1 = make_uniq<PhysicalSIPJoin>(join_info_type_it1_op, move(scan_info_type_it1), move(join_movie_info_),
                                                         move(cond_info_type_it1), JoinType::INNER, left_projection_map,
                                                         right_projection_map_info_type_it1, delim_types_info_type_it1,
                                                         0);


    vector<idx_t> keyword_k_ids{COLUMN_IDENTIFIER_ROW_ID, 1};
    vector<LogicalType> get_keyword_k_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_keyword_k = "k";
    vector<LogicalType> table_types_keyword_k;
    vector<unique_ptr<Expression>> filter_keyword_k;
    unique_ptr<LogicalGet> get_op_keyword_k = move(
            getLogicalGet(*this, table_keyword, alias_keyword_k, table_index_keyword_k, table_types_keyword_k));
    unique_ptr<TableFilterSet> table_filters_keyword_k = NULL;
    unique_ptr<PhysicalTableScan> scan_keyword_k = make_uniq<PhysicalTableScan>(get_keyword_k_types,
                                                                                get_op_keyword_k->function,
                                                                                get_op_keyword_k->table_index,
                                                                                move(get_op_keyword_k->bind_data),
                                                                                table_types_keyword_k, keyword_k_ids,
                                                                                move(filter_keyword_k),
                                                                                vector<column_t>(),
                                                                                get_op_keyword_k->names,
                                                                                std::move(table_filters_keyword_k),
                                                                                get_op_keyword_k->estimated_cardinality,
                                                                                get_op_keyword_k->extra_info);

    auto &allocator_k = Allocator::Get(context);
    vector<LogicalType> join_in_types_k {LogicalType::VARCHAR};
    auto collection_k =
            make_uniq<ColumnDataCollection>(context, join_in_types_k, ColumnDataAllocatorType::IN_MEMORY_ALLOCATOR);

    vector<LogicalType> chunk_in_types_k {LogicalType::VARCHAR};
    DataChunk chunk_k;
    chunk_k.SetCardinality(7);
    chunk_k.Initialize(allocator_k, chunk_in_types_k);
    chunk_k.SetValue(0, 0, Value("murder"));
    chunk_k.SetValue(0, 1, Value("violence"));
    chunk_k.SetValue(0, 2, Value("blood"));
    chunk_k.SetValue(0, 3, Value("gore"));
    chunk_k.SetValue(0, 4, Value("death"));
    chunk_k.SetValue(0, 5, Value("female-nudity"));
    chunk_k.SetValue(0, 6, Value("hospital"));
    collection_k->Append(chunk_k);

    // create a chunk scan to output the result
    vector<LogicalType> ouput_in_types_k {LogicalType::VARCHAR};
    auto chunk_scan_k = make_uniq<PhysicalColumnDataScan>(ouput_in_types_k, PhysicalOperatorType::COLUMN_DATA_SCAN,
                                                          7, std::move(collection_k));

    vector<JoinCondition> cond_hash_join_k;
    JoinCondition join_condition_hash_join_k;
    join_condition_hash_join_k.left = make_uniq<BoundReferenceExpression>("keyword", LogicalType::VARCHAR, 1);
    join_condition_hash_join_k.right = make_uniq<BoundReferenceExpression>("", LogicalType::VARCHAR, 0);
    join_condition_hash_join_k.comparison = ExpressionType::COMPARE_EQUAL;
    cond_hash_join_k.push_back(move(join_condition_hash_join_k));

    LogicalComparisonJoin join_hash_join_op_k(JoinType::MARK);
    vector<LogicalType> output_hash_join_types_k{LogicalType::BIGINT,
                                                 LogicalType::VARCHAR, LogicalType::BOOLEAN};
    join_hash_join_op_k.types = output_hash_join_types_k;
    vector<idx_t> right_projection_map_hash_join_k;
    vector<LogicalType> delim_types_hash_join_k;
    PerfectHashJoinStats joinstate_k;
    auto join_hash_join_k = make_uniq<PhysicalHashJoin>(join_hash_join_op_k, move(scan_keyword_k), move(chunk_scan_k), move(cond_hash_join_k),
                                                        JoinType::MARK, left_projection_map,
                                                        right_projection_map_hash_join_k,
                                                        delim_types_hash_join_k, 0, joinstate_k);

    vector<LogicalType> filter_in_types_k{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::BOOLEAN};
    vector<unique_ptr<Expression>> select_list_in_k;
    auto in_exp_k = make_uniq<BoundReferenceExpression>("IN (...)", LogicalType::BOOLEAN, 2);
    select_list_in_k.push_back(move(in_exp_k));
    unique_ptr<PhysicalFilter> filter_in_k = make_uniq<PhysicalFilter>(filter_in_types_k, move(select_list_in_k), 0);
    filter_in_k->children.push_back(move(join_hash_join_k));


    vector<JoinCondition> cond_keyword_k;
    JoinCondition join_condition_keyword_k;
    join_condition_keyword_k.left = make_uniq<BoundReferenceExpression>("keyword_rowid", LogicalType::BIGINT, 0);
    join_condition_keyword_k.right = make_uniq<BoundReferenceExpression>("movie_id_rowid", LogicalType::BIGINT, 2);
    join_condition_keyword_k.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_keyword_k = make_uniq<RAIInfo>();
    rai_info_keyword_k->rai = table_movie_keyword.GetStorage().info->rais[0].get();
    rai_info_keyword_k->rai_type = RAIType::SOURCE_EDGE;
    rai_info_keyword_k->forward = false;
    rai_info_keyword_k->vertex = &table_keyword;
    rai_info_keyword_k->vertex_id = table_index_keyword_k;
    rai_info_keyword_k->passing_tables[0] = table_index_keyword_k;
    rai_info_keyword_k->left_cardinalities[0] = table_keyword.GetStorage().info->cardinality;
    // rai_info_keyword_k->compact_list = &rai_info_keyword_k->rai->alist->compact__list;

    join_condition_keyword_k.rais.push_back(move(rai_info_keyword_k));
    cond_keyword_k.push_back(move(join_condition_keyword_k));

    LogicalComparisonJoin join_keyword_k_op(JoinType::INNER);
    vector<LogicalType> output_keyword_k_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::BOOLEAN,
                                               LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::VARCHAR,
                                               LogicalType::VARCHAR};
    join_keyword_k_op.types = output_keyword_k_types;
    vector<idx_t> right_projection_map_keyword_k{2, 3, 4, 5};
    vector<idx_t> merge_project_map_keyword_k;
    vector<LogicalType> delim_types_keyword_k;
    auto join_keyword_k = make_uniq<PhysicalMergeSIPJoin>(join_keyword_k_op, move(filter_in_k), move(join_info_type_it1), move(cond_keyword_k),
                                                     JoinType::INNER, left_projection_map,
                                                     right_projection_map_keyword_k,
                                                     merge_project_map_keyword_k,
                                                     delim_types_keyword_k, 0);

    vector<idx_t> cast_info_ids{4, 7, 8};
    vector<LogicalType> get_cast_info_types{LogicalType::VARCHAR, LogicalType::BIGINT, LogicalType::BIGINT};
    string alias_cast_info = "ci";
    vector<LogicalType> table_types_cast_info;
    vector<unique_ptr<Expression>> filter_cast_info;
    unique_ptr<LogicalGet> get_op_cast_info = move(
            getLogicalGet(*this, table_cast_info, alias_cast_info, table_index_cast_info_, table_types_cast_info));
    unique_ptr<TableFilterSet> table_filters_cast_info = NULL;
    unique_ptr<PhysicalTableScan> scan_cast_info = make_uniq<PhysicalTableScan>(get_cast_info_types,
                                                                                get_op_cast_info->function,
                                                                                get_op_cast_info->table_index,
                                                                                move(get_op_cast_info->bind_data),
                                                                                table_types_cast_info, cast_info_ids,
                                                                                move(filter_cast_info),
                                                                                vector<column_t>(),
                                                                                get_op_cast_info->names,
                                                                                std::move(table_filters_cast_info),
                                                                                get_op_cast_info->estimated_cardinality,
                                                                                get_op_cast_info->extra_info);

    auto &allocator_ci = Allocator::Get(context);
    vector<LogicalType> join_in_types_ci{LogicalType::VARCHAR};
    auto collection_ci =
            make_uniq<ColumnDataCollection>(context, join_in_types_ci, ColumnDataAllocatorType::IN_MEMORY_ALLOCATOR);

    vector<LogicalType> chunk_in_types_ci{LogicalType::VARCHAR};
    DataChunk chunk_ci;
    chunk_ci.SetCardinality(5);
    chunk_ci.Initialize(allocator_ci, chunk_in_types_ci);
    chunk_ci.SetValue(0, 0, Value("(writer)"));
    chunk_ci.SetValue(0, 1, Value("(head writer)"));
    chunk_ci.SetValue(0, 2, Value("(written by)"));
    chunk_ci.SetValue(0, 3, Value("(story)"));
    chunk_ci.SetValue(0, 4, Value("(story editor)"));
    collection_ci->Append(chunk_ci);

    // create a chunk scan to output the result
    vector<LogicalType> ouput_in_types_ci{LogicalType::VARCHAR};
    auto chunk_scan_ci = make_uniq<PhysicalColumnDataScan>(ouput_in_types_ci, PhysicalOperatorType::COLUMN_DATA_SCAN,
                                                        5, std::move(collection_ci));

    vector<JoinCondition> cond_hash_join__ci;
    JoinCondition join_condition_hash_join__ci;
    join_condition_hash_join__ci.left = make_uniq<BoundReferenceExpression>("note", LogicalType::VARCHAR, 0);
    join_condition_hash_join__ci.right = make_uniq<BoundReferenceExpression>("", LogicalType::VARCHAR, 0);
    join_condition_hash_join__ci.comparison = ExpressionType::COMPARE_EQUAL;
    cond_hash_join__ci.push_back(move(join_condition_hash_join__ci));

    LogicalComparisonJoin join_hash_join_op_ci(JoinType::MARK);
    vector<LogicalType> output_hash_join_types_ci{LogicalType::VARCHAR, LogicalType::BIGINT, LogicalType::BIGINT,
                                                  LogicalType::BOOLEAN};
    join_hash_join_op_ci.types = output_hash_join_types_ci;
    vector<idx_t> right_projection_map_hash_join__ci;
    vector<LogicalType> delim_types_hash_join__ci;
    PerfectHashJoinStats joinstate_ci;
    auto join_hash_join__ci = make_uniq<PhysicalHashJoin>(join_hash_join_op_ci, move(scan_cast_info), move(chunk_scan_ci),
                                                       move(cond_hash_join__ci),
                                                       JoinType::MARK, left_projection_map,
                                                       right_projection_map_hash_join__ci,
                                                       delim_types_hash_join__ci, 0, joinstate_ci);


    vector<LogicalType> filter_in_types_ci{LogicalType::VARCHAR, LogicalType::BIGINT, LogicalType::BIGINT,
                                           LogicalType::BOOLEAN};
    vector<unique_ptr<Expression>> select_list_in_ci;
    auto in_exp_ci = make_uniq<BoundReferenceExpression>("IN (...)", LogicalType::BOOLEAN, 3);
    select_list_in_ci.push_back(move(in_exp_ci));
    unique_ptr<PhysicalFilter> filter_in_ci = make_uniq<PhysicalFilter>(filter_in_types_ci, move(select_list_in_ci), 0);
    filter_in_ci->children.push_back(move(join_hash_join__ci));


    vector<JoinCondition> cond_cast_info_;
    JoinCondition join_condition_cast_info_;
    join_condition_cast_info_.left = make_uniq<BoundReferenceExpression>("movie_id_rowid", LogicalType::BIGINT, 1);
    join_condition_cast_info_.right = make_uniq<BoundReferenceExpression>("movie_id_rowid", LogicalType::BIGINT, 3);
    join_condition_cast_info_.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_cast_info_ = make_uniq<RAIInfo>();
    rai_info_cast_info_->rai = table_cast_info.GetStorage().info->rais[0].get();
    rai_info_cast_info_->rai_type = RAIType::EDGE_SOURCE;
    rai_info_cast_info_->forward = true;
    rai_info_cast_info_->vertex = &table_title;
    rai_info_cast_info_->vertex_id = table_index_title_t;
    rai_info_cast_info_->passing_tables[0] = table_index_cast_info_;
    rai_info_cast_info_->left_cardinalities[0] = table_cast_info.GetStorage().info->cardinality;
    rai_info_cast_info_->compact_list = &rai_info_cast_info_->rai->alist->compact_forward_list;

    join_condition_cast_info_.rais.push_back(move(rai_info_cast_info_));
    cond_cast_info_.push_back(move(join_condition_cast_info_));

    LogicalComparisonJoin join_cast_info__op(JoinType::INNER);
    vector<LogicalType> output_cast_info__types{LogicalType::VARCHAR, LogicalType::BIGINT, LogicalType::BIGINT,
                                                LogicalType::BOOLEAN, LogicalType::VARCHAR, LogicalType::VARCHAR, LogicalType::VARCHAR};
    join_cast_info__op.types = output_cast_info__types;
    vector<idx_t> right_projection_map_cast_info_{4, 5, 6};
    vector<idx_t> merge_project_map_cast_info_;
    vector<LogicalType> delim_types_cast_info_;
    auto join_cast_info_ = make_uniq<PhysicalSIPJoin>(join_cast_info__op, move(filter_in_ci), move(join_keyword_k), move(cond_cast_info_),
                                                           JoinType::INNER, left_projection_map,
                                                           right_projection_map_cast_info_,
                                                           delim_types_cast_info_, 0);

    vector<idx_t> name_n_ids{COLUMN_IDENTIFIER_ROW_ID, 1, 4};
    vector<LogicalType> get_name_n_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::VARCHAR};
    string alias_name_n = "n";
    vector<LogicalType> table_types_name_n;
    vector<unique_ptr<Expression>> filter_name_n;
    unique_ptr<LogicalGet> get_op_name_n = move(
            getLogicalGet(*this, table_name, alias_name_n, table_index_name_n, table_types_name_n));
    unique_ptr<TableFilterSet> table_filters_name_n = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_n = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL, Value("m"));
    table_filters_name_n->filters[2] = move(constant_filter_n);
    unique_ptr<PhysicalTableScan> scan_name_n = make_uniq<PhysicalTableScan>(get_name_n_types, get_op_name_n->function,
                                                                             get_op_name_n->table_index,
                                                                             move(get_op_name_n->bind_data),
                                                                             table_types_name_n, name_n_ids,
                                                                             move(filter_name_n), vector<column_t>(),
                                                                             get_op_name_n->names,
                                                                             std::move(table_filters_name_n),
                                                                             get_op_name_n->estimated_cardinality,
                                                                             get_op_name_n->extra_info);


    vector<JoinCondition> cond_name_n;
    JoinCondition join_condition_name_n;
    join_condition_name_n.left = make_uniq<BoundReferenceExpression>("name_rowid", LogicalType::BIGINT, 0);
    join_condition_name_n.right = make_uniq<BoundReferenceExpression>("person_id_rowid", LogicalType::BIGINT, 2);
    join_condition_name_n.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_name_n = make_uniq<RAIInfo>();
    rai_info_name_n->rai = table_cast_info.GetStorage().info->rais[0].get();
    rai_info_name_n->rai_type = RAIType::TARGET_EDGE;
    rai_info_name_n->forward = true;
    rai_info_name_n->vertex = &table_name;
    rai_info_name_n->vertex_id = table_index_name_n;
    rai_info_name_n->passing_tables[0] = table_index_name_n;
    rai_info_name_n->left_cardinalities[0] = table_name.GetStorage().info->cardinality;
    // rai_info_name_n->compact_list = &rai_info_name_n->rai->alist->compact__list;

    join_condition_name_n.rais.push_back(move(rai_info_name_n));
    cond_name_n.push_back(move(join_condition_name_n));

    LogicalComparisonJoin join_name_n_op(JoinType::INNER);
    vector<LogicalType> output_name_n_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::VARCHAR,
                                            LogicalType::VARCHAR, LogicalType::VARCHAR, LogicalType::VARCHAR};
    join_name_n_op.types = output_name_n_types;
    vector<idx_t> right_projection_map_name_n{4, 5, 6};
    vector<idx_t> merge_project_map_name_n;
    vector<LogicalType> delim_types_name_n;
    auto join_name_n = make_uniq<PhysicalSIPJoin>(join_name_n_op, move(scan_name_n), move(join_cast_info_), move(cond_name_n), JoinType::INNER,
                                                  left_projection_map, right_projection_map_name_n, delim_types_name_n,
                                                  0);


    vector<LogicalType> result_types{LogicalType::VARCHAR, LogicalType::VARCHAR, LogicalType::VARCHAR, LogicalType::VARCHAR};
    vector<unique_ptr<Expression>> select_list;
    auto result_col0 = make_uniq<BoundReferenceExpression>("info", LogicalType::VARCHAR, 3);
    auto result_col1 = make_uniq<BoundReferenceExpression>("info", LogicalType::VARCHAR, 4);
    auto result_col2 = make_uniq<BoundReferenceExpression>("name", LogicalType::VARCHAR, 1);
    auto result_col3 = make_uniq<BoundReferenceExpression>("title", LogicalType::VARCHAR, 5);
    select_list.push_back(move(result_col0));
    select_list.push_back(move(result_col1));
    select_list.push_back(move(result_col2));
    select_list.push_back(move(result_col3));
    auto projection = make_uniq<PhysicalProjection>(result_types, move(select_list), 0);
    projection->children.push_back(move(join_name_n));

    // aggregate
    string agg_name = "min";
    string agg_error = "";
    QueryErrorContext error_context(NULL, NULL);
    auto min_func = Catalog::GetEntry(context, CatalogType::SCALAR_FUNCTION_ENTRY, "", "",
                                      "min", OnEntryNotFound::RETURN_NULL, error_context);
    auto &min_func_set = min_func->Cast<AggregateFunctionCatalogEntry>();
    // bind the aggregate
    FunctionBinder function_binder(context);
    vector<LogicalType> types;
    types.push_back(LogicalType::VARCHAR);
    idx_t best_function_varchar = function_binder.BindFunction(agg_name, min_func_set.functions, types, agg_error);
    auto bound_function_min_varchar = min_func_set.functions.GetFunctionByOffset(best_function_varchar);
    // std::cout << best_function_varchar << " " << bound_function_min_varchar.return_type.ToString() << std::endl;

    auto first_children = make_uniq<BoundReferenceExpression>("info", LogicalType::VARCHAR, 0);
    vector<unique_ptr<Expression>> childrenlist1;
    childrenlist1.push_back(move(first_children));
    auto aggregate1 =
            function_binder.BindAggregateFunction(bound_function_min_varchar, std::move(childrenlist1), nullptr,
                                                  AggregateType::NON_DISTINCT);

    auto second_children = make_uniq<BoundReferenceExpression>("info", LogicalType::VARCHAR, 1);
    vector<unique_ptr<Expression>> childrenlist2;
    childrenlist2.push_back(move(second_children));
    auto aggregate2 =
            function_binder.BindAggregateFunction(bound_function_min_varchar, std::move(childrenlist2), nullptr,
                                                  AggregateType::NON_DISTINCT);

    auto third_children = make_uniq<BoundReferenceExpression>("name", LogicalType::VARCHAR, 2);
    vector<unique_ptr<Expression>> childrenlist3;
    childrenlist3.push_back(move(third_children));
    auto aggregate3 =
            function_binder.BindAggregateFunction(bound_function_min_varchar, std::move(childrenlist3), nullptr,
                                                  AggregateType::NON_DISTINCT);

    auto fourth_children = make_uniq<BoundReferenceExpression>("title", LogicalType::VARCHAR, 3);
    vector<unique_ptr<Expression>> childrenlist4;
    childrenlist4.push_back(move(fourth_children));
    auto aggregate4 =
            function_binder.BindAggregateFunction(bound_function_min_varchar, std::move(childrenlist4), nullptr,
                                                  AggregateType::NON_DISTINCT);

    vector<unique_ptr<Expression>> aggregates;
    aggregates.push_back(move(aggregate1));
    aggregates.push_back(move(aggregate2));
    aggregates.push_back(move(aggregate3));
    aggregates.push_back(move(aggregate4));

    vector<LogicalType> aggregate_types{LogicalType::VARCHAR, LogicalType::VARCHAR, LogicalType::VARCHAR, LogicalType::VARCHAR};
    auto ungrouped_aggregate = make_uniq<PhysicalUngroupedAggregate>(aggregate_types, move(aggregates), 0);
    ungrouped_aggregate->children.push_back(move(projection));

    return ungrouped_aggregate;
}

unique_ptr<PhysicalOperator> ClientContext::GenerateJOB31aPlan(duckdb::ClientContext &context) {
    vector<idx_t> left_projection_map, right_projection_map;

    string table_vertex_info_type_it1 = "info_type";
    string table_vertex_title_t = "title";
    string table_vertex_info_type_it2 = "info_type";
    string table_vertex_name_n = "name";
    string table_vertex_keyword_k = "keyword";
    string table_vertex_company_name_cn = "company_name";
    string table_vertex_movie_info_ = "movie_info";
    string table_vertex_movie_info_idx_ = "movie_info_idx";
    string table_vertex_cast_info_ = "cast_info";
    string table_vertex_movie_keyword_ = "movie_keyword";
    string table_vertex_movie_companies_ = "movie_companies";

    idx_t table_index_info_type_it1 = 1;
    idx_t table_index_title_t = 2;
    idx_t table_index_info_type_it2 = 3;
    idx_t table_index_name_n = 4;
    idx_t table_index_keyword_k = 5;
    idx_t table_index_company_name_cn = 6;
    idx_t table_index_movie_info_ = 7;
    idx_t table_index_movie_info_idx_ = 8;
    idx_t table_index_cast_info_ = 9;
    idx_t table_index_movie_keyword_ = 10;
    idx_t table_index_movie_companies_ = 11;
    auto table_or_view_info_type = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                     table_vertex_info_type_it1, OnEntryNotFound::RETURN_NULL);
    auto &table_info_type = table_or_view_info_type->Cast<TableCatalogEntry>();
    auto table_or_view_title = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_title_t,
                                                 OnEntryNotFound::RETURN_NULL);
    auto &table_title = table_or_view_title->Cast<TableCatalogEntry>();
    auto table_or_view_name = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_name_n,
                                                OnEntryNotFound::RETURN_NULL);
    auto &table_name = table_or_view_name->Cast<TableCatalogEntry>();
    auto table_or_view_keyword = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_keyword_k,
                                                   OnEntryNotFound::RETURN_NULL);
    auto &table_keyword = table_or_view_keyword->Cast<TableCatalogEntry>();
    auto table_or_view_company_name = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                        table_vertex_company_name_cn, OnEntryNotFound::RETURN_NULL);
    auto &table_company_name = table_or_view_company_name->Cast<TableCatalogEntry>();
    auto table_or_view_movie_info = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_movie_info_,
                                                      OnEntryNotFound::RETURN_NULL);
    auto &table_movie_info = table_or_view_movie_info->Cast<TableCatalogEntry>();
    auto table_or_view_movie_info_idx = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                          table_vertex_movie_info_idx_, OnEntryNotFound::RETURN_NULL);
    auto &table_movie_info_idx = table_or_view_movie_info_idx->Cast<TableCatalogEntry>();
    auto table_or_view_cast_info = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_cast_info_,
                                                     OnEntryNotFound::RETURN_NULL);
    auto &table_cast_info = table_or_view_cast_info->Cast<TableCatalogEntry>();
    auto table_or_view_movie_keyword = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                         table_vertex_movie_keyword_, OnEntryNotFound::RETURN_NULL);
    auto &table_movie_keyword = table_or_view_movie_keyword->Cast<TableCatalogEntry>();
    auto table_or_view_movie_companies = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                           table_vertex_movie_companies_, OnEntryNotFound::RETURN_NULL);
    auto &table_movie_companies = table_or_view_movie_companies->Cast<TableCatalogEntry>();

    vector<idx_t> info_type_it2_ids{COLUMN_IDENTIFIER_ROW_ID, 1};
    vector<LogicalType> get_info_type_it2_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_info_type_it2 = "it2";
    vector<LogicalType> table_types_info_type_it2;
    vector<unique_ptr<Expression>> filter_info_type_it2;
    unique_ptr<LogicalGet> get_op_info_type_it2 = move(
            getLogicalGet(*this, table_info_type, alias_info_type_it2, table_index_info_type_it2,
                          table_types_info_type_it2));
    unique_ptr<TableFilterSet> table_filters_info_type_it2 = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_it2 = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL, Value("votes"));
    table_filters_info_type_it2->filters[1] = move(constant_filter_it2);
    unique_ptr<PhysicalTableScan> scan_info_type_it2 = make_uniq<PhysicalTableScan>(get_info_type_it2_types,
                                                                                    get_op_info_type_it2->function,
                                                                                    get_op_info_type_it2->table_index,
                                                                                    move(get_op_info_type_it2->bind_data),
                                                                                    table_types_info_type_it2,
                                                                                    info_type_it2_ids,
                                                                                    move(filter_info_type_it2),
                                                                                    vector<column_t>(),
                                                                                    get_op_info_type_it2->names,
                                                                                    std::move(
                                                                                            table_filters_info_type_it2),
                                                                                    get_op_info_type_it2->estimated_cardinality,
                                                                                    get_op_info_type_it2->extra_info);

    vector<idx_t> movie_info_idx_ids{6, 5, 3};
    vector<LogicalType> get_movie_info_idx_type{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_movie_info_idx = "mi";
    vector<LogicalType> table_types_movie_info_idx;
    vector<unique_ptr<Expression>> filter_movie_info_idx;
    unique_ptr<LogicalGet> get_op_movie_info_idx = move(
            getLogicalGet(*this, table_movie_info_idx, alias_movie_info_idx, table_index_movie_info_idx_, table_types_movie_info_idx));
    unique_ptr<TableFilterSet> table_filters_movie_info_idx = NULL;
    unique_ptr<PhysicalTableScan> scan_movie_info_idx = make_uniq<PhysicalTableScan>(get_movie_info_idx_type,
                                                                                     get_op_movie_info_idx->function,
                                                                                     get_op_movie_info_idx->table_index,
                                                                                     move(get_op_movie_info_idx->bind_data),
                                                                                     table_types_movie_info_idx, movie_info_idx_ids,
                                                                                     move(filter_movie_info_idx),
                                                                                     vector<column_t>(),
                                                                                     get_op_movie_info_idx->names,
                                                                                     std::move(table_filters_movie_info_idx),
                                                                                     get_op_movie_info_idx->estimated_cardinality,
                                                                                     get_op_movie_info_idx->extra_info);

    vector<JoinCondition> cond_movie_info_idx;
    JoinCondition join_condition_movie_info_idx;
    join_condition_movie_info_idx.left = make_uniq<BoundReferenceExpression>("info_type_id_rowid", LogicalType::BIGINT, 1);
    join_condition_movie_info_idx.right = make_uniq<BoundReferenceExpression>("info_type_rowid", LogicalType::BIGINT, 0);
    join_condition_movie_info_idx.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_movie_info_idx = make_uniq<RAIInfo>();
    rai_info_movie_info_idx->rai = table_movie_info_idx.GetStorage().info->rais[0].get();
    rai_info_movie_info_idx->rai_type = RAIType::EDGE_SOURCE;
    rai_info_movie_info_idx->forward = true;
    rai_info_movie_info_idx->vertex = &table_info_type;
    rai_info_movie_info_idx->vertex_id = table_index_info_type_it2;
    rai_info_movie_info_idx->passing_tables[0] = table_index_movie_info_idx_;
    rai_info_movie_info_idx->left_cardinalities[0] = table_movie_info_idx.GetStorage().info->cardinality;
    rai_info_movie_info_idx->compact_list = &rai_info_movie_info_idx->rai->alist->compact_forward_list;

    join_condition_movie_info_idx.rais.push_back(move(rai_info_movie_info_idx));
    cond_movie_info_idx.push_back(move(join_condition_movie_info_idx));

    LogicalComparisonJoin join_movie_info_idx_op(JoinType::INNER);
    vector<LogicalType> output_movie_info_idx_types{LogicalType::BIGINT, LogicalType::BIGINT,
                                                    LogicalType::VARCHAR, LogicalType::BIGINT};
    join_movie_info_idx_op.types = output_movie_info_idx_types;
    vector<idx_t> right_projection_map_movie_info_idx{0};
    vector<LogicalType> delim_types_movie_info_idx;
    auto join_movie_info_idx = make_uniq<PhysicalSIPJoin>(join_movie_info_idx_op, move(scan_movie_info_idx), move(scan_info_type_it2),
                                                          move(cond_movie_info_idx),
                                                          JoinType::INNER, left_projection_map,
                                                          right_projection_map_movie_info_idx,
                                                          delim_types_movie_info_idx, 0);


    vector<idx_t> title_t_ids{COLUMN_IDENTIFIER_ROW_ID, 1};
    vector<LogicalType> get_title_t_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_title_t = "t";
    vector<LogicalType> table_types_title_t;
    vector<unique_ptr<Expression>> filter_title_t;
    unique_ptr<LogicalGet> get_op_title_t = move(
            getLogicalGet(*this, table_title, alias_title_t, table_index_title_t, table_types_title_t));
    unique_ptr<TableFilterSet> table_filters_title_t = NULL;
    unique_ptr<PhysicalTableScan> scan_title_t = make_uniq<PhysicalTableScan>(get_title_t_types,
                                                                              get_op_title_t->function,
                                                                              get_op_title_t->table_index,
                                                                              move(get_op_title_t->bind_data),
                                                                              table_types_title_t, title_t_ids,
                                                                              move(filter_title_t), vector<column_t>(),
                                                                              get_op_title_t->names,
                                                                              std::move(table_filters_title_t),
                                                                              get_op_title_t->estimated_cardinality,
                                                                              get_op_title_t->extra_info);


    vector<JoinCondition> cond_movie_info_idx_;
    JoinCondition join_condition_movie_info_idx_;
    join_condition_movie_info_idx_.left = make_uniq<BoundReferenceExpression>("title_rowid", LogicalType::BIGINT, 0);
    join_condition_movie_info_idx_.right = make_uniq<BoundReferenceExpression>("movie_id_rowid", LogicalType::BIGINT, 0);
    join_condition_movie_info_idx_.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_movie_info_idx_ = make_uniq<RAIInfo>();
    rai_info_movie_info_idx_->rai = table_movie_info_idx.GetStorage().info->rais[0].get();
    rai_info_movie_info_idx_->rai_type = RAIType::TARGET_EDGE;
    rai_info_movie_info_idx_->forward = true;
    rai_info_movie_info_idx_->vertex = &table_title;
    rai_info_movie_info_idx_->vertex_id = table_index_title_t;
    rai_info_movie_info_idx_->passing_tables[0] = table_index_title_t;
    rai_info_movie_info_idx_->left_cardinalities[0] = table_title.GetStorage().info->cardinality;
    // rai_info_movie_info_idx_->compact_list = &rai_info_movie_info_idx_->rai->alist->compact__list;

    join_condition_movie_info_idx_.rais.push_back(move(rai_info_movie_info_idx_));
    cond_movie_info_idx_.push_back(move(join_condition_movie_info_idx_));

    LogicalComparisonJoin join_movie_info_idx__op(JoinType::INNER);
    vector<LogicalType> output_movie_info_idx__types{LogicalType::BIGINT, LogicalType::VARCHAR,
                                                     LogicalType::VARCHAR};
    join_movie_info_idx__op.types = output_movie_info_idx__types;
    vector<idx_t> right_projection_map_movie_info_idx_{2};
    vector<idx_t> merge_project_map_movie_info_idx_;
    vector<LogicalType> delim_types_movie_info_idx_;
    auto join_movie_info_idx_ = make_uniq<PhysicalSIPJoin>(join_movie_info_idx__op, move(scan_title_t), move(join_movie_info_idx),
                                                                move(cond_movie_info_idx_), JoinType::INNER,
                                                                left_projection_map,
                                                                right_projection_map_movie_info_idx_,
                                                                delim_types_movie_info_idx_, 0);

    vector<idx_t> movie_info_ids{6, 5, 3};
    vector<LogicalType> get_movie_info_types{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_movie_info = "i";
    vector<LogicalType> table_types_movie_info;
    vector<unique_ptr<Expression>> filter_movie_info;
    unique_ptr<LogicalGet> get_op_movie_info = move(
            getLogicalGet(*this, table_movie_info, alias_movie_info, table_index_movie_info_, table_types_movie_info));
    unique_ptr<TableFilterSet> table_filters_movie_info = NULL;
    unique_ptr<PhysicalTableScan> scan_movie_info = make_uniq<PhysicalTableScan>(get_movie_info_types,
                                                                                 get_op_movie_info->function,
                                                                                 get_op_movie_info->table_index,
                                                                                 move(get_op_movie_info->bind_data),
                                                                                 table_types_movie_info,
                                                                                 movie_info_ids,
                                                                                 move(filter_movie_info),
                                                                                 vector<column_t>(),
                                                                                 get_op_movie_info->names,
                                                                                 std::move(table_filters_movie_info),
                                                                                 get_op_movie_info->estimated_cardinality,
                                                                                 get_op_movie_info->extra_info);

    auto &allocator_mi = Allocator::Get(context);
    vector<LogicalType> join_in_types_mi {LogicalType::VARCHAR};
    auto collection_mi =
            make_uniq<ColumnDataCollection>(context, join_in_types_mi, ColumnDataAllocatorType::IN_MEMORY_ALLOCATOR);

    vector<LogicalType> chunk_in_types_mi {LogicalType::VARCHAR};
    DataChunk chunk_mi;
    chunk_mi.SetCardinality(2);
    chunk_mi.Initialize(allocator_mi, chunk_in_types_mi);
    chunk_mi.SetValue(0, 0, Value("Horror"));
    chunk_mi.SetValue(0, 1, Value("Thriller"));
    collection_mi->Append(chunk_mi);

    // create a chunk scan to output the result
    vector<LogicalType> ouput_in_types_mi {LogicalType::VARCHAR};
    auto chunk_scan_mi = make_uniq<PhysicalColumnDataScan>(ouput_in_types_mi, PhysicalOperatorType::COLUMN_DATA_SCAN,
                                                           2, std::move(collection_mi));

    vector<JoinCondition> cond_hash_join_mi;
    JoinCondition join_condition_hash_join_mi;
    join_condition_hash_join_mi.left = make_uniq<BoundReferenceExpression>("info", LogicalType::VARCHAR, 2);
    join_condition_hash_join_mi.right = make_uniq<BoundReferenceExpression>("", LogicalType::VARCHAR, 0);
    join_condition_hash_join_mi.comparison = ExpressionType::COMPARE_EQUAL;
    cond_hash_join_mi.push_back(move(join_condition_hash_join_mi));

    LogicalComparisonJoin join_hash_join_op_mi(JoinType::MARK);
    vector<LogicalType> output_hash_join_types_mi{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::BOOLEAN};
    join_hash_join_op_mi.types = output_hash_join_types_mi;
    vector<idx_t> right_projection_map_hash_join_mi;
    vector<LogicalType> delim_types_hash_join_mi;
    PerfectHashJoinStats joinstate_mi;
    auto join_hash_join_mi = make_uniq<PhysicalHashJoin>(join_hash_join_op_mi, move(scan_movie_info), move(chunk_scan_mi), move(cond_hash_join_mi),
                                                         JoinType::MARK, left_projection_map,
                                                         right_projection_map_hash_join_mi,
                                                         delim_types_hash_join_mi, 0, joinstate_mi);

    vector<LogicalType> filter_in_types_mi{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::BOOLEAN};
    vector<unique_ptr<Expression>> select_list_in_mi;
    auto in_exp_mi = make_uniq<BoundReferenceExpression>("IN (...)", LogicalType::BOOLEAN, 3);
    select_list_in_mi.push_back(move(in_exp_mi));
    unique_ptr<PhysicalFilter> filter_in_mi = make_uniq<PhysicalFilter>(filter_in_types_mi, move(select_list_in_mi), 0);
    filter_in_mi->children.push_back(move(join_hash_join_mi));

    vector<JoinCondition> cond_movie_info_;
    JoinCondition join_condition_movie_info_;
    join_condition_movie_info_.left = make_uniq<BoundReferenceExpression>("movie_id_rowid", LogicalType::BIGINT, 0);
    join_condition_movie_info_.right = make_uniq<BoundReferenceExpression>("title_rowid", LogicalType::BIGINT, 0);
    join_condition_movie_info_.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_movie_info_ = make_uniq<RAIInfo>();
    rai_info_movie_info_->rai = table_movie_info.GetStorage().info->rais[0].get();
    rai_info_movie_info_->rai_type = RAIType::EDGE_TARGET;
    rai_info_movie_info_->forward = false;
    rai_info_movie_info_->vertex = &table_title;
    rai_info_movie_info_->vertex_id = table_index_title_t;
    rai_info_movie_info_->passing_tables[0] = table_index_movie_info_;
    rai_info_movie_info_->left_cardinalities[0] = table_movie_info.GetStorage().info->cardinality;
    rai_info_movie_info_->compact_list = &rai_info_movie_info_->rai->alist->compact_backward_list;

    join_condition_movie_info_.rais.push_back(move(rai_info_movie_info_));
    cond_movie_info_.push_back(move(join_condition_movie_info_));

    LogicalComparisonJoin join_movie_info__op(JoinType::INNER);
    vector<LogicalType> output_movie_info__types{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::VARCHAR,
                                                 LogicalType::BOOLEAN, LogicalType::VARCHAR, LogicalType::VARCHAR};
    join_movie_info__op.types = output_movie_info__types;
    vector<idx_t> right_projection_map_movie_info_{1, 2};
    vector<idx_t> merge_project_map_movie_info_;
    vector<LogicalType> delim_types_movie_info_;
    auto join_movie_info_ = make_uniq<PhysicalSIPJoin>(join_movie_info__op, move(filter_in_mi), move(join_movie_info_idx_), move(cond_movie_info_),
                                                            JoinType::INNER, left_projection_map,
                                                            right_projection_map_movie_info_,
                                                            delim_types_movie_info_, 0);


    vector<idx_t> info_type_it1_ids{COLUMN_IDENTIFIER_ROW_ID, 1};
    vector<LogicalType> get_info_type_it1_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_info_type_it1 = "it1";
    vector<LogicalType> table_types_info_type_it1;
    vector<unique_ptr<Expression>> filter_info_type_it1;
    unique_ptr<LogicalGet> get_op_info_type_it1 = move(
            getLogicalGet(*this, table_info_type, alias_info_type_it1, table_index_info_type_it1,
                          table_types_info_type_it1));
    unique_ptr<TableFilterSet> table_filters_info_type_it1 = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_it1 = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL, Value("genres"));
    table_filters_info_type_it1->filters[1] = move(constant_filter_it1);
    unique_ptr<PhysicalTableScan> scan_info_type_it1 = make_uniq<PhysicalTableScan>(get_info_type_it1_types,
                                                                                    get_op_info_type_it1->function,
                                                                                    get_op_info_type_it1->table_index,
                                                                                    move(get_op_info_type_it1->bind_data),
                                                                                    table_types_info_type_it1,
                                                                                    info_type_it1_ids,
                                                                                    move(filter_info_type_it1),
                                                                                    vector<column_t>(),
                                                                                    get_op_info_type_it1->names,
                                                                                    std::move(
                                                                                            table_filters_info_type_it1),
                                                                                    get_op_info_type_it1->estimated_cardinality,
                                                                                    get_op_info_type_it1->extra_info);


    vector<JoinCondition> cond_info_type_it1;
    JoinCondition join_condition_info_type_it1;
    join_condition_info_type_it1.left = make_uniq<BoundReferenceExpression>("info_type_rowid", LogicalType::BIGINT, 0);
    join_condition_info_type_it1.right = make_uniq<BoundReferenceExpression>("info_type_id_rowid", LogicalType::BIGINT, 1);
    join_condition_info_type_it1.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_info_type_it1 = make_uniq<RAIInfo>();
    rai_info_info_type_it1->rai = table_movie_info.GetStorage().info->rais[0].get();
    rai_info_info_type_it1->rai_type = RAIType::SOURCE_EDGE;
    rai_info_info_type_it1->forward = false;
    rai_info_info_type_it1->vertex = &table_info_type;
    rai_info_info_type_it1->vertex_id = table_index_info_type_it1;
    rai_info_info_type_it1->passing_tables[0] = table_index_info_type_it1;
    rai_info_info_type_it1->left_cardinalities[0] = table_info_type.GetStorage().info->cardinality;
    // rai_info_info_type_it1->compact_list = &rai_info_info_type_it1->rai->alist->compact__list;

    join_condition_info_type_it1.rais.push_back(move(rai_info_info_type_it1));
    cond_info_type_it1.push_back(move(join_condition_info_type_it1));

    LogicalComparisonJoin join_info_type_it1_op(JoinType::INNER);
    vector<LogicalType> output_info_type_it1_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::BIGINT,
                                                   LogicalType::VARCHAR, LogicalType::VARCHAR, LogicalType::VARCHAR};
    join_info_type_it1_op.types = output_info_type_it1_types;
    vector<idx_t> right_projection_map_info_type_it1{0, 2, 4, 5};
    vector<idx_t> merge_project_map_info_type_it1;
    vector<LogicalType> delim_types_info_type_it1;
    auto join_info_type_it1 = make_uniq<PhysicalSIPJoin>(join_info_type_it1_op, move(scan_info_type_it1), move(join_movie_info_),
                                                         move(cond_info_type_it1), JoinType::INNER, left_projection_map,
                                                         right_projection_map_info_type_it1, delim_types_info_type_it1,
                                                         0);


    vector<idx_t> company_name_cn_ids{COLUMN_IDENTIFIER_ROW_ID, 1};
    vector<LogicalType> get_company_name_cn_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_company_name_cn = "cn";
    vector<LogicalType> table_types_company_name_cn;
    vector<unique_ptr<Expression>> filter_company_name_cn;
    unique_ptr<LogicalGet> get_op_company_name_cn = move(
            getLogicalGet(*this, table_company_name, alias_company_name_cn, table_index_company_name_cn,
                          table_types_company_name_cn));
    unique_ptr<TableFilterSet> table_filters_company_name_cn = NULL;
    unique_ptr<PhysicalTableScan> scan_company_name_cn = make_uniq<PhysicalTableScan>(get_company_name_cn_types,
                                                                                      get_op_company_name_cn->function,
                                                                                      get_op_company_name_cn->table_index,
                                                                                      move(get_op_company_name_cn->bind_data),
                                                                                      table_types_company_name_cn,
                                                                                      company_name_cn_ids,
                                                                                      move(filter_company_name_cn),
                                                                                      vector<column_t>(),
                                                                                      get_op_company_name_cn->names,
                                                                                      std::move(
                                                                                              table_filters_company_name_cn),
                                                                                      get_op_company_name_cn->estimated_cardinality,
                                                                                      get_op_company_name_cn->extra_info);


    vector<LogicalType> filter_name_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    vector<unique_ptr<Expression>> select_list_name;
    auto like_expression_left_name = make_uniq<BoundReferenceExpression>("name", LogicalType::VARCHAR, 1);
    auto like_expression_value_name = make_uniq<BoundConstantExpression>(Value("Lionsgate%"));
    vector<unique_ptr<Expression>> like_arguments_name;
    like_arguments_name.push_back(move(like_expression_left_name));
    like_arguments_name.push_back(move(like_expression_value_name));

    ScalarFunction bound_function_like = LikeFun::GetLikeFunction();
    unique_ptr<FunctionData> bind_data_contains = NULL;

    auto like_bound_function_name = make_uniq<BoundFunctionExpression>(LogicalType::BOOLEAN,
                                                                       bound_function_like,
                                                                       move(like_arguments_name),
                                                                       move(bind_data_contains), false);

    select_list_name.push_back(move(like_bound_function_name));
    unique_ptr<PhysicalFilter> filter_name_contains = make_uniq<PhysicalFilter>(filter_name_types, move(select_list_name), 0);
    filter_name_contains->children.push_back(move(scan_company_name_cn));


    vector<JoinCondition> cond_company_name_cn;
    JoinCondition join_condition_company_name_cn;
    join_condition_company_name_cn.left = make_uniq<BoundReferenceExpression>("company_name_rowid", LogicalType::BIGINT, 0);
    join_condition_company_name_cn.right = make_uniq<BoundReferenceExpression>("movie_id_rowid", LogicalType::BIGINT, 2);
    join_condition_company_name_cn.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_company_name_cn = make_uniq<RAIInfo>();
    rai_info_company_name_cn->rai = table_movie_companies.GetStorage().info->rais[0].get();
    rai_info_company_name_cn->rai_type = RAIType::SOURCE_EDGE;
    rai_info_company_name_cn->forward = false;
    rai_info_company_name_cn->vertex = &table_company_name;
    rai_info_company_name_cn->vertex_id = table_index_company_name_cn;
    rai_info_company_name_cn->passing_tables[0] = table_index_company_name_cn;
    rai_info_company_name_cn->left_cardinalities[0] = table_company_name.GetStorage().info->cardinality;
    // rai_info_company_name_cn->compact_list = &rai_info_company_name_cn->rai->alist->compact__list;

    join_condition_company_name_cn.rais.push_back(move(rai_info_company_name_cn));
    cond_company_name_cn.push_back(move(join_condition_company_name_cn));

    LogicalComparisonJoin join_company_name_cn_op(JoinType::INNER);
    vector<LogicalType> output_company_name_cn_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::BIGINT,
                                                     LogicalType::VARCHAR, LogicalType::VARCHAR, LogicalType::VARCHAR};
    join_company_name_cn_op.types = output_company_name_cn_types;
    vector<idx_t> right_projection_map_company_name_cn{2, 3, 4, 5};
    vector<idx_t> merge_project_map_company_name_cn;
    vector<LogicalType> delim_types_company_name_cn;
    auto join_company_name_cn = make_uniq<PhysicalMergeSIPJoin>(join_company_name_cn_op, move(filter_name_contains), move(join_info_type_it1),
                                                           move(cond_company_name_cn), JoinType::INNER,
                                                           left_projection_map, right_projection_map_company_name_cn,
                                                           merge_project_map_company_name_cn,
                                                           delim_types_company_name_cn, 0);

    vector<idx_t> keyword_k_ids{COLUMN_IDENTIFIER_ROW_ID, 1};
    vector<LogicalType> get_keyword_k_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_keyword_k = "k";
    vector<LogicalType> table_types_keyword_k;
    vector<unique_ptr<Expression>> filter_keyword_k;
    unique_ptr<LogicalGet> get_op_keyword_k = move(
            getLogicalGet(*this, table_keyword, alias_keyword_k, table_index_keyword_k, table_types_keyword_k));
    unique_ptr<TableFilterSet> table_filters_keyword_k = NULL;
    unique_ptr<PhysicalTableScan> scan_keyword_k = make_uniq<PhysicalTableScan>(get_keyword_k_types,
                                                                                get_op_keyword_k->function,
                                                                                get_op_keyword_k->table_index,
                                                                                move(get_op_keyword_k->bind_data),
                                                                                table_types_keyword_k, keyword_k_ids,
                                                                                move(filter_keyword_k),
                                                                                vector<column_t>(),
                                                                                get_op_keyword_k->names,
                                                                                std::move(table_filters_keyword_k),
                                                                                get_op_keyword_k->estimated_cardinality,
                                                                                get_op_keyword_k->extra_info);

    auto &allocator_k = Allocator::Get(context);
    vector<LogicalType> join_in_types_k {LogicalType::VARCHAR};
    auto collection_k =
            make_uniq<ColumnDataCollection>(context, join_in_types_k, ColumnDataAllocatorType::IN_MEMORY_ALLOCATOR);

    vector<LogicalType> chunk_in_types_k {LogicalType::VARCHAR};
    DataChunk chunk_k;
    chunk_k.SetCardinality(7);
    chunk_k.Initialize(allocator_k, chunk_in_types_k);
    chunk_k.SetValue(0, 0, Value("murder"));
    chunk_k.SetValue(0, 1, Value("violence"));
    chunk_k.SetValue(0, 2, Value("blood"));
    chunk_k.SetValue(0, 3, Value("gore"));
    chunk_k.SetValue(0, 4, Value("death"));
    chunk_k.SetValue(0, 5, Value("female-nudity"));
    chunk_k.SetValue(0, 6, Value("hospital"));
    collection_k->Append(chunk_k);

    // create a chunk scan to output the result
    vector<LogicalType> ouput_in_types_k {LogicalType::VARCHAR};
    auto chunk_scan_k = make_uniq<PhysicalColumnDataScan>(ouput_in_types_k, PhysicalOperatorType::COLUMN_DATA_SCAN,
                                                          7, std::move(collection_k));

    vector<JoinCondition> cond_hash_join_k;
    JoinCondition join_condition_hash_join_k;
    join_condition_hash_join_k.left = make_uniq<BoundReferenceExpression>("keyword", LogicalType::VARCHAR, 1);
    join_condition_hash_join_k.right = make_uniq<BoundReferenceExpression>("", LogicalType::VARCHAR, 0);
    join_condition_hash_join_k.comparison = ExpressionType::COMPARE_EQUAL;
    cond_hash_join_k.push_back(move(join_condition_hash_join_k));

    LogicalComparisonJoin join_hash_join_op_k(JoinType::MARK);
    vector<LogicalType> output_hash_join_types_k{LogicalType::BIGINT,
                                                 LogicalType::VARCHAR, LogicalType::BOOLEAN};
    join_hash_join_op_k.types = output_hash_join_types_k;
    vector<idx_t> right_projection_map_hash_join_k;
    vector<LogicalType> delim_types_hash_join_k;
    PerfectHashJoinStats joinstate_k;
    auto join_hash_join_k = make_uniq<PhysicalHashJoin>(join_hash_join_op_k, move(scan_keyword_k), move(chunk_scan_k), move(cond_hash_join_k),
                                                        JoinType::MARK, left_projection_map,
                                                        right_projection_map_hash_join_k,
                                                        delim_types_hash_join_k, 0, joinstate_k);

    vector<LogicalType> filter_in_types_k{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::BOOLEAN};
    vector<unique_ptr<Expression>> select_list_in_k;
    auto in_exp_k = make_uniq<BoundReferenceExpression>("IN (...)", LogicalType::BOOLEAN, 2);
    select_list_in_k.push_back(move(in_exp_k));
    unique_ptr<PhysicalFilter> filter_in_k = make_uniq<PhysicalFilter>(filter_in_types_k, move(select_list_in_k), 0);
    filter_in_k->children.push_back(move(join_hash_join_k));


    vector<JoinCondition> cond_keyword_k;
    JoinCondition join_condition_keyword_k;
    join_condition_keyword_k.left = make_uniq<BoundReferenceExpression>("keyword_rowid", LogicalType::BIGINT, 0);
    join_condition_keyword_k.right = make_uniq<BoundReferenceExpression>("movie_id_rowid", LogicalType::BIGINT, 2);
    join_condition_keyword_k.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_keyword_k = make_uniq<RAIInfo>();
    rai_info_keyword_k->rai = table_movie_keyword.GetStorage().info->rais[0].get();
    rai_info_keyword_k->rai_type = RAIType::SOURCE_EDGE;
    rai_info_keyword_k->forward = false;
    rai_info_keyword_k->vertex = &table_keyword;
    rai_info_keyword_k->vertex_id = table_index_keyword_k;
    rai_info_keyword_k->passing_tables[0] = table_index_keyword_k;
    rai_info_keyword_k->left_cardinalities[0] = table_keyword.GetStorage().info->cardinality;
    // rai_info_keyword_k->compact_list = &rai_info_keyword_k->rai->alist->compact__list;

    join_condition_keyword_k.rais.push_back(move(rai_info_keyword_k));
    cond_keyword_k.push_back(move(join_condition_keyword_k));

    LogicalComparisonJoin join_keyword_k_op(JoinType::INNER);
    vector<LogicalType> output_keyword_k_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::BOOLEAN,
                                               LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::VARCHAR,
                                               LogicalType::VARCHAR};
    join_keyword_k_op.types = output_keyword_k_types;
    vector<idx_t> right_projection_map_keyword_k{2, 3, 4, 5};
    vector<idx_t> merge_project_map_keyword_k;
    vector<LogicalType> delim_types_keyword_k;
    auto join_keyword_k = make_uniq<PhysicalMergeSIPJoin>(join_keyword_k_op, move(filter_in_k), move(join_company_name_cn), move(cond_keyword_k),
                                                     JoinType::INNER, left_projection_map,
                                                     right_projection_map_keyword_k,
                                                     merge_project_map_keyword_k,
                                                     delim_types_keyword_k, 0);

    vector<idx_t> cast_info_ids{4, 7, 8};
    vector<LogicalType> get_cast_info_types{LogicalType::VARCHAR, LogicalType::BIGINT, LogicalType::BIGINT};
    string alias_cast_info = "ci";
    vector<LogicalType> table_types_cast_info;
    vector<unique_ptr<Expression>> filter_cast_info;
    unique_ptr<LogicalGet> get_op_cast_info = move(
            getLogicalGet(*this, table_cast_info, alias_cast_info, table_index_cast_info_, table_types_cast_info));
    unique_ptr<TableFilterSet> table_filters_cast_info = NULL;
    unique_ptr<PhysicalTableScan> scan_cast_info = make_uniq<PhysicalTableScan>(get_cast_info_types,
                                                                                get_op_cast_info->function,
                                                                                get_op_cast_info->table_index,
                                                                                move(get_op_cast_info->bind_data),
                                                                                table_types_cast_info, cast_info_ids,
                                                                                move(filter_cast_info),
                                                                                vector<column_t>(),
                                                                                get_op_cast_info->names,
                                                                                std::move(table_filters_cast_info),
                                                                                get_op_cast_info->estimated_cardinality,
                                                                                get_op_cast_info->extra_info);

    auto &allocator = Allocator::Get(context);
    vector<LogicalType> join_in_types{LogicalType::VARCHAR};
    auto collection =
            make_uniq<ColumnDataCollection>(context, join_in_types, ColumnDataAllocatorType::IN_MEMORY_ALLOCATOR);

    vector<LogicalType> chunk_in_types{LogicalType::VARCHAR};
    DataChunk chunk;
    chunk.SetCardinality(5);
    chunk.Initialize(allocator, chunk_in_types);
    chunk.SetValue(0, 0, Value("(writer)"));
    chunk.SetValue(0, 1, Value("(head writer)"));
    chunk.SetValue(0, 2, Value("(written by)"));
    chunk.SetValue(0, 3, Value("(story)"));
    chunk.SetValue(0, 4, Value("(story editor)"));
    collection->Append(chunk);

    // create a chunk scan to output the result
    vector<LogicalType> ouput_in_types{LogicalType::VARCHAR};
    auto chunk_scan = make_uniq<PhysicalColumnDataScan>(ouput_in_types, PhysicalOperatorType::COLUMN_DATA_SCAN,
                                                        5, std::move(collection));

    vector<JoinCondition> cond_hash_join_;
    JoinCondition join_condition_hash_join_;
    join_condition_hash_join_.left = make_uniq<BoundReferenceExpression>("note", LogicalType::VARCHAR, 0);
    join_condition_hash_join_.right = make_uniq<BoundReferenceExpression>("", LogicalType::VARCHAR, 0);
    join_condition_hash_join_.comparison = ExpressionType::COMPARE_EQUAL;
    cond_hash_join_.push_back(move(join_condition_hash_join_));

    LogicalComparisonJoin join_hash_join_op(JoinType::MARK);
    vector<LogicalType> output_hash_join_types{LogicalType::VARCHAR, LogicalType::BIGINT, LogicalType::BIGINT,
                                               LogicalType::BOOLEAN};
    join_hash_join_op.types = output_hash_join_types;
    vector<idx_t> right_projection_map_hash_join_;
    vector<LogicalType> delim_types_hash_join_;
    PerfectHashJoinStats joinstate;
    auto join_hash_join_ = make_uniq<PhysicalHashJoin>(join_hash_join_op, move(scan_cast_info), move(chunk_scan),
                                                       move(cond_hash_join_),
                                                       JoinType::MARK, left_projection_map,
                                                       right_projection_map_hash_join_,
                                                       delim_types_hash_join_, 0, joinstate);


    vector<LogicalType> filter_in_types{LogicalType::VARCHAR, LogicalType::BIGINT, LogicalType::BIGINT,
                                        LogicalType::BOOLEAN};
    vector<unique_ptr<Expression>> select_list_in;
    auto in_exp = make_uniq<BoundReferenceExpression>("IN (...)", LogicalType::BOOLEAN, 3);
    select_list_in.push_back(move(in_exp));
    unique_ptr<PhysicalFilter> filter_in = make_uniq<PhysicalFilter>(filter_in_types, move(select_list_in), 0);
    filter_in->children.push_back(move(join_hash_join_));


    vector<JoinCondition> cond_cast_info_;
    JoinCondition join_condition_cast_info_;
    join_condition_cast_info_.left = make_uniq<BoundReferenceExpression>("movie_id_rowid", LogicalType::BIGINT, 1);
    join_condition_cast_info_.right = make_uniq<BoundReferenceExpression>("movie_id_rowid", LogicalType::BIGINT, 3);
    join_condition_cast_info_.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_cast_info_ = make_uniq<RAIInfo>();
    rai_info_cast_info_->rai = table_cast_info.GetStorage().info->rais[0].get();
    rai_info_cast_info_->rai_type = RAIType::EDGE_SOURCE;
    rai_info_cast_info_->forward = true;
    rai_info_cast_info_->vertex = &table_title;
    rai_info_cast_info_->vertex_id = table_index_title_t;
    rai_info_cast_info_->passing_tables[0] = table_index_cast_info_;
    rai_info_cast_info_->left_cardinalities[0] = table_cast_info.GetStorage().info->cardinality;
    rai_info_cast_info_->compact_list = &rai_info_cast_info_->rai->alist->compact_forward_list;

    join_condition_cast_info_.rais.push_back(move(rai_info_cast_info_));
    cond_cast_info_.push_back(move(join_condition_cast_info_));

    LogicalComparisonJoin join_cast_info__op(JoinType::INNER);
    vector<LogicalType> output_cast_info__types{LogicalType::VARCHAR, LogicalType::BIGINT, LogicalType::BIGINT,
                                                LogicalType::BOOLEAN, LogicalType::VARCHAR, LogicalType::VARCHAR,
                                                LogicalType::VARCHAR};
    join_cast_info__op.types = output_cast_info__types;
    vector<idx_t> right_projection_map_cast_info_{4, 5, 6};
    vector<idx_t> merge_project_map_cast_info_;
    vector<LogicalType> delim_types_cast_info_;
    auto join_cast_info_ = make_uniq<PhysicalSIPJoin>(join_cast_info__op, move(filter_in), move(join_keyword_k), move(cond_cast_info_),
                                                           JoinType::INNER, left_projection_map,
                                                           right_projection_map_cast_info_,
                                                           delim_types_cast_info_, 0);


    vector<idx_t> name_n_ids{COLUMN_IDENTIFIER_ROW_ID, 1, 4};
    vector<LogicalType> get_name_n_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::VARCHAR};
    string alias_name_n = "n";
    vector<LogicalType> table_types_name_n;
    vector<unique_ptr<Expression>> filter_name_n;
    unique_ptr<LogicalGet> get_op_name_n = move(
            getLogicalGet(*this, table_name, alias_name_n, table_index_name_n, table_types_name_n));
    unique_ptr<TableFilterSet> table_filters_name_n = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_n = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL, Value("m"));
    table_filters_name_n->filters[2] = move(constant_filter_n);
    unique_ptr<PhysicalTableScan> scan_name_n = make_uniq<PhysicalTableScan>(get_name_n_types, get_op_name_n->function,
                                                                             get_op_name_n->table_index,
                                                                             move(get_op_name_n->bind_data),
                                                                             table_types_name_n, name_n_ids,
                                                                             move(filter_name_n), vector<column_t>(),
                                                                             get_op_name_n->names,
                                                                             std::move(table_filters_name_n),
                                                                             get_op_name_n->estimated_cardinality,
                                                                             get_op_name_n->extra_info);


    vector<JoinCondition> cond_name_n;
    JoinCondition join_condition_name_n;
    join_condition_name_n.left = make_uniq<BoundReferenceExpression>("name_rowid", LogicalType::BIGINT, 0);
    join_condition_name_n.right = make_uniq<BoundReferenceExpression>("person_id_rowid", LogicalType::BIGINT, 2);
    join_condition_name_n.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_name_n = make_uniq<RAIInfo>();
    rai_info_name_n->rai = table_cast_info.GetStorage().info->rais[0].get();
    rai_info_name_n->rai_type = RAIType::TARGET_EDGE;
    rai_info_name_n->forward = true;
    rai_info_name_n->vertex = &table_name;
    rai_info_name_n->vertex_id = table_index_name_n;
    rai_info_name_n->passing_tables[0] = table_index_name_n;
    rai_info_name_n->left_cardinalities[0] = table_name.GetStorage().info->cardinality;
    // rai_info_name_n->compact_list = &rai_info_name_n->rai->alist->compact__list;

    join_condition_name_n.rais.push_back(move(rai_info_name_n));
    cond_name_n.push_back(move(join_condition_name_n));

    LogicalComparisonJoin join_name_n_op(JoinType::INNER);
    vector<LogicalType> output_name_n_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::VARCHAR,
                                            LogicalType::VARCHAR, LogicalType::VARCHAR, LogicalType::VARCHAR};
    join_name_n_op.types = output_name_n_types;
    vector<idx_t> right_projection_map_name_n{4, 5, 6};
    vector<idx_t> merge_project_map_name_n;
    vector<LogicalType> delim_types_name_n;
    auto join_name_n = make_uniq<PhysicalSIPJoin>(join_name_n_op, move(scan_name_n), move(join_cast_info_), move(cond_name_n), JoinType::INNER,
                                                  left_projection_map, right_projection_map_name_n, delim_types_name_n,
                                                  0);


    vector<LogicalType> result_types{LogicalType::VARCHAR, LogicalType::VARCHAR, LogicalType::VARCHAR, LogicalType::VARCHAR};
    vector<unique_ptr<Expression>> select_list;
    auto result_col0 = make_uniq<BoundReferenceExpression>("info", LogicalType::VARCHAR, 3);
    auto result_col1 = make_uniq<BoundReferenceExpression>("info", LogicalType::VARCHAR, 5);
    auto result_col2 = make_uniq<BoundReferenceExpression>("name", LogicalType::VARCHAR, 1);
    auto result_col3 = make_uniq<BoundReferenceExpression>("title", LogicalType::VARCHAR, 4);
    select_list.push_back(move(result_col0));
    select_list.push_back(move(result_col1));
    select_list.push_back(move(result_col2));
    select_list.push_back(move(result_col3));
    auto projection = make_uniq<PhysicalProjection>(result_types, move(select_list), 0);
    projection->children.push_back(move(join_name_n));

    // aggregate
    string agg_name = "min";
    string agg_error = "";
    QueryErrorContext error_context(NULL, NULL);
    auto min_func = Catalog::GetEntry(context, CatalogType::SCALAR_FUNCTION_ENTRY, "", "",
                                      "min", OnEntryNotFound::RETURN_NULL, error_context);
    auto &min_func_set = min_func->Cast<AggregateFunctionCatalogEntry>();
    // bind the aggregate
    FunctionBinder function_binder(context);
    vector<LogicalType> types;
    types.push_back(LogicalType::VARCHAR);
    idx_t best_function_varchar = function_binder.BindFunction(agg_name, min_func_set.functions, types, agg_error);
    auto bound_function_min_varchar = min_func_set.functions.GetFunctionByOffset(best_function_varchar);
    // std::cout << best_function_varchar << " " << bound_function_min_varchar.return_type.ToString() << std::endl;

    auto first_children = make_uniq<BoundReferenceExpression>("info", LogicalType::VARCHAR, 0);
    vector<unique_ptr<Expression>> childrenlist1;
    childrenlist1.push_back(move(first_children));
    auto aggregate1 =
            function_binder.BindAggregateFunction(bound_function_min_varchar, std::move(childrenlist1), nullptr,
                                                  AggregateType::NON_DISTINCT);

    auto second_children = make_uniq<BoundReferenceExpression>("info", LogicalType::VARCHAR, 1);
    vector<unique_ptr<Expression>> childrenlist2;
    childrenlist2.push_back(move(second_children));
    auto aggregate2 =
            function_binder.BindAggregateFunction(bound_function_min_varchar, std::move(childrenlist2), nullptr,
                                                  AggregateType::NON_DISTINCT);

    auto third_children = make_uniq<BoundReferenceExpression>("name", LogicalType::VARCHAR, 2);
    vector<unique_ptr<Expression>> childrenlist3;
    childrenlist3.push_back(move(third_children));
    auto aggregate3 =
            function_binder.BindAggregateFunction(bound_function_min_varchar, std::move(childrenlist3), nullptr,
                                                  AggregateType::NON_DISTINCT);

    auto fourth_children = make_uniq<BoundReferenceExpression>("title", LogicalType::VARCHAR, 3);
    vector<unique_ptr<Expression>> childrenlist4;
    childrenlist4.push_back(move(fourth_children));
    auto aggregate4 =
            function_binder.BindAggregateFunction(bound_function_min_varchar, std::move(childrenlist4), nullptr,
                                                  AggregateType::NON_DISTINCT);

    vector<unique_ptr<Expression>> aggregates;
    aggregates.push_back(move(aggregate1));
    aggregates.push_back(move(aggregate2));
    aggregates.push_back(move(aggregate3));
    aggregates.push_back(move(aggregate4));

    vector<LogicalType> aggregate_types{LogicalType::VARCHAR, LogicalType::VARCHAR, LogicalType::VARCHAR, LogicalType::VARCHAR};
    auto ungrouped_aggregate = make_uniq<PhysicalUngroupedAggregate>(aggregate_types, move(aggregates), 0);
    ungrouped_aggregate->children.push_back(move(projection));

    return ungrouped_aggregate;
}

unique_ptr<PhysicalOperator> ClientContext::GenerateJOB32aPlan(duckdb::ClientContext &context) {
    vector<idx_t> left_projection_map, right_projection_map;

    string table_vertex_title_t1 = "title";
    string table_vertex_keyword_k = "keyword";
    string table_vertex_title_t2 = "title";
    string table_vertex_link_type_lt = "link_type";
    string table_vertex_movie_keyword_ = "movie_keyword";
    string table_vertex_movie_link_ = "movie_link";

    idx_t table_index_title_t1 = 1;
    idx_t table_index_keyword_k = 2;
    idx_t table_index_title_t2 = 3;
    idx_t table_index_link_type_lt = 4;
    idx_t table_index_movie_keyword_ = 5;
    idx_t table_index_movie_link_ = 7;

    auto table_or_view_title = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_title_t1,
                                                 OnEntryNotFound::RETURN_NULL);
    auto &table_title = table_or_view_title->Cast<TableCatalogEntry>();
    auto table_or_view_keyword = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_keyword_k,
                                                   OnEntryNotFound::RETURN_NULL);
    auto &table_keyword = table_or_view_keyword->Cast<TableCatalogEntry>();
    auto table_or_view_link_type = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_link_type_lt,
                                                     OnEntryNotFound::RETURN_NULL);
    auto &table_link_type = table_or_view_link_type->Cast<TableCatalogEntry>();
    auto table_or_view_movie_keyword = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                         table_vertex_movie_keyword_, OnEntryNotFound::RETURN_NULL);
    auto &table_movie_keyword = table_or_view_movie_keyword->Cast<TableCatalogEntry>();
    auto table_or_view_movie_link = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_movie_link_,
                                                      OnEntryNotFound::RETURN_NULL);
    auto &table_movie_link = table_or_view_movie_link->Cast<TableCatalogEntry>();

    vector<idx_t> link_type_lt_ids{COLUMN_IDENTIFIER_ROW_ID, 1};
    vector<LogicalType> get_link_type_lt_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_link_type_lt = "lt";
    vector<LogicalType> table_types_link_type_lt;
    vector<unique_ptr<Expression>> filter_link_type_lt;
    unique_ptr<LogicalGet> get_op_link_type_lt = move(
            getLogicalGet(*this, table_link_type, alias_link_type_lt, table_index_link_type_lt,
                          table_types_link_type_lt));
    unique_ptr<TableFilterSet> table_filters_link_type_lt = NULL;
    unique_ptr<PhysicalTableScan> scan_link_type_lt = make_uniq<PhysicalTableScan>(get_link_type_lt_types,
                                                                                   get_op_link_type_lt->function,
                                                                                   get_op_link_type_lt->table_index,
                                                                                   move(get_op_link_type_lt->bind_data),
                                                                                   table_types_link_type_lt,
                                                                                   link_type_lt_ids,
                                                                                   move(filter_link_type_lt),
                                                                                   vector<column_t>(),
                                                                                   get_op_link_type_lt->names,
                                                                                   std::move(
                                                                                           table_filters_link_type_lt),
                                                                                   get_op_link_type_lt->estimated_cardinality,
                                                                                   get_op_link_type_lt->extra_info);

    vector<idx_t> movie_link_ml_ids{4, 5, 6};
    vector<LogicalType> get_movie_link_ml_types{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::BIGINT};
    string alias_movie_link_ml = "ml";
    vector<LogicalType> table_types_movie_link_ml;
    vector<unique_ptr<Expression>> filter_movie_link_ml;
    unique_ptr<LogicalGet> get_op_movie_link_ml = move(
            getLogicalGet(*this, table_movie_link, alias_movie_link_ml, table_index_movie_link_,
                          table_types_movie_link_ml));
    unique_ptr<TableFilterSet> table_filters_movie_link_ml = NULL;
    unique_ptr<PhysicalTableScan> scan_movie_link_ml = make_uniq<PhysicalTableScan>(get_movie_link_ml_types,
                                                                                   get_op_movie_link_ml->function,
                                                                                   get_op_movie_link_ml->table_index,
                                                                                   move(get_op_movie_link_ml->bind_data),
                                                                                   table_types_movie_link_ml,
                                                                                    movie_link_ml_ids,
                                                                                   move(filter_movie_link_ml),
                                                                                   vector<column_t>(),
                                                                                   get_op_movie_link_ml->names,
                                                                                   std::move(
                                                                                           table_filters_movie_link_ml),
                                                                                   get_op_movie_link_ml->estimated_cardinality,
                                                                                   get_op_movie_link_ml->extra_info);

    vector<JoinCondition> cond_movie_link_;
    JoinCondition join_condition_movie_link_;
    join_condition_movie_link_.left = make_uniq<BoundReferenceExpression>("link_type_id_rowid", LogicalType::BIGINT, 0);
    join_condition_movie_link_.right = make_uniq<BoundReferenceExpression>("link_type_rowid", LogicalType::BIGINT, 0);
    join_condition_movie_link_.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_movie_link_ = make_uniq<RAIInfo>();
    rai_info_movie_link_->rai = table_movie_link.GetStorage().info->rais[0].get();
    rai_info_movie_link_->rai_type = RAIType::EDGE_SOURCE;
    rai_info_movie_link_->forward = true;
    rai_info_movie_link_->vertex = &table_link_type;
    rai_info_movie_link_->vertex_id = table_index_link_type_lt;
    rai_info_movie_link_->passing_tables[0] = table_index_movie_link_;
    rai_info_movie_link_->left_cardinalities[0] = table_movie_link.GetStorage().info->cardinality;
    rai_info_movie_link_->compact_list = &rai_info_movie_link_->rai->alist->compact_forward_list;

    join_condition_movie_link_.rais.push_back(move(rai_info_movie_link_));
    cond_movie_link_.push_back(move(join_condition_movie_link_));

    LogicalComparisonJoin join_movie_link__op(JoinType::INNER);
    vector<LogicalType> output_movie_link__types{LogicalType::BIGINT, LogicalType::BIGINT,
                                                 LogicalType::BIGINT, LogicalType::VARCHAR};
    join_movie_link__op.types = output_movie_link__types;
    vector<idx_t> right_projection_map_movie_link_{1};
    vector<idx_t> merge_project_map_movie_link_;
    vector<LogicalType> delim_types_movie_link_;
    auto join_movie_link_ = make_uniq<PhysicalSIPJoin>(join_movie_link__op, move(scan_movie_link_ml), move(scan_link_type_lt), move(cond_movie_link_),
                                                            JoinType::INNER, left_projection_map,
                                                            right_projection_map_movie_link_,
                                                            delim_types_movie_link_, 0);

    vector<idx_t> title_t1_ids{COLUMN_IDENTIFIER_ROW_ID, 1};
    vector<LogicalType> get_title_t1_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_title_t1 = "t1";
    vector<LogicalType> table_types_title_t1;
    vector<unique_ptr<Expression>> filter_title_t1;
    unique_ptr<LogicalGet> get_op_title_t1 = move(
            getLogicalGet(*this, table_title, alias_title_t1, table_index_title_t1, table_types_title_t1));
    unique_ptr<TableFilterSet> table_filters_title_t1 = NULL;
    unique_ptr<PhysicalTableScan> scan_title_t1 = make_uniq<PhysicalTableScan>(get_title_t1_types,
                                                                               get_op_title_t1->function,
                                                                               get_op_title_t1->table_index,
                                                                               move(get_op_title_t1->bind_data),
                                                                               table_types_title_t1, title_t1_ids,
                                                                               move(filter_title_t1),
                                                                               vector<column_t>(),
                                                                               get_op_title_t1->names,
                                                                               std::move(table_filters_title_t1),
                                                                               get_op_title_t1->estimated_cardinality,
                                                                               get_op_title_t1->extra_info);

    vector<JoinCondition> cond_title_t1;
    JoinCondition join_condition_title_t1;
    join_condition_title_t1.left = make_uniq<BoundReferenceExpression>("title_rowid", LogicalType::BIGINT, 0);
    join_condition_title_t1.right = make_uniq<BoundReferenceExpression>("movie_id_rowid", LogicalType::BIGINT, 1);
    join_condition_title_t1.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_title_t1 = make_uniq<RAIInfo>();
    rai_info_title_t1->rai = table_movie_link.GetStorage().info->rais[0].get();
    rai_info_title_t1->rai_type = RAIType::TARGET_EDGE;
    rai_info_title_t1->forward = true;
    rai_info_title_t1->vertex = &table_title;
    rai_info_title_t1->vertex_id = table_index_title_t1;
    rai_info_title_t1->passing_tables[0] = table_index_title_t1;
    rai_info_title_t1->left_cardinalities[0] = table_title.GetStorage().info->cardinality;
    // rai_info_title_t->compact_list = &rai_info_title_t->rai->alist->compact__list;

    join_condition_title_t1.rais.push_back(move(rai_info_title_t1));
    cond_title_t1.push_back(move(join_condition_title_t1));

    LogicalComparisonJoin join_title_t1_op(JoinType::INNER);
    vector<LogicalType> output_title_t1_types{LogicalType::BIGINT, LogicalType::VARCHAR,
                                             LogicalType::BIGINT, LogicalType::VARCHAR};
    join_title_t1_op.types = output_title_t1_types;
    vector<idx_t> right_projection_map_title_t1{2, 3};
    vector<idx_t> merge_project_map_title_t1;
    vector<LogicalType> delim_types_title_t1;
    auto join_title_t1 = make_uniq<PhysicalSIPJoin>(join_title_t1_op, move(scan_title_t1), move(join_movie_link_), move(cond_title_t1), JoinType::INNER,
                                                        left_projection_map, right_projection_map_title_t1,
                                                        delim_types_title_t1, 0);



    vector<idx_t> title_t2_ids{COLUMN_IDENTIFIER_ROW_ID, 1};
    vector<LogicalType> get_title_t2_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_title_t2 = "t2";
    vector<LogicalType> table_types_title_t2;
    vector<unique_ptr<Expression>> filter_title_t2;
    unique_ptr<LogicalGet> get_op_title_t2 = move(
            getLogicalGet(*this, table_title, alias_title_t2, table_index_title_t2, table_types_title_t2));
    unique_ptr<TableFilterSet> table_filters_title_t2 = NULL;
    unique_ptr<PhysicalTableScan> scan_title_t2 = make_uniq<PhysicalTableScan>(get_title_t2_types,
                                                                               get_op_title_t2->function,
                                                                               get_op_title_t2->table_index,
                                                                               move(get_op_title_t2->bind_data),
                                                                               table_types_title_t2, title_t2_ids,
                                                                               move(filter_title_t2),
                                                                               vector<column_t>(),
                                                                               get_op_title_t2->names,
                                                                               std::move(table_filters_title_t2),
                                                                               get_op_title_t2->estimated_cardinality,
                                                                               get_op_title_t2->extra_info);

    vector<JoinCondition> cond_title_t2;
    JoinCondition join_condition_title_t2;
    join_condition_title_t2.left = make_uniq<BoundReferenceExpression>("title_rowid", LogicalType::BIGINT, 0);
    join_condition_title_t2.right = make_uniq<BoundReferenceExpression>("linked_movie_id_rowid", LogicalType::BIGINT, 2);
    join_condition_title_t2.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_title_t2 = make_uniq<RAIInfo>();
    rai_info_title_t2->rai = table_movie_link.GetStorage().info->rais[1].get();
    rai_info_title_t2->rai_type = RAIType::TARGET_EDGE;
    rai_info_title_t2->forward = true;
    rai_info_title_t2->vertex = &table_title;
    rai_info_title_t2->vertex_id = table_index_title_t2;
    rai_info_title_t2->passing_tables[0] = table_index_title_t2;
    rai_info_title_t2->left_cardinalities[0] = table_title.GetStorage().info->cardinality;
    // rai_info_title_t->compact_list = &rai_info_title_t->rai->alist->compact__list;

    join_condition_title_t2.rais.push_back(move(rai_info_title_t2));
    cond_title_t2.push_back(move(join_condition_title_t2));

    LogicalComparisonJoin join_title_t2_op(JoinType::INNER);
    vector<LogicalType> output_title_t2_types{LogicalType::BIGINT, LogicalType::VARCHAR,
                                              LogicalType::BIGINT, LogicalType::VARCHAR,
                                              LogicalType::VARCHAR};
    join_title_t2_op.types = output_title_t2_types;
    vector<idx_t> right_projection_map_title_t2{0, 1, 3};
    vector<idx_t> merge_project_map_title_t2;
    vector<LogicalType> delim_types_title_t2;
    auto join_title_t2 = make_uniq<PhysicalSIPJoin>(join_title_t2_op, move(scan_title_t2), move(join_title_t1), move(cond_title_t2), JoinType::INNER,
                                                    left_projection_map, right_projection_map_title_t2,
                                                    delim_types_title_t2, 0);


    vector<idx_t> keyword_k_ids{COLUMN_IDENTIFIER_ROW_ID, 1};
    vector<LogicalType> get_keyword_k_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_keyword_k = "k";
    vector<LogicalType> table_types_keyword_k;
    vector<unique_ptr<Expression>> filter_keyword_k;
    unique_ptr<LogicalGet> get_op_keyword_k = move(
            getLogicalGet(*this, table_keyword, alias_keyword_k, table_index_keyword_k, table_types_keyword_k));
    unique_ptr<TableFilterSet> table_filters_keyword_k = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_k = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL, Value("10,000-mile-club"));
    table_filters_keyword_k->filters[1] = move(constant_filter_k);
    unique_ptr<PhysicalTableScan> scan_keyword_k = make_uniq<PhysicalTableScan>(get_keyword_k_types,
                                                                                get_op_keyword_k->function,
                                                                                get_op_keyword_k->table_index,
                                                                                move(get_op_keyword_k->bind_data),
                                                                                table_types_keyword_k, keyword_k_ids,
                                                                                move(filter_keyword_k),
                                                                                vector<column_t>(),
                                                                                get_op_keyword_k->names,
                                                                                std::move(table_filters_keyword_k),
                                                                                get_op_keyword_k->estimated_cardinality,
                                                                                get_op_keyword_k->extra_info);


    vector<JoinCondition> cond_keyword_k;
    JoinCondition join_condition_keyword_k;
    join_condition_keyword_k.left = make_uniq<BoundReferenceExpression>("keyword_rowid", LogicalType::BIGINT, 0);
    join_condition_keyword_k.right = make_uniq<BoundReferenceExpression>("title_rowid1", LogicalType::BIGINT, 2);
    join_condition_keyword_k.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_keyword_k = make_uniq<RAIInfo>();
    rai_info_keyword_k->rai = table_movie_keyword.GetStorage().info->rais[0].get();
    rai_info_keyword_k->rai_type = RAIType::SOURCE_EDGE;
    rai_info_keyword_k->forward = false;
    rai_info_keyword_k->vertex = &table_keyword;
    rai_info_keyword_k->vertex_id = table_index_keyword_k;
    rai_info_keyword_k->passing_tables[0] = table_index_keyword_k;
    rai_info_keyword_k->left_cardinalities[0] = table_keyword.GetStorage().info->cardinality;
    // rai_info_keyword_k->compact_list = &rai_info_keyword_k->rai->alist->compact__list;

    join_condition_keyword_k.rais.push_back(move(rai_info_keyword_k));
    cond_keyword_k.push_back(move(join_condition_keyword_k));

    LogicalComparisonJoin join_keyword_k_op(JoinType::INNER);
    vector<LogicalType> output_keyword_k_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::VARCHAR,
                                               LogicalType::VARCHAR, LogicalType::VARCHAR};
    join_keyword_k_op.types = output_keyword_k_types;
    vector<idx_t> right_projection_map_keyword_k{1, 3, 4};
    vector<idx_t> merge_project_map_keyword_k;
    vector<LogicalType> delim_types_keyword_k;
    auto join_keyword_k = make_uniq<PhysicalMergeSIPJoin>(join_keyword_k_op, move(scan_keyword_k), move(join_title_t2), move(cond_keyword_k),
                                                     JoinType::INNER, left_projection_map,
                                                     right_projection_map_keyword_k,
                                                     merge_project_map_keyword_k,
                                                     delim_types_keyword_k, 0);


    vector<LogicalType> result_types{LogicalType::VARCHAR, LogicalType::VARCHAR, LogicalType::VARCHAR};
    vector<unique_ptr<Expression>> select_list;
    auto result_col0 = make_uniq<BoundReferenceExpression>("link", LogicalType::VARCHAR, 4);
    auto result_col1 = make_uniq<BoundReferenceExpression>("title", LogicalType::VARCHAR, 3);
    auto result_col2 = make_uniq<BoundReferenceExpression>("title", LogicalType::VARCHAR, 2);
    select_list.push_back(move(result_col0));
    select_list.push_back(move(result_col1));
    select_list.push_back(move(result_col2));
    auto projection = make_uniq<PhysicalProjection>(result_types, move(select_list), 0);
    projection->children.push_back(move(join_keyword_k));

    // aggregate
    string agg_name = "min";
    string agg_error = "";
    QueryErrorContext error_context(NULL, NULL);
    auto min_func = Catalog::GetEntry(context, CatalogType::SCALAR_FUNCTION_ENTRY, "", "",
                                      "min", OnEntryNotFound::RETURN_NULL, error_context);
    auto &min_func_set = min_func->Cast<AggregateFunctionCatalogEntry>();
    // bind the aggregate
    FunctionBinder function_binder(context);
    vector<LogicalType> types;
    types.push_back(LogicalType::VARCHAR);
    idx_t best_function_varchar = function_binder.BindFunction(agg_name, min_func_set.functions, types, agg_error);
    auto bound_function_min_varchar = min_func_set.functions.GetFunctionByOffset(best_function_varchar);
    // std::cout << best_function_varchar << " " << bound_function_min_varchar.return_type.ToString() << std::endl;

    auto first_children = make_uniq<BoundReferenceExpression>("link", LogicalType::VARCHAR, 0);
    vector<unique_ptr<Expression>> childrenlist1;
    childrenlist1.push_back(move(first_children));
    auto aggregate1 =
            function_binder.BindAggregateFunction(bound_function_min_varchar, std::move(childrenlist1), nullptr,
                                                  AggregateType::NON_DISTINCT);

    auto second_children = make_uniq<BoundReferenceExpression>("title", LogicalType::VARCHAR, 1);
    vector<unique_ptr<Expression>> childrenlist2;
    childrenlist2.push_back(move(second_children));
    auto aggregate2 =
            function_binder.BindAggregateFunction(bound_function_min_varchar, std::move(childrenlist2), nullptr,
                                                  AggregateType::NON_DISTINCT);

    auto third_children = make_uniq<BoundReferenceExpression>("title", LogicalType::VARCHAR, 2);
    vector<unique_ptr<Expression>> childrenlist3;
    childrenlist3.push_back(move(third_children));
    auto aggregate3 =
            function_binder.BindAggregateFunction(bound_function_min_varchar, std::move(childrenlist3), nullptr,
                                                  AggregateType::NON_DISTINCT);

    vector<unique_ptr<Expression>> aggregates;
    aggregates.push_back(move(aggregate1));
    aggregates.push_back(move(aggregate2));
    aggregates.push_back(move(aggregate3));

    vector<LogicalType> aggregate_types{LogicalType::VARCHAR, LogicalType::VARCHAR, LogicalType::VARCHAR};
    auto ungrouped_aggregate = make_uniq<PhysicalUngroupedAggregate>(aggregate_types, move(aggregates), 0);
    ungrouped_aggregate->children.push_back(move(projection));

    return ungrouped_aggregate;
}

unique_ptr<PhysicalOperator> ClientContext::GenerateJOB33aPlan(duckdb::ClientContext &context) {
    vector<idx_t> left_projection_map, right_projection_map;

    string table_vertex_link_type_lt = "link_type";
    string table_vertex_title_t1 = "title";
    string table_vertex_title_t2 = "title";
    string table_vertex_info_type_it1 = "info_type";
    string table_vertex_kind_type_kt1 = "kind_type";
    string table_vertex_company_name_cn1 = "company_name";
    string table_vertex_info_type_it2 = "info_type";
    string table_vertex_kind_type_kt2 = "kind_type";
    string table_vertex_company_name_cn2 = "company_name";
    string table_vertex_movie_link_ = "movie_link";
    string table_vertex_movie_info_idx_mi_idx1 = "movie_info_idx";
    string table_vertex_movie_companies_mc1 = "movie_companies";
    string table_vertex_movie_info_idx_mi_idx2 = "movie_info_idx";
    string table_vertex_movie_companies_mc2 = "movie_companies";

    idx_t table_index_link_type_lt = 1;
    idx_t table_index_title_t1 = 2;
    idx_t table_index_title_t2 = 3;
    idx_t table_index_info_type_it1 = 4;
    idx_t table_index_kind_type_kt1 = 5;
    idx_t table_index_company_name_cn1 = 6;
    idx_t table_index_info_type_it2 = 7;
    idx_t table_index_kind_type_kt2 = 8;
    idx_t table_index_company_name_cn2 = 9;
    idx_t table_index_movie_link_ = 11;
    idx_t table_index_movie_info_idx_mi_idx1 = 12;
    idx_t table_index_movie_companies_mc1 = 14;
    idx_t table_index_movie_info_idx_mi_idx2 = 15;
    idx_t table_index_movie_companies_mc2 = 17;

    auto table_or_view_link_type = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_link_type_lt,
                                                     OnEntryNotFound::RETURN_NULL);
    auto &table_link_type = table_or_view_link_type->Cast<TableCatalogEntry>();
    auto table_or_view_title = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_title_t1,
                                                 OnEntryNotFound::RETURN_NULL);
    auto &table_title = table_or_view_title->Cast<TableCatalogEntry>();
    auto table_or_view_info_type = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                     table_vertex_info_type_it1, OnEntryNotFound::RETURN_NULL);
    auto &table_info_type = table_or_view_info_type->Cast<TableCatalogEntry>();
    auto table_or_view_kind_type = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                     table_vertex_kind_type_kt1, OnEntryNotFound::RETURN_NULL);
    auto &table_kind_type = table_or_view_kind_type->Cast<TableCatalogEntry>();
    auto table_or_view_company_name = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                        table_vertex_company_name_cn1, OnEntryNotFound::RETURN_NULL);
    auto &table_company_name = table_or_view_company_name->Cast<TableCatalogEntry>();
    auto table_or_view_movie_link = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "", table_vertex_movie_link_,
                                                      OnEntryNotFound::RETURN_NULL);
    auto &table_movie_link = table_or_view_movie_link->Cast<TableCatalogEntry>();
    auto table_or_view_movie_info_idx = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                          table_vertex_movie_info_idx_mi_idx1,
                                                          OnEntryNotFound::RETURN_NULL);
    auto &table_movie_info_idx = table_or_view_movie_info_idx->Cast<TableCatalogEntry>();
    auto table_or_view_movie_companies = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                           table_vertex_movie_companies_mc1,
                                                           OnEntryNotFound::RETURN_NULL);
    auto &table_movie_companies = table_or_view_movie_companies->Cast<TableCatalogEntry>();

    vector<idx_t> link_type_lt_ids{COLUMN_IDENTIFIER_ROW_ID, 1};
    vector<LogicalType> get_link_type_lt_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_link_type_lt = "lt";
    vector<LogicalType> table_types_link_type_lt;
    vector<unique_ptr<Expression>> filter_link_type_lt;
    unique_ptr<LogicalGet> get_op_link_type_lt = move(
            getLogicalGet(*this, table_link_type, alias_link_type_lt, table_index_link_type_lt,
                          table_types_link_type_lt));
    unique_ptr<TableFilterSet> table_filters_link_type_lt = NULL;
    unique_ptr<PhysicalTableScan> scan_link_type_lt = make_uniq<PhysicalTableScan>(get_link_type_lt_types,
                                                                                   get_op_link_type_lt->function,
                                                                                   get_op_link_type_lt->table_index,
                                                                                   move(get_op_link_type_lt->bind_data),
                                                                                   table_types_link_type_lt,
                                                                                   link_type_lt_ids,
                                                                                   move(filter_link_type_lt),
                                                                                   vector<column_t>(),
                                                                                   get_op_link_type_lt->names,
                                                                                   std::move(
                                                                                           table_filters_link_type_lt),
                                                                                   get_op_link_type_lt->estimated_cardinality,
                                                                                   get_op_link_type_lt->extra_info);

    auto &allocator_l = Allocator::Get(context);
    vector<LogicalType> join_in_types_l {LogicalType::VARCHAR};
    auto collection_l =
            make_uniq<ColumnDataCollection>(context, join_in_types_l, ColumnDataAllocatorType::IN_MEMORY_ALLOCATOR);

    vector<LogicalType> chunk_in_types_l {LogicalType::VARCHAR};
    DataChunk chunk_l;
    chunk_l.SetCardinality(3);
    chunk_l.Initialize(allocator_l, chunk_in_types_l);
    chunk_l.SetValue(0, 0, Value("sequel"));
    chunk_l.SetValue(0, 1, Value("follows"));
    chunk_l.SetValue(0, 2, Value("followed by"));
    collection_l->Append(chunk_l);

    // create a chunk scan to output the result
    vector<LogicalType> ouput_in_types_l {LogicalType::VARCHAR};
    auto chunk_scan_l = make_uniq<PhysicalColumnDataScan>(ouput_in_types_l, PhysicalOperatorType::COLUMN_DATA_SCAN,
                                                           3, std::move(collection_l));

    vector<JoinCondition> cond_hash_join_l;
    JoinCondition join_condition_hash_join_l;
    join_condition_hash_join_l.left = make_uniq<BoundReferenceExpression>("link", LogicalType::VARCHAR, 1);
    join_condition_hash_join_l.right = make_uniq<BoundReferenceExpression>("", LogicalType::VARCHAR, 0);
    join_condition_hash_join_l.comparison = ExpressionType::COMPARE_EQUAL;
    cond_hash_join_l.push_back(move(join_condition_hash_join_l));

    LogicalComparisonJoin join_hash_join_op_l(JoinType::MARK);
    vector<LogicalType> output_hash_join_types_l{LogicalType::BIGINT,
                                                  LogicalType::VARCHAR, LogicalType::BOOLEAN};
    join_hash_join_op_l.types = output_hash_join_types_l;
    vector<idx_t> right_projection_map_hash_join_l;
    vector<LogicalType> delim_types_hash_join_l;
    PerfectHashJoinStats joinstate_l;
    auto join_hash_join_l = make_uniq<PhysicalHashJoin>(join_hash_join_op_l, move(scan_link_type_lt), move(chunk_scan_l), move(cond_hash_join_l),
                                                         JoinType::MARK, left_projection_map,
                                                         right_projection_map_hash_join_l,
                                                         delim_types_hash_join_l, 0, joinstate_l);

    vector<LogicalType> filter_in_types_l{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::BOOLEAN};
    vector<unique_ptr<Expression>> select_list_in_l;
    auto in_exp_l = make_uniq<BoundReferenceExpression>("IN (...)", LogicalType::BOOLEAN, 2);
    select_list_in_l.push_back(move(in_exp_l));
    unique_ptr<PhysicalFilter> filter_in_l = make_uniq<PhysicalFilter>(filter_in_types_l, move(select_list_in_l), 0);
    filter_in_l->children.push_back(move(join_hash_join_l));


    vector<idx_t> movie_link_ml_ids{4, 5, 6};
    vector<LogicalType> get_movie_link_ml_types{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::BIGINT};
    string alias_movie_link_ml = "ml";
    vector<LogicalType> table_types_movie_link_ml;
    vector<unique_ptr<Expression>> filter_movie_link_ml;
    unique_ptr<LogicalGet> get_op_movie_link_ml = move(
            getLogicalGet(*this, table_movie_link, alias_movie_link_ml, table_index_movie_link_,
                          table_types_movie_link_ml));
    unique_ptr<TableFilterSet> table_filters_movie_link_ml = NULL;
    unique_ptr<PhysicalTableScan> scan_movie_link_ml = make_uniq<PhysicalTableScan>(get_movie_link_ml_types,
                                                                                    get_op_movie_link_ml->function,
                                                                                    get_op_movie_link_ml->table_index,
                                                                                    move(get_op_movie_link_ml->bind_data),
                                                                                    table_types_movie_link_ml,
                                                                                    movie_link_ml_ids,
                                                                                    move(filter_movie_link_ml),
                                                                                    vector<column_t>(),
                                                                                    get_op_movie_link_ml->names,
                                                                                    std::move(
                                                                                            table_filters_movie_link_ml),
                                                                                    get_op_movie_link_ml->estimated_cardinality,
                                                                                    get_op_movie_link_ml->extra_info);

    vector<JoinCondition> cond_movie_link_;
    JoinCondition join_condition_movie_link_;
    join_condition_movie_link_.left = make_uniq<BoundReferenceExpression>("link_type_id_rowid", LogicalType::BIGINT, 0);
    join_condition_movie_link_.right = make_uniq<BoundReferenceExpression>("link_type_rowid", LogicalType::BIGINT, 0);
    join_condition_movie_link_.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_movie_link_ = make_uniq<RAIInfo>();
    rai_info_movie_link_->rai = table_movie_link.GetStorage().info->rais[0].get();
    rai_info_movie_link_->rai_type = RAIType::EDGE_SOURCE;
    rai_info_movie_link_->forward = true;
    rai_info_movie_link_->vertex = &table_link_type;
    rai_info_movie_link_->vertex_id = table_index_link_type_lt;
    rai_info_movie_link_->passing_tables[0] = table_index_movie_link_;
    rai_info_movie_link_->left_cardinalities[0] = table_movie_link.GetStorage().info->cardinality;
    rai_info_movie_link_->compact_list = &rai_info_movie_link_->rai->alist->compact_forward_list;

    join_condition_movie_link_.rais.push_back(move(rai_info_movie_link_));
    cond_movie_link_.push_back(move(join_condition_movie_link_));

    LogicalComparisonJoin join_movie_link__op(JoinType::INNER);
    vector<LogicalType> output_movie_link__types{LogicalType::BIGINT, LogicalType::BIGINT,
                                                 LogicalType::BIGINT, LogicalType::BIGINT};
    join_movie_link__op.types = output_movie_link__types;
    vector<idx_t> right_projection_map_movie_link_{0};
    vector<idx_t> merge_project_map_movie_link_;
    vector<LogicalType> delim_types_movie_link_;
    auto join_movie_link_ = make_uniq<PhysicalSIPJoin>(join_movie_link__op, move(scan_movie_link_ml), move(filter_in_l), move(cond_movie_link_),
                                                       JoinType::INNER, left_projection_map,
                                                       right_projection_map_movie_link_,
                                                       delim_types_movie_link_, 0);


    vector<idx_t> title_t1_ids{COLUMN_IDENTIFIER_ROW_ID, 1, 12};
    vector<LogicalType> get_title_t1_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::BIGINT};
    string alias_title_t1 = "t1";
    vector<LogicalType> table_types_title_t1;
    vector<unique_ptr<Expression>> filter_title_t1;
    unique_ptr<LogicalGet> get_op_title_t1 = move(
            getLogicalGet(*this, table_title, alias_title_t1, table_index_title_t1, table_types_title_t1));
    unique_ptr<TableFilterSet> table_filters_title_t1 = NULL;
    unique_ptr<PhysicalTableScan> scan_title_t1 = make_uniq<PhysicalTableScan>(get_title_t1_types,
                                                                               get_op_title_t1->function,
                                                                               get_op_title_t1->table_index,
                                                                               move(get_op_title_t1->bind_data),
                                                                               table_types_title_t1, title_t1_ids,
                                                                               move(filter_title_t1),
                                                                               vector<column_t>(),
                                                                               get_op_title_t1->names,
                                                                               std::move(table_filters_title_t1),
                                                                               get_op_title_t1->estimated_cardinality,
                                                                               get_op_title_t1->extra_info);


    vector<JoinCondition> cond_title_t1;
    JoinCondition join_condition_title_t1;
    join_condition_title_t1.left = make_uniq<BoundReferenceExpression>("title_rowid", LogicalType::BIGINT, 0);
    join_condition_title_t1.right = make_uniq<BoundReferenceExpression>("movie_id_rowid", LogicalType::BIGINT, 1);
    join_condition_title_t1.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_title_t1 = make_uniq<RAIInfo>();
    rai_info_title_t1->rai = table_movie_link.GetStorage().info->rais[0].get();
    rai_info_title_t1->rai_type = RAIType::TARGET_EDGE;
    rai_info_title_t1->forward = true;
    rai_info_title_t1->vertex = &table_title;
    rai_info_title_t1->vertex_id = table_index_title_t1;
    rai_info_title_t1->passing_tables[0] = table_index_title_t1;
    rai_info_title_t1->left_cardinalities[0] = table_title.GetStorage().info->cardinality;
    // rai_info_title_t->compact_list = &rai_info_title_t->rai->alist->compact__list;

    join_condition_title_t1.rais.push_back(move(rai_info_title_t1));
    cond_title_t1.push_back(move(join_condition_title_t1));

    LogicalComparisonJoin join_title_t1_op(JoinType::INNER);
    vector<LogicalType> output_title_t1_types{LogicalType::BIGINT, LogicalType::VARCHAR,
                                              LogicalType::BIGINT, LogicalType::BIGINT};
    join_title_t1_op.types = output_title_t1_types;
    vector<idx_t> right_projection_map_title_t1{2};
    vector<idx_t> merge_project_map_title_t1;
    vector<LogicalType> delim_types_title_t1;
    auto join_title_t1 = make_uniq<PhysicalSIPJoin>(join_title_t1_op, move(scan_title_t1), move(join_movie_link_), move(cond_title_t1), JoinType::INNER,
                                                    left_projection_map, right_projection_map_title_t1,
                                                    delim_types_title_t1, 0);



    vector<idx_t> title_t2_ids{COLUMN_IDENTIFIER_ROW_ID, 1, 12, 4};
    vector<LogicalType> get_title_t2_types{LogicalType::BIGINT, LogicalType::VARCHAR,
                                           LogicalType::BIGINT, LogicalType::BIGINT};
    string alias_title_t2 = "t2";
    vector<LogicalType> table_types_title_t2;
    vector<unique_ptr<Expression>> filter_title_t2;
    unique_ptr<LogicalGet> get_op_title_t2 = move(
            getLogicalGet(*this, table_title, alias_title_t2, table_index_title_t2, table_types_title_t2));
    unique_ptr<TableFilterSet> table_filters_title_t2 = make_uniq<TableFilterSet>();
    unique_ptr<ConjunctionAndFilter> and_filter_t2 = duckdb::make_uniq<ConjunctionAndFilter>();
    unique_ptr<ConstantFilter> constant_filter_t2_start = duckdb::make_uniq<ConstantFilter>(
            ExpressionType::COMPARE_GREATERTHANOREQUALTO, Value::BIGINT(2005));
    unique_ptr<ConstantFilter> constant_filter_t2_end = duckdb::make_uniq<ConstantFilter>(
            ExpressionType::COMPARE_LESSTHANOREQUALTO, Value::BIGINT(2008));
    and_filter_t2->child_filters.push_back(move(constant_filter_t2_start));
    and_filter_t2->child_filters.push_back(move(constant_filter_t2_end));
    table_filters_title_t2->filters[3] = move(and_filter_t2);
    unique_ptr<PhysicalTableScan> scan_title_t2 = make_uniq<PhysicalTableScan>(get_title_t2_types,
                                                                               get_op_title_t2->function,
                                                                               get_op_title_t2->table_index,
                                                                               move(get_op_title_t2->bind_data),
                                                                               table_types_title_t2, title_t2_ids,
                                                                               move(filter_title_t2),
                                                                               vector<column_t>(),
                                                                               get_op_title_t2->names,
                                                                               std::move(table_filters_title_t2),
                                                                               get_op_title_t2->estimated_cardinality,
                                                                               get_op_title_t2->extra_info);


    vector<JoinCondition> cond_title_t2;
    JoinCondition join_condition_title_t2;
    join_condition_title_t2.left = make_uniq<BoundReferenceExpression>("title_rowid", LogicalType::BIGINT, 0);
    join_condition_title_t2.right = make_uniq<BoundReferenceExpression>("linked_movie_id_rowid", LogicalType::BIGINT, 3);
    join_condition_title_t2.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_title_t2 = make_uniq<RAIInfo>();
    rai_info_title_t2->rai = table_movie_link.GetStorage().info->rais[1].get();
    rai_info_title_t2->rai_type = RAIType::TARGET_EDGE;
    rai_info_title_t2->forward = true;
    rai_info_title_t2->vertex = &table_title;
    rai_info_title_t2->vertex_id = table_index_title_t2;
    rai_info_title_t2->passing_tables[0] = table_index_title_t2;
    rai_info_title_t2->left_cardinalities[0] = table_title.GetStorage().info->cardinality;
    // rai_info_title_t2->compact_list = &rai_info_title_t2->rai->alist->compact__list;

    join_condition_title_t2.rais.push_back(move(rai_info_title_t2));
    cond_title_t2.push_back(move(join_condition_title_t2));

    LogicalComparisonJoin join_title_t2_op(JoinType::INNER);
    vector<LogicalType> output_title_t2_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::BIGINT,
                                              LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::VARCHAR,
                                              LogicalType::BIGINT};
    join_title_t2_op.types = output_title_t2_types;
    vector<idx_t> right_projection_map_title_t2{0, 1, 2};
    vector<idx_t> merge_project_map_title_t2;
    vector<LogicalType> delim_types_title_t2;
    auto join_title_t2 = make_uniq<PhysicalSIPJoin>(join_title_t2_op, move(scan_title_t2), move(join_title_t1), move(cond_title_t2),
                                                    JoinType::INNER, left_projection_map, right_projection_map_title_t2,
                                                    delim_types_title_t2, 0);


    vector<idx_t> movie_info_idx_ids_2{6, 5, 3};
    vector<LogicalType> get_movie_info_idx_type_2{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_movie_info_idx_2 = "mi";
    vector<LogicalType> table_types_movie_info_idx_2;
    vector<unique_ptr<Expression>> filter_movie_info_idx_2;
    unique_ptr<LogicalGet> get_op_movie_info_idx_2 = move(
            getLogicalGet(*this, table_movie_info_idx, alias_movie_info_idx_2, table_index_movie_info_idx_mi_idx2, table_types_movie_info_idx_2));
    unique_ptr<TableFilterSet> table_filters_movie_info_idx_2 = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_idx_2 = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_LESSTHAN, Value("3.0"));
    table_filters_movie_info_idx_2->filters[2] = move(constant_filter_idx_2);
    unique_ptr<PhysicalTableScan> scan_movie_info_idx_2 = make_uniq<PhysicalTableScan>(get_movie_info_idx_type_2,
                                                                                     get_op_movie_info_idx_2->function,
                                                                                     get_op_movie_info_idx_2->table_index,
                                                                                     move(get_op_movie_info_idx_2->bind_data),
                                                                                     table_types_movie_info_idx_2, movie_info_idx_ids_2,
                                                                                     move(filter_movie_info_idx_2),
                                                                                     vector<column_t>(),
                                                                                     get_op_movie_info_idx_2->names,
                                                                                     std::move(table_filters_movie_info_idx_2),
                                                                                     get_op_movie_info_idx_2->estimated_cardinality,
                                                                                     get_op_movie_info_idx_2->extra_info);


    vector<JoinCondition> cond_movie_info_idx_mi_idx2;
    JoinCondition join_condition_movie_info_idx_mi_idx2;
    join_condition_movie_info_idx_mi_idx2.left = make_uniq<BoundReferenceExpression>("movie_id_rowid", LogicalType::BIGINT, 0);
    join_condition_movie_info_idx_mi_idx2.right = make_uniq<BoundReferenceExpression>("title_rowid", LogicalType::BIGINT, 0);
    join_condition_movie_info_idx_mi_idx2.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_movie_info_idx_mi_idx2 = make_uniq<RAIInfo>();
    rai_info_movie_info_idx_mi_idx2->rai = table_movie_info_idx.GetStorage().info->rais[0].get();
    rai_info_movie_info_idx_mi_idx2->rai_type = RAIType::EDGE_TARGET;
    rai_info_movie_info_idx_mi_idx2->forward = false;
    rai_info_movie_info_idx_mi_idx2->vertex = &table_title;
    rai_info_movie_info_idx_mi_idx2->vertex_id = table_index_title_t2;
    rai_info_movie_info_idx_mi_idx2->passing_tables[0] = table_index_movie_info_idx_mi_idx2;
    rai_info_movie_info_idx_mi_idx2->left_cardinalities[0] = table_movie_info_idx.GetStorage().info->cardinality;
    rai_info_movie_info_idx_mi_idx2->compact_list = &rai_info_movie_info_idx_mi_idx2->rai->alist->compact_backward_list;

    join_condition_movie_info_idx_mi_idx2.rais.push_back(move(rai_info_movie_info_idx_mi_idx2));
    cond_movie_info_idx_mi_idx2.push_back(move(join_condition_movie_info_idx_mi_idx2));

    LogicalComparisonJoin join_movie_info_idx_mi_idx2_op(JoinType::INNER);
    vector<LogicalType> output_movie_info_idx_mi_idx2_types{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::VARCHAR,
                                                            LogicalType::VARCHAR, LogicalType::BIGINT, LogicalType::BIGINT,
                                                            LogicalType::VARCHAR, LogicalType::BIGINT};
    join_movie_info_idx_mi_idx2_op.types = output_movie_info_idx_mi_idx2_types;
    vector<idx_t> right_projection_map_movie_info_idx_mi_idx2{1, 2, 4, 5, 6};
    vector<idx_t> merge_project_map_movie_info_idx_mi_idx2;
    vector<LogicalType> delim_types_movie_info_idx_mi_idx2;
    auto join_movie_info_idx_mi_idx2 = make_uniq<PhysicalSIPJoin>(join_movie_info_idx_mi_idx2_op, move(scan_movie_info_idx_2), move(join_title_t2),
                                                                move(cond_movie_info_idx_mi_idx2), JoinType::INNER,
                                                                left_projection_map,
                                                                right_projection_map_movie_info_idx_mi_idx2,
                                                                delim_types_movie_info_idx_mi_idx2, 0);


    vector<idx_t> info_type_it2_ids{COLUMN_IDENTIFIER_ROW_ID, 1};
    vector<LogicalType> get_info_type_it2_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_info_type_it2 = "it2";
    vector<LogicalType> table_types_info_type_it2;
    vector<unique_ptr<Expression>> filter_info_type_it2;
    unique_ptr<LogicalGet> get_op_info_type_it2 = move(
            getLogicalGet(*this, table_info_type, alias_info_type_it2, table_index_info_type_it2,
                          table_types_info_type_it2));
    unique_ptr<TableFilterSet> table_filters_info_type_it2 = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_it2 = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL, Value("rating"));
    table_filters_info_type_it2->filters[1] = move(constant_filter_it2);
    unique_ptr<PhysicalTableScan> scan_info_type_it2 = make_uniq<PhysicalTableScan>(get_info_type_it2_types,
                                                                                    get_op_info_type_it2->function,
                                                                                    get_op_info_type_it2->table_index,
                                                                                    move(get_op_info_type_it2->bind_data),
                                                                                    table_types_info_type_it2,
                                                                                    info_type_it2_ids,
                                                                                    move(filter_info_type_it2),
                                                                                    vector<column_t>(),
                                                                                    get_op_info_type_it2->names,
                                                                                    std::move(
                                                                                            table_filters_info_type_it2),
                                                                                    get_op_info_type_it2->estimated_cardinality,
                                                                                    get_op_info_type_it2->extra_info);


    vector<JoinCondition> cond_info_type_it2;
    JoinCondition join_condition_info_type_it2;
    join_condition_info_type_it2.left = make_uniq<BoundReferenceExpression>("info_type_rowid", LogicalType::BIGINT, 0);
    join_condition_info_type_it2.right = make_uniq<BoundReferenceExpression>("info_type_id_rowid", LogicalType::BIGINT, 1);
    join_condition_info_type_it2.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_info_type_it2 = make_uniq<RAIInfo>();
    rai_info_info_type_it2->rai = table_movie_info_idx.GetStorage().info->rais[0].get();
    rai_info_info_type_it2->rai_type = RAIType::SOURCE_EDGE;
    rai_info_info_type_it2->forward = false;
    rai_info_info_type_it2->vertex = &table_info_type;
    rai_info_info_type_it2->vertex_id = table_index_info_type_it2;
    rai_info_info_type_it2->passing_tables[0] = table_index_info_type_it2;
    rai_info_info_type_it2->left_cardinalities[0] = table_info_type.GetStorage().info->cardinality;
    // rai_info_info_type_it2->compact_list = &rai_info_info_type_it2->rai->alist->compact__list;

    join_condition_info_type_it2.rais.push_back(move(rai_info_info_type_it2));
    cond_info_type_it2.push_back(move(join_condition_info_type_it2));

    LogicalComparisonJoin join_info_type_it2_op(JoinType::INNER);
    vector<LogicalType> output_info_type_it2_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::BIGINT,
                                                   LogicalType::VARCHAR, LogicalType::VARCHAR, LogicalType::BIGINT,
                                                   LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::BIGINT};
    join_info_type_it2_op.types = output_info_type_it2_types;
    vector<idx_t> right_projection_map_info_type_it2{0, 2, 3, 4, 5, 6, 7};
    vector<idx_t> merge_project_map_info_type_it2;
    vector<LogicalType> delim_types_info_type_it2;
    auto join_info_type_it2 = make_uniq<PhysicalSIPJoin>(join_info_type_it2_op, move(scan_info_type_it2), move(join_movie_info_idx_mi_idx2),
                                                         move(cond_info_type_it2), JoinType::INNER, left_projection_map,
                                                         right_projection_map_info_type_it2, delim_types_info_type_it2,
                                                         0);

    vector<idx_t> movie_info_idx_ids{6, 5, 3};
    vector<LogicalType> get_movie_info_idx_type{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_movie_info_idx = "mi";
    vector<LogicalType> table_types_movie_info_idx;
    vector<unique_ptr<Expression>> filter_movie_info_idx;
    unique_ptr<LogicalGet> get_op_movie_info_idx = move(
            getLogicalGet(*this, table_movie_info_idx, alias_movie_info_idx, table_index_movie_info_idx_mi_idx1, table_types_movie_info_idx));
    unique_ptr<TableFilterSet> table_filters_movie_info_idx = NULL;
    unique_ptr<PhysicalTableScan> scan_movie_info_idx = make_uniq<PhysicalTableScan>(get_movie_info_idx_type,
                                                                                     get_op_movie_info_idx->function,
                                                                                     get_op_movie_info_idx->table_index,
                                                                                     move(get_op_movie_info_idx->bind_data),
                                                                                     table_types_movie_info_idx, movie_info_idx_ids,
                                                                                     move(filter_movie_info_idx),
                                                                                     vector<column_t>(),
                                                                                     get_op_movie_info_idx->names,
                                                                                     std::move(table_filters_movie_info_idx),
                                                                                     get_op_movie_info_idx->estimated_cardinality,
                                                                                     get_op_movie_info_idx->extra_info);


    vector<JoinCondition> cond_movie_info_idx_;
    JoinCondition join_condition_movie_info_idx_;
    join_condition_movie_info_idx_.left = make_uniq<BoundReferenceExpression>("movie_id_rowid", LogicalType::BIGINT, 0);
    join_condition_movie_info_idx_.right = make_uniq<BoundReferenceExpression>("title_rowid", LogicalType::BIGINT, 6);
    join_condition_movie_info_idx_.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_movie_info_idx_ = make_uniq<RAIInfo>();
    rai_info_movie_info_idx_->rai = table_movie_info_idx.GetStorage().info->rais[0].get();
    rai_info_movie_info_idx_->rai_type = RAIType::EDGE_TARGET;
    rai_info_movie_info_idx_->forward = false;
    rai_info_movie_info_idx_->vertex = &table_title;
    rai_info_movie_info_idx_->vertex_id = table_index_title_t1;
    rai_info_movie_info_idx_->passing_tables[0] = table_index_title_t1;
    rai_info_movie_info_idx_->left_cardinalities[0] = table_title.GetStorage().info->cardinality;
    rai_info_movie_info_idx_->compact_list = &rai_info_movie_info_idx_->rai->alist->compact_backward_list;

    join_condition_movie_info_idx_.rais.push_back(move(rai_info_movie_info_idx_));
    cond_movie_info_idx_.push_back(move(join_condition_movie_info_idx_));

    LogicalComparisonJoin join_movie_info_idx__op(JoinType::INNER);
    vector<LogicalType> output_movie_info_idx__types{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::VARCHAR,
                                                     LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::VARCHAR,
                                                     LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::BIGINT};
    join_movie_info_idx__op.types = output_movie_info_idx__types;
    vector<idx_t> right_projection_map_movie_info_idx_{2, 3, 4, 5, 7, 8};
    vector<idx_t> merge_project_map_movie_info_idx_;
    vector<LogicalType> delim_types_movie_info_idx_;
    auto join_movie_info_idx_ = make_uniq<PhysicalSIPJoin>(join_movie_info_idx__op, move(scan_movie_info_idx), move(join_info_type_it2),
                                                                move(cond_movie_info_idx_), JoinType::INNER,
                                                                left_projection_map,
                                                                right_projection_map_movie_info_idx_,
                                                                delim_types_movie_info_idx_, 0);


    vector<idx_t> info_type_it1_ids{COLUMN_IDENTIFIER_ROW_ID, 1};
    vector<LogicalType> get_info_type_it1_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_info_type_it1 = "it1";
    vector<LogicalType> table_types_info_type_it1;
    vector<unique_ptr<Expression>> filter_info_type_it1;
    unique_ptr<LogicalGet> get_op_info_type_it1 = move(
            getLogicalGet(*this, table_info_type, alias_info_type_it1, table_index_info_type_it1,
                          table_types_info_type_it1));
    unique_ptr<TableFilterSet> table_filters_info_type_it1 = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_it1 = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL, Value("rating"));
    table_filters_info_type_it1->filters[1] = move(constant_filter_it1);
    unique_ptr<PhysicalTableScan> scan_info_type_it1 = make_uniq<PhysicalTableScan>(get_info_type_it1_types,
                                                                                    get_op_info_type_it1->function,
                                                                                    get_op_info_type_it1->table_index,
                                                                                    move(get_op_info_type_it1->bind_data),
                                                                                    table_types_info_type_it1,
                                                                                    info_type_it1_ids,
                                                                                    move(filter_info_type_it1),
                                                                                    vector<column_t>(),
                                                                                    get_op_info_type_it1->names,
                                                                                    std::move(
                                                                                            table_filters_info_type_it1),
                                                                                    get_op_info_type_it1->estimated_cardinality,
                                                                                    get_op_info_type_it1->extra_info);


    vector<JoinCondition> cond_info_type_it1;
    JoinCondition join_condition_info_type_it1;
    join_condition_info_type_it1.left = make_uniq<BoundReferenceExpression>("info_type_rowid", LogicalType::BIGINT, 0);
    join_condition_info_type_it1.right = make_uniq<BoundReferenceExpression>("info_type_id_rowid", LogicalType::BIGINT, 1);
    join_condition_info_type_it1.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_info_type_it1 = make_uniq<RAIInfo>();
    rai_info_info_type_it1->rai = table_movie_info_idx.GetStorage().info->rais[0].get();
    rai_info_info_type_it1->rai_type = RAIType::SOURCE_EDGE;
    rai_info_info_type_it1->forward = false;
    rai_info_info_type_it1->vertex = &table_info_type;
    rai_info_info_type_it1->vertex_id = table_index_info_type_it1;
    rai_info_info_type_it1->passing_tables[0] = table_index_info_type_it1;
    rai_info_info_type_it1->left_cardinalities[0] = table_info_type.GetStorage().info->cardinality;
    // rai_info_info_type_it1->compact_list = &rai_info_info_type_it1->rai->alist->compact__list;

    join_condition_info_type_it1.rais.push_back(move(rai_info_info_type_it1));
    cond_info_type_it1.push_back(move(join_condition_info_type_it1));

    LogicalComparisonJoin join_info_type_it1_op(JoinType::INNER);
    vector<LogicalType> output_info_type_it1_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::BIGINT,
                                                   LogicalType::VARCHAR, LogicalType::BIGINT, LogicalType::VARCHAR,
                                                   LogicalType::VARCHAR, LogicalType::BIGINT, LogicalType::VARCHAR,
                                                   LogicalType::BIGINT};
    join_info_type_it1_op.types = output_info_type_it1_types;
    vector<idx_t> right_projection_map_info_type_it1{0, 2, 3, 4, 5, 6, 7, 8};
    vector<idx_t> merge_project_map_info_type_it1;
    vector<LogicalType> delim_types_info_type_it1;
    auto join_info_type_it1 = make_uniq<PhysicalSIPJoin>(join_info_type_it1_op, move(scan_info_type_it1), move(join_movie_info_idx_),
                                                         move(cond_info_type_it1), JoinType::INNER, left_projection_map,
                                                         right_projection_map_info_type_it1, delim_types_info_type_it1,
                                                         0);


    vector<idx_t> company_name_cn1_ids{COLUMN_IDENTIFIER_ROW_ID, 1, 2};
    vector<LogicalType> get_company_name_cn1_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::VARCHAR};
    string alias_company_name_cn1 = "cn1";
    vector<LogicalType> table_types_company_name_cn1;
    vector<unique_ptr<Expression>> filter_company_name_cn1;
    unique_ptr<LogicalGet> get_op_company_name_cn1 = move(
            getLogicalGet(*this, table_company_name, alias_company_name_cn1, table_index_company_name_cn1,
                          table_types_company_name_cn1));
    unique_ptr<TableFilterSet> table_filters_company_name_cn1 = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_cn1 = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL, Value("[us]"));
    table_filters_company_name_cn1->filters[2] = move(constant_filter_cn1);
    unique_ptr<PhysicalTableScan> scan_company_name_cn1 = make_uniq<PhysicalTableScan>(get_company_name_cn1_types,
                                                                                       get_op_company_name_cn1->function,
                                                                                       get_op_company_name_cn1->table_index,
                                                                                       move(get_op_company_name_cn1->bind_data),
                                                                                       table_types_company_name_cn1,
                                                                                       company_name_cn1_ids,
                                                                                       move(filter_company_name_cn1),
                                                                                       vector<column_t>(),
                                                                                       get_op_company_name_cn1->names,
                                                                                       std::move(
                                                                                               table_filters_company_name_cn1),
                                                                                       get_op_company_name_cn1->estimated_cardinality,
                                                                                       get_op_company_name_cn1->extra_info);


    vector<JoinCondition> cond_company_name_cn1;
    JoinCondition join_condition_company_name_cn1;
    join_condition_company_name_cn1.left = make_uniq<BoundReferenceExpression>("company_name_rowid", LogicalType::BIGINT, 0);
    join_condition_company_name_cn1.right = make_uniq<BoundReferenceExpression>("movie_id_rowid", LogicalType::BIGINT, 2);
    join_condition_company_name_cn1.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_company_name_cn1 = make_uniq<RAIInfo>();
    rai_info_company_name_cn1->rai = table_movie_companies.GetStorage().info->rais[0].get();
    rai_info_company_name_cn1->rai_type = RAIType::SOURCE_EDGE;
    rai_info_company_name_cn1->forward = false;
    rai_info_company_name_cn1->vertex = &table_company_name;
    rai_info_company_name_cn1->vertex_id = table_index_company_name_cn1;
    rai_info_company_name_cn1->passing_tables[0] = table_index_company_name_cn1;
    rai_info_company_name_cn1->left_cardinalities[0] = table_company_name.GetStorage().info->cardinality;
    // rai_info_company_name_cn1->compact_list = &rai_info_company_name_cn1->rai->alist->compact__list;

    join_condition_company_name_cn1.rais.push_back(move(rai_info_company_name_cn1));
    cond_company_name_cn1.push_back(move(join_condition_company_name_cn1));

    LogicalComparisonJoin join_company_name_cn1_op(JoinType::INNER);
    vector<LogicalType> output_company_name_cn1_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::VARCHAR,
                                                      LogicalType::VARCHAR, LogicalType::BIGINT, LogicalType::VARCHAR,
                                                      LogicalType::VARCHAR, LogicalType::BIGINT, LogicalType::VARCHAR,
                                                      LogicalType::BIGINT};
    join_company_name_cn1_op.types = output_company_name_cn1_types;
    vector<idx_t> right_projection_map_company_name_cn1{3, 4, 5, 6, 7, 8, 9};
    vector<idx_t> merge_project_map_company_name_cn1;
    vector<LogicalType> delim_types_company_name_cn1;
    auto join_company_name_cn1 = make_uniq<PhysicalMergeSIPJoin>(join_company_name_cn1_op, move(scan_company_name_cn1), move(join_info_type_it1),
                                                            move(cond_company_name_cn1), JoinType::INNER,
                                                            left_projection_map, right_projection_map_company_name_cn1,
                                                            merge_project_map_company_name_cn1,
                                                            delim_types_company_name_cn1, 0);


    vector<idx_t> kind_type_kt2_ids{COLUMN_IDENTIFIER_ROW_ID, 1};
    vector<LogicalType> get_kind_type_kt2_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_kind_type_kt2 = "kt2";
    vector<LogicalType> table_types_kind_type_kt2;
    vector<unique_ptr<Expression>> filter_kind_type_kt2;
    unique_ptr<LogicalGet> get_op_kind_type_kt2 = move(
            getLogicalGet(*this, table_kind_type, alias_kind_type_kt2, table_index_kind_type_kt2,
                          table_types_kind_type_kt2));
    unique_ptr<TableFilterSet> table_filters_kind_type_kt2 = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_kt2 = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL, Value("tv series"));
    table_filters_kind_type_kt2->filters[1] = move(constant_filter_kt2);
    unique_ptr<PhysicalTableScan> scan_kind_type_kt2 = make_uniq<PhysicalTableScan>(get_kind_type_kt2_types,
                                                                                    get_op_kind_type_kt2->function,
                                                                                    get_op_kind_type_kt2->table_index,
                                                                                    move(get_op_kind_type_kt2->bind_data),
                                                                                    table_types_kind_type_kt2,
                                                                                    kind_type_kt2_ids,
                                                                                    move(filter_kind_type_kt2),
                                                                                    vector<column_t>(),
                                                                                    get_op_kind_type_kt2->names,
                                                                                    std::move(
                                                                                            table_filters_kind_type_kt2),
                                                                                    get_op_kind_type_kt2->estimated_cardinality,
                                                                                    get_op_kind_type_kt2->extra_info);


    vector<JoinCondition> cond_kind_type_kt2;
    JoinCondition join_condition_kind_type_kt2;
    join_condition_kind_type_kt2.left = make_uniq<BoundReferenceExpression>("kind_type_rowid", LogicalType::BIGINT, 0);
    join_condition_kind_type_kt2.right = make_uniq<BoundReferenceExpression>("kind_id_rowid", LogicalType::BIGINT, 7);
    join_condition_kind_type_kt2.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_kind_type_kt2 = make_uniq<RAIInfo>();
    rai_info_kind_type_kt2->rai = table_title.GetStorage().info->rais[0].get();
    rai_info_kind_type_kt2->rai_type = RAIType::TARGET_EDGE;
    rai_info_kind_type_kt2->forward = true;
    rai_info_kind_type_kt2->vertex = &table_kind_type;
    rai_info_kind_type_kt2->vertex_id = table_index_kind_type_kt2;
    rai_info_kind_type_kt2->passing_tables[0] = table_index_kind_type_kt2;
    rai_info_kind_type_kt2->left_cardinalities[0] = table_kind_type.GetStorage().info->cardinality;
    // rai_info_kind_type_kt2->compact_list = &rai_info_kind_type_kt2->rai->alist->compact__list;

    join_condition_kind_type_kt2.rais.push_back(move(rai_info_kind_type_kt2));
    cond_kind_type_kt2.push_back(move(join_condition_kind_type_kt2));

    LogicalComparisonJoin join_kind_type_kt2_op(JoinType::INNER);
    vector<LogicalType> output_kind_type_kt2_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::VARCHAR,
                                                   LogicalType::VARCHAR, LogicalType::BIGINT, LogicalType::VARCHAR,
                                                   LogicalType::VARCHAR, LogicalType::VARCHAR, LogicalType::BIGINT};
    join_kind_type_kt2_op.types = output_kind_type_kt2_types;
    vector<idx_t> right_projection_map_kind_type_kt2{1, 3, 4, 5, 6, 8, 9};
    vector<idx_t> merge_project_map_kind_type_kt2;
    vector<LogicalType> delim_types_kind_type_kt2;
    auto join_kind_type_kt2 = make_uniq<PhysicalSIPJoin>(join_kind_type_kt2_op, move(scan_kind_type_kt2), move(join_company_name_cn1),
                                                         move(cond_kind_type_kt2), JoinType::INNER, left_projection_map,
                                                         right_projection_map_kind_type_kt2, delim_types_kind_type_kt2,
                                                         0);


    vector<idx_t> kind_type_kt1_ids{COLUMN_IDENTIFIER_ROW_ID, 1};
    vector<LogicalType> get_kind_type_kt1_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_kind_type_kt1 = "kt1";
    vector<LogicalType> table_types_kind_type_kt1;
    vector<unique_ptr<Expression>> filter_kind_type_kt1;
    unique_ptr<LogicalGet> get_op_kind_type_kt1 = move(
            getLogicalGet(*this, table_kind_type, alias_kind_type_kt1, table_index_kind_type_kt1,
                          table_types_kind_type_kt1));
    unique_ptr<TableFilterSet> table_filters_kind_type_kt1 = make_uniq<TableFilterSet>();
    unique_ptr<ConstantFilter> constant_filter_kt1 = duckdb::make_uniq<ConstantFilter>(ExpressionType::COMPARE_EQUAL, Value("tv series"));
    table_filters_kind_type_kt1->filters[1] = move(constant_filter_kt1);
    unique_ptr<PhysicalTableScan> scan_kind_type_kt1 = make_uniq<PhysicalTableScan>(get_kind_type_kt1_types,
                                                                                    get_op_kind_type_kt1->function,
                                                                                    get_op_kind_type_kt1->table_index,
                                                                                    move(get_op_kind_type_kt1->bind_data),
                                                                                    table_types_kind_type_kt1,
                                                                                    kind_type_kt1_ids,
                                                                                    move(filter_kind_type_kt1),
                                                                                    vector<column_t>(),
                                                                                    get_op_kind_type_kt1->names,
                                                                                    std::move(
                                                                                            table_filters_kind_type_kt1),
                                                                                    get_op_kind_type_kt1->estimated_cardinality,
                                                                                    get_op_kind_type_kt1->extra_info);


    vector<JoinCondition> cond_kind_type_kt1;
    JoinCondition join_condition_kind_type_kt1;
    join_condition_kind_type_kt1.left = make_uniq<BoundReferenceExpression>("kind_type_rowid", LogicalType::BIGINT, 0);
    join_condition_kind_type_kt1.right = make_uniq<BoundReferenceExpression>("kind_id_rowid", LogicalType::BIGINT, 8);
    join_condition_kind_type_kt1.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_kind_type_kt1 = make_uniq<RAIInfo>();
    rai_info_kind_type_kt1->rai = table_title.GetStorage().info->rais[0].get();
    rai_info_kind_type_kt1->rai_type = RAIType::TARGET_EDGE;
    rai_info_kind_type_kt1->forward = true;
    rai_info_kind_type_kt1->vertex = &table_kind_type;
    rai_info_kind_type_kt1->vertex_id = table_index_kind_type_kt2;
    rai_info_kind_type_kt1->passing_tables[0] = table_index_kind_type_kt2;
    rai_info_kind_type_kt1->left_cardinalities[0] = table_kind_type.GetStorage().info->cardinality;
    // rai_info_kind_type_kt1->compact_list = &rai_info_kind_type_kt1->rai->alist->compact__list;

    join_condition_kind_type_kt1.rais.push_back(move(rai_info_kind_type_kt1));
    cond_kind_type_kt1.push_back(move(join_condition_kind_type_kt1));

    LogicalComparisonJoin join_kind_type_kt1_op(JoinType::INNER);
    vector<LogicalType> output_kind_type_kt1_types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::VARCHAR,
                                                   LogicalType::VARCHAR, LogicalType::BIGINT, LogicalType::VARCHAR,
                                                   LogicalType::VARCHAR, LogicalType::VARCHAR};
    join_kind_type_kt1_op.types = output_kind_type_kt1_types;
    vector<idx_t> right_projection_map_kind_type_kt1{2, 3, 4, 5, 6, 7};
    vector<idx_t> merge_project_map_kind_type_kt1;
    vector<LogicalType> delim_types_kind_type_kt1;
    auto join_kind_type_kt1 = make_uniq<PhysicalSIPJoin>(join_kind_type_kt1_op, move(scan_kind_type_kt1), move(join_kind_type_kt2),
                                                         move(cond_kind_type_kt1), JoinType::INNER, left_projection_map,
                                                         right_projection_map_kind_type_kt1, delim_types_kind_type_kt1,
                                                         0);


    vector<idx_t> company_name_cn2_ids{COLUMN_IDENTIFIER_ROW_ID, 1};
    vector<LogicalType> get_company_name_cn2_types{LogicalType::BIGINT, LogicalType::VARCHAR};
    string alias_company_name_cn2 = "cn2";
    vector<LogicalType> table_types_company_name_cn2;
    vector<unique_ptr<Expression>> filter_company_name_cn2;
    unique_ptr<LogicalGet> get_op_company_name_cn2 = move(
            getLogicalGet(*this, table_company_name, alias_company_name_cn2, table_index_company_name_cn2,
                          table_types_company_name_cn2));
    unique_ptr<TableFilterSet> table_filters_company_name_cn2 = NULL;
    unique_ptr<PhysicalTableScan> scan_company_name_cn2 = make_uniq<PhysicalTableScan>(get_company_name_cn2_types,
                                                                                       get_op_company_name_cn2->function,
                                                                                       get_op_company_name_cn2->table_index,
                                                                                       move(get_op_company_name_cn2->bind_data),
                                                                                       table_types_company_name_cn2,
                                                                                       company_name_cn2_ids,
                                                                                       move(filter_company_name_cn2),
                                                                                       vector<column_t>(),
                                                                                       get_op_company_name_cn2->names,
                                                                                       std::move(
                                                                                               table_filters_company_name_cn2),
                                                                                       get_op_company_name_cn2->estimated_cardinality,
                                                                                       get_op_company_name_cn2->extra_info);


    vector<JoinCondition> cond_movie_companies_;
    JoinCondition join_condition_movie_companies_;
    join_condition_movie_companies_.left = make_uniq<BoundReferenceExpression>("company_name_rowid", LogicalType::BIGINT, 0);
    join_condition_movie_companies_.right = make_uniq<BoundReferenceExpression>("movie_id_rowid", LogicalType::BIGINT, 4);
    join_condition_movie_companies_.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_movie_companies_ = make_uniq<RAIInfo>();
    rai_info_movie_companies_->rai = table_movie_companies.GetStorage().info->rais[0].get();
    rai_info_movie_companies_->rai_type = RAIType::SOURCE_EDGE;
    rai_info_movie_companies_->forward = false;
    rai_info_movie_companies_->vertex = &table_company_name;
    rai_info_movie_companies_->vertex_id = table_index_company_name_cn2;
    rai_info_movie_companies_->passing_tables[0] = table_index_company_name_cn2;
    rai_info_movie_companies_->left_cardinalities[0] = table_company_name.GetStorage().info->cardinality;
    // rai_info_movie_companies_->compact_list = &rai_info_movie_companies_->rai->alist->compact__list;

    join_condition_movie_companies_.rais.push_back(move(rai_info_movie_companies_));
    cond_movie_companies_.push_back(move(join_condition_movie_companies_));

    LogicalComparisonJoin join_movie_companies__op(JoinType::INNER);
    vector<LogicalType> output_movie_companies__types{LogicalType::BIGINT, LogicalType::VARCHAR, LogicalType::VARCHAR,
                                                      LogicalType::VARCHAR, LogicalType::VARCHAR, LogicalType::VARCHAR,
                                                      LogicalType::VARCHAR};
    join_movie_companies__op.types = output_movie_companies__types;
    vector<idx_t> right_projection_map_movie_companies_{2, 3, 5, 6 ,7};
    vector<idx_t> merge_project_map_movie_companies_;
    vector<LogicalType> delim_types_movie_companies_;
    auto join_movie_companies_ = make_uniq<PhysicalMergeSIPJoin>(join_movie_companies__op, move(scan_company_name_cn2), move(join_kind_type_kt1),
                                                                 move(cond_movie_companies_), JoinType::INNER,
                                                                 left_projection_map,
                                                                 right_projection_map_movie_companies_,
                                                                 merge_project_map_movie_companies_,
                                                                 delim_types_movie_companies_, 0);


    vector<LogicalType> result_types{LogicalType::VARCHAR, LogicalType::VARCHAR, LogicalType::VARCHAR,
                                     LogicalType::VARCHAR, LogicalType::VARCHAR, LogicalType::VARCHAR};
    vector<unique_ptr<Expression>> select_list;
    auto result_col0 = make_uniq<BoundReferenceExpression>("name", LogicalType::VARCHAR, 2);
    auto result_col1 = make_uniq<BoundReferenceExpression>("name", LogicalType::VARCHAR, 1);
    auto result_col2 = make_uniq<BoundReferenceExpression>("info", LogicalType::VARCHAR, 3);
    auto result_col3 = make_uniq<BoundReferenceExpression>("info", LogicalType::VARCHAR, 4);
    auto result_col4 = make_uniq<BoundReferenceExpression>("title", LogicalType::VARCHAR, 6);
    auto result_col5 = make_uniq<BoundReferenceExpression>("title", LogicalType::VARCHAR, 5);
    select_list.push_back(move(result_col0));
    select_list.push_back(move(result_col1));
    select_list.push_back(move(result_col2));
    select_list.push_back(move(result_col3));
    select_list.push_back(move(result_col4));
    select_list.push_back(move(result_col5));
    auto projection = make_uniq<PhysicalProjection>(result_types, move(select_list), 0);
    projection->children.push_back(move(join_movie_companies_));

    // aggregate
    string agg_name = "min";
    string agg_error = "";
    QueryErrorContext error_context(NULL, NULL);
    auto min_func = Catalog::GetEntry(context, CatalogType::SCALAR_FUNCTION_ENTRY, "", "",
                                      "min", OnEntryNotFound::RETURN_NULL, error_context);
    auto &min_func_set = min_func->Cast<AggregateFunctionCatalogEntry>();
    // bind the aggregate
    FunctionBinder function_binder(context);
    vector<LogicalType> types;
    types.push_back(LogicalType::VARCHAR);
    idx_t best_function_varchar = function_binder.BindFunction(agg_name, min_func_set.functions, types, agg_error);
    auto bound_function_min_varchar = min_func_set.functions.GetFunctionByOffset(best_function_varchar);
    // std::cout << best_function_varchar << " " << bound_function_min_varchar.return_type.ToString() << std::endl;

    auto first_children = make_uniq<BoundReferenceExpression>("name", LogicalType::VARCHAR, 0);
    vector<unique_ptr<Expression>> childrenlist1;
    childrenlist1.push_back(move(first_children));
    auto aggregate1 =
            function_binder.BindAggregateFunction(bound_function_min_varchar, std::move(childrenlist1), nullptr,
                                                  AggregateType::NON_DISTINCT);

    auto second_children = make_uniq<BoundReferenceExpression>("name", LogicalType::VARCHAR, 1);
    vector<unique_ptr<Expression>> childrenlist2;
    childrenlist2.push_back(move(second_children));
    auto aggregate2 =
            function_binder.BindAggregateFunction(bound_function_min_varchar, std::move(childrenlist2), nullptr,
                                                  AggregateType::NON_DISTINCT);

    auto third_children = make_uniq<BoundReferenceExpression>("info", LogicalType::VARCHAR, 2);
    vector<unique_ptr<Expression>> childrenlist3;
    childrenlist3.push_back(move(third_children));
    auto aggregate3 =
            function_binder.BindAggregateFunction(bound_function_min_varchar, std::move(childrenlist3), nullptr,
                                                  AggregateType::NON_DISTINCT);

    auto fourth_children = make_uniq<BoundReferenceExpression>("info", LogicalType::VARCHAR, 3);
    vector<unique_ptr<Expression>> childrenlist4;
    childrenlist4.push_back(move(fourth_children));
    auto aggregate4 =
            function_binder.BindAggregateFunction(bound_function_min_varchar, std::move(childrenlist4), nullptr,
                                                  AggregateType::NON_DISTINCT);

    auto fifth_children = make_uniq<BoundReferenceExpression>("title", LogicalType::VARCHAR, 4);
    vector<unique_ptr<Expression>> childrenlist5;
    childrenlist5.push_back(move(fifth_children));
    auto aggregate5 =
            function_binder.BindAggregateFunction(bound_function_min_varchar, std::move(childrenlist5), nullptr,
                                                  AggregateType::NON_DISTINCT);

    auto sixth_children = make_uniq<BoundReferenceExpression>("title", LogicalType::VARCHAR, 5);
    vector<unique_ptr<Expression>> childrenlist6;
    childrenlist6.push_back(move(sixth_children));
    auto aggregate6 =
            function_binder.BindAggregateFunction(bound_function_min_varchar, std::move(childrenlist6), nullptr,
                                                  AggregateType::NON_DISTINCT);

    vector<unique_ptr<Expression>> aggregates;
    aggregates.push_back(move(aggregate1));
    aggregates.push_back(move(aggregate2));
    aggregates.push_back(move(aggregate3));
    aggregates.push_back(move(aggregate4));
    aggregates.push_back(move(aggregate5));
    aggregates.push_back(move(aggregate6));

    vector<LogicalType> aggregate_types{LogicalType::VARCHAR, LogicalType::VARCHAR, LogicalType::VARCHAR,
                                        LogicalType::VARCHAR, LogicalType::VARCHAR, LogicalType::VARCHAR};
    auto ungrouped_aggregate = make_uniq<PhysicalUngroupedAggregate>(aggregate_types, move(aggregates), 0);
    ungrouped_aggregate->children.push_back(move(projection));

    return ungrouped_aggregate;
}

unique_ptr<PhysicalOperator> ClientContext::GenerateTriangle(ClientContext& context) {
    vector<idx_t> left_projection_map, right_projection_map;

    string table_vertex_person = "person";
    string table_vertex_forum = "forum";
    string table_vertex_post = "post";
    string table_edge_knows = "knows";
    string table_edge_forum_person = "forum_person";
    idx_t table_index_person1 = 6;
    idx_t table_index_forum = 10;
    idx_t table_index_person2 = 8;
    idx_t table_index_post = 12;
    idx_t table_index_knows = 7;
    idx_t table_index_forum_person = 13;


    auto table_or_view_person = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                  table_vertex_person, OnEntryNotFound::RETURN_NULL);
    auto &table_person = table_or_view_person->Cast<TableCatalogEntry>();

    auto table_or_view_forum = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                 table_vertex_forum, OnEntryNotFound::RETURN_NULL);
    auto &table_forum = table_or_view_forum->Cast<TableCatalogEntry>();

    auto table_or_view_post = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                table_vertex_post, OnEntryNotFound::RETURN_NULL);
    auto &table_post = table_or_view_post->Cast<TableCatalogEntry>();

    auto table_or_view_knows = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                 table_edge_knows, OnEntryNotFound::RETURN_NULL);
    auto &table_knows = table_or_view_knows->Cast<TableCatalogEntry>();

    auto table_or_view_forum_person = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                        table_edge_forum_person, OnEntryNotFound::RETURN_NULL);
    auto &table_forum_person = table_or_view_forum_person->Cast<TableCatalogEntry>();


    vector<idx_t> person2_ids{COLUMN_IDENTIFIER_ROW_ID, 0};
    vector<LogicalType> get_person2_types{LogicalType::BIGINT, LogicalType::BIGINT};
    string alias_person2 = "p2";
    vector<LogicalType> table_types_person2;
    vector<unique_ptr<Expression>> filter_person2;
    unique_ptr<LogicalGet> get_op_person2 = move(
            getLogicalGet(*this, table_person, alias_person2, table_index_person2, table_types_person2));
    unique_ptr<TableFilterSet> table_filters_person2 = NULL;
    unique_ptr<PhysicalTableScan> scan_person2 = make_uniq<PhysicalTableScan>(get_person2_types,
                                                                              get_op_person2->function,
                                                                              get_op_person2->table_index,
                                                                              move(get_op_person2->bind_data),
                                                                              table_types_person2, person2_ids,
                                                                              move(filter_person2), vector<column_t>(),
                                                                              get_op_person2->names,
                                                                              std::move(table_filters_person2),
                                                                              get_op_person2->estimated_cardinality,
                                                                              get_op_person2->extra_info);


    // join post with person-person
    vector<idx_t> post_ids{11, COLUMN_IDENTIFIER_ROW_ID, 13};
    vector<LogicalType> get_post_types{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::BIGINT};
    string alias_post = "m";
    vector<LogicalType> table_types_post;
    vector<unique_ptr<Expression>> filter_post;
    unique_ptr<LogicalGet> get_op_post = move(
            getLogicalGet(*this, table_post, alias_post, table_index_post, table_types_post));
    unique_ptr<TableFilterSet> table_filters_post = NULL;
    unique_ptr<PhysicalTableScan> scan_post = make_uniq<PhysicalTableScan>(get_post_types, get_op_post->function,
                                                                           get_op_post->table_index,
                                                                           move(get_op_post->bind_data),
                                                                           table_types_post, post_ids,
                                                                           move(filter_post), vector<column_t>(),
                                                                           get_op_post->names,
                                                                           std::move(table_filters_post),
                                                                           get_op_post->estimated_cardinality,
                                                                           get_op_post->extra_info);

    vector<JoinCondition> cond_post;
    JoinCondition join_condition_post;
    join_condition_post.left = make_uniq<BoundReferenceExpression>("m_creatorid_rowid", LogicalType::BIGINT, 0);
    join_condition_post.right = make_uniq<BoundReferenceExpression>("person_rowid", LogicalType::BIGINT, 0);
    join_condition_post.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_post = make_uniq<RAIInfo>();
    rai_info_post->rai = table_post.GetStorage().info->rais[0].get();
    rai_info_post->rai_type = RAIType::EDGE_SOURCE;
    rai_info_post->forward = true;
    rai_info_post->vertex = &table_person;
    rai_info_post->vertex_id = table_index_person2;
    rai_info_post->passing_tables[0] = table_index_post;
    rai_info_post->left_cardinalities[0] = table_post.GetStorage().info->cardinality;
    rai_info_post->compact_list = &rai_info_post->rai->alist->compact_forward_list;

    join_condition_post.rais.push_back(move(rai_info_post));
    cond_post.push_back(move(join_condition_post));

    LogicalComparisonJoin join_post_op(JoinType::INNER);
    vector<LogicalType> output_post_types{LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::BIGINT,
                                          LogicalType::BIGINT, LogicalType::BIGINT};
    join_post_op.types = output_post_types;
    vector<idx_t> right_projection_map_post{0, 1};
    vector<idx_t> merge_project_map_post;
    vector<LogicalType> delim_types_post;
    auto join_post = make_uniq<PhysicalSIPJoin>(join_post_op, move(scan_post), move(scan_person2), move(cond_post),
                                                JoinType::INNER, left_projection_map, right_projection_map_post,
                                                delim_types_post, 0);

    // join forum with person-person-post
    vector<idx_t> forum_ids{COLUMN_IDENTIFIER_ROW_ID};
    vector<LogicalType> get_forum_types{LogicalType::BIGINT};
    string alias_forum = "f";
    vector<LogicalType> table_types_forum;
    vector<unique_ptr<Expression>> filter_forum;
    unique_ptr<LogicalGet> get_op_forum = move(
            getLogicalGet(*this, table_forum, alias_forum, table_index_forum, table_types_forum));
    unique_ptr<TableFilterSet> table_filters_forum = NULL;
    unique_ptr<PhysicalTableScan> scan_forum = make_uniq<PhysicalTableScan>(get_forum_types, get_op_forum->function,
                                                                            get_op_forum->table_index,
                                                                            move(get_op_forum->bind_data),
                                                                            table_types_forum, forum_ids,
                                                                            move(filter_forum), vector<column_t>(),
                                                                            get_op_forum->names,
                                                                            std::move(table_filters_forum),
                                                                            get_op_forum->estimated_cardinality,
                                                                            get_op_forum->extra_info);

    vector<JoinCondition> cond_forum;
    vector<JoinCondition> other_conditions_forum;
    JoinCondition join_condition_forum, join_condition_forum_person;
    join_condition_forum_person.left = make_uniq<BoundReferenceExpression>("forum_rowid", LogicalType::BIGINT, 0);
    join_condition_forum_person.right = make_uniq<BoundReferenceExpression>("person_rowid", LogicalType::BIGINT, 3);
    join_condition_forum_person.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_forum_person = make_uniq<RAIInfo>();
    rai_info_forum_person->rai = table_forum_person.GetStorage().info->rais[0].get();
    rai_info_forum_person->rai_type = RAIType::TARGET_EDGE;
    rai_info_forum_person->forward = true;
    rai_info_forum_person->vertex = &table_forum;
    rai_info_forum_person->vertex_id = table_index_forum;
    rai_info_forum_person->passing_tables[0] = table_index_forum;
    rai_info_forum_person->left_cardinalities[0] = table_forum.GetStorage().info->cardinality;
    // rai_info_forum_person->compact_list = &rai_info_forum_person->rai->alist->compact_backward_list;

    join_condition_forum_person.rais.push_back(move(rai_info_forum_person));
    cond_forum.push_back(move(join_condition_forum_person));

    join_condition_forum.left = make_uniq<BoundReferenceExpression>("forum_rowid", LogicalType::BIGINT, 0);
    join_condition_forum.right = make_uniq<BoundReferenceExpression>("m_ps_forumid_rowid", LogicalType::BIGINT, 2);
    join_condition_forum.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_forum = make_uniq<RAIInfo>();
    rai_info_forum->rai = table_post.GetStorage().info->rais[2].get();
    rai_info_forum->rai_type = RAIType::TARGET_EDGE;
    rai_info_forum->forward = true;
    rai_info_forum->vertex = &table_forum;
    rai_info_forum->vertex_id = table_index_forum;
    rai_info_forum->passing_tables[0] = table_index_forum;
    rai_info_forum->left_cardinalities[0] = table_forum.GetStorage().info->cardinality;
    // rai_info_forum->compact_list = &rai_info_forum->rai->alist->compact_forward_list;

    join_condition_forum.rais.push_back(move(rai_info_forum));
    other_conditions_forum.push_back(move(join_condition_forum));

    LogicalComparisonJoin join_forum_op(JoinType::INNER);
    vector<LogicalType> output_forum_types{LogicalType::BIGINT, LogicalType::BIGINT};
    join_forum_op.types = output_forum_types;
    vector<idx_t> right_projection_map_forum{4};
    vector<idx_t> merge_project_map_forum;
    vector<LogicalType> delim_types_forum;
    auto join_extend_intersect = make_uniq<PhysicalExtendIntersect>(join_forum_op, move(scan_forum), move(join_post), move(cond_forum), move(other_conditions_forum),
                                                                    JoinType::INNER, left_projection_map, right_projection_map_forum,
                                                                    merge_project_map_forum, delim_types_forum, 0);

    // project
    vector<LogicalType> result_types{LogicalType::BIGINT};
    vector<unique_ptr<Expression>> select_list;
    auto result_col0 = make_uniq<BoundReferenceExpression>("p_personid", LogicalType::BIGINT, 1);
    select_list.push_back(move(result_col0));
    auto projection = make_uniq<PhysicalProjection>(result_types, move(select_list), 0);
    projection->children.push_back(move(join_extend_intersect));

    return projection;
}

unique_ptr<PhysicalOperator> ClientContext::GeneratePath(ClientContext& context) {
    vector<idx_t> left_projection_map, right_projection_map;

    string table_vertex_person = "person";
    string table_vertex_forum = "forum";
    string table_vertex_post = "post";
    string table_edge_knows = "knows";
    string table_edge_forum_person = "forum_person";
    idx_t table_index_person1 = 6;
    idx_t table_index_forum = 10;
    idx_t table_index_person2 = 8;
    idx_t table_index_post = 12;
    idx_t table_index_knows = 7;
    idx_t table_index_forum_person = 13;


    auto table_or_view_person = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                  table_vertex_person, OnEntryNotFound::RETURN_NULL);
    auto &table_person = table_or_view_person->Cast<TableCatalogEntry>();

    auto table_or_view_forum = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                 table_vertex_forum, OnEntryNotFound::RETURN_NULL);
    auto &table_forum = table_or_view_forum->Cast<TableCatalogEntry>();

    auto table_or_view_post = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                table_vertex_post, OnEntryNotFound::RETURN_NULL);
    auto &table_post = table_or_view_post->Cast<TableCatalogEntry>();

    auto table_or_view_knows = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                 table_edge_knows, OnEntryNotFound::RETURN_NULL);
    auto &table_knows = table_or_view_knows->Cast<TableCatalogEntry>();

    auto table_or_view_forum_person = Catalog::GetEntry(*this, CatalogType::TABLE_ENTRY, "", "",
                                                        table_edge_forum_person, OnEntryNotFound::RETURN_NULL);
    auto &table_forum_person = table_or_view_forum_person->Cast<TableCatalogEntry>();


    vector<idx_t> person2_ids{COLUMN_IDENTIFIER_ROW_ID};
    vector<LogicalType> get_person2_types{LogicalType::BIGINT};
    string alias_person2 = "p2";
    vector<LogicalType> table_types_person2;
    vector<unique_ptr<Expression>> filter_person2;
    unique_ptr<LogicalGet> get_op_person2 = move(
            getLogicalGet(*this, table_person, alias_person2, table_index_person2, table_types_person2));
    unique_ptr<TableFilterSet> table_filters_person2 = NULL;
    unique_ptr<PhysicalTableScan> scan_person2 = make_uniq<PhysicalTableScan>(get_person2_types,
                                                                              get_op_person2->function,
                                                                              get_op_person2->table_index,
                                                                              move(get_op_person2->bind_data),
                                                                              table_types_person2, person2_ids,
                                                                              move(filter_person2), vector<column_t>(),
                                                                              get_op_person2->names,
                                                                              std::move(table_filters_person2),
                                                                              get_op_person2->estimated_cardinality,
                                                                              get_op_person2->extra_info);


    vector<idx_t> person1_ids{COLUMN_IDENTIFIER_ROW_ID};
    vector<LogicalType> get_person1_types{LogicalType::BIGINT};
    string alias_person1 = "p1";
    vector<LogicalType> table_types_person1;
    unique_ptr<LogicalGet> get_op_person1 = move(
            getLogicalGet(*this, table_person, alias_person1, table_index_person1, table_types_person1));
    vector<unique_ptr<Expression>> filter_person1;
    unique_ptr<TableFilterSet> table_filters_person1 = NULL;
    unique_ptr<PhysicalTableScan> scan_person1 = make_uniq<PhysicalTableScan>(get_person1_types,
                                                                              get_op_person1->function,
                                                                              get_op_person1->table_index,
                                                                              move(get_op_person1->bind_data),
                                                                              table_types_person1, person1_ids,
                                                                              move(filter_person1), vector<column_t>(),
                                                                              get_op_person1->names,
                                                                              std::move(table_filters_person1),
                                                                              get_op_person1->estimated_cardinality,
                                                                              get_op_person1->extra_info);

    // join forum with person-person-post
    vector<idx_t> forum_ids{COLUMN_IDENTIFIER_ROW_ID};
    vector<LogicalType> get_forum_types{LogicalType::BIGINT};
    string alias_forum = "f";
    vector<LogicalType> table_types_forum;
    vector<unique_ptr<Expression>> filter_forum;
    unique_ptr<LogicalGet> get_op_forum = move(
            getLogicalGet(*this, table_forum, alias_forum, table_index_forum, table_types_forum));
    unique_ptr<TableFilterSet> table_filters_forum = NULL;
    unique_ptr<PhysicalTableScan> scan_forum = make_uniq<PhysicalTableScan>(get_forum_types, get_op_forum->function,
                                                                            get_op_forum->table_index,
                                                                            move(get_op_forum->bind_data),
                                                                            table_types_forum, forum_ids,
                                                                            move(filter_forum), vector<column_t>(),
                                                                            get_op_forum->names,
                                                                            std::move(table_filters_forum),
                                                                            get_op_forum->estimated_cardinality,
                                                                            get_op_forum->extra_info);

    vector<JoinCondition> cond_forum_person;
    JoinCondition join_fp;
    join_fp.left = make_uniq<BoundReferenceExpression>("person_rowid", LogicalType::BIGINT, 0);
    join_fp.right = make_uniq<BoundReferenceExpression>("forum_rowid", LogicalType::BIGINT, 0);
    join_fp.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_forum_p = make_uniq<RAIInfo>();
    rai_info_forum_p->rai = table_forum_person.GetStorage().info->rais[0].get();
    rai_info_forum_p->rai_type = RAIType::SOURCE_EDGE;
    rai_info_forum_p->forward = false;
    rai_info_forum_p->vertex = &table_person;
    rai_info_forum_p->vertex_id = table_index_person1;
    rai_info_forum_p->passing_tables[0] = table_index_person1;
    rai_info_forum_p->left_cardinalities[0] = table_person.GetStorage().info->cardinality;
    // rai_info_forum->compact_list = &rai_info_forum->rai->alist->compact_forward_list;

    join_fp.rais.push_back(move(rai_info_forum_p));
    cond_forum_person.push_back(move(join_fp));

    LogicalComparisonJoin join_forum_person_op(JoinType::INNER);
    vector<LogicalType> output_forum_person_types{LogicalType::BIGINT, LogicalType::BIGINT};
    join_forum_person_op.types = output_forum_person_types;
    vector<idx_t> right_projection_map_forum_person{0};
    vector<idx_t> merge_project_map_forum_person;
    vector<LogicalType> delim_types_forum_person;
    auto join_forum_person = make_uniq<PhysicalMergeSIPJoin>(join_forum_person_op, move(scan_person1), move(scan_forum), move(cond_forum_person),
                                                         JoinType::INNER, left_projection_map, right_projection_map_forum_person, merge_project_map_forum_person,
                                                         delim_types_forum_person, 0);


    vector<JoinCondition> cond_forum;
    JoinCondition join_condition_forum;
    join_condition_forum.left = make_uniq<BoundReferenceExpression>("person_rowid", LogicalType::BIGINT, 0);
    join_condition_forum.right = make_uniq<BoundReferenceExpression>("forum_rowid", LogicalType::BIGINT, 1);
    join_condition_forum.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_forum = make_uniq<RAIInfo>();
    rai_info_forum->rai = table_forum_person.GetStorage().info->rais[0].get();
    rai_info_forum->rai_type = RAIType::SOURCE_EDGE;
    rai_info_forum->forward = false;
    rai_info_forum->vertex = &table_person;
    rai_info_forum->vertex_id = table_index_person2;
    rai_info_forum->passing_tables[0] = table_index_person2;
    rai_info_forum->left_cardinalities[0] = table_person.GetStorage().info->cardinality;
    // rai_info_forum->compact_list = &rai_info_forum->rai->alist->compact_forward_list;

    join_condition_forum.rais.push_back(move(rai_info_forum));
    cond_forum.push_back(move(join_condition_forum));


    vector<JoinCondition> cond_knows;
    JoinCondition join_condition_knows;
    join_condition_knows.left = make_uniq<BoundReferenceExpression>("person_rowid", LogicalType::BIGINT, 0);
    join_condition_knows.right = make_uniq<BoundReferenceExpression>("person_rowid", LogicalType::BIGINT, 0);
    join_condition_knows.comparison = ExpressionType::COMPARE_EQUAL;

    auto rai_info_knows = make_uniq<RAIInfo>();
    rai_info_knows->rai = table_knows.GetStorage().info->rais[0].get();
    rai_info_knows->rai_type = RAIType::TARGET_EDGE;
    rai_info_knows->forward = true;
    rai_info_knows->vertex = &table_person;
    rai_info_knows->vertex_id = table_index_person2;
    rai_info_knows->passing_tables[0] = table_index_person2;
    rai_info_knows->left_cardinalities[0] = table_person.GetStorage().info->cardinality;
    // rai_info_knows->compact_list = &rai_info_knows->rai->alist->compact_backward_list;

    join_condition_knows.rais.push_back(move(rai_info_knows));
    cond_forum.push_back(move(join_condition_knows));

    LogicalComparisonJoin join_knows_op(JoinType::INNER);
    vector<LogicalType> output_knows_types{LogicalType::BIGINT, LogicalType::BIGINT};
    join_knows_op.types = output_knows_types;
    vector<idx_t> right_projection_map_knows{0};
    vector<idx_t> merge_project_map;
    vector<LogicalType> delim_types;
    auto join_knows = make_uniq<PhysicalExtendIntersect>(join_knows_op, move(scan_person2), move(join_forum_person),
                                                      move(cond_forum), move(cond_knows),
                                                      JoinType::INNER, left_projection_map, right_projection_map_knows,
                                                      merge_project_map, delim_types, 0);


    // project
    vector<LogicalType> result_types{LogicalType::BIGINT};
    vector<unique_ptr<Expression>> select_list;
    auto result_col0 = make_uniq<BoundReferenceExpression>("person_rowid", LogicalType::BIGINT, 0);
    select_list.push_back(move(result_col0));
    auto projection = make_uniq<PhysicalProjection>(result_types, move(select_list), 0);
    projection->children.push_back(move(join_knows));

    return projection;
}

} // namespace duckdb
